1
00:00:00,000 --> 00:00:04,350
 I see a lot of people figure it out to come early so good for you

2
00:00:05,529 --> 00:00:12,299
 so if you recall my name is Randal Bryant, and I'm co instructor of this course along with David O'Hallaron and

3
00:00:12,820 --> 00:00:19,439
 For the next couple lectures the first part of this course really will be talking about

4
00:00:20,380 --> 00:00:28,109
 sort of data representations in particular, how numbers are represented in different forms and some of the properties and you saw that

5
00:00:28,779 --> 00:00:36,148
 when I talked last week, I showed you things like you can multiply some numbers together that are positive and get negative result

6
00:00:36,149 --> 00:00:43,019
 So what we want to understand is what is the bit level representation of numbers, and how does that affect

7
00:00:44,079 --> 00:00:49,979
 some of the properties you have when you operate them on and especially looking at the corner cases when things

8
00:00:50,260 --> 00:00:53,910
 overflow or we sort of don't do what you might expect them to do

9
00:00:54,610 --> 00:00:57,539
 So we'll start off with very basic stuff of how

10
00:00:58,420 --> 00:01:03,629
 numbers are represented especially integer valued numbers are represented in bits

11
00:01:06,250 --> 00:01:13,769
 so I think you've pretty well figured out in this world that the whole digital world is sort of based on on binary values and

12
00:01:16,720 --> 00:01:18,090
 that wasn't always the case

13
00:01:18,090 --> 00:01:24,600
 I mean since humans have ten fingers and ten toes, a lot of the world was based on the decimal system

14
00:01:24,610 --> 00:01:27,809
 And it was really only and in fact the first

15
00:01:28,930 --> 00:01:31,199
 electronic computer the ENIAC built in

16
00:01:32,200 --> 00:01:34,200
 University of Pennsylvania

17
00:01:34,540 --> 00:01:42,299
 Basically encoded did all of its arithmetic using base ten they had 10 vacuum tubes per digit they wanted to represent

18
00:01:43,240 --> 00:01:50,820
 so they basically turned on or off those tubes to represent which of the 10 possible digits you could want and

19
00:01:51,159 --> 00:01:53,159
 It really didn't come

20
00:01:53,920 --> 00:02:01,409
 to people until later than that, so that's 1948 that they really should just think about base two for everything

21
00:02:02,500 --> 00:02:03,790
 and

22
00:02:03,790 --> 00:02:08,069
 The reason why bits are great is in the digital world

23
00:02:08,590 --> 00:02:12,479
 you can sort of take what otherwise an analog signal and

24
00:02:13,120 --> 00:02:18,509
 Quantify it and just say I'm going to say that one range of values would say it's a low voltage

25
00:02:18,549 --> 00:02:24,479
 I'm going to call that a zero and a high range of values. I'm going to call it a one and

26
00:02:25,060 --> 00:02:27,060
 if there's noise or

27
00:02:27,790 --> 00:02:34,319
 imperfections in the circuit or anything's going on as long as that doesn't exceed these

28
00:02:35,110 --> 00:02:36,430
 bit these

29
00:02:36,430 --> 00:02:40,260
 thresholds you've set up, then you'll get a nice clean signal out of it

30
00:02:40,260 --> 00:02:44,879
 And that's the main advantage of digital processing over analog processing

31
00:02:46,659 --> 00:02:52,798
 And so that sort of at the core why everything we do and especially for storing information it turns out

32
00:02:52,799 --> 00:02:56,279
 it's much easier to store one bit of information or a

33
00:02:57,040 --> 00:02:59,909
 digital value than it is to store an analog value

34
00:03:02,109 --> 00:03:03,879
 and

35
00:03:03,879 --> 00:03:05,879
 sorry this kind of

36
00:03:06,819 --> 00:03:08,969
 slides went a little crazy on animation

37
00:03:09,639 --> 00:03:13,559
 so the point is that we represent all the numbers in a computer as

38
00:03:14,230 --> 00:03:18,179
 sets of bits, and I think you generally understand that fairly well and

39
00:03:18,970 --> 00:03:24,539
 So of course the familiar binary representation of integers which we'll go over today just

40
00:03:25,150 --> 00:03:28,230
 uses a bit position for each power of two

41
00:03:28,840 --> 00:03:30,840
 We can also represent

42
00:03:31,150 --> 00:03:37,440
 Values that are fractional and we'll talk about that a week from today when we do a floating-point numbers

43
00:03:37,720 --> 00:03:43,709
 where what you do is to the right of the binary point, so this is no longer a

44
00:03:44,560 --> 00:03:52,349
 decimal point, it's a binary point and so something to the left of that would have a weight one two to the zero and

45
00:03:53,620 --> 00:03:56,160
 The next one over would have weight to the one

46
00:03:57,040 --> 00:04:01,349
 But what you do is is you go to the right that adds weight to the minus one

47
00:04:02,349 --> 00:04:05,009
 to the minus two in other words,

48
00:04:05,949 --> 00:04:10,109
 this is 1, this is 2, this is 1/2, and this is 1/4

49
00:04:11,139 --> 00:04:15,418
 So we can represent just like you do the decimal representation of fractions

50
00:04:15,639 --> 00:04:19,499
 We can do the binary representation of fractions, so that's the core of

51
00:04:20,409 --> 00:04:22,409
 floating-Point number of representations

52
00:04:24,190 --> 00:04:26,060
 and so

53
00:04:26,060 --> 00:04:29,239
 it gets very annoying if you have say 32 or even

54
00:04:30,060 --> 00:04:36,350
 64-bit numbers to be writing the strings of ones and zeros out and so what we use

55
00:04:37,200 --> 00:04:43,189
 And what's become largely the the most common is to group collections of four bits at a time

56
00:04:44,130 --> 00:04:45,810
 into

57
00:04:45,810 --> 00:04:50,269
 And then represent that in base 16, or what's known as hexadecimal representation

58
00:04:51,210 --> 00:04:53,210
 using the letters a through f as

59
00:04:54,360 --> 00:04:58,970
 Values 10 through 15, and you'll spend a lot of time staring at 

60
00:04:58,970 --> 00:05:05,450
 hex decimal numbers this year and you'll get pretty good at being able to look at a hex number just write it out in binary

61
00:05:07,530 --> 00:05:14,179
 The way I do it just to tell you is I mean I've got the values from 0 to

62
00:05:18,750 --> 00:05:20,750
 9

63
00:05:21,150 --> 00:05:28,310
 wired down pretty well and then I keep track of a few special cases 1 0 1 0 it's A

64
00:05:29,910 --> 00:05:35,450
 1 1 0 0 is C and 1 1 1 1

65
00:05:36,960 --> 00:05:38,960
 is F and

66
00:05:39,120 --> 00:05:41,120
 for B

67
00:05:41,700 --> 00:05:43,700
 D and E I kind of

68
00:05:44,160 --> 00:05:47,899
 interpolate between those so if you want to develop that skill

69
00:05:47,900 --> 00:05:51,320
 That's the way you can do it you're looking for ...

70
00:05:52,320 --> 00:05:57,079
 An HDMI... what no, I don't think there's any connector here. You know...

71
00:06:03,110 --> 00:06:09,999
 So that's something you're going to end up wanting to be able to do so in C we don't

72
00:06:12,110 --> 00:06:14,060
 in most

73
00:06:14,060 --> 00:06:19,390
 Declarations you don't actually are told exactly how many bytes abide is eight bits

74
00:06:20,450 --> 00:06:28,119
 Each Data value is represented as and that's partly C was designed actually back when microprocessors only had

75
00:06:29,360 --> 00:06:32,169
 16-bit words, it was actually before micro processors

76
00:06:33,050 --> 00:06:40,239
 so 16-bit words were a fairly standard thing and over time that's expanded from 16 to 32 to now 64 and

77
00:06:40,670 --> 00:06:42,670
 so C rather than a

78
00:06:42,680 --> 00:06:48,970
 sort of an advanced saying here is how many bytes every value will have has these slightly ambiguous terms

79
00:06:49,580 --> 00:06:53,139
 That vary actually from one machine to the next

80
00:06:55,190 --> 00:06:58,719
 and if you're a very careful C programmer you have to

81
00:06:59,390 --> 00:07:03,189
 anticipate that zone, but what won't deal with is

82
00:07:04,040 --> 00:07:07,390
 x86_64 is the class of machines will be working with

83
00:07:08,450 --> 00:07:12,700
 Exclusively this term and so you can see that when you declare something to be a care

84
00:07:13,820 --> 00:07:20,200
 Sometimes people call it a char that the one byte value a short is 16 bits

85
00:07:21,440 --> 00:07:23,440
 an int is

86
00:07:24,320 --> 00:07:29,379
 32 and if you want to get all 64 bits you have to declare it to be a long

87
00:07:31,760 --> 00:07:36,520
 And then again, there's two different precision's of floating-point. There's four byte or 32-bit

88
00:07:37,130 --> 00:07:41,770
 Floating point numbers and 64 bits. There's also a slightly obscure

89
00:07:42,680 --> 00:07:45,400
 holdover from ancient days of of

90
00:07:46,550 --> 00:07:53,440
 Floating point where there's a special representation in intel machines that uses a 10 bite or 80 bit representation

91
00:07:54,440 --> 00:07:56,440
 and when you use that on a

92
00:07:58,850 --> 00:08:04,600
 64-bit machine they sort of waste an extra six bytes out of that so that everything is

93
00:08:05,360 --> 00:08:07,869
 aligned in sixteen byte Increments

94
00:08:08,690 --> 00:08:12,489
 The other thing and this is an important feature is any address is

95
00:08:13,190 --> 00:08:15,190
 defined to be the

96
00:08:15,200 --> 00:08:22,269
 Sort of the word size of the machine when they say it's a 64-bit machine what they really mean is that the addresses are

97
00:08:23,750 --> 00:08:28,419
 64 bit values or 8 byte values and that's different for example if you use a

98
00:08:28,880 --> 00:08:33,820
 Older machine a 32 bit machine those will only be 32-bit addresses

99
00:08:37,070 --> 00:08:39,249
 so the basis and I

100
00:08:40,490 --> 00:08:42,609
 imagine you've had this at some point of

101
00:08:43,430 --> 00:08:49,330
 How do we then think about bits is based on Boolean Algebra. Which is actually

102
00:08:49,910 --> 00:08:51,910
 comes from the 1890s that

103
00:08:52,670 --> 00:08:58,060
 a guy named George boole who recognized it's sort of relation between

104
00:08:59,000 --> 00:09:01,900
 What we'd call bits, but they weren't called bits

105
00:09:03,800 --> 00:09:05,800
 01 and

106
00:09:05,990 --> 00:09:11,140
 Logic are basically truth values in logic. I'm thinking of an Algebra sort of a

107
00:09:11,780 --> 00:09:16,089
 Structured set of operations you could apply that would capture some of the concepts that

108
00:09:16,820 --> 00:09:23,830
 People assume is in logic. So for example if we think of 1 being true and 0 being false

109
00:09:24,380 --> 00:09:30,640
 Then the end operation is true if both of the inputs both of the arguments are true

110
00:09:31,040 --> 00:09:34,480
 So we get this chart here and similarly the or operation

111
00:09:35,180 --> 00:09:38,440
 Is true if either input is true or 1

112
00:09:39,860 --> 00:09:46,690
 the not is just to flip the bit and then the exclusive-or is what you get when you say it's

113
00:09:47,390 --> 00:09:51,580
 One or the other but not both and so it has this representation

114
00:09:52,310 --> 00:09:55,060
 so just as a bit of history it was a

115
00:09:56,660 --> 00:10:02,560
 Master's degree student at mit named Claude Shannon, who had taken a course in logic

116
00:10:04,190 --> 00:10:06,489
 as an undergraduate at University of Michigan

117
00:10:07,880 --> 00:10:10,780
 and he was the one who made the connection between

118
00:10:11,540 --> 00:10:13,040
 thinking about

119
00:10:13,040 --> 00:10:16,810
 This this what was at the time very obscure

120
00:10:17,600 --> 00:10:25,540
 Branch of something a rather of logic and applying it to digital systems back in an area when they actually built these things out of

121
00:10:25,850 --> 00:10:27,460
 electromechanical

122
00:10:27,460 --> 00:10:28,340
 and

123
00:10:28,340 --> 00:10:34,899
 so his master's thesis is probably the most impactful master's thesis in the history of

124
00:10:35,810 --> 00:10:37,610
 humankind

125
00:10:37,610 --> 00:10:44,020
 and you always wonder well, what did they do before that then you know how do they even think about these things, so

126
00:10:44,690 --> 00:10:46,809
 Anyways the idea of applying this

127
00:10:47,630 --> 00:10:49,630
 Algebra then to bits is not

128
00:10:50,330 --> 00:10:56,889
 Something that should have been true since the world began. It's something that's a relatively modern concept

129
00:10:57,860 --> 00:10:59,860
 Now what's an important

130
00:11:01,340 --> 00:11:06,459
 Thing that might be less obvious is we can also do these over words

131
00:11:06,460 --> 00:11:10,059
 We can do these boolean operations where we apply them on

132
00:11:10,820 --> 00:11:14,020
 each successive bit in that word and these

133
00:11:14,330 --> 00:11:21,520
 Symbols we use the ampersand vertical bar carrot and tilde are actually the ones that C uses to represent these

134
00:11:21,800 --> 00:11:23,120
 operations and

135
00:11:23,120 --> 00:11:28,390
 so again if we look at here the one is only if both of the values of 1 and

136
00:11:29,150 --> 00:11:30,710
 the of

137
00:11:30,710 --> 00:11:35,559
 for the or for the and for the wants or if either of number 1

138
00:11:36,230 --> 00:11:39,790
 the exclusive-or if 1 is 1 and the other is 0

139
00:11:40,490 --> 00:11:44,830
 until it is just invert the bits of it so again

140
00:11:44,830 --> 00:11:46,830
 We will spend a lot of time

141
00:11:46,850 --> 00:11:50,560
 Making use of the fact that in C and this is one of the features of C

142
00:11:50,560 --> 00:11:55,299
 That people like is that you can do these sort of very low level of bit manipulations

143
00:11:55,880 --> 00:11:57,880
 directly in the language and

144
00:12:00,380 --> 00:12:03,880
 This actually turns out to be useful in practice

145
00:12:03,920 --> 00:12:11,440
 And it's sort of implicit of a way of representing sets of values, so this example is a imagine we want to

146
00:12:12,140 --> 00:12:14,169
 represent Sets where the

147
00:12:14,900 --> 00:12:21,069
 Elements of the set are numbers ranging between 0 & 7 so one bit is enough to capture 8

148
00:12:22,910 --> 00:12:28,509
 cases, and we'll just if we number the bits, and we number them from right to left

149
00:12:29,150 --> 00:12:31,720
 So this is bit zero so that would represent

150
00:12:32,810 --> 00:12:37,000
 whether or not the value 0 is an element of the set and

151
00:12:38,300 --> 00:12:41,800
 Similarly here, you'll see 0 1 2 3. So we're saying that

152
00:12:43,160 --> 00:12:49,209
 bit three being one here means three is an element of the set and so forth and

153
00:12:51,050 --> 00:12:53,050
 the

154
00:12:54,350 --> 00:12:58,540
 So the idea is then the and operation becomes like set intersection

155
00:12:59,360 --> 00:13:03,250
 the or operation becomes like set Union and the

156
00:13:03,920 --> 00:13:08,530
 exclusive-or operation is what's called symmetric difference

157
00:13:09,980 --> 00:13:17,830
 And so these are actually and tilde is like set complement. So these are actually very common for example

158
00:13:19,520 --> 00:13:21,520
 there's a

159
00:13:23,240 --> 00:13:25,510
 operations you'll learn later when we look at A

160
00:13:26,420 --> 00:13:31,270
 File I/o about i/o that you can track I want to know

161
00:13:31,880 --> 00:13:36,970
 Which set of possible inputs to the system think of different network [connections]?

162
00:13:37,250 --> 00:13:40,059
 have an input ready for me to read and

163
00:13:40,610 --> 00:13:42,500
 there is a

164
00:13:42,500 --> 00:13:49,419
 Data structure that it's sort of hidden away among some seeing library calls, but it basically is using exactly this

165
00:13:50,150 --> 00:13:56,109
 representation about a thousand a bits worth of information to represent these sets and

166
00:13:56,780 --> 00:14:00,129
 do manipulation on those sets, so this is a very common and

167
00:14:01,700 --> 00:14:05,349
 [why] do we use representation of sets in computer science?

168
00:14:07,640 --> 00:14:11,799
 so as I mentioned those are available directly and see the

169
00:14:12,440 --> 00:14:15,429
 Ampersand vertical Bar Tilde and Caret

170
00:14:16,400 --> 00:14:19,059
 one thing that's really really important and that

171
00:14:19,850 --> 00:14:27,160
 programmers screw it up all the time beginning programmers a lot and even experienced programmers from time to time is to mix up the

172
00:14:27,860 --> 00:14:29,420
 single

173
00:14:29,420 --> 00:14:36,250
 ampersand in the double Ampersand or the single vertical bar in the double vertical bar and the tilde versus the

174
00:14:37,040 --> 00:14:39,310
 Exclamation mark Which is often pronounced bang?

175
00:14:40,250 --> 00:14:42,250
 so

176
00:14:42,770 --> 00:14:44,770
 and the reason

177
00:14:45,470 --> 00:14:51,550
 So obviously there's sort of a syntactic similarity there's actually somewhat of a semantic relation to that

178
00:14:51,740 --> 00:14:56,470
 This is another kind of another kind of or and another kind of not

179
00:14:58,040 --> 00:15:05,499
 But if you mix and match these you're certainly going to have problems, so the double bar [ones] aren't thinking about

180
00:15:06,050 --> 00:15:08,050
 bitwise operations through thinking about

181
00:15:08,480 --> 00:15:11,109
 something that's either true or false periods and

182
00:15:12,080 --> 00:15:13,880
 in that representation

183
00:15:13,880 --> 00:15:21,340
 The number Zero is the thing that faults and anything else any other bit pattern is considered to be true

184
00:15:23,720 --> 00:15:27,939
 And so it the other feature that the double

185
00:15:28,790 --> 00:15:31,480
 Bonds give you is what's called early termination?

186
00:15:32,390 --> 00:15:34,220
 so in particular

187
00:15:34,220 --> 00:15:37,480
 if we do some examples on

188
00:15:39,440 --> 00:15:43,150
 the some hex Pattern for one, so this is a a

189
00:15:45,320 --> 00:15:46,480
 Not a zero

190
00:15:46,480 --> 00:15:53,679
 And so that's considered true in this interpretation and so the the bang of that the not of that is zero

191
00:15:53,840 --> 00:15:58,119
 and similarly if you have zero the not event is one and if you

192
00:15:58,730 --> 00:16:04,209
 Apply bang to a number twice. You'll get back a one unless it was zero and

193
00:16:08,810 --> 00:16:10,040
 [then]

194
00:16:10,040 --> 00:16:12,040
 similarly these patterns here are

195
00:16:13,010 --> 00:16:17,980
 The reason why this returns one is because it's considered two cases that are true

196
00:16:19,430 --> 00:16:24,370
 So it's not doing bitwise operations. It's just trying to create true and [False]

197
00:16:24,520 --> 00:16:28,809
 It's interpreting argument speeds or true or false and returning either true, or false

198
00:16:29,360 --> 00:16:34,810
 But when it returns true it returns one and not whatever number you happen to give it

199
00:16:35,480 --> 00:16:42,369
 so obviously this is a very different operations than you have with the single versions of those and

200
00:16:44,540 --> 00:16:46,540
 but it's easy just

201
00:16:46,790 --> 00:16:51,399
 Because you mentally slip or because you type something wrong to do the wrong time?

202
00:16:51,770 --> 00:16:59,319
 But in particularly this early termination is something that of [course] people use a lot if you want to make sure that you're not

203
00:16:59,690 --> 00:17:06,969
 Accessing a null pointer you can test whether that's a null pointer first before accessing it and this if this is zero

204
00:17:07,180 --> 00:17:10,990
 No, then it will do the the dereferencing of null

205
00:17:12,020 --> 00:17:14,590
 So it's a fairly useful feature as well

206
00:17:15,260 --> 00:17:17,260
 so anyways just

207
00:17:17,690 --> 00:17:24,309
 That's an aside at this level. We're mostly looking at bits, but just as a programming note. Don't mix these up?

208
00:17:32,480 --> 00:17:39,789
 the other class of operations will make use of a lot are shifting which again is not something that you normally sort of as

209
00:17:40,130 --> 00:17:46,930
 Beginning programmers think about too much, and if there's a curious feature that a left shifts are always the [same]

210
00:17:46,930 --> 00:17:53,230
 But there's two different flavors of right shift, [and] we'll see in a little bit later. Why there's two different flavors of right shift

211
00:17:54,560 --> 00:17:56,560
 but um

212
00:17:57,410 --> 00:17:58,850
 the

213
00:17:58,850 --> 00:18:00,020
 idea then of

214
00:18:00,020 --> 00:18:02,050
 Shifting is that you have some argument

215
00:18:02,270 --> 00:18:06,670
 X and you want to shift it some number of positions either to the left or to the right?

216
00:18:07,280 --> 00:18:09,280
 Given by Y and

217
00:18:09,350 --> 00:18:14,709
 so when you shift left, you, just fill in whatever value there was so you pick up the

218
00:18:15,410 --> 00:18:21,009
 I'm shifting by three, so I'll take the lower [order] five bits move them over three positions

219
00:18:21,010 --> 00:18:28,869
 and then fill in with a zero and whatever was in the upper positions of that original word they just sort of disappear into the

220
00:18:29,120 --> 00:18:30,410
 of

221
00:18:30,410 --> 00:18:32,030
 into nowhere

222
00:18:32,030 --> 00:18:39,340
 Similarly if I do a right shift I kicked the upper six bits. I move them over to positions and I fill in with zeros

223
00:18:39,860 --> 00:18:42,189
 so that's a logical shift and that's

224
00:18:42,830 --> 00:18:44,830
 Well, it's logical um

225
00:18:45,080 --> 00:18:51,819
 There's another flavor called the arithmetic shift which it differs in that the rule for what bits you fill in with?

226
00:18:52,070 --> 00:18:54,070
 are not based on the

227
00:18:55,220 --> 00:19:01,329
 Are not zeros necessarily, but it's whatever the most significant bit was in the original value

228
00:19:01,610 --> 00:19:06,549
 So it doesn't matter here because the most significant bit was zero, but you'll see in the case here of

229
00:19:09,440 --> 00:19:14,470
 Where the leading bit was a one that when I shift it to the right?

230
00:19:15,740 --> 00:19:18,850
 arithmetic [we] I'll fill it in with once and

231
00:19:19,490 --> 00:19:25,159
 That'll make sense more when we understand how negative numbers get represented in a machine

232
00:19:25,710 --> 00:19:28,789
 And that's the purpose of it, and why it's called arithmetic. [oh]

233
00:19:31,620 --> 00:19:33,620
 the other thing that

234
00:19:33,870 --> 00:19:35,100
 is

235
00:19:35,100 --> 00:19:39,799
 Kind of confusing to [people] is what what should happen if you say?

236
00:19:39,799 --> 00:19:44,269
 I want to shift an 8-bit number eight positions to the left

237
00:19:52,919 --> 00:19:58,519
 And x is a single byte, what do you think you should get?

238
00:20:02,640 --> 00:20:09,049
 Zero that would be a pretty logical thing you kind of shift all those bits out you fill them with zeros on most machines

239
00:20:09,990 --> 00:20:12,319
 You'll get whatever x was

240
00:20:17,299 --> 00:20:21,638
 Because what it will do is it will compute this number mod eight

241
00:20:24,470 --> 00:20:25,789
 and

242
00:20:25,789 --> 00:20:28,539
 The reason that happens is [if] you think about it

243
00:20:28,539 --> 00:20:32,378
 it's looking at just the low order three bits of the shift amount and

244
00:20:32,749 --> 00:20:36,579
 Ignoring all the rest so that's effectively like module eight

245
00:20:37,369 --> 00:20:44,348
 so that's just a warning [I] and some machines [that] does what you just thought it should and other machines that does this and

246
00:20:44,690 --> 00:20:46,639
 So there's no

247
00:20:46,639 --> 00:20:49,659
 No, guarantee and see that it will be one way or the other

248
00:20:52,759 --> 00:20:57,159
 Same with if you try to shift left by a negative number that might be

249
00:20:57,799 --> 00:21:02,829
 logically well I guess you [really] want to shift right then but that usually doesn't work either, so

250
00:21:05,450 --> 00:21:08,979
 [now] let's talk about number representation and

251
00:21:11,749 --> 00:21:14,139
 This instead of a very core its

252
00:21:15,169 --> 00:21:21,248
 Idea that you have to really have wired in you, and I'm going to illustrate it with some examples

253
00:21:27,710 --> 00:21:29,710
 so the these two

254
00:21:30,440 --> 00:21:38,289
 Equations then are everything that we'll talk about sort of stems from them, so one is if you have an unsigned number

255
00:21:39,049 --> 00:21:41,049
 then basically

256
00:21:43,129 --> 00:21:45,129
 It keeps jumping on [you]

257
00:21:46,429 --> 00:21:49,028
 if you have an unsigned number then

258
00:21:49,399 --> 00:21:55,149
 This is just the the conversion then BTU means from bit [sum] a bit level

259
00:21:55,700 --> 00:21:58,479
 representation to an unsigned number of

260
00:21:59,210 --> 00:22:04,629
 Some bit pattern it just says we'll just add up the sum of the weighted bits

261
00:22:04,669 --> 00:22:10,628
 Where each bit is weighted by a power of two and the only difference when we look at two's complement?

262
00:22:10,629 --> 00:22:12,629
 Which is a way to represent both?

263
00:22:12,889 --> 00:22:18,669
 Negative and positive [numbers] is we'll consider the most significant bit to be what's called the time bit

264
00:22:19,159 --> 00:22:21,159
 So it will have a negative value

265
00:22:22,159 --> 00:22:26,348
 So let me just illustrate this with I'll use some running examples

266
00:22:26,349 --> 00:22:32,259
 And we'll just use 5 min umbers just as a way it really helps often if you're trying to understand this stuff

267
00:22:32,419 --> 00:22:34,658
 To do it for some smaller cases

268
00:22:35,629 --> 00:22:38,858
 so if we think about bit positions

269
00:22:49,260 --> 00:22:51,260
 zero through four

270
00:22:58,860 --> 00:23:02,630
 then those represent of different powers of two ways of

271
00:23:03,539 --> 00:23:07,789
 as I've shown and so now if we take some bit of pattern

272
00:23:18,570 --> 00:23:21,860
 Like so so that's what I'll call x and

273
00:23:23,490 --> 00:23:29,780
 I want to convert that to an unsigned number. I will just combine eight plus

274
00:23:31,080 --> 00:23:36,020
 Four plus one and I'll get 13

275
00:23:37,770 --> 00:23:43,489
 all right, so that's all that equation says the left-hand equation just take the

276
00:23:44,970 --> 00:23:49,250
 positions that are ones use the corresponding [power] of two and you're done and

277
00:23:50,220 --> 00:23:53,150
 Similarly if I have a number where there's a leading bit

278
00:24:01,200 --> 00:24:08,629
 It will be 16 plus 4 plus 2 so that will be 22

279
00:24:11,070 --> 00:24:13,070
 And so that's the unsigned case

280
00:24:13,770 --> 00:24:15,000
 and

281
00:24:15,000 --> 00:24:17,930
 The sign Case is the same idea

282
00:24:18,750 --> 00:24:20,750
 except that most significant debt

283
00:24:24,180 --> 00:24:28,879
 Has a negative value, [so] it will still this is I?

284
00:24:31,740 --> 00:24:37,819
 And our weights will be 1/2 for a but this one. I will be minus 16

285
00:24:39,240 --> 00:24:41,240
 so that's what the

286
00:24:41,430 --> 00:24:43,490
 Equation on the right is saying this bit

287
00:24:44,460 --> 00:24:47,569
 Now we're going to change it from being a negative number to a positive

288
00:24:47,970 --> 00:24:51,949
 so obviously if I have this is my bit pattern it's going to be the same because

289
00:24:52,770 --> 00:24:56,180
 the other [bits] stayed at the same, so let's do it [for] this case of

290
00:24:57,090 --> 00:24:59,090
 1 0

291
00:24:59,100 --> 00:25:01,100
 1 1 0

292
00:25:02,760 --> 00:25:04,760
 So that will be minus 16

293
00:25:06,180 --> 00:25:09,740
 [Plus] 4 Plus 2 so that equal minus 10

294
00:25:12,030 --> 00:25:17,149
 All right, so you see in this case. We have the same bit pattern

295
00:25:18,720 --> 00:25:21,079
 It's just if we interpret it

296
00:25:21,150 --> 00:25:26,960
 You know how we think about what number this represents, then in one case. It's a positive number

297
00:25:27,750 --> 00:25:30,620
 22 and in another case, it's a negative number minus 10

298
00:25:32,430 --> 00:25:34,460
 And that's what these equations do say

299
00:25:39,970 --> 00:25:47,579
 and so the most significant, bit is sometimes called the sign bit because if it's a one the number is going to be negative, so

300
00:25:51,640 --> 00:25:53,640
 [let's]

301
00:25:54,010 --> 00:25:56,010
 Say to think about

302
00:25:57,670 --> 00:26:03,600
 What extreme what are the sort of extreme ranges of [numbers] we can get with these two different [representations]?

303
00:26:12,130 --> 00:26:15,930
 So obviously if these are all zeros my number is going to equal zero

304
00:26:18,490 --> 00:26:20,819
 and if it's all one

305
00:26:26,340 --> 00:26:33,919
 [it'll] be 16 plus 8 plus 4 Plus 2 Plus 1 will be 31

306
00:26:35,820 --> 00:26:39,439
 And over here for the two's complement

307
00:26:41,280 --> 00:26:45,379
 the smallest number well the largest number

308
00:26:46,980 --> 00:26:48,980
 will actually be

309
00:26:50,490 --> 00:26:56,510
 Let me do it this way actually [the] most negative [number] so the smallest number and the strictest sense of the word

310
00:26:57,090 --> 00:26:59,179
 Is this it's minus 16?

311
00:27:01,050 --> 00:27:04,159
 You can argue this by the way that this is the only

312
00:27:04,800 --> 00:27:08,330
 Bit that has a negative weight all the other ones have positive one

313
00:27:08,330 --> 00:27:12,769
 So certainly one and all the rest being zeros is going to be the smallest number

314
00:27:13,470 --> 00:27:15,560
 Consider away the largest number you can represent

315
00:27:20,220 --> 00:27:26,870
 Will be 8 plus 4 Plus 2 Plus [1] which is 15

316
00:27:30,800 --> 00:27:33,460
 And so we call this number you max

317
00:27:37,640 --> 00:27:45,070
 And we call this number t max and we call this number 2 min

318
00:27:48,140 --> 00:27:52,300
 So there's a few things to observe about these numbers all

319
00:27:53,840 --> 00:27:58,030
 that remember this is a 5 bit word size right, so

320
00:28:00,290 --> 00:28:07,899
 You'll see that 31 is pretty close to 32 right in fact it's 2 to the fifth

321
00:28:09,260 --> 00:28:11,260
 minus 1 and

322
00:28:12,320 --> 00:28:14,060
 in General if

323
00:28:14,060 --> 00:28:16,599
 It's a fight and that's for a 5 bit word size

324
00:28:16,600 --> 00:28:21,490
 So you would say in General it will have value 2 to the w if I have a [w] bit number

325
00:28:21,980 --> 00:28:23,980
 Minus 1 and that's what?

326
00:28:25,700 --> 00:28:27,700
 this shows

327
00:28:29,480 --> 00:28:31,839
 And similarly over here

328
00:28:33,590 --> 00:28:36,490
 This is 2 to the minus 2 to the [4th]

329
00:28:38,750 --> 00:28:46,359
 And so we'd say in general that will be minus 2 to the w if it's the w bit number minus 1

330
00:28:48,980 --> 00:28:53,680
 But all these make [sense] by the way you'll notice one other feature is

331
00:28:58,070 --> 00:29:00,070
 a whole string of one

332
00:29:01,230 --> 00:29:05,990
 like this if you sum up those digits 8 plus 4 Plus 2 Plus 1

333
00:29:06,630 --> 00:29:12,259
 will be 1 less than the next bit position up and

334
00:29:13,260 --> 00:29:15,500
 You can think about that if you were to count?

335
00:29:17,220 --> 00:29:24,079
 this number if you were to increment this number by 1 you'd get 1 1 is 0 carry 1 and

336
00:29:24,180 --> 00:29:29,149
 So forth and you'd carry that value up to this position. So these various ways you can think about that

337
00:29:29,940 --> 00:29:31,260
 and

338
00:29:31,260 --> 00:29:33,440
 then similarly this number is

339
00:29:34,620 --> 00:29:42,439
 2 to the 4th minus 1 and so that's equal to 2 to the w minus 1 minus 1

340
00:29:47,460 --> 00:29:49,460
 As is shown here?

341
00:29:51,390 --> 00:29:53,390
 so

342
00:29:54,240 --> 00:29:58,549
 You know there's a lot of the book goes through formulas and done starvation's

343
00:29:59,400 --> 00:30:02,000
 but if you just think about it in these smaller

344
00:30:02,520 --> 00:30:09,710
 scale ways the intuition is pretty easy to get and don't get lost in in formulas when

345
00:30:10,020 --> 00:30:13,700
 Really at the gut level. It's a fairly straightforward sort of ideas

346
00:30:14,550 --> 00:30:21,500
 Well if you ever see some confusions, and you confused try out some small examples and see what they're saying

347
00:30:22,590 --> 00:30:27,350
 another interesting number in the world of Two's complement is

348
00:30:28,230 --> 00:30:31,189
 What happens when you have all ones in your bit pattern?

349
00:30:35,280 --> 00:30:42,139
 and that will have 8 minus 16 plus 8 plus 4 Plus 2 Plus 1 and

350
00:30:43,320 --> 00:30:45,320
 That will equal minus 1

351
00:30:47,460 --> 00:30:48,780
 so

352
00:30:48,780 --> 00:30:55,430
 The bit Pattern all one is always [a] minus 1 in this representation. [I] should mention to complement

353
00:30:55,430 --> 00:30:57,430
 it's not the only way to represent a

354
00:30:57,930 --> 00:31:01,070
 positive and negative numbers, but sometimes called signed numbers

355
00:31:01,260 --> 00:31:06,200
 But it's so universal that you'll hardly ever encounter another case

356
00:31:06,630 --> 00:31:10,819
 So if you understand two's complement you have a pretty good understanding

357
00:31:11,389 --> 00:31:12,869
 of

358
00:31:12,869 --> 00:31:14,869
 What really is going on?

359
00:31:21,660 --> 00:31:29,389
 So these numbers I call you max the biggest unsigned number [team] [n]. The smallest most negative

360
00:31:30,720 --> 00:31:36,079
 To compliment [Lender] and team x the largest most positive two's complement

361
00:31:36,690 --> 00:31:43,850
 This chart shows the range of values for different word sizes or different numbers of bytes, and so [you'll] see that

362
00:31:45,600 --> 00:31:51,199
 with a with an 8 bit number you only have 256 possibilities right and

363
00:31:54,270 --> 00:31:56,270
 so we can either choose to

364
00:31:57,690 --> 00:32:04,129
 Think of those as representing the range from 0 to 255 or [basically] with two's complement numbers. We're just

365
00:32:05,010 --> 00:32:07,520
 Doing a sort of a wraparound, we're saying well

366
00:32:07,520 --> 00:32:12,410
 We're going to have half of them be negative and the other half will be either 0 or positive

367
00:32:15,120 --> 00:32:20,479
 and so it's a pretty limited range of values of course and then 16 and

368
00:32:22,170 --> 00:32:29,300
 believe me back when computers had 16-bit word sizes it was a nuisance to keep your numbers within that range and

369
00:32:29,970 --> 00:32:33,109
 32 gives you a pretty decent range it used to be said

370
00:32:33,960 --> 00:32:35,960
 Microsoft had to go to

371
00:32:36,990 --> 00:32:40,729
 64-bit Word size to represent Bill Gates's net worth But

372
00:32:43,440 --> 00:32:49,309
 for me at least this would easily handle my range of normal Day-To-day transaction, so

373
00:32:51,330 --> 00:32:56,600
 but now with 64-bit at least to us nowadays those seem like really big numbers and

374
00:32:57,270 --> 00:32:59,750
 hard to imagine exceeding the bounds of those

375
00:33:04,380 --> 00:33:10,790
 So one interesting feature that you noticed here was I was um

376
00:33:15,480 --> 00:33:17,480
 like this case here

377
00:33:23,130 --> 00:33:26,570
 in this case here

378
00:33:33,960 --> 00:33:39,499
 and then this case here of all one I

379
00:33:42,930 --> 00:33:44,930
 was comparing it to

380
00:33:45,510 --> 00:33:47,510
 This case here of all one

381
00:33:48,840 --> 00:33:53,929
 So in other words in both these cases and hard to jump boards here

382
00:33:56,280 --> 00:33:59,600
 You're seeing that you have the same bit pattern in either case

383
00:34:00,720 --> 00:34:06,139
 But they the numeric they represent different numeric values because one is the two's complement case

384
00:34:06,780 --> 00:34:13,820
 And the other is an unsigned right and you can actually see the relation between them is pretty simple

385
00:34:14,310 --> 00:34:21,560
 Because basically what we're doing is we're jumping between a plus sixteen and a minus 60

386
00:34:23,010 --> 00:34:27,770
 between those and so you'd expect it to change by 32 right and

387
00:34:28,170 --> 00:34:32,719
 You see that here that this is 31 here and minus 1 this is

388
00:34:33,270 --> 00:34:37,070
 22 [and] minus 10, so they're differ from each other by

389
00:34:38,040 --> 00:34:44,300
 plus or minus 30 to 2 to the fifth [to] to the word size and so we

390
00:34:44,970 --> 00:34:48,830
 sort of a long derivation in the book and things here, but

391
00:34:49,650 --> 00:34:51,300
 that

392
00:34:51,300 --> 00:34:56,509
 Connection is actually fairly important because when you jump back and [forth]

393
00:34:57,180 --> 00:35:01,249
 between unsigned numbers and two's complement numbers in [Sea]

394
00:35:03,039 --> 00:35:09,989
 That that's the jump that [you] get in other words when of in and so

395
00:35:12,010 --> 00:35:14,010
 You'll often find cases where?

396
00:35:14,410 --> 00:35:16,770
 What used to be a very large

397
00:35:17,380 --> 00:35:22,410
 Number because it was unsigned all of a sudden becomes a negative number because it's considered two's complement

398
00:35:23,500 --> 00:35:26,699
 So that's what this next part covers will say that

399
00:35:31,119 --> 00:35:35,429
 if we take a cart of 4 bit numbers

400
00:35:35,430 --> 00:35:39,899
 and we write out all the possible [values] as unsigned or as of

401
00:35:41,530 --> 00:35:47,909
 Two's complement numbers then the ones where the low the higher bit is 0 will be the same in both cases

402
00:35:49,000 --> 00:35:55,619
 the ones where the higher order, bit is a 1 in this case will differ by 16 2 to the 4Th and

403
00:35:58,510 --> 00:36:01,919
 Similarly you'll notice that these numbers. There's a unique

404
00:36:02,619 --> 00:36:08,399
 It goes unique in both directions. There's a for any given bit pattern there's a unique

405
00:36:09,160 --> 00:36:13,859
 number it represents and similarly for any number within the given range

406
00:36:14,380 --> 00:36:16,380
 There's a unique bit pattern

407
00:36:16,510 --> 00:36:18,430
 so we can sort of

408
00:36:18,430 --> 00:36:20,700
 jump between those two and

409
00:36:21,579 --> 00:36:23,579
 Say I

410
00:36:23,829 --> 00:36:25,829
 Can make up a rule?

411
00:36:26,079 --> 00:36:31,979
 For converting between a two's complement number x and an unsigned number [ux] that

412
00:36:32,559 --> 00:36:39,119
 Basically says. I'll use the same bit. I'll just think of them as [being] different numbers and so and

413
00:36:40,180 --> 00:36:41,980
 You can go either way

414
00:36:41,980 --> 00:36:45,389
 so for example if we thought of this is a a

415
00:36:48,730 --> 00:36:50,939
 Two's complement representative

416
00:36:52,119 --> 00:36:53,650
 representation

417
00:36:53,650 --> 00:36:55,599
 It's minus 1

418
00:36:55,599 --> 00:36:58,528
 This function. I'm calling [t] [to] you

419
00:36:59,680 --> 00:37:04,230
 goes from that number minus 1 to this number 31 as

420
00:37:06,069 --> 00:37:11,609
 The where in between the two I'm saying they both have the same bit pattern

421
00:37:15,710 --> 00:37:16,820
 and

422
00:37:16,820 --> 00:37:18,820
 The reason why this rather?

423
00:37:19,190 --> 00:37:25,150
 Function that would otherwise seem to have no particular use is important is because that's basically what happens in

424
00:37:25,700 --> 00:37:28,840
 [Cr]. Actually in the program in the

425
00:37:29,750 --> 00:37:37,449
 Program on the [computer] itself has no clue whether a given bit pattern if it's something you're thinking of as being a negative

426
00:37:37,820 --> 00:37:42,189
 None signed number or tooth compliment number. It's just [a] bunch of bits to it and

427
00:37:43,460 --> 00:37:50,650
 Similarly we can go back and forth between a two's complement [and] unsigned keeping the bit patterns the same

428
00:37:53,570 --> 00:37:59,289
 And so I'll call [that] t to you when I go from signed to unsigned two's complement tons

429
00:38:00,320 --> 00:38:04,390
 Unsigned and said well, I'll call it u [2t]. If I go from unsigned to signed

430
00:38:06,350 --> 00:38:07,850
 and

431
00:38:07,850 --> 00:38:12,039
 As I mentioned the difference for the the numbers where the high order?

432
00:38:12,040 --> 00:38:17,979
 Bit is a 1 will be by a factor 2 to the w where w is the word size of the word?

433
00:38:19,940 --> 00:38:21,940
 and

434
00:38:21,980 --> 00:38:23,980
 So this can be thought of as a function

435
00:38:26,930 --> 00:38:28,930
 where

436
00:38:34,380 --> 00:38:36,380
 Let me just draw [it] out

437
00:38:47,070 --> 00:38:51,530
 over here with my five bit numbers

438
00:38:54,750 --> 00:38:56,750
 That is the number

439
00:38:57,390 --> 00:39:01,369
 This is to complement again. So that was the number of minus [sixteen] and

440
00:39:02,370 --> 00:39:05,599
 Then there'll be some other negative numbers up to all one

441
00:39:08,910 --> 00:39:12,410
 This number negative one and then I'll have zero

442
00:39:15,510 --> 00:39:18,260
 And so forth and then all up to

443
00:39:21,660 --> 00:39:24,020
 I'm going to run a room

444
00:39:27,060 --> 00:39:32,150
 Plus [fifteen], I just draw I got myself in trouble

445
00:39:37,080 --> 00:39:40,640
 Blackboard management is they didn't teach me this cool?

446
00:39:44,280 --> 00:39:46,280
 so I'm going to

447
00:39:47,700 --> 00:39:49,700
 Use two boards at once here

448
00:39:56,550 --> 00:39:58,550
 oh

449
00:40:05,890 --> 00:40:07,890
 What makes it okay?

450
00:40:14,350 --> 00:40:16,030
 [we'll] make it work

451
00:40:16,030 --> 00:40:17,710
 so now

452
00:40:17,710 --> 00:40:21,390
 when we go from the [ttU] function then

453
00:40:22,210 --> 00:40:24,360
 These numbers are going to just carry over

454
00:40:25,000 --> 00:40:27,000
 We'll get zero

455
00:40:28,030 --> 00:40:30,030
 up through [fifteen]

456
00:40:32,020 --> 00:40:36,509
 But now this number here will become positive sixteen

457
00:40:39,820 --> 00:40:42,360
 and all one

458
00:40:46,240 --> 00:40:48,419
 Will become positive thirty-one

459
00:40:50,050 --> 00:40:56,130
 Right and so that's what this picture is showing is it for the pink numbers?

460
00:40:56,650 --> 00:40:59,460
 are the ones that flip between negative and

461
00:41:00,190 --> 00:41:03,090
 actually the largest of the positive numbers and

462
00:41:03,640 --> 00:41:08,459
 Then the green numbers are the ones that stay [the] same because they're leading bit to zeros

463
00:41:14,359 --> 00:41:16,359
 So why does this matter?

464
00:41:17,269 --> 00:41:21,158
 you never thought if you programmed in python say or even

465
00:41:22,009 --> 00:41:25,599
 Java you don't see that and the reason is because

466
00:41:26,419 --> 00:41:33,219
 C is one of the few languages where unsigned is actually an explicit datatype and

467
00:41:34,099 --> 00:41:37,568
 You so you can declare a value being unsigned in it

468
00:41:38,029 --> 00:41:42,158
 You can if you just say unsigned what you're really saying is unsigned int

469
00:41:42,979 --> 00:41:47,979
 Or you can call something an unsigned care and unsigned short or an unsigned long

470
00:41:49,279 --> 00:41:53,829
 So and you're declaring and see that it should think about using this

471
00:41:54,859 --> 00:41:57,248
 representation we show on the right when it's

472
00:41:58,219 --> 00:42:00,219
 working on those numbers

473
00:42:01,699 --> 00:42:04,418
 So that's sort of one thing and this

474
00:42:05,029 --> 00:42:11,529
 It's one thing if you declare a number and use it that way, but what gets people and often got you is

475
00:42:12,049 --> 00:42:14,049
 if you declare something

476
00:42:14,929 --> 00:42:16,929
 If you have a in this case

477
00:42:17,419 --> 00:42:21,309
 something that's declared as a [to] [complement] number x to x and

478
00:42:21,619 --> 00:42:25,688
 You assign it a value you at y x it will do an implicit casting

479
00:42:26,479 --> 00:42:32,319
 which is exactly based on this conversion that we've been talking about and vice versa and

480
00:42:33,199 --> 00:42:35,199
 [so]

481
00:42:36,589 --> 00:42:43,869
 as this example goes through this goes through some examples that if I look at two numbers and

482
00:42:45,349 --> 00:42:50,888
 I compare them or [I] actually I do any operation on them. I add them divide them anything

483
00:42:52,489 --> 00:42:59,019
 Implicitly, it will try to make these to be of the same [type] and the way it will do that is to say if both

484
00:42:59,019 --> 00:43:00,559
 [of] them are signed

485
00:43:00,559 --> 00:43:03,548
 Then I'll do I'll treat them as a signed

486
00:43:04,429 --> 00:43:07,329
 Case if either of them is unsigned

487
00:43:07,759 --> 00:43:12,668
 then I'll convert the other one to be an unsigned number and do the operation and

488
00:43:13,009 --> 00:43:16,509
 So in particular this set of examples is imagine

489
00:43:16,509 --> 00:43:21,218
 I'm comparing these I'm saying these numbers are either equal less or greater

490
00:43:21,889 --> 00:43:27,369
 What will the outcomes be and the key to answering that question is to first of all figure out?

491
00:43:27,980 --> 00:43:32,199
 Okay, is it assigned or an unsigned comparison should I convert?

492
00:43:33,980 --> 00:43:35,980
 one of these numbers to

493
00:43:36,200 --> 00:43:39,700
 either of these numbers to an unsigned form before I do it and

494
00:43:40,010 --> 00:43:44,320
 the rule was if either argument is unsigned then you got to do it and

495
00:43:45,050 --> 00:43:51,909
 as you see when you put [a] you at the end either a lowercase [u] or uppercase u at the end of a

496
00:43:52,370 --> 00:43:56,349
 Numeric constant you're saying this is an unsigned value

497
00:43:57,080 --> 00:43:59,769
 so for example if we compare a

498
00:44:01,850 --> 00:44:04,989
 0 and 0 unsigned they're equal

499
00:44:07,640 --> 00:44:10,119
 and if we combine negative 1

500
00:44:10,910 --> 00:44:12,910
 compare negative 1 to 0

501
00:44:13,400 --> 00:44:14,750
 we'll get

502
00:44:14,750 --> 00:44:19,030
 That the first one is less because negative 1 is less [than] 0

503
00:44:20,120 --> 00:44:24,759
 But what would happen with the next one when we compare negative 1 to an unsigned 0?

504
00:44:26,570 --> 00:44:28,570
 greater

505
00:44:29,450 --> 00:44:35,470
 right, so this is the surprise and it has to do with a

506
00:44:38,960 --> 00:44:40,960
 number that I erased

507
00:44:43,940 --> 00:44:47,409
 But we can still get it remember. This is negative 1

508
00:44:49,340 --> 00:44:50,870
 but when I

509
00:44:50,870 --> 00:44:53,859
 Cast that to an unsigned number. I'm

510
00:44:55,070 --> 00:44:59,860
 Flipping this from minus 16 to positive 16 and turning this into 31

511
00:44:59,860 --> 00:45:03,880
 I'm turning it into actually the largest number I can represent and

512
00:45:04,400 --> 00:45:06,400
 So it will be greater than 0

513
00:45:07,340 --> 00:45:12,850
 So it's a little bit weird to think about I took an unsigned 0 which after all is to 0 and

514
00:45:13,460 --> 00:45:16,540
 Compared it to negative 1 [and] it said oh

515
00:45:17,180 --> 00:45:22,870
 You really meant 31 didn't you or whatever word size were using and so it said, it's greater

516
00:45:24,890 --> 00:45:28,809
 And basically the rest of these you can answer in a similar way that

517
00:45:33,080 --> 00:45:38,559
 These two numbers are this is clearly one smaller than this

518
00:45:39,920 --> 00:45:41,920
 No, I'm sorry

519
00:45:41,930 --> 00:45:47,649
 [this] is a positive. This is a negative number and if I compare those and

520
00:45:48,650 --> 00:45:50,650
 The positive will be greater than the negative

521
00:45:51,859 --> 00:45:59,169
 I'll tell you in a minute. Why this number is written this way the next one. It's the same pair of numbers

522
00:46:00,950 --> 00:46:04,810
 but you see it flipped and the reason is that

523
00:46:06,950 --> 00:46:08,950
 this number on the left is

524
00:46:10,040 --> 00:46:12,429
 [t] Max [4]

525
00:46:19,430 --> 00:46:22,510
 So it's the bit Pattern in a 32-bit [number]

526
00:46:48,819 --> 00:46:50,589
 um

527
00:46:50,589 --> 00:46:57,028
 To this day I've not memorized this number by the way, but and then this number is actually [t] [min]

528
00:47:14,270 --> 00:47:16,250
 and

529
00:47:16,250 --> 00:47:20,469
 That when I subtract you can think of it as this is negative t

530
00:47:21,350 --> 00:47:22,640
 Max

531
00:47:22,640 --> 00:47:24,640
 Minus [one], so that's t min

532
00:47:24,650 --> 00:47:29,889
 So if I do an unsigned comparison between those two now think of those this leading

533
00:47:30,230 --> 00:47:36,370
 bit not being a negative weight, but a positive weight you'll see that this is [a] bigger number than this one and

534
00:47:42,410 --> 00:47:47,949
 [so] it so it goes that minus 1 is greater than minus 2 if they're unsigned

535
00:47:49,220 --> 00:47:51,220
 Because minus 1 is

536
00:47:51,440 --> 00:47:58,209
 You can think of it as converts into [U] max it will be the biggest number possible and minus 2 will be

537
00:48:00,200 --> 00:48:02,200
 would be 1 1

538
00:48:02,900 --> 00:48:05,170
 1 1 0

539
00:48:17,480 --> 00:48:20,320
 So that can get fairly confusing

540
00:48:23,390 --> 00:48:26,859
 One final quirk this way of writing this number

541
00:48:26,859 --> 00:48:33,159
 is there's a little side in the book about it if you write a business number oh as

542
00:48:33,800 --> 00:48:37,509
 you'd expect - as - blah blah blah [six] four eight

543
00:48:40,220 --> 00:48:44,649
 It will actually get the C compiler gets kind of confused by that

544
00:48:45,950 --> 00:48:53,919
 For obscure reasons one other thing I should point out that it's a property that I don't think we cover well enough here

545
00:48:55,940 --> 00:48:57,940
 let me see

546
00:49:02,330 --> 00:49:07,900
 There's a few things that the slides don't really cover here, and I don't know why not. I like to point out

547
00:49:13,700 --> 00:49:16,179
 so they're kind of useful [properties] to keep track of

548
00:49:24,740 --> 00:49:25,940
 is

549
00:49:25,940 --> 00:49:27,620
 that

550
00:49:27,620 --> 00:49:32,410
 You notice that if you look at the absolute [value] of t max?

551
00:49:33,140 --> 00:49:34,940
 and

552
00:49:34,940 --> 00:49:37,599
 You compare it to the absolute value [of] t min?

553
00:49:40,280 --> 00:49:42,280
 that it's off by [1]

554
00:49:46,010 --> 00:49:53,920
 Right so that the negative number is more negative the smallest negative number is more negative than the largest

555
00:49:53,920 --> 00:50:00,519
 positive number is positive and the reason for that actually is fairly simple if you think about it is that

556
00:50:02,450 --> 00:50:05,139
 The cases where you have zeros?

557
00:50:07,640 --> 00:50:09,640
 includes the number [0]

558
00:50:20,790 --> 00:50:22,790
 you can see it better and

559
00:50:26,160 --> 00:50:29,030
 [there's] two to the half year ranges

560
00:50:30,630 --> 00:50:33,920
 occupied by those numbers and the negative numbers

561
00:50:35,369 --> 00:50:37,369
 are all negative

562
00:50:40,680 --> 00:50:46,700
 and there's so the other half of the range is in there and

563
00:50:48,180 --> 00:50:53,599
 The point is that you had to use one of these [for] zero and so they're only there's one less

564
00:50:54,660 --> 00:50:59,180
 One less value left over, and that's why you end up with this

565
00:51:00,510 --> 00:51:02,040
 asymmetry

566
00:51:02,040 --> 00:51:06,589
 And this asymmetry is the cause of no end of pain in various ways

567
00:51:07,260 --> 00:51:09,260
 that like a few

568
00:51:10,290 --> 00:51:15,229
 The classic example is if you implement absolute value

569
00:51:32,980 --> 00:51:39,629
 Like so what do you what does this return for team in?

570
00:51:44,260 --> 00:51:49,619
 Yeah, the returns team in we'll talk a little bit basically

571
00:51:51,430 --> 00:51:55,710
 When you try to negate this number that's here

572
00:51:58,750 --> 00:52:00,750
 You'll end up with it back again

573
00:52:07,580 --> 00:52:09,580
 So it's always a corner case

574
00:52:10,340 --> 00:52:15,880
 And whenever we do program testing we always throw that case in there to break things question

575
00:52:32,930 --> 00:52:36,040
 know that they do that if you ever look at the

576
00:52:36,710 --> 00:52:37,730
 in

577
00:52:37,730 --> 00:52:42,459
 the length and the C constants they use this as a way of representing team in and

578
00:52:42,890 --> 00:52:46,000
 They do it for that reason because you see

579
00:52:46,910 --> 00:52:50,710
 It's [exactly] the spot and they put parentheses around it, so there's no

580
00:52:51,380 --> 00:52:56,589
 President's problem, but you see that number that in six for seven that team acts and

581
00:52:58,310 --> 00:53:05,200
 So basically it's just saying that team n. Is minus t max minus one question

582
00:53:13,089 --> 00:53:15,449
 Well- [Wonderful] would get you laughs

583
00:53:17,049 --> 00:53:24,299
 Yeah, [Mm-hmm]. Yes, so comparison is just a special case [of] the more general one which is

584
00:53:26,020 --> 00:53:33,869
 Addition subtraction all of those if either argument is unsigned then it interprets remaining. What is being unsigned it?

585
00:53:35,049 --> 00:53:42,209
 It turns out, and we'll get into this more next time as far as bit patterns, but it turns out that at the bit level

586
00:53:43,930 --> 00:53:45,789
 addition

587
00:53:45,789 --> 00:53:47,680
 subtraction even

588
00:53:47,680 --> 00:53:54,869
 Multiplication are the same whether it's an unsigned number two's complement number so what we'll talk about that more next time

589
00:53:58,240 --> 00:54:03,539
 And the other thing to observe, sort of property

590
00:54:16,390 --> 00:54:21,160
 Is uh you saw that you [maxis] is sort of like

591
00:54:25,069 --> 00:54:27,069
 Twice [team] x plus one

592
00:54:30,650 --> 00:54:34,180
 right so before you max was

593
00:54:35,630 --> 00:54:42,190
 15 in our five bit numbers, and that's again not too hard to figure out

594
00:54:44,240 --> 00:54:50,109
 [here's] one way to think about it t max is a zero followed by a bunch of [ones] and

595
00:54:52,819 --> 00:55:00,038
 if I want to double that number I basically shift it left by one position and

596
00:55:01,369 --> 00:55:06,399
 That would end up with a zero here, so this is ut, Max

597
00:55:08,299 --> 00:55:10,299
 and this is twice team x

598
00:55:11,750 --> 00:55:14,409
 and now if I add a [one] to that

599
00:55:15,650 --> 00:55:20,769
 I'll just set this bit to one and get this so there's various ways [you] can think about it

600
00:55:20,769 --> 00:55:22,769
 But that's one way [to] do it

601
00:55:34,520 --> 00:55:36,520
 um

602
00:55:39,869 --> 00:55:41,869
 It's one other

603
00:55:43,109 --> 00:55:45,439
 Thing that I wanted to mention, too

604
00:55:46,859 --> 00:55:49,278
 This can get you into a lot of trouble

605
00:55:52,019 --> 00:55:57,019
 Programming why so let me just show you what I mean

606
00:56:06,630 --> 00:56:08,630
 so imagine I wanted to

607
00:56:13,410 --> 00:56:18,469
 Go backwards through an array, so I write a loop of the form for [I]

608
00:56:20,009 --> 00:56:24,829
 equals N [minus] 1 I is greater than

609
00:56:27,569 --> 00:56:29,569
 or equal to 0 I

610
00:56:31,200 --> 00:56:36,889
 - - and then I do something with Array element a of [I]

611
00:56:40,079 --> 00:56:42,079
 [I'll] just call some function eyes

612
00:56:43,619 --> 00:56:47,568
 Whatever you want to do in that loop. So that's a pretty standard pattern in a loop, right?

613
00:56:48,299 --> 00:56:49,650
 Except that

614
00:56:49,650 --> 00:56:52,160
 You write this greater equal [To10]?

615
00:56:53,999 --> 00:57:01,279
 You can imagine various uses for that. So here's an interesting question. What if I?

616
00:57:03,449 --> 00:57:05,449
 Were declared as being unsigned?

617
00:57:08,839 --> 00:57:12,339
 Because it's array index after all what will happen with this loop?

618
00:57:14,570 --> 00:57:16,570
 Hmm. Yeah

619
00:57:17,780 --> 00:57:19,780
 What's that?

620
00:57:20,030 --> 00:57:27,580
 Yes, so the loop will go forever. What would most likely happen is I would go from being 0 to being U max and

621
00:57:28,670 --> 00:57:32,379
 that's a really big number and the ray you'd uh

622
00:57:33,740 --> 00:57:35,690
 most likely

623
00:57:35,690 --> 00:57:38,619
 Cause a memory fault because it's so far out of bounds

624
00:57:39,260 --> 00:57:43,780
 But the point is it wouldn't do what you want. It wouldn't stop where you want it to and

625
00:57:44,810 --> 00:57:47,469
 because of the simple reason that I is of course I

626
00:57:48,080 --> 00:57:52,359
 Is always going to be greater than or equal to zero because it's an unsigned number

627
00:57:53,030 --> 00:57:54,589
 so that's uh

628
00:57:54,589 --> 00:57:56,589
 One you'd say okay well

629
00:57:57,890 --> 00:58:01,780
 You should have figured that one [out] it can be paired more subtle though

630
00:58:06,000 --> 00:58:09,989
 if you have something [like] int, I

631
00:58:13,570 --> 00:58:15,809
 and then we say something like

632
00:58:18,490 --> 00:58:21,869
 Let me just change. It here a little bit, so this will be

633
00:58:40,210 --> 00:58:42,210
 something like this where

634
00:58:42,880 --> 00:58:47,849
 the I'm mixing metaphors here I have to confess, but if you use the

635
00:58:49,000 --> 00:58:55,859
 Standard the term [sizeof] which is the way you get how many bytes it takes to [represent] some given Data type?

636
00:58:56,109 --> 00:58:58,169
 So this will actually be the number one

637
00:58:59,140 --> 00:59:03,030
 So it's not the same loop as before but imagine. I'm sort of mixing in of

638
00:59:04,450 --> 00:59:07,770
 My arithmetic and making use of some of these built-in forms

639
00:59:10,060 --> 00:59:12,060
 What would happen with this loop?

640
00:59:13,810 --> 00:59:15,810
 Yeah

641
00:59:17,260 --> 00:59:19,260
 right

642
00:59:20,510 --> 00:59:23,799
 Yes, exactly so sizeof

643
00:59:24,590 --> 00:59:27,730
 Returns an unsigned value, it's not actually a function

644
00:59:27,730 --> 00:59:32,679
 it's a built in but it's the result of [Sizeof] is considered to be unsigned and

645
00:59:34,280 --> 00:59:35,630
 so

646
00:59:35,630 --> 00:59:37,930
 just like I was saying if you have a

647
00:59:39,170 --> 00:59:42,039
 signed value [in] an unsigned in any kind of arithmetic

648
00:59:42,950 --> 00:59:43,970
 it'll

649
00:59:43,970 --> 00:59:47,289
 Turn treat the combination of the two is unsigned

650
00:59:47,290 --> 00:59:53,620
 And so it will actually do an unsigned comparison here. Which is almost surely not what you wanted

651
00:59:54,590 --> 00:59:56,590
 and this will just

652
00:59:58,130 --> 01:00:04,000
 You'll look at this program, and you will have any idea why it's crashing you'll be so confused

653
01:00:04,790 --> 01:00:08,110
 And that's the kind of thing you have to know it's one of the quirks of C

654
01:00:08,110 --> 01:00:14,289
 That probably a fake could start over again and redesign it. They'd come up with some different set of conventions than they did

655
01:00:14,870 --> 01:00:19,270
 But unfortunately, it's way too late for [that], so this is [just] one of those things you have to remember

656
01:00:20,780 --> 01:00:22,250
 but yes

657
01:00:22,250 --> 01:00:28,869
 My point is there's some subtleties to Spencie about this business of [sign] versus unsigned arithmetic

658
01:00:35,910 --> 01:00:41,239
 Okay, so now let's look at a sort of final class of operations which is

659
01:00:42,180 --> 01:00:49,039
 suppose I have a number that so many bits say eight bits, and I want to now expand it to be a

660
01:00:49,860 --> 01:00:57,410
 16-bit number, but it's a fairly cute rule for doing this that's called sign extension. I'm talking about

661
01:00:57,960 --> 01:01:00,949
 Two's complement numbers here of how you go

662
01:01:01,500 --> 01:01:02,550
 take A

663
01:01:02,550 --> 01:01:06,410
 And make it bigger without changing its value

664
01:01:07,920 --> 01:01:09,920
 and the

665
01:01:10,410 --> 01:01:17,689
 [basic] rule is you do it by copying the sign bit to the left so let me give you the intuition behind that?

666
01:01:29,580 --> 01:01:32,029
 So let's [look] [at] some 4-bit value

667
01:01:41,700 --> 01:01:44,810
 well, it's pretty straightforward the leading bit is a 0

668
01:01:46,650 --> 01:01:51,950
 I'm just going to do a left shift and then fill in so

669
01:01:57,750 --> 01:02:00,709
 Right wait what am I talking about I?

670
01:02:04,410 --> 01:02:10,160
 Got ahead of myself. [I'm] talking about something totally different. No. Sorry the same number. [I'm] not changing the number

671
01:02:10,160 --> 01:02:12,680
 I'm keeping it the same so I just add a zero to the

672
01:02:13,650 --> 01:02:19,190
 Leading and this will be the number six still this is plus four plus two equals six

673
01:02:21,570 --> 01:02:25,549
 But now let's think about it as a where. There's a leading sign bit

674
01:02:28,650 --> 01:02:35,780
 So this is minus 8 plus four plus two is equal to minus [two]

675
01:02:37,530 --> 01:02:44,719
 So now what look at what happens if I copy that sign bit over one position?

676
01:02:47,730 --> 01:02:50,090
 so this becomes a 1

677
01:02:51,510 --> 01:02:56,270
 1 1 1 0 and

678
01:02:57,660 --> 01:03:05,299
 what happens is this is a now has value plus 8 here, but the sign bit has value minus 16 and

679
01:03:05,880 --> 01:03:07,910
 Then this is still +2 and +4

680
01:03:09,750 --> 01:03:12,199
 And so it will still equal minus 2

681
01:03:13,500 --> 01:03:17,360
 So here's what happened before my sign bit

682
01:03:18,450 --> 01:03:20,510
 had a weight of minus 8 and

683
01:03:21,420 --> 01:03:24,260
 [my] new sign, bit has a weight of minus 16

684
01:03:25,230 --> 01:03:31,850
 But I converted that old sign bit into a positive number. Which is plus 8 and those 2 cancelled out

685
01:03:32,580 --> 01:03:40,580
 sit right the duck that you combine those two and you get minus 8 which is exactly this so you see by sort of

686
01:03:42,030 --> 01:03:44,030
 Copying that sign bit over

687
01:03:44,580 --> 01:03:47,059
 Giving it twice the weight turning it

688
01:03:47,310 --> 01:03:53,600
 What was the sign bit into a positive number you don't change the net effect of the sum?

689
01:03:53,820 --> 01:04:00,380
 and that's exactly the idea of sign extension just keep going with [that] as far as you need to carry it over and

690
01:04:00,720 --> 01:04:04,640
 each time [you] doing it you're effectively doing this business of

691
01:04:06,390 --> 01:04:11,629
 Coming up with a pair of bits that end up with the same value is this original bit?

692
01:04:13,440 --> 01:04:16,760
 So that's the idea of sign extension, and you'll see that a lot in

693
01:04:19,530 --> 01:04:26,989
 bit patterns, especially if you see a bit pattern with it starts with a bunch of f

694
01:04:35,600 --> 01:04:40,450
 What that tells you remember [f] is just for one?

695
01:04:45,200 --> 01:04:49,389
 Is a whole bunch of leading one that tells you the number is negative

696
01:04:50,780 --> 01:04:56,290
 Negative but not too far away from zero right and and you'll see that over and over again

697
01:04:56,290 --> 01:05:01,330
 You'll see bit patterns, and you just sort of want it when you see leading f's you say. Oh, that's a negative number

698
01:05:01,330 --> 01:05:03,330
 I know what's going on there?

699
01:05:05,570 --> 01:05:07,570
 and

700
01:05:07,730 --> 01:05:13,359
 So here's some examples, but like you can see the main idea is you carry that leading bit?

701
01:05:14,180 --> 01:05:19,869
 From the 16-bit case over and make as many copies. You need to expand the word size

702
01:05:24,950 --> 01:05:31,029
 [and] I should mention with the unsigned case obviously you just want to fill in with zeros

703
01:05:36,350 --> 01:05:41,529
 to talk about location and [send] missing slides in this but

704
01:05:47,810 --> 01:05:54,009
 A final case to look at is what happens if I make something shorter?

705
01:05:56,810 --> 01:05:59,590
 so if I had my unsigned number from before

706
01:06:06,980 --> 01:06:09,730
 if this were an unsigned number this would be

707
01:06:11,540 --> 01:06:16,360
 1 2 8 16 14

708
01:06:17,900 --> 01:06:19,900
 17 right

709
01:06:21,470 --> 01:06:23,590
 What if I decided oh, I can't afford

710
01:06:28,070 --> 01:06:31,779
 For bit, I don't have enough money [for] five bits. I'm only going to give you four

711
01:06:33,230 --> 01:06:36,010
 well you basically just drop the most significant bit and

712
01:06:37,970 --> 01:06:39,950
 you get

713
01:06:39,950 --> 01:06:45,310
 Eight [plus] two [plus] one which is a [low] which is nine

714
01:06:47,670 --> 01:06:52,379
 And the relation there is that this is it's like modular arithmetic

715
01:06:58,890 --> 01:07:02,180
 Right Mod 16 you're taking no

716
01:07:07,050 --> 01:07:09,050
 Thank you

717
01:07:12,210 --> 01:07:16,760
 the risk of improvising So 27

718
01:07:21,300 --> 01:07:23,300
 and 11

719
01:07:26,340 --> 01:07:28,340
 Yeah, [make] [cent]

720
01:07:31,080 --> 01:07:33,080
 [difference] a 16 I knew that

721
01:07:35,130 --> 01:07:37,760
 Okay, excuse me for my stumbling

722
01:07:37,760 --> 01:07:43,159
 But the point being that when you drop this thing effectively you're just taking the mod

723
01:07:43,890 --> 01:07:45,890
 Some power of two of it

724
01:07:46,500 --> 01:07:52,369
 Like I mentioned the case where you're taking module eight if you just keep the only the lowest sort of three bits

725
01:07:52,370 --> 01:07:58,279
 You're having module eight now one really this is a sort of logical in the unsigned world

726
01:07:58,590 --> 01:08:01,039
 Your modular arithmetic is something that

727
01:08:01,560 --> 01:08:04,430
 Was understood by the ancient [Greek]?

728
01:08:05,160 --> 01:08:07,160
 So not too

729
01:08:07,860 --> 01:08:09,860
 Far away from

730
01:08:10,110 --> 01:08:12,110
 human experience

731
01:08:12,870 --> 01:08:15,980
 but it gets a little bit funky if you're

732
01:08:19,650 --> 01:08:25,189
 Dealing with two's complement numbers because this is now

733
01:08:29,550 --> 01:08:32,719
 Ten Eleven minus five right

734
01:08:35,310 --> 01:08:37,820
 But this number if I just drop this bit

735
01:08:38,460 --> 01:08:39,600
 and

736
01:08:39,600 --> 01:08:42,439
 Call it a 4-bit number this now becomes minus eight

737
01:08:43,200 --> 01:08:45,200
 two and one

738
01:08:49,770 --> 01:08:51,770
 Which might have five?

739
01:08:56,310 --> 01:09:02,720
 You say how'd that happen? Well actually if you look at it. This is [just] what [you'd] get by sign extension, right?

740
01:09:04,470 --> 01:09:06,740
 So this wasn't a very interesting example

741
01:09:11,870 --> 01:09:13,870
 but if we changed it to this

742
01:09:22,400 --> 01:09:29,710
 Then this would be minus 13 and this would be plus 3

743
01:09:32,600 --> 01:09:34,600
 and

744
01:09:38,029 --> 01:09:44,769
 It's a little harder to think about in terms of modular arithmetic the way you basically have to think about it is well

745
01:09:45,710 --> 01:09:50,560
 you know this is minus 13, but it's really kind of like 27 and

746
01:09:51,920 --> 01:09:54,399
 27 Mod 16 is sort of like

747
01:09:55,130 --> 01:09:58,270
 Or no, this isn't 20. We changed our number, right?

748
01:09:58,670 --> 01:10:05,620
 So this is really kind of like 19 and 19 mod 16 is 3 and this is 3 so

749
01:10:05,900 --> 01:10:07,900
 you can sort of do it by

750
01:10:08,690 --> 01:10:11,830
 Coming back around to it, but it's not some

751
01:10:12,980 --> 01:10:20,919
 arithmetic property that would jump out at you as being something logical, but that happens all the time that and it's very common for

752
01:10:22,010 --> 01:10:29,440
 Numbers to get truncated for one reason or another and you can see that you can have a negative number become a positive number you

753
01:10:29,600 --> 01:10:33,969
 Can have a positive number become a negative number and all kinds of goofy stuff can happen

754
01:10:35,750 --> 01:10:38,500
 And we'll see [funny] examples of that when we look at arithmetic

755
01:10:40,760 --> 01:10:42,760
 so that's

756
01:10:45,230 --> 01:10:50,649
 That is what I want to cover today, and we'll cover the other arithmetic operation on

757
01:10:51,440 --> 01:10:53,710
 Tuesday, so thank you very much

