1
00:00:00,000 --> 00:00:05,016
这一切， 大家下午好 

2
00:00:01,005 --> 00:00:06,087
欢迎很高兴见到你，欢迎 到 

3
00:00:05,016 --> 00:00:11,375
所有这些谁正在看 录像带 

4
00:00:06,087 --> 00:00:12,186
还有我想澄清 ，我意识到 

5
00:00:11,519 --> 00:00:15,990
最后 的 演讲后，我没有 

6
00:00:13,086 --> 00:00:17,100
解释 的峰值内存 的想法 

7
00:00:15,099 --> 00:00:19,173
利用得非常好给你，所以我想

8
00:00:18,000 --> 00:00:22,071
只是解释 说，这是一个重要的 

9
00:00:20,073 --> 00:00:27,114
想法，我想请确保 

10
00:00:22,071 --> 00:00:31,143
我们必须清楚 ，如果你还记得这么召回 

11
00:00:28,014 --> 00:00:42,039
从我们有我们执行的一系列 

12
00:00:32,043 --> 00:00:48,602
请求，R 0 R 1个R 2 RK向上的序列

13
00:00:42,039 --> 00:00:55,958
我们n减1，并在在任何点 

14
00:00:48,989 --> 00:01:03,320
之后的时间K 1 k加 1级 的要求，我们 有 

15
00:00:56,309 --> 00:01:03,320
ħķ这是堆大小 

16
00:01:05,159 --> 00:01:28,164
k加1后的请求，然后我们有一个 

17
00:01:18,031 --> 00:01:32,880
Ëķ其是聚合的总和 

18
00:01:28,659 --> 00:01:37,737
所有 k加1 后的有效载荷的 

19
00:01:33,159 --> 00:01:41,920
申请好了，所以我们现在要做的 

20
00:01:38,439 --> 00:01:45,670
这种这场PK测量这个总

21
00:01:41,092 --> 00:01:46,159
有效载荷是在任何时间点，以便我们 

22
00:01:45,067 --> 00:01:50,376
当我们执行 后的一个请求 

23
00:01:47,059 --> 00:01:52,147
在所有有效载荷的其他总和 

24
00:01:50,979 --> 00:01:56,013
堆将会增加或减少 

25
00:01:53,047 --> 00:01:58,506
右所以如果我们执行与分配 

26
00:01:56,319 --> 00:02:02,355
那么有效载荷的这个规模将

27
00:01:58,929 --> 00:02:04,005
增加，如果我们执行一个免费大小 

28
00:02:02,679 --> 00:02:07,720
所有这些分配的有效载荷将

29
00:02:04,689 --> 00:02:09,750
减少右所以这样我们在 执行 

30
00:02:07,072 --> 00:02:11,137
这些请求在这个序列

31
00:02:10,299 --> 00:02:14,730
聚集所有有效载荷的总和 

32
00:02:12,037 --> 00:02:17,119
将要增加和减少 

33
00:02:14,073 --> 00:02:19,081
好吧 还等什么我们是什么我们 

34
00:02:18,019 --> 00:02:21,468
与所有这些的总和捕捉 

35
00:02:19,081 --> 00:02:23,176
有效载荷它就像一个完美的分配器 

36
00:02:21,639 --> 00:02:28,060
有没有开销 ，甚至更多 

37
00:02:24,076 --> 00:02:29,143
这样一个我们可以 在那里我们允许 

38
00:02:28,006 --> 00:02:33,305
紧凑的块 ，这样所有的总和 

39
00:02:30,043 --> 00:02:37,075
该有效负载是最小的 可能 

40
00:02:33,359 --> 00:02:40,431
堆大小或它的最小可能 

41
00:02:37,075 --> 00:02:43,344
这些所需 的字节数

42
00:02:41,079 --> 00:02:45,970
分配的块好了，这是非常非常 

43
00:02:44,019 --> 00:02:47,920
进取，这是不可能 的 

44
00:02:45,097 --> 00:02:50,586
实现但我们要使用它作为 

45
00:02:47,092 --> 00:02:55,179
排序我们最好的情况很好，而且这么 

46
00:02:51,459 --> 00:02:56,790
衡量一个高峰

47
00:02:57,098 --> 00:03:15,137
k加1后皮裤内存利用率 

48
00:03:09,018 --> 00:03:24,084
请求将表示的Kü这 

49
00:03:16,019 --> 00:03:28,066
要等于最大 所有我 

50
00:03:24,084 --> 00:03:27,733
小于或等于 K 

51
00:03:32,045 --> 00:03:40,091
我们的总有效载荷的除以 

52
00:03:38,033 --> 00:03:44,036
堆的大小为K加1之后后 

53
00:03:40,091 --> 00:03:46,139
申请好了，所以我们正在做的事情是什么 

54
00:03:44,036 --> 00:03:50,072
这个诀窍是我们想起了 

55
00:03:47,039 --> 00:03:53,081
你知道作为 我们的高 水位标记 我们 

56
00:03:50,072 --> 00:03:54,161
总有效载荷的增加 和减少 

57
00:03:53,081 --> 00:03:57,340
我们要记住的 高水位标记 

58
00:03:55,061 --> 00:03:59,084
右所以这是那种最糟糕的是 

59
00:03:58,069 --> 00:04:03,097
就像最大的集有效载荷 

60
00:03:59,084 --> 00:04:05,162
我们不得不然后让max为 

61
00:04:03,349 --> 00:04:08,416
记住其Ramez记住 

62
00:04:06,062 --> 00:04:10,148
高水位标记，然后我们将 

63
00:04:09,019 --> 00:04:14,510
通过堆，以便总大小 

64
00:04:11,048 --> 00:04:18,107
得到一个效率的措施好了，所以 

65
00:04:14,051 --> 00:04:21,280
这个最大DK 是怎么样的，这是 最好的 

66
00:04:19,007 --> 00:04:26,826
我们可以做 的除以总 

67
00:04:21,739 --> 00:04:26,754
总堆大小好了，所以是

68
00:04:30,025 --> 00:04:36,038
以及分配器跟踪如何

69
00:04:33,065 --> 00:04:38,147
大堆是，这样是很容易 

70
00:04:36,038 --> 00:04:41,042
右所以它的每一次每一次 

71
00:04:39,047 --> 00:04:43,088
它 每次通话时间s打破它 

72
00:04:41,078 --> 00:04:45,086
只是这增加的大小

73
00:04:43,088 --> 00:04:48,967
堆并记住 我们是我们假设 

74
00:04:45,086 --> 00:04:52,178
在这种情况下，热量总是 

75
00:04:49,759 --> 00:04:55,910
还好增加左右，但即使 即使 

76
00:04:53,078 --> 00:04:58,097
我们允许堆大小，以减少可能

77
00:04:55,091 --> 00:05:01,159
只是，如果分配器被控制

78
00:04:58,097 --> 00:05:03,193
通过调用分手吧堆的大小

79
00:05:02,059 --> 00:05:09,918
好了，所以是明确 

80
00:05:04,093 --> 00:05:12,982
所以英国越高越好很好，而且 

81
00:05:10,449 --> 00:05:17,452
对于分配和冻结的任何序列 

82
00:05:13,819 --> 00:05:20,210
这个最大的PK将是相同的还好这 

83
00:05:17,479 --> 00:05:22,610
恒权

84
00:05:20,021 --> 00:05:24,080
但什么变化为K，并使得 h 

85
00:05:22,061 --> 00:05:26,137
取决于如何有效地你的 

86
00:05:24,008 --> 00:05:27,080
分配器被使用堆存储 

87
00:05:27,037 --> 00:05:35,206
好的

88
00:05:28,052 --> 00:05:39,143
是的 问题，所以我们正在做的事情是在 

89
00:05:35,539 --> 00:05:42,860
后k加 1 之后的任何时间点 

90
00:05:40,043 --> 00:05:44,087
我们对我们正在评估申请

91
00:05:42,086 --> 00:05:52,118
我们堆起来到那的利用率

92
00:05:44,087 --> 00:05:59,376
点，从而它应当在 K 4I我小于 

93
00:05:53,018 --> 00:05:59,997
或等于 k哦， 我很抱歉 

94
00:06:10,012 --> 00:06:13,090
噢，抱歉好福气应该

95
00:06:12,004 --> 00:06:17,058
是我们要考虑所有的眼睛权 

96
00:06:13,009 --> 00:06:24,081
所有的所有请求，即

97
00:06:17,094 --> 00:06:24,162
以前 还好任何其他问题 来了 

98
00:06:26,037 --> 00:06:29,037
好的 

99
00:06:35,007 --> 00:06:40,090
没事所以 我们 最后 一次 看了一些 

100
00:06:37,087 --> 00:06:42,106
动态存储的简单的基础知识

101
00:06:40,009 --> 00:06:45,096
分配的，我们要 看看一些 

102
00:06:43,006 --> 00:06:49,012
使用更复杂的技术 

103
00:06:46,077 --> 00:06:52,132
不同的数据结构 来存储 

104
00:06:49,012 --> 00:06:55,075
免费名单主要是我们来看看 

105
00:06:53,032 --> 00:06:57,091
隐式分配器，所以我们会得到 一个排序 

106
00:06:55,075 --> 00:06:58,084
如何垃圾的简短调查 

107
00:06:57,091 --> 00:07:02,130
收藏家工作，我们就来看看

108
00:06:59,065 --> 00:07:03,121
一个才刚刚一个很简单的那种 

109
00:07:02,949 --> 00:07:07,720
垃圾收集器，但它会给你一个 

110
00:07:04,021 --> 00:07:11,053
中 这意味着 什么想法，然后我们会 

111
00:07:07,072 --> 00:07:12,085
完成了，我们将通过观察完成了

112
00:07:11,053 --> 00:07:15,058
它你可以让自己的所有方法 

113
00:07:12,085 --> 00:07:17,158
成通过使用动态 麻烦 

114
00:07:16,003 --> 00:07:20,056
分配存储所以一旦当你 一次 

115
00:07:18,058 --> 00:07:22,081
你用你一旦开始动态 

116
00:07:20,056 --> 00:07:25,093
分配存储的东西可以去真的 

117
00:07:22,081 --> 00:07:27,118
坏真的 很快，所以我们就去了 

118
00:07:25,093 --> 00:07:30,612
一些 那些其中 的一些不好的东西 

119
00:07:28,018 --> 00:07:32,101
这可能发生 ，尽量提醒 您 

120
00:07:31,449 --> 00:07:35,460
那些让你不这样做他们在你 

121
00:07:33,001 --> 00:07:35,046
程式

122
00:07:43,069 --> 00:07:49,097
好了，所以我们看到了如何 存储免费 

123
00:07:47,084 --> 00:07:52,109
看在这种隐含的空闲列表 

124
00:07:49,097 --> 00:07:54,188
形式由刚会走路的 整个热和 

125
00:07:53,009 --> 00:07:58,025
从而那种能够访问 

126
00:07:55,088 --> 00:08:00,146
所有的空闲块，但我们可以做的更好 

127
00:07:58,025 --> 00:08:03,094
如果我们实际上有一个 双重如果我们存储 

128
00:08:01,046 --> 00:08:08,090
自由买了免费列表 使用 

129
00:08:03,319 --> 00:08:11,660
作为一个双向链表所以我们称之为

130
00:08:08,009 --> 00:08:14,060
这些明确的空闲列表这样的想法

131
00:08:11,066 --> 00:08:18,140
有一个明确的空闲列表是我们

132
00:08:15,041 --> 00:08:21,058
put指针我们把该指针

133
00:08:19,004 --> 00:08:24,092
实现这种双向链表 

134
00:08:21,058 --> 00:08:27,103
空闲块 的主体内

135
00:08:25,028 --> 00:08:30,097
其中使用的旧的有效载荷去这样 

136
00:08:28,003 --> 00:08:32,012
分配的块长得一模一样 

137
00:08:30,349 --> 00:08:34,610
因为他们没有右边地板有一个 

138
00:08:32,012 --> 00:08:37,013
头边界标签可选边界

139
00:08:34,061 --> 00:08:40,139
标签分离器，然后该有效载荷 

140
00:08:37,013 --> 00:08:42,086
和任何填充空闲块虽然 

141
00:08:41,039 --> 00:08:46,061
分配 和分配不 

142
00:08:42,086 --> 00:08:49,139
允许在里面碰任何东西 

143
00:08:46,061 --> 00:08:52,030
所分配的块的有效载荷 

144
00:08:50,039 --> 00:08:54,125
但空闲数据块的自由权的人 

145
00:08:52,579 --> 00:08:58,970
使用它们，所以我们的分配器可以 

146
00:08:55,025 --> 00:09:01,043
把实现数据的指针 

147
00:08:58,097 --> 00:09:05,105
里面有什么是旧体制

148
00:09:01,043 --> 00:09:07,127
有效载荷所以逻辑上这只是一个 

149
00:09:06,005 --> 00:09:13,016
你已经简单的双向链表 

150
00:09:08,027 --> 00:09:14,126
之前，但实际上这些都见过

151
00:09:13,016 --> 00:09:19,037
东西都可以在内存中的任何地方的权利 

152
00:09:15,026 --> 00:09:23,030
所以你知道这里，我们有我们有一个 

153
00:09:19,037 --> 00:09:25,006
大小的 6 块 ，它有一个向前 

154
00:09:23,003 --> 00:09:27,017
指针指向一些其他链接

155
00:09:25,339 --> 00:09:29,890
它有一个向后指针

156
00:09:27,044 --> 00:09:32,383
指向该块恰好是

157
00:09:29,089 --> 00:09:36,136
比大于 a的内存地址

158
00:09:32,779 --> 00:09:40,010
它好了，只是这个想法是，你不能 

159
00:09:37,036 --> 00:09:42,092
你知道，除非，除非你做，除非

160
00:09:40,001 --> 00:09:48,000
你去不厌其烦地保持这种 

161
00:09:42,092 --> 00:09:49,501
排序这些地址有序结构

162
00:09:48,009 --> 00:09:57,620
这些， 这些模块是那种 

163
00:09:50,329 --> 00:10:00,350
分散在存储器中的任何噢等等

164
00:09:57,062 --> 00:10:02,341
这是 经过数你知道 刚才排序 

165
00:10:00,035 --> 00:10:10,954
马利克的不定数， 

166
00:10:02,899 --> 00:10:12,740
薯条是的哦，是 很好的 问题，这是 

167
00:10:11,269 --> 00:10:14,305
像这样的问题是什么会 

168
00:10:12,074 --> 00:10:16,603
如果你免费这是一个块发生

169
00:10:14,629 --> 00:10:18,860
在 两者 之间 自由块，所以你 

170
00:10:17,269 --> 00:10:22,910
要合并就有点棘手 

171
00:10:18,086 --> 00:10:30,185
我会在第二个好，现在告诉你

172
00:10:22,091 --> 00:10:32,156
分配哦，是这样的问题了

173
00:10:31,085 --> 00:10:35,174
问题是当地发生了什么

174
00:10:33,056 --> 00:10:39,080
所以你仍然可以得到你仍然得到块 

175
00:10:36,074 --> 00:10:44,156
地方你知道使用的块仍 

176
00:10:39,008 --> 00:10:48,071
连续的，所以如果，但如果如果你

177
00:10:45,056 --> 00:10:50,123
扫描类型的一组分配的 

178
00:10:49,043 --> 00:10:53,072
块，如果你能会更好

179
00:10:51,023 --> 00:10:58,085
让他们所有连续正确的，所以 

180
00:10:53,072 --> 00:11:02,881
它真的等有一个你知道的 

181
00:10:58,085 --> 00:11:04,174
这是一个权衡，我不它得到 

182
00:11:03,529 --> 00:11:06,553
困难，如果你觉得你怎么能

183
00:11:04,939 --> 00:11:08,870
保持这样你就不会真正关心 

184
00:11:06,769 --> 00:11:12,805
空闲块的局部性权你 

185
00:11:08,087 --> 00:11:13,906
只是走一个 链表 以及无我 

186
00:11:13,129 --> 00:11:17,161
不应该说 ，这就是如果你 

187
00:11:14,689 --> 00:11:20,480
走该列表，如果你打一个一个 

188
00:11:17,449 --> 00:11:22,537
空闲块会它将把在 

189
00:11:20,048 --> 00:11:25,091
整个页面所以它会更好，如果你是 

190
00:11:23,329 --> 00:11:27,500
如果 走 在列表中，您知道，如果尽可能多 

191
00:11:25,091 --> 00:11:29,640
该名单载内 

192
00:11:27,005 --> 00:11:33,098
页面所以即使 是这样，你将受益 

193
00:11:30,459 --> 00:11:35,497
你可以用两种分配中受益

194
00:11:34,043 --> 00:11:37,136
块，因为应用程序会 

195
00:11:35,839 --> 00:11:40,790
使用它们，并与自由块，因为

196
00:11:38,036 --> 00:11:44,068
分配器将走的是那 

197
00:11:40,079 --> 00:11:43,168
免费列表，以便问题 

198
00:11:44,074 --> 00:11:51,543
我们可以做 的意义有一个程序 

199
00:11:48,082 --> 00:11:54,351
能够有效 能量的预断 

200
00:11:52,209 --> 00:11:57,760
因此，即使他们 只需要两个甚至 

201
00:11:55,089 --> 00:11:59,560
虽然他们只烷烃成情侣 

202
00:11:57,076 --> 00:12:02,152
单先生，如果你将来知道 

203
00:11:59,056 --> 00:12:04,138
多米诺 他们 的心态 不知何故 

204
00:12:03,052 --> 00:12:08,089
烷烃是他们 ，我们要尝试 

205
00:12:05,038 --> 00:12:09,100
你可以帮助你了解一下工作 

206
00:12:08,089 --> 00:12:10,150
这是一个非常好的问题 ，因此 

207
00:12:10,000 --> 00:12:14,011
问题是 ， 可能将有可能 

208
00:12:11,005 --> 00:12:16,030
对于应用程序之类的给提示 

209
00:12:14,011 --> 00:12:18,067
该分配器 会增加 

210
00:12:16,075 --> 00:12:21,166
他们提高分配器性能

211
00:12:18,067 --> 00:12:27,070
或内存利用率的答案你

212
00:12:22,066 --> 00:12:28,120
绝对可以，但如果你做到了这 

213
00:12:27,007 --> 00:12:30,456
不会是一个通用的分配器 

214
00:12:29,002 --> 00:12:34,009
所以喜欢 的malloc 它是一个通用 

215
00:12:31,149 --> 00:12:36,190
分配器所以它和它没有提供 

216
00:12:34,027 --> 00:12:37,102
没有选择它不提供任何

217
00:12:36,019 --> 00:12:40,054
在其界面传递参数

218
00:12:38,002 --> 00:12:42,079
在但它绝对如果 信息 

219
00:12:40,054 --> 00:12:44,853
它有对未来的一些知识

220
00:12:42,079 --> 00:12:47,101
程序的行为可能会受益 

221
00:12:45,339 --> 00:12:49,420
右所以特别我认为你 

222
00:12:48,001 --> 00:12:51,055
总是有这样的决定，当你把 

223
00:12:49,042 --> 00:12:53,961
一个分配的块是否分割该 

224
00:12:51,055 --> 00:12:57,055
阻止或没有得到很好的，如果你知道你 

225
00:12:54,339 --> 00:12:59,376
打算让你知道的请求 

226
00:12:57,055 --> 00:13:00,076
如果拆分块，你就知道 

227
00:12:59,709 --> 00:13:03,700
你打算 给 请求 

228
00:13:00,076 --> 00:13:04,215
在未来即将到来的第一个 尺寸 

229
00:13:03,007 --> 00:13:06,079
原来的块，那么你就不会

230
00:13:04,899 --> 00:13:09,520
想拆它，因为那时你会 

231
00:13:07,042 --> 00:13:12,061
希望你只是保持 不分开 

232
00:13:09,052 --> 00:13:13,431
然后当你释放它，那么你会 

233
00:13:12,061 --> 00:13:17,100
有这 将是合适的块

234
00:13:13,899 --> 00:13:19,899
尺寸为将来的要求等 

235
00:13:17,649 --> 00:13:22,662
这是你绝对 可以 从中受益 

236
00:13:19,899 --> 00:13:24,820
这一点，所以虽然你不能，如果 

237
00:13:22,779 --> 00:13:26,770
通用内存分配器没有

238
00:13:24,082 --> 00:13:27,124
计提的那种 暗示的，但 

239
00:13:26,077 --> 00:13:30,079
没有什么可以防止鳄鱼 

240
00:13:28,024 --> 00:13:33,091
从基础上的做预测 

241
00:13:30,079 --> 00:13:34,123
请求以前的模式，你知道，所以 

242
00:13:33,091 --> 00:13:36,210
如果你得到的请求模式 

243
00:13:35,023 --> 00:13:38,122
它交替大块小块 

244
00:13:37,029 --> 00:13:41,440
大箱小块状你可能在你 

245
00:13:39,022 --> 00:13:43,024
可以利用，也许，也许预测 

246
00:13:41,044 --> 00:13:45,933
那下一个请求将 是 一个你 

247
00:13:43,042 --> 00:13:47,047
知道这是以前的请求是 

248
00:13:46,329 --> 00:13:49,424
大块的下一个可能是 

249
00:13:47,092 --> 00:13:51,136
一个小方块，你可以 

250
00:13:50,279 --> 00:13:54,160
这是一个很好的问题， 任何其他 

251
00:13:52,036 --> 00:14:08,062
问题向导是的 

252
00:13:54,016 --> 00:14:10,755
我不知道我这样的问题是其他

253
00:14:08,062 --> 00:14:12,154
是有智能 的短吻鳄是 做 

254
00:14:10,899 --> 00:14:15,160
那种 如果有 预测 和 

255
00:14:13,054 --> 00:14:29,092
我不知道他们的，但我不会我 

256
00:14:15,016 --> 00:14:32,020
不会说没有问题是会 是什么 

257
00:14:29,092 --> 00:14:37,120
发生你 结束了一个免费的 降压了 

258
00:14:32,002 --> 00:14:40,051
块就像它只是一个单独的块 

259
00:14:38,002 --> 00:14:44,026
哦， 所以问题 是，如果你什么结束 

260
00:14:40,069 --> 00:14:46,123
了 一个空闲块，这是 一个单 

261
00:14:44,044 --> 00:14:49,075
块由两个分配块包围 

262
00:14:47,023 --> 00:14:52,069
好其实我的意思是这的一个 

263
00:14:49,075 --> 00:14:54,076
一个良好的鳄鱼 有不变量

264
00:14:52,069 --> 00:14:56,101
保持你永远不应该有两个 

265
00:14:54,085 --> 00:14:58,138
连续的自由块右边的 

266
00:14:57,001 --> 00:15:02,017
鳄鱼应始终作为合并

267
00:14:59,038 --> 00:15:05,041
尽可能它可以，如果它，如果它确实是 

268
00:15:02,017 --> 00:15:06,100
凝聚是它总是这样说 

269
00:15:05,041 --> 00:15:10,340
凝聚然后再永远不会有 

270
00:15:07,000 --> 00:15:19,769
两个连续的自由块行 

271
00:15:10,709 --> 00:15:21,791
是个问题 哦，你会看到，当我们这 

272
00:15:19,769 --> 00:15:25,000
进场时 ，我们释放一个块 

273
00:15:22,529 --> 00:15:27,820
因为你要排序的缝合起来 

274
00:15:25,000 --> 00:15:32,079
当你释放一个块， 你必须 排序 

275
00:15:27,082 --> 00:15:33,181
的缝合起来的链表 等 

276
00:15:32,079 --> 00:15:36,640
你既需要你既需要你的指针

277
00:15:34,081 --> 00:15:38,089
可以用单链表所以在做

278
00:15:36,064 --> 00:15:41,373
您 在 书中KNR有一个一 

279
00:15:38,089 --> 00:15:43,174
使用单链表鳄鱼

280
00:15:41,949 --> 00:15:46,660
但缺点是免费的 

281
00:15:44,074 --> 00:15:48,085
需要一个搜索，它需要一个

282
00:15:46,066 --> 00:15:52,175
从列表的开头进行搜索

283
00:15:48,085 --> 00:15:52,004
找到 以前 的 块 

284
00:15:54,082 --> 00:16:06,091
并有问题，这些都 不错 

285
00:15:56,041 --> 00:16:07,138
是的问题好了，所以这个问题 是 

286
00:16:06,091 --> 00:16:09,175
内存利用率如何做头

287
00:16:08,038 --> 00:16:13,069
和对内存页脚计数 

288
00:16:10,075 --> 00:16:15,151
利用等等这些那些 

289
00:16:13,069 --> 00:16:17,143
开销减少内存

290
00:16:16,051 --> 00:16:19,123
利用没关系，因为他们不 

291
00:16:18,043 --> 00:16:22,117
有效载荷所以当我们计算内存 

292
00:16:20,023 --> 00:16:25,105
利用我们正在做的我们 

293
00:16:23,017 --> 00:16:31,096
使用有效载荷的有效载荷聚合

294
00:16:26,005 --> 00:16:34,018
对估计 我们的利用率 还是 

295
00:16:31,096 --> 00:16:38,127
计算我们的利用率，所以，只要 

296
00:16:34,018 --> 00:16:43,066
这不是有效载荷SAR是一定的开销 

297
00:16:39,027 --> 00:16:48,118
一个字， 一切都 像 没事了 

298
00:16:43,066 --> 00:16:50,071
也一个字，所以我们不得不如果我们所有的 

299
00:16:49,018 --> 00:16:56,019
有效载荷有一个字，我们的开销

300
00:16:51,016 --> 00:16:56,028
是为一个字那么会是50％ 

301
00:16:58,036 --> 00:17:04,067
是的，如果你要预订这点成 

302
00:17:02,048 --> 00:17:08,123
下一个和以前 有光泽索尼 

303
00:17:04,067 --> 00:17:09,140
喜欢什么样每次都这样呀 

304
00:17:09,023 --> 00:17:12,080
问题是，你还 需要一个 

305
00:17:10,004 --> 00:17:13,100
边界标签，如果你有这些这些

306
00:17:12,008 --> 00:17:17,009
下一个和以前的指针和 

307
00:17:14,036 --> 00:17:32,129
答案是肯定的绝对，你会看到 

308
00:17:17,009 --> 00:17:34,028
在第二，为什么是好的，这是一个真正的 

309
00:17:33,029 --> 00:17:37,126
很好的问题，所以 你知道你该怎么办 

310
00:17:35,009 --> 00:17:40,076
如果你有一个和前一个指针 

311
00:17:38,026 --> 00:17:44,033
如果有一个请求会发生什么 

312
00:17:40,076 --> 00:17:46,097
小的更小的块所以答案 是 

313
00:17:44,096 --> 00:17:47,165
所有 的这些 东西头的 

314
00:17:46,097 --> 00:17:50,183
页脚中的一个和前一个指针 

315
00:17:48,065 --> 00:17:53,158
并处以 最小的块大小，所以如果你 

316
00:17:51,083 --> 00:17:58,172
有一个字的头一个字页脚 

317
00:17:54,058 --> 00:18:01,115
一个字，甚至前一个字旁则 

318
00:17:59,072 --> 00:18:03,101
你是你的最低块大小 为 四个 

319
00:18:02,015 --> 00:18:07,019
字节，这将是一个零 

320
00:18:04,001 --> 00:18:09,056
零大小的有效载荷，所以你永远不能 

321
00:18:07,019 --> 00:18:11,078
分配一块比你小

322
00:18:09,056 --> 00:18:14,150
最小的块大小所以这是一个非常 好的 

323
00:18:11,078 --> 00:18:18,080
非常好的问题所以它是一个 

324
00:18:15,005 --> 00:18:19,070
差异右即使即使 

325
00:18:18,098 --> 00:18:21,152
我们要知道它看起来我们 

326
00:18:20,015 --> 00:18:25,019
让这些看起来 我们 

327
00:18:22,052 --> 00:18:26,117
及彼这些指针 免费的 ，但 

328
00:18:25,055 --> 00:18:33,068
我们并不是真的因为 这个最小 的 

329
00:18:27,017 --> 00:18:36,086
块大小需求 是的，我们继续 

330
00:18:33,068 --> 00:18:38,099
或分配给自己巨大的幸运 

331
00:18:36,086 --> 00:18:42,128
给你具体的不同部分 

332
00:18:38,099 --> 00:18:44,138
因为他们说 ， 有 一天我会 

333
00:18:43,028 --> 00:18:49,056
坐上卡车的比喻，因为我不 

334
00:18:45,038 --> 00:18:53,043
刷新我的网页，或者是一个空间，以便 

335
00:18:49,056 --> 00:18:55,062
正确的 ，但如果你要 喜欢拿第一 

336
00:18:53,043 --> 00:18:57,132
一半让他们 采取药物 和TECHNIC一 

337
00:18:55,062 --> 00:19:03,090
某些东西，如果说所有 的 

338
00:18:58,032 --> 00:19:05,088
这件事我的程序可笑 ， 像 这样 

339
00:19:03,009 --> 00:19:08,070
它就 像是 一个 电影的选择 

340
00:19:05,088 --> 00:19:12,177
这是我得到尼克·巴卡斯 醒来好耶 

341
00:19:09,051 --> 00:19:15,123
所以，问题是你可以得到一个 

342
00:19:13,077 --> 00:19:17,088
得到一个大的块，然后把它分解了 

343
00:19:16,023 --> 00:19:19,028
我想你是假设

344
00:19:17,088 --> 00:19:22,146
请求将 四个同样大小的 

345
00:19:19,073 --> 00:19:25,136
对象权利，使这一点，这就是一个

346
00:19:23,046 --> 00:19:29,085
真正好的战略其实所以如果你 

347
00:19:26,036 --> 00:19:32,052
如果你知道，或者如果你认为你的 

348
00:19:29,085 --> 00:19:33,096
工作量都将有没有你 

349
00:19:32,052 --> 00:19:35,085
在 通用分配器做到这一点 

350
00:19:33,096 --> 00:19:35,184
但对于像专用分配器 

351
00:19:35,085 --> 00:19:38,085
如果你知道你将要 

352
00:19:36,084 --> 00:19:40,143
要求 是所有相同的 对象 

353
00:19:38,085 --> 00:19:43,122
大小一样的编译器，例如化妆 

354
00:19:41,043 --> 00:19:46,086
维护抽象语法树

355
00:19:44,022 --> 00:19:50,055
他们是动态分配的节点和 

356
00:19:46,086 --> 00:19:51,114
这些节点的大小相同，所以如果你 

357
00:19:50,055 --> 00:19:54,137
你可以可以利用由刚 

358
00:19:52,014 --> 00:19:57,018
分配大块，然后

359
00:19:55,037 --> 00:19:59,100
分配该尺寸 的所有对象 

360
00:19:57,054 --> 00:20:01,089
出该块它的效率非常高 

361
00:20:00,000 --> 00:20:04,017
你甚至不需要指针或什么 

362
00:20:01,089 --> 00:20:05,094
你需要的是一个位向量来告诉你

363
00:20:04,017 --> 00:20:08,034
该块被分配在

364
00:20:05,094 --> 00:20:09,101
块是免费的，那么， 你也可以作为 

365
00:20:08,034 --> 00:20:12,111
副作用您将获得连续 

366
00:20:10,064 --> 00:20:16,140
该连续访问，以便如果一个程序

367
00:20:13,011 --> 00:20:19,011
这些访问这些对象喜欢被 

368
00:20:17,004 --> 00:20:20,022
链表的一部分有 

369
00:20:19,011 --> 00:20:25,052
这是要穿越的东西

370
00:20:20,058 --> 00:20:26,060
你可以为了分配这些和 

371
00:20:25,052 --> 00:20:28,107
连续

372
00:20:26,078 --> 00:20:30,107
现在用通用

373
00:20:29,007 --> 00:20:37,019
分配器，你真的不知道 

374
00:20:31,007 --> 00:20:37,019
什么会被要求 它的 

375
00:20:39,051 --> 00:20:43,102
ASL是扇区侮辱 绝对是你 

376
00:20:42,097 --> 00:20:45,124
能做到这一点，你可以让一般 

377
00:20:44,002 --> 00:20:47,061
对那种行为的假设

378
00:20:46,024 --> 00:20:50,032
你的程序的，你知道 你可以 

379
00:20:47,061 --> 00:20:51,070
你可以运行痕迹或在案件喜欢

380
00:20:50,032 --> 00:20:54,121
malok实验室，你可以看看 

381
00:20:51,007 --> 00:20:57,106
痕迹，但是这是没有，这是一个真正的 

382
00:20:55,021 --> 00:21:01,740
你知道好东西你不能 你是你 

383
00:20:58,069 --> 00:21:03,076
不能只是喜欢做，如果声明说

384
00:21:01,929 --> 00:21:06,600
以及如果尺寸是42，然后 下一个 

385
00:21:04,039 --> 00:21:08,128
尺寸是24后来我知道这是该 跟踪 

386
00:21:06,006 --> 00:21:11,011
不错，但你可以看看跟踪并说 

387
00:21:09,028 --> 00:21:13,123
这里有一个有趣的模式 ，我 

388
00:21:12,001 --> 00:21:15,073
要 解释这个模式我 

389
00:21:14,023 --> 00:21:17,065
要优化该模式 和 

390
00:21:15,082 --> 00:21:18,127
，这将只是，这就是 

391
00:21:17,065 --> 00:21:20,140
完全有效的，这只是像回吐 

392
00:21:19,027 --> 00:21:25,086
利用你的工作量正确的是 

393
00:21:21,004 --> 00:21:25,050
我们做什么，在系统中所有的时间耶 

394
00:21:29,004 --> 00:21:41,097
我们可以瓜分我们的数据是 

395
00:21:38,074 --> 00:21:41,097
存储 在其他 方 

396
00:21:42,669 --> 00:21:47,682
哦，哦，这样的 问题是，为什么我们不能 

397
00:21:45,359 --> 00:21:49,422
我们为什么不能排序的具有独立区域 

398
00:21:47,799 --> 00:21:55,830
堆的指针和的

399
00:21:49,989 --> 00:22:01,068
有效载荷没事加入他们了 

400
00:21:56,109 --> 00:22:03,162
三分球哦，为什么不 

401
00:22:01,779 --> 00:22:06,820
好了， 问题 是为什么不 为什么 

402
00:22:03,639 --> 00:22:09,654
我们不能分裂的有效载荷并将其链接 

403
00:22:06,082 --> 00:22:11,031
与指针一起答案 

404
00:22:09,789 --> 00:22:14,590
这些应用程序期待 

405
00:22:11,769 --> 00:22:17,950
连续块不能分配或 

406
00:22:14,059 --> 00:22:19,338
不能把任何东西在有效载荷一切 

407
00:22:17,095 --> 00:22:21,534
我可以做所有它允许做的是 

408
00:22:19,869 --> 00:22:24,820
返回 的大小的 连续块 

409
00:22:22,389 --> 00:22:28,401
应用程序请求后一次

410
00:22:24,082 --> 00:22:32,751
它，它不能触摸它 好一切 

411
00:22:28,509 --> 00:22:36,070
好一个好没事所以让我们看看 

412
00:22:33,489 --> 00:22:38,514
怎么我们会分配和释放一次，如果我们

413
00:22:36,007 --> 00:22:41,616
有这个这个明确的清单，我们怎么样 

414
00:22:38,739 --> 00:22:45,744
将分配和释放块， 

415
00:22:41,679 --> 00:22:48,711
分配是相当简单的，我们将有 

416
00:22:45,789 --> 00:22:52,791
所以这里是我们的图形中 我们的排序

417
00:22:48,999 --> 00:22:55,960
空闲列表所以我们必须 前进指针 

418
00:22:52,809 --> 00:22:56,883
落后指针和想法是我们 

419
00:22:55,096 --> 00:23:03,795
要分配出这个中间 

420
00:22:57,549 --> 00:23:08,586
块，所以我们分配的块 

421
00:23:04,659 --> 00:23:10,704
大小， 我们需要，然后 我们就 

422
00:23:08,919 --> 00:23:15,190
更新的前进和后退指针 

423
00:23:11,109 --> 00:23:18,940
上一页和下一页块指向 

424
00:23:15,019 --> 00:23:20,110
这种新的空闲块好了，这就是 

425
00:23:18,094 --> 00:23:26,183
很简单，我们 只是我们要更新 

426
00:23:21,001 --> 00:23:26,930
一二三四五六六指针

427
00:23:28,044 --> 00:23:33,115
现在没事给我们它变得棘手时 

428
00:23:31,003 --> 00:23:37,057
我们不得不因为自由，因为我们 

429
00:23:34,015 --> 00:23:40,080
需要凝聚所以当你释放一个

430
00:23:37,084 --> 00:23:42,097
阻止先前被分配 

431
00:23:40,008 --> 00:23:44,014
问题是你怎么与做 

432
00:23:42,097 --> 00:23:46,116
空闲块右它不是在免费 

433
00:23:44,086 --> 00:23:48,154
列表中，因为它是一个分配的块 

434
00:23:47,016 --> 00:23:51,019
所以现在你已经释放了其中块 

435
00:23:49,054 --> 00:23:54,073
你把它当成你得把它 

436
00:23:51,046 --> 00:23:56,119
某个地方， 这样 最简单 的 事情是 

437
00:23:54,073 --> 00:23:58,105
这样的生活 - 所有的策略，以最简单的

438
00:23:57,019 --> 00:24:01,072
事情只是把它之初 

439
00:23:59,005 --> 00:24:04,087
列表，以便释放了最后一块是 

440
00:24:01,072 --> 00:24:08,073
如果这是它的好第一个块分配

441
00:24:04,087 --> 00:24:10,099
所以这所谓的喜欢哦，现在这 是 

442
00:24:08,082 --> 00:24:11,125
简单，因为你总是在做 

443
00:24:10,099 --> 00:24:13,183
同样的事情 ， 你 只是把 块 

444
00:24:12,025 --> 00:24:16,051
在开始列表，它是 

445
00:24:14,083 --> 00:24:19,171
恒定的时间你只是更新了数 

446
00:24:16,051 --> 00:24:23,089
指针不错 ，但研究 表明， 

447
00:24:20,071 --> 00:24:25,123
该碎片可能会更糟 

448
00:24:23,089 --> 00:24:27,168
比其他技术，该技术 

449
00:24:26,023 --> 00:24:32,029
继续按地址排列块

450
00:24:28,068 --> 00:24:33,163
好了，所以当 呃，如果你，如果你，如果 你 

451
00:24:32,083 --> 00:24:36,171
选择这个地址下单策略 

452
00:24:34,063 --> 00:24:39,109
您在释放一个分配的块 

453
00:24:37,071 --> 00:24:41,122
你会以 某种方式弄清楚 

454
00:24:40,009 --> 00:24:44,086
你会以某种方式把该块 

455
00:24:42,022 --> 00:24:47,023
在列表中， 前块 

456
00:24:44,086 --> 00:24:49,102
开始于一个较小的地址和下 

457
00:24:47,023 --> 00:24:51,061
块开始于更大的地址 右 

458
00:24:50,002 --> 00:24:54,037
所以这通常涉及某种 

459
00:24:51,061 --> 00:24:56,077
搜索对你没有，你只是给 

460
00:24:54,037 --> 00:24:58,045
这种分配的块，然后以某种方式

461
00:24:56,077 --> 00:24:59,164
你有，你知道它的地址和 

462
00:24:58,045 --> 00:25:03,121
所以现在你必须以某种方式搜索 

463
00:25:00,064 --> 00:25:06,091
空闲列表找到你知道 

464
00:25:04,021 --> 00:25:08,059
适当的地方插入，现在我想 

465
00:25:06,091 --> 00:25:09,169
你可以做的 更好，如果你有某种 

466
00:25:08,059 --> 00:25:12,127
所以如果你能加快该搜索 

467
00:25:10,069 --> 00:25:16,072
与某种平衡树的该 

468
00:25:13,027 --> 00:25:18,055
将是一个 选择 权，但那时， 

469
00:25:16,072 --> 00:25:20,149
我们总会遇到这样的问题 

470
00:25:18,055 --> 00:25:22,132
平衡树，通常是一个学生 

471
00:25:21,049 --> 00:25:24,097
在LEA有人 总是试图 

472
00:25:23,032 --> 00:25:26,059
实现的malloc有某种 

473
00:25:24,097 --> 00:25:29,170
平衡树 红黑树什么的 

474
00:25:26,059 --> 00:25:32,098
它似乎是一个 很好的主意，但 

475
00:25:30,007 --> 00:25:36,058
你必须 认识到 ，你是你 

476
00:25:32,098 --> 00:25:39,124
与其他技术竞争

477
00:25:37,021 --> 00:25:42,100
特别是隔离的名单是 

478
00:25:40,024 --> 00:25:45,813
速度非常快，并且具有非常小的常数

479
00:25:43,000 --> 00:25:48,046
因素和存在的，即使连 

480
00:25:46,029 --> 00:25:51,460
虽然有序列表是我认为这是 

481
00:25:48,046 --> 00:25:54,097
通常N日志中更新的顺序树 

482
00:25:51,046 --> 00:25:56,095
在你所订购之树常

483
00:25:54,097 --> 00:25:58,926
因素可能会 很大， 因此 

484
00:25:56,095 --> 00:26:02,424
通常会得到钉了恒 

485
00:25:59,799 --> 00:26:04,836
保持树的因素，你 

486
00:26:03,279 --> 00:26:08,380
没有得到帮助，搜索时间 

487
00:26:05,169 --> 00:26:13,233
日志N但是我们会看到隔离 

488
00:26:08,038 --> 00:26:15,097
在 列出的限制 作为 

489
00:26:13,809 --> 00:26:18,850
限制如 不同尺寸的数 

490
00:26:15,097 --> 00:26:20,119
类增加了搜索时间 

491
00:26:18,085 --> 00:26:22,914
接近恒定的时间，如果你，如果

492
00:26:21,019 --> 00:26:25,608
你有大小类，覆盖范围

493
00:26:23,679 --> 00:26:28,210
两 周搜索时间的权力

494
00:26:25,779 --> 00:26:31,000
减少了很长一段时间，因为反正 

495
00:26:28,021 --> 00:26:36,480
每个班级的大小是现在 

496
00:26:31,000 --> 00:26:40,033
对数日志，所以你 知道我会 

497
00:26:36,669 --> 00:26:41,694
建议做了你知道刚才做 了 

498
00:26:40,033 --> 00:26:44,382
简单的事情通常每当 你 

499
00:26:41,919 --> 00:26:46,360
你处理了几分大设计 

500
00:26:44,679 --> 00:26:48,970
像malakut空间，你最好 

501
00:26:46,036 --> 00:26:50,325
做简单的事情，然后 

502
00:26:48,097 --> 00:26:53,166
只有当你看到优化 

503
00:26:50,649 --> 00:26:56,320
还有，你需要优化好 

504
00:26:54,039 --> 00:26:58,840
所以记得我们谈到了最后一次 

505
00:26:56,032 --> 00:27:01,069
这一招消除 边界 

506
00:26:58,084 --> 00:27:02,152
标签页脚和分配的块这

507
00:27:01,069 --> 00:27:07,150
优化的例子，你应该

508
00:27:03,052 --> 00:27:09,145
推迟让等待 你知道 等待得到做 

509
00:27:08,005 --> 00:27:14,041
简单的事情，然后尝试改善 

510
00:27:10,045 --> 00:27:16,111
通过逐步由INT你知道 有 

511
00:27:14,086 --> 00:27:20,101
只是这种优化或其他 

512
00:27:17,011 --> 00:27:22,075
优化所以有此现象 

513
00:27:21,001 --> 00:27:24,037
很多很多程序员的使 

514
00:27:22,075 --> 00:27:26,244
就是我们所说的过早错误 

515
00:27:24,037 --> 00:27:28,099
优化所以尽量 想的一切 

516
00:27:26,919 --> 00:27:30,480
花哨的东西，他们可以做什么，然后他们 

517
00:27:28,099 --> 00:27:31,788
把所有这些在开始 和 

518
00:27:30,048 --> 00:27:32,146
之前，他们甚至不知道它需要 

519
00:27:32,679 --> 00:27:36,070
进行优化 

520
00:27:33,046 --> 00:27:38,101
好吧，D， 使得你想要的方式 去努力 

521
00:27:36,007 --> 00:27:42,022
这一点，任何种类的任何复杂的问题 的 

522
00:27:39,001 --> 00:27:44,002
像鳄鱼般的是，你知道 

523
00:27:42,022 --> 00:27:46,051
首先做相当简单的事情，然后

524
00:27:44,002 --> 00:27:48,651
看看，看看哪里哪里怠工 

525
00:27:46,051 --> 00:27:48,138
是效率低下，然后就 

526
00:27:48,669 --> 00:27:51,180
有点 

527
00:27:49,038 --> 00:27:52,071
打击的一前一后和 

528
00:27:51,018 --> 00:27:55,089
只有优化那些事 

529
00:27:52,071 --> 00:28:01,086
必要的，这 是一个很好的例子 

530
00:27:55,089 --> 00:28:09,102
现在好了去你的问题 

531
00:28:01,086 --> 00:28:10,167
关于释放释放是艰难的，因为 

532
00:28:10,002 --> 00:28:13,020
我们总是不得不这样做凝聚 

533
00:28:11,067 --> 00:28:16,125
正确的，因为这个不变的是我们 

534
00:28:13,002 --> 00:28:19,089
可从来没有自由块 

535
00:28:17,025 --> 00:28:21,108
相邻空闲块，以便让我们通过 

536
00:28:20,007 --> 00:28:23,079
每一个这四个案例，我们去 

537
00:28:22,008 --> 00:28:28,044
比去年 时间，看看 我们 会 怎么 做 

538
00:28:23,079 --> 00:28:30,174
现在， 我们有这个只是 这个 

539
00:28:28,044 --> 00:28:33,141
明确免费列表，在这里我们有 

540
00:28:31,074 --> 00:28:36,075
我们的指向空闲列表的根

541
00:28:34,041 --> 00:28:38,139
在免费榜第一块有一个 

542
00:28:36,084 --> 00:28:40,110
空回指针，那么有

543
00:28:39,039 --> 00:28:43,080
空预指针再 下一 

544
00:28:41,001 --> 00:28:47,028
接下来的指针指向某个不确定的 

545
00:28:43,008 --> 00:28:48,087
块，所以我们有这样的黄色块 

546
00:28:47,037 --> 00:28:51,093
被分配到现在的 

547
00:28:49,059 --> 00:28:52,140
应用程序 被称为自由免费 使用 

548
00:28:51,093 --> 00:28:56,097
指针指向的开始 

549
00:28:53,004 --> 00:28:58,071
该块所以我们做什么以及这 

550
00:28:57,033 --> 00:29:01,041
情况是非常简单的 ，因为没有 

551
00:28:59,007 --> 00:29:06,014
合并，因为两者的前身 

552
00:29:02,013 --> 00:29:10,044
和后继块分配 

553
00:29:06,077 --> 00:29:11,109
好了，所以我们只是这个新释放的块 

554
00:29:10,044 --> 00:29:13,140
现在成为我们要做一个LIFO

555
00:29:12,009 --> 00:29:17,043
政策使这成为第一个块 

556
00:29:14,004 --> 00:29:19,008
在免费的列表，所以我们更新 

557
00:29:17,043 --> 00:29:21,090
路径指向这个这个新 释放 

558
00:29:19,008 --> 00:29:22,086
阻止我们更新正向指针 

559
00:29:21,009 --> 00:29:26,060
该块的指向什么用 

560
00:29:23,058 --> 00:29:26,141
是在堆中的第一个块 

561
00:29:29,000 --> 00:29:36,012
现在我要小心，这是一个 

562
00:29:33,048 --> 00:29:38,145
有点混乱，因为我们已经有了 

563
00:29:36,012 --> 00:29:42,033
有点像以前的两个概念，并 

564
00:29:39,045 --> 00:29:44,051
右旁还有的你知道给定

565
00:29:42,033 --> 00:29:47,061
一些给予一定的块

566
00:29:44,051 --> 00:29:50,073
有一个在内存中的前身块 

567
00:29:47,061 --> 00:29:51,126
其可以或可以不被分配或

568
00:29:50,073 --> 00:29:54,165
它可能会或可能不会在自由权 

569
00:29:52,026 --> 00:29:57,048
免费列表，并有一个后继块

570
00:29:55,065 --> 00:30:01,131
好了，所以我们将使用前作

571
00:29:57,048 --> 00:30:05,049
继任者来区分相邻的 

572
00:30:02,031 --> 00:30:07,125
内存没关系，我们将使用事先连旁边

573
00:30:05,058 --> 00:30:13,071
表示 在空闲列表 邻接 

574
00:30:08,025 --> 00:30:15,099
好了，所以这此 块是下一个 

575
00:30:13,071 --> 00:30:19,088
块用于当前块 ，它有 

576
00:30:15,099 --> 00:30:18,188
没有以前好块 

577
00:30:20,029 --> 00:30:26,053
现在好了怎么样 的情况下，以数 

578
00:30:22,054 --> 00:30:29,092
情况下向前身块空闲 

579
00:30:26,053 --> 00:30:32,134
和后继块分配 

580
00:30:29,092 --> 00:30:37,120
现在我们要释放这个东西是一个 

581
00:30:33,034 --> 00:30:41,062
分配块由黄色和我们记 

582
00:30:38,002 --> 00:30:43,006
有这个这个这个接班人

583
00:30:41,062 --> 00:30:45,157
前身块是自由的一部分

584
00:30:43,024 --> 00:30:48,028
列表中右键所以它有它 以前和 

585
00:30:46,057 --> 00:30:50,149
接下来的块是 只是 部分 

586
00:30:48,064 --> 00:30:52,093
免费名单等我们的路线指向 

587
00:30:51,049 --> 00:30:56,104
在列表中，然后第一块

588
00:30:52,093 --> 00:30:58,156
最终你得到这个空闲块 

589
00:30:57,004 --> 00:31:02,092
它指向该自由块，其

590
00:30:59,056 --> 00:31:05,083
指向这个空闲块好了，所以什么 

591
00:31:02,092 --> 00:31:08,143
我们需要做的就是我们要 

592
00:31:05,083 --> 00:31:12,088
合并这两个这两个块成 

593
00:31:09,043 --> 00:31:14,086
一个大的空闲块行不行，然后我们有 

594
00:31:12,088 --> 00:31:19,150
拼接出来，并在坚持下去

595
00:31:14,086 --> 00:31:20,098
列表中的 开始 好了，这是什么 

596
00:31:20,005 --> 00:31:24,013
看起来像 

597
00:31:20,098 --> 00:31:26,140
概念 就是我们我们我们这些合并 

598
00:31:25,003 --> 00:31:32,064
现在两个街区，形成这一个免费

599
00:31:27,004 --> 00:31:35,080
块，然后我们剪接出来的 

600
00:31:32,091 --> 00:31:38,092
已经什么是什么是它 

601
00:31:36,016 --> 00:31:40,021
先前块现在都指向什么用 

602
00:31:38,092 --> 00:31:45,117
成为下一个块行不行 

603
00:31:40,066 --> 00:31:45,117
当前 块 的 修复 好了，所以这 

604
00:31:46,008 --> 00:31:52,012
从该块中的指针现在指向

605
00:31:50,041 --> 00:31:54,049
该块行不行， 然后 使我们已经 

606
00:31:53,002 --> 00:31:58,009
有效拼接认为， 目前的 

607
00:31:55,021 --> 00:32:00,022
块空闲列表，然后将出

608
00:31:58,027 --> 00:32:02,056
根我们有 根点到 

609
00:32:00,031 --> 00:32:04,038
块，使得现在新的第一块

610
00:32:02,056 --> 00:32:04,101
名单 

611
00:32:07,002 --> 00:32:11,026
好吧，然后我们必须更新什么 

612
00:32:09,067 --> 00:32:14,074
用于在列表中的第一个块 

613
00:32:11,026 --> 00:32:18,115
所以现在它指向回 新 

614
00:32:14,074 --> 00:32:24,151
释放 聚结块， 使 清 

615
00:32:19,015 --> 00:32:27,028
大家的没错所以与盾 

616
00:32:25,051 --> 00:32:31,060
全局 变量 可能是， 也可能 

617
00:32:27,028 --> 00:32:32,083
是有有两种方法可以做到 这一点 

618
00:32:31,006 --> 00:32:37,012
右它可能只是一个全局变量 

619
00:32:32,083 --> 00:32:39,160
或者它可能是一个也可能是一个结构 

620
00:32:38,002 --> 00:32:42,019
像以前的下一个指针 

621
00:32:40,006 --> 00:32:43,063
所以有时候，如果你保持更容易

622
00:32:42,037 --> 00:32:45,112
同样的，你知道，当你在做链接 

623
00:32:44,017 --> 00:32:47,080
列出 了途径，如果你只是使它 

624
00:32:46,012 --> 00:32:49,078
同样的，因为它可以在所有其他节点 

625
00:32:47,008 --> 00:32:50,104
简化事情但是，是它可能是一个 

626
00:32:49,078 --> 00:32:59,104
在全局变量全局 标 

627
00:32:51,076 --> 00:33:00,160
分配好了，所以情况哦，现在有一件事 

628
00:33:00,004 --> 00:33:05,026
我想到的还有一件事

629
00:33:01,006 --> 00:33:09,085
像有一个优化，我们 

630
00:33:05,026 --> 00:33:13,075
可在这种情况下做的，你看我们什么时候 

631
00:33:10,039 --> 00:33:15,112
当我们合并，我们可以见好就收

632
00:33:13,075 --> 00:33:18,082
在免费列表 框右侧 有 

633
00:33:16,012 --> 00:33:20,020
右我们做虽然 我相信通过 

634
00:33:18,082 --> 00:33:23,154
所以我要去的例子来 告诉你 

635
00:33:20,092 --> 00:33:26,101
在假设中插入的LIFO政策 

636
00:33:24,054 --> 00:33:28,120
我们可以先不管它正确的 

637
00:33:27,001 --> 00:33:31,003
只是不只是更新任何内容 

638
00:33:29,002 --> 00:33:33,010
加大创建这个新 合并 

639
00:33:31,021 --> 00:33:35,047
块，然后精神上 我们不 要求 

640
00:33:34,000 --> 00:33:38,008
在这种情况下，我们不需要任何

641
00:33:35,047 --> 00:33:39,135
免费列表操作不错，但该 

642
00:33:38,008 --> 00:33:42,093
是这将是其中之一 

643
00:33:40,035 --> 00:33:43,038
优化权

644
00:33:43,094 --> 00:33:50,162
现在案例三，如果你还记得的 话 

645
00:33:49,004 --> 00:33:54,043
其中前身块是 

646
00:33:51,062 --> 00:33:57,079
分配和后继块

647
00:33:54,079 --> 00:33:57,079
释放

648
00:34:00,038 --> 00:34:05,069
后继块是免费的，所以在这 

649
00:34:04,309 --> 00:34:08,335
什么情况下，我们要做的是 ， 我们必须 

650
00:34:05,069 --> 00:34:12,131
创建我们必须凝聚新 

651
00:34:08,569 --> 00:34:16,573
释放的块与与后继 

652
00:34:13,031 --> 00:34:20,100
块，然后我们要拼接出来 

653
00:34:16,609 --> 00:34:25,940
在用同样的 方法 我们做 的情况下，两个 

654
00:34:20,379 --> 00:34:27,427
所以我们拼接出来的名单和

655
00:34:25,094 --> 00:34:29,102
然后把它在列表 的开头

656
00:34:27,859 --> 00:34:32,780
通过指向 在它 的 根，然后 

657
00:34:30,002 --> 00:34:35,311
更新曾经 被认为是第一个 块 

658
00:34:32,078 --> 00:34:37,717
在列表中更新其返回指针 

659
00:34:35,329 --> 00:34:41,000
它的前指针指向 这个 

660
00:34:38,419 --> 00:34:42,514
新合并块好了，所以它的这个 

661
00:34:41,000 --> 00:34:46,849
是与壳体 完全对称 

662
00:34:43,369 --> 00:34:48,421
我们看着 面前 的 ，但现在我们没有 

663
00:34:46,849 --> 00:34:49,948
再有它的一点点麻烦

664
00:34:48,889 --> 00:34:53,540
如果我们只是想离开这个块 

665
00:34:50,839 --> 00:34:56,300
空闲列表，我们不得不更新所有 

666
00:34:53,054 --> 00:34:57,373
这些指针指向回 

667
00:34:56,003 --> 00:35:02,090
开始新 创建 的块 

668
00:34:57,859 --> 00:35:06,440
好了，所以有这么在这种情况下，有 

669
00:35:03,017 --> 00:35:07,073
没有性能优化对，我们 

670
00:35:06,044 --> 00:35:09,071
还更新了相同数量的 

671
00:35:07,073 --> 00:35:11,212
指针，我们是否把它放在 

672
00:35:09,071 --> 00:35:14,167
开始列表 ， 或者 如果我们如果我们 

673
00:35:11,869 --> 00:35:15,670
拼接，或者如果我们就此打住 

674
00:35:17,002 --> 00:35:22,054
而现在的情况下四是那样的话 

675
00:35:21,099 --> 00:35:26,106
在前任和继任者都

676
00:35:22,072 --> 00:35:31,461
块是免费的，所以我们必须应用 

677
00:35:26,799 --> 00:35:35,856
同一分片技术都 意识到 

678
00:35:32,109 --> 00:35:39,180
前身块，我们必须我们有

679
00:35:36,369 --> 00:35:43,720
创造这个新的 聚结块 

680
00:35:39,819 --> 00:35:44,844
接下来我们就来拼接，我们必须我们 

681
00:35:43,072 --> 00:35:50,074
要排序的拼接出来的 

682
00:35:45,069 --> 00:35:56,097
更新两套不同以往 

683
00:35:50,074 --> 00:35:59,101
和后继块好了，所以 ， 当 我们 

684
00:35:56,349 --> 00:36:01,930
当我们完成了该本 

685
00:36:00,001 --> 00:36:07,003
新合并块，现在是第一 

686
00:36:01,093 --> 00:36:09,012
块在堆中的四个

687
00:36:07,003 --> 00:36:11,047
免费单， 我们剪接我们是持拼接 

688
00:36:09,849 --> 00:36:14,970
从上述 两个 不同的部分出来

689
00:36:11,047 --> 00:36:14,052
在空闲列表 

690
00:36:17,044 --> 00:36:26,108
好了，所以任何相关的问题是这样的 

691
00:36:22,067 --> 00:36:30,068
是 你真的看起来它 看起来 

692
00:36:27,008 --> 00:36:34,085
很简单的事， 但我向 你 保证 

693
00:36:30,077 --> 00:36:35,156
这将是 它的 一些 最困难的 

694
00:36:34,085 --> 00:36:36,182
只有像200 行 代码，但一些 

695
00:36:36,056 --> 00:36:41,090
最难的代码，就必须写

696
00:36:37,082 --> 00:36:42,137
因为你，你那种 自由的 

697
00:36:41,009 --> 00:36:44,063
C'S型系统，您需要做的 

698
00:36:43,037 --> 00:36:46,115
一切通过明确这些铸造 

699
00:36:45,044 --> 00:36:52,049
指针只是在中间 

700
00:36:47,015 --> 00:36:54,029
任意块，所以它看起来很简单

701
00:36:52,049 --> 00:36:55,052
与图表，但你要 

702
00:36:54,029 --> 00:37:00,068
必须 当你 真 细心 

703
00:36:55,052 --> 00:37:03,068
这其实是我 会建议 

704
00:37:00,068 --> 00:37:05,069
最好的建议我 可以给你的是它是 

705
00:37:03,068 --> 00:37:07,142
先从 隐含名单 

706
00:37:05,069 --> 00:37:09,104
分配器，我们在书中 描述 

707
00:37:08,042 --> 00:37:11,114
这是太慢 获得任何信贷 

708
00:37:10,004 --> 00:37:16,061
可怕的分配器，但它包含了所有 

709
00:37:12,014 --> 00:37:18,023
基本 的想法，然后写函数 

710
00:37:16,061 --> 00:37:19,157
写一个函数调用插入块和 

711
00:37:19,004 --> 00:37:23,081
另写函数调用删除 

712
00:37:20,057 --> 00:37:25,121
块插入块成游离 

713
00:37:23,081 --> 00:37:28,130
列出并从自由删除块 

714
00:37:26,021 --> 00:37:31,064
分别列表， 如果你，如果你 

715
00:37:29,003 --> 00:37:32,078
写，如果你抽象的像，如果 

716
00:37:31,064 --> 00:37:35,105
您使用的那种 抽象的 它 

717
00:37:33,005 --> 00:37:37,094
很简单的隐式转换 

718
00:37:36,005 --> 00:37:42,005
名单分配给一个明确的列表 

719
00:37:37,094 --> 00:37:44,102
分配好它仍然会是 太慢 

720
00:37:42,005 --> 00:37:50,006
得到这样的话会从去 像 

721
00:37:45,002 --> 00:37:52,049
˚F分配到 B-分配器 ，然后 

722
00:37:50,015 --> 00:37:54,074
要真正做一个好的分配像 

723
00:37:52,049 --> 00:37:58,066
你需要使用糖是分配器

724
00:37:54,074 --> 00:37:57,166
列出了我们来看看在 第二 

725
00:37:59,004 --> 00:38:04,039
好了，所以明确的名单现在的 

726
00:38:02,029 --> 00:38:06,078
分配时间是在数线性 

727
00:38:04,039 --> 00:38:10,117
的空闲块代替 的总大小 

728
00:38:06,339 --> 00:38:12,417
的代替的总大小 

729
00:38:11,017 --> 00:38:14,050
堆所以它的这个 比快得多 

730
00:38:13,119 --> 00:38:17,470
当你有很多的分配 

731
00:38:14,005 --> 00:38:19,021
块这是一个有点复杂 

732
00:38:17,047 --> 00:38:23,130
因为 所有的拼接业务和 

733
00:38:19,066 --> 00:38:26,149
而你需要做一些额外的空间，你的 

734
00:38:24,003 --> 00:38:28,102
对于这些指针，这增加了

735
00:38:27,049 --> 00:38:35,928
最小的块大小，并创建

736
00:38:29,029 --> 00:38:38,077
现在 的额外 开销的链接 列表 

737
00:38:36,369 --> 00:38:41,470
明确的名单分配器不 

738
00:38:38,077 --> 00:38:43,080
真的足够足够 用于 

739
00:38:41,047 --> 00:38:47,089
排序通用 现实生活 的 

740
00:38:43,008 --> 00:38:49,017
分配器，但他们是在为部分有用

741
00:38:47,089 --> 00:38:51,166
一个隔离列表 分配的，所以你 

742
00:38:49,809 --> 00:38:54,780
可以有你可以有 多个免费 

743
00:38:52,066 --> 00:38:56,164
列出每一个都是一个明确的列表 

744
00:38:54,078 --> 00:39:00,142
和它的罚款 ，对于该 

745
00:38:57,064 --> 00:39:03,076
应用好了让我们看看我们 

746
00:39:01,042 --> 00:39:06,981
第三种 方法 是创建 一个呼叫 

747
00:39:03,076 --> 00:39:08,865
隔离自由列表，它是有 

748
00:39:07,359 --> 00:39:14,700
不同尺寸的多个自由列表 

749
00:39:09,549 --> 00:39:19,557
班所以这个想法是，每个 

750
00:39:14,007 --> 00:39:22,039
每个类大小的块大小的具有其 

751
00:39:20,349 --> 00:39:24,700
自己的自由列表和那类可以 

752
00:39:23,002 --> 00:39:27,531
单身，你也许知道 一个 

753
00:39:24,007 --> 00:39:29,053
特定大小或它可以是一个范围 

754
00:39:27,549 --> 00:39:32,740
大小，所以 你 可能你可能 有一个 

755
00:39:30,016 --> 00:39:35,715
你知道，如果 你如果 不同数量

756
00:39:32,074 --> 00:39:36,169
你的 ，如果你的工作负载包括大量的 

757
00:39:35,859 --> 00:39:38,980
这些小块的，你知道， 

758
00:39:37,069 --> 00:39:41,104
还有的将是大量 的 请求 

759
00:39:38,098 --> 00:39:44,107
对于一个1-4块，你可以 有 

760
00:39:42,004 --> 00:39:48,273
对于那些小的不同的空闲列表 

761
00:39:45,088 --> 00:39:49,144
那些小的块大小和在此之后 

762
00:39:48,309 --> 00:39:52,720
你可以去 ，只是做的范围 

763
00:39:50,044 --> 00:39:55,066
2的幂所以这是一个这是一个常见的 

764
00:39:52,072 --> 00:39:57,201
技术，因此在这里我们有一个尺寸级别 

765
00:39:55,066 --> 00:40:02,265
覆盖从大小为5块〜8和 

766
00:39:57,849 --> 00:40:05,460
然后另一个尺寸类覆盖

767
00:40:02,859 --> 00:40:05,460
一切 

768
00:40:06,309 --> 00:40:11,510
所以与赛格 名单 分配器的想法

769
00:40:09,023 --> 00:40:14,122
该给定 的 这些 给定的阵列 

770
00:40:11,051 --> 00:40:16,600
免费名单一个个针对一些 

771
00:40:14,329 --> 00:40:20,450
如果我们想分配尺寸类

772
00:40:17,059 --> 00:40:22,138
大小为n的块，然后我们我们去 

773
00:40:20,045 --> 00:40:24,874
合适的自由列表右边有只 

774
00:40:22,849 --> 00:40:28,873
人们总是将是一个免费列表 

775
00:40:25,279 --> 00:40:30,358
对于任何任意结束，然后我们说搜索

776
00:40:29,089 --> 00:40:34,138
列表就像我们以前那样 

777
00:40:31,069 --> 00:40:40,010
对于某些尺寸 如果块尺寸M大 

778
00:40:34,579 --> 00:40:43,880
大于n，然后如果我们发现那我们 

779
00:40:40,001 --> 00:40:46,030
地方，我们将新的块我们把 

780
00:40:43,088 --> 00:40:48,547
在块中，该块，我们 

781
00:40:46,039 --> 00:40:51,020
发现我们把它分解，我们采取这种 

782
00:40:49,339 --> 00:40:52,435
分块，我们把它放到 

783
00:40:51,002 --> 00:40:55,073
适当的尺寸类，使得块 

784
00:40:53,299 --> 00:40:57,325
我们分出可用可不用的可能或 

785
00:40:55,073 --> 00:40:58,166
可能不属于目前的规模类 

786
00:40:57,559 --> 00:41:01,567
了，所以我们可能要 移动它 

787
00:40:59,066 --> 00:41:06,095
并且将其插入任何 的 

788
00:41:02,359 --> 00:41:08,428
适当大小的类是如果没有 

789
00:41:06,095 --> 00:41:10,224
块，如果我们不能找到一个块，然后我们 

790
00:41:09,049 --> 00:41:14,180
要尝试下一个较大的尺寸级别 

791
00:41:11,079 --> 00:41:16,220
好了，所以它 可能对于给定 尺寸 

792
00:41:14,018 --> 00:41:21,907
类，他们只是有可能不是 一个 

793
00:41:16,022 --> 00:41:23,911
块， 适合 所以我的意思是一个，所以我们只是 

794
00:41:22,069 --> 00:41:25,165
要 我们去，我们尝试下大小 

795
00:41:24,109 --> 00:41:27,208
下一个更大的类和机会 

796
00:41:26,029 --> 00:41:31,111
我们会找到适合有一个块 

797
00:41:28,099 --> 00:41:33,145
如果你一直这样做，直到你 

798
00:41:31,849 --> 00:41:34,921
最终如果你不能找到你

799
00:41:33,559 --> 00:41:37,615
最终看在尺寸级别 

800
00:41:35,569 --> 00:41:40,618
这是覆盖所有的休息 

801
00:41:38,119 --> 00:41:44,920
最后径级，如果再你不能

802
00:41:41,059 --> 00:41:48,980
找到它，然后，该分配器具有 

803
00:41:44,092 --> 00:41:50,451
与由科琳小号分配更多的内存

804
00:41:48,098 --> 00:41:50,397
打破

805
00:41:52,057 --> 00:41:56,105
还好释放你凝聚像块 

806
00:41:55,061 --> 00:41:59,063
之前， 然后你将它放在 

807
00:41:57,005 --> 00:42:01,043
相应的列表所以这是这 

808
00:41:59,063 --> 00:42:03,071
简单 ，再次你 有这样的 

809
00:42:01,043 --> 00:42:05,069
选项来尝试维持上市 

810
00:42:03,071 --> 00:42:06,107
地址订购或只是做简单的

811
00:42:05,069 --> 00:42:12,094
事情 并把它在 的 开始 

812
00:42:07,007 --> 00:42:17,041
列出好了，所以说 鸡蛋 列表 鳄鱼是 

813
00:42:12,094 --> 00:42:19,139
这是迄今为止鳄鱼最好的类型

814
00:42:17,041 --> 00:42:22,132
因为他们为您提供改进 

815
00:42:20,039 --> 00:42:26,045
在性能和吞吐量 

816
00:42:23,032 --> 00:42:28,064
内存利用率所以他们更快

817
00:42:26,099 --> 00:42:30,158
他们有更高的吞吐量，因为 

818
00:42:28,064 --> 00:42:33,137
个体大小类是

819
00:42:31,058 --> 00:42:36,110
然后比就像一个小

820
00:42:34,037 --> 00:42:40,046
巨人空闲列表， 而且你 

821
00:42:37,001 --> 00:42:43,016
搜索你知道 列表 

822
00:42:41,027 --> 00:42:44,081
您正在搜索将是接近 

823
00:42:43,025 --> 00:42:47,069
您正在寻找这样的大小

824
00:42:44,081 --> 00:42:49,142
快速找到东西的机会

825
00:42:47,069 --> 00:42:51,131
在那个 特定的大小类 是 

826
00:42:50,042 --> 00:42:54,125
高于他们，如果你只是 

827
00:42:52,031 --> 00:42:56,120
搜索你想知道一个免费列表 

828
00:42:55,025 --> 00:42:59,039
保存所有不同规模类 

829
00:42:57,002 --> 00:43:03,074
好了，搜索速度更快，使 

830
00:42:59,039 --> 00:43:05,135
上升增加吞吐量，但 

831
00:43:03,092 --> 00:43:08,108
关于鸡蛋 列表鳄鱼大的事情是 

832
00:43:06,035 --> 00:43:11,054
像我们之前，他们谈到了 

833
00:43:09,008 --> 00:43:14,024
接近最适合在不牺牲

834
00:43:11,054 --> 00:43:16,097
演出前的权利，如果我们想 

835
00:43:14,024 --> 00:43:18,059
做最适合于单一空闲列表我们

836
00:43:16,097 --> 00:43:20,125
不得不搜索整个空闲列表和

837
00:43:18,059 --> 00:43:24,083
然后选择这是它最好的块 

838
00:43:21,025 --> 00:43:27,110
在这种情况下，我们也得到了我们获得最适合 

839
00:43:24,083 --> 00:43:34,088
释放由通过具有这些尺寸的 

840
00:43:28,001 --> 00:43:36,008
类等，这是你知道这 是 

841
00:43:34,088 --> 00:43:39,097
这是你如何能提高你的 

842
00:43:36,008 --> 00:43:39,106
内存利用率是 

843
00:43:44,259 --> 00:43:52,315
对我来说这鳄鱼，更咬伤或 

844
00:43:50,049 --> 00:43:56,930
下哦耶，耶，很好的问题，因此 

845
00:43:52,819 --> 00:43:59,420
问题 是是是打破固定的 时间它 

846
00:43:56,093 --> 00:44:01,097
是，但它是非常昂贵 ，因此这是一个 

847
00:43:59,042 --> 00:44:04,351
思科所以它必须从用户空间传递

848
00:44:01,097 --> 00:44:07,366
到涉及更改内核 

849
00:44:04,729 --> 00:44:12,710
联系人改变栈所以它的 这个 

850
00:44:08,239 --> 00:44:14,630
叫一般来说，你可以，你可以指望 

851
00:44:12,071 --> 00:44:16,166
协助呼叫是像几百 

852
00:44:14,063 --> 00:44:20,782
微秒还好这是一个不平凡的 

853
00:44:17,066 --> 00:44:22,088
开销，所以在这种情况下，你 

854
00:44:21,349 --> 00:44:25,910
我不想让你要 分摊 

855
00:44:22,088 --> 00:44:28,094
的突破的费用由 

856
00:44:25,091 --> 00:44:29,114
分配稍大块，但 

857
00:44:28,094 --> 00:44:31,393
你必须要小心，如果你分配 

858
00:44:30,014 --> 00:44:34,019
过大的块，然后对你的记忆 

859
00:44:32,239 --> 00:44:35,420
利用率下降所以这是一个

860
00:44:34,019 --> 00:44:40,888
权衡它的这些一个又一个 

861
00:44:35,042 --> 00:44:43,097
时空权衡问题，以便在那里 

862
00:44:41,059 --> 00:44:45,085
你存储在此阵列 的空闲列表 等等 

863
00:44:43,097 --> 00:44:49,396
你将它存储在的开始

864
00:44:45,319 --> 00:44:52,345
热啊，其实你Mallik实验中我们 

865
00:44:50,269 --> 00:44:56,302
要求你要做到这一点，我们不 知道和 

866
00:44:52,579 --> 00:44:59,690
原因是我们不能蝙蝠进行阵列 

867
00:44:56,599 --> 00:45:00,661
这取决于如何做爱在一些小部分

868
00:44:59,069 --> 00:45:03,388
大数组是它会影响您的 

869
00:45:01,219 --> 00:45:06,880
内存利用率，所以它应该 是 

870
00:45:04,009 --> 00:45:06,880
在热的 开始 

871
00:45:12,002 --> 00:45:19,035
还好有一个分配器已 

872
00:45:16,005 --> 00:45:24,090
撒手人寰和的经典 

873
00:45:19,053 --> 00:45:26,094
引用克努特的1973年 文本 和 

874
00:45:24,009 --> 00:45:29,013
这里还有这个伟大的纸， 你 

875
00:45:26,094 --> 00:45:32,139
可以从 本书的网站 得到 

876
00:45:29,094 --> 00:45:34,158
1995年，做你的调查知道 

877
00:45:33,039 --> 00:45:36,102
小数十座技术

878
00:45:35,058 --> 00:45:38,127
就像我们只是表面 

879
00:45:37,002 --> 00:45:42,048
所以在这里，如果你真正感兴趣 

880
00:45:39,027 --> 00:45:44,031
这个东西，那试卷 

881
00:45:42,048 --> 00:45:49,122
迷人的读取和它可能给你 

882
00:45:44,031 --> 00:45:53,085
现在没事了一些想法，供 大家实验预习 所以 

883
00:45:50,022 --> 00:45:55,065
目前为止我们还假设应用程序

884
00:45:53,085 --> 00:45:59,091
同时负责 分配 

885
00:45:55,065 --> 00:46:02,070
存储和释放存储，但有 

886
00:45:59,091 --> 00:46:05,169
有内存管理的一种形式叫

887
00:46:02,007 --> 00:46:09,009
内隐记忆经理们做的

888
00:46:06,069 --> 00:46:10,128
释放你那么那么的应用

889
00:46:09,072 --> 00:46:12,078
分配空间，但他们从来没有 

890
00:46:11,028 --> 00:46:18,063
担心释放空间系统

891
00:46:13,032 --> 00:46:23,109
这是否自动所以在 

892
00:46:18,063 --> 00:46:25,149
思想是 确定所谓的垃圾等等 

893
00:46:24,009 --> 00:46:29,013
内存方面是绝不可能 

894
00:46:26,049 --> 00:46:31,076
再引用，然后释放 

895
00:46:29,049 --> 00:46:34,068
这些块

896
00:46:31,076 --> 00:46:36,090
所以什么是垃圾以及这里是一个 例子 

897
00:46:34,068 --> 00:46:40,068
我们有一个函数foo，现在喜欢 

898
00:46:36,009 --> 00:46:43,065
128个字节它 在此 存储的地址 

899
00:46:40,068 --> 00:46:46,074
指针P，然后在某个时刻 ，当它 

900
00:46:44,046 --> 00:46:48,084
从FOO返回该指针丢失 

901
00:46:47,028 --> 00:46:51,123
永远正确的，因为P是一个地方 

902
00:46:48,084 --> 00:46:54,096
在 堆栈 上 可变 所以一旦这一次 

903
00:46:52,023 --> 00:46:57,075
函数返回的块 

904
00:46:54,096 --> 00:46:59,139
存储器由p指向的是垃圾罐

905
00:46:57,075 --> 00:47:01,086
永远不会再因为引用

906
00:47:00,039 --> 00:47:05,055
有没有办法， 没有 办法的 

907
00:47:01,086 --> 00:47:07,119
程序获得到达那个等访问

908
00:47:05,055 --> 00:47:10,080
什么样的 分配会认识一些 

909
00:47:08,019 --> 00:47:12,096
指出这一点的存储器的这个块是 

910
00:47:10,008 --> 00:47:13,107
垃圾，它会释放那些 

911
00:47:12,096 --> 00:47:17,097
通过调用free这是相同的块

912
00:47:14,079 --> 00:47:21,102
实物一模一样的 免费通话为 

913
00:47:18,006 --> 00:47:23,010
我们已经讨论过，但现在它是由被称为 

914
00:47:22,002 --> 00:47:26,004
垃圾收集器不

915
00:47:23,046 --> 00:47:29,067
应用好让你在看到这个 

916
00:47:26,004 --> 00:47:31,059
各种不同类型的动态语言 

917
00:47:29,067 --> 00:47:34,122
而且也有有也 

918
00:47:31,059 --> 00:47:39,144
对于C，但由于可用的变种

919
00:47:35,022 --> 00:47:42,024
C'S 指针性的垃圾 

920
00:47:40,044 --> 00:47:44,049
对于C收藏家都在保守 

921
00:47:42,042 --> 00:47:46,128
某种意义上说 有一些块不会 

922
00:47:44,049 --> 00:47:49,074
释放有一些垃圾块是 

923
00:47:47,028 --> 00:47:53,079
这不会是免费的，因为分配器 

924
00:47:49,074 --> 00:47:55,089
不能确定它们 是 

925
00:47:53,079 --> 00:47:58,143
的确垃圾所以它必须要小心

926
00:47:55,089 --> 00:48:00,183
当它只要有疑问，这是 

927
00:47:59,043 --> 00:48:08,046
叶不回收的 

928
00:48:01,083 --> 00:48:08,169
分配的块所以它得到这个 

929
00:48:08,046 --> 00:48:13,052
像问题如何 做内存 

930
00:48:09,069 --> 00:48:16,116
经理知道什么时候存储可以是自由的 

931
00:48:13,052 --> 00:48:18,054
你知道，如果我们知道，如果我们不知何故知道 

932
00:48:17,016 --> 00:48:21,060
我们可以预测所有的未来 

933
00:48:18,072 --> 00:48:22,149
请求，然后如果我们知道 有 

934
00:48:21,006 --> 00:48:25,029
是没有前途的请求 访问 

935
00:48:23,049 --> 00:48:30,062
块，我们可以释放它 不错，但我们 

936
00:48:25,083 --> 00:48:32,091
无法预测好了，所以我们必须 

937
00:48:30,062 --> 00:48:34,140
但如果没有指针，如果没有 

938
00:48:33,063 --> 00:48:36,068
指针存在于特定块 

939
00:48:35,004 --> 00:48:39,021
那么我们知道， 它不能 被访问 

940
00:48:37,013 --> 00:48:42,078
可以的，这样我们就 可以正确的预测，如果 

941
00:48:39,057 --> 00:48:46,059
有一些方法，我们 可以排序扫描 

942
00:48:42,078 --> 00:48:48,096
节目识别或扫描存储器 

943
00:48:46,059 --> 00:48:51,093
识别内存的所有指针

944
00:48:48,096 --> 00:48:53,160
并且部分，查看哪些块有 

945
00:48:51,093 --> 00:48:55,131
指出了它的存在，如果他们不 

946
00:48:54,006 --> 00:48:59,055
指向任何指针然后 然后 

947
00:48:56,031 --> 00:49:04,038
他们的定义是垃圾 好了，所以到 

948
00:49:00,009 --> 00:49:06,045
做到这一点，虽然这是 很难使第一 

949
00:49:04,038 --> 00:49:07,044
所有的内存管理器必须能够 

950
00:49:06,045 --> 00:49:10,083
区分非指针 

951
00:49:07,098 --> 00:49:10,167
指针这是我们不能做的，见右图 

952
00:49:10,083 --> 00:49:13,164
他们只是这些 

953
00:49:11,067 --> 00:49:17,136
他们只是这些积分值权

954
00:49:14,064 --> 00:49:20,082
我们不知道它可能 是 ，如果我们看到 

955
00:49:18,036 --> 00:49:24,099
这个大的积分值这个大 

956
00:49:20,082 --> 00:49:25,164
长一个八字节的值，它可能是它 

957
00:49:24,099 --> 00:49:27,123
可以指向一个数据结构， 它 

958
00:49:26,064 --> 00:49:33,072
可能仅仅是一个大的整数正确的，我们 

959
00:49:28,023 --> 00:49:34,116
不知道，然后我们还所有指针 

960
00:49:33,072 --> 00:49:36,901
必须指向一个块的开始 

961
00:49:35,016 --> 00:49:40,113
这是不正确的，要么看 

962
00:49:37,549 --> 00:49:43,140
好吧，如果我们有 一个指针，我们 

963
00:49:41,013 --> 00:49:45,242
确定在指针 那么我们 

964
00:49:43,014 --> 00:49:47,019
知道它指向它指出了一些 

965
00:49:45,359 --> 00:49:49,140
如果阻止它指向一个块怎样的内部 

966
00:49:47,064 --> 00:49:50,163
我们怎么办，我们发现的开端 

967
00:49:49,014 --> 00:49:53,091
你知道块我们怎么知道如何 

968
00:49:51,063 --> 00:49:54,146
大该块是 如此有指向 

969
00:49:53,091 --> 00:50:00,800
块或首部的 开头 

970
00:49:55,046 --> 00:50:02,097
告诉我们的规模和和和和 

971
00:50:01,619 --> 00:50:03,713
不能有隐瞒指针方式

972
00:50:02,097 --> 00:50:06,226
该点的是一个属性

973
00:50:04,559 --> 00:50:11,588
指针必须是某种静态 

974
00:50:07,099 --> 00:50:12,197
说没有不能改变，因此 

975
00:50:11,849 --> 00:50:14,280
这是排序 的挑战 ，如果你 

976
00:50:13,079 --> 00:50:15,630
思考如何在世界上你 

977
00:50:14,028 --> 00:50:17,567
实现垃圾收集所以那些 

978
00:50:15,063 --> 00:50:20,012
是 一些 的 挑战 

979
00:50:17,819 --> 00:50:23,490
他们目前正因为它的 

980
00:50:20,579 --> 00:50:26,750
成为 研究和垃圾 史 

981
00:50:23,049 --> 00:50:29,088
收藏家它是旧的古老和 

982
00:50:26,075 --> 00:50:30,171
目前它仍然是它仍在进行中 

983
00:50:29,088 --> 00:50:33,089
今天特别是在上下文 

984
00:50:31,071 --> 00:50:35,180
并行程序和垃圾收集

985
00:50:33,089 --> 00:50:36,998
运行多个程序

986
00:50:35,819 --> 00:50:40,950
线程，以便有一大堆 

987
00:50:37,799 --> 00:50:43,500
这些东西，人们已经看 

988
00:50:40,095 --> 00:50:45,120
将所有的方式 回到1960年 

989
00:50:43,005 --> 00:50:48,021
今天我们来看看，我们将看看

990
00:50:46,002 --> 00:50:50,028
较简单的最简单的一个东西 

991
00:50:48,066 --> 00:50:51,995
变种称为标记和清除，我们 

992
00:50:50,046 --> 00:50:53,067
不会，我们不会讨论休息，但如果 

993
00:50:52,589 --> 00:50:55,980
你有兴趣他们有一个 

994
00:50:53,067 --> 00:50:59,154
相当不错的书 ， 描述 

995
00:50:55,098 --> 00:51:02,237
描述这些东西没事所以如何 

996
00:51:00,054 --> 00:51:05,091
我们建立一个 分配 ，所以我们通过启动 

997
00:51:03,119 --> 00:51:10,163
观看存储器作为向图，其中 

998
00:51:05,091 --> 00:51:17,120
图中的每一个相对应的每个节点

999
00:51:10,559 --> 00:51:18,200
到一个块行的块的堆块和 

1000
00:51:18,005 --> 00:51:26,052
食用出分配的堆块 和 

1001
00:51:23,066 --> 00:51:29,735
每个边缘是真实包含一个指针

1002
00:51:26,097 --> 00:51:33,099
内的块指针到某处

1003
00:51:30,329 --> 00:51:36,510
另一个块，然后有一个和 

1004
00:51:34,017 --> 00:51:39,024
再有就是 所谓的根 特殊节点 

1005
00:51:36,051 --> 00:51:40,053
包含指针到节点

1006
00:51:39,024 --> 00:51:42,117
堆，但他们不是堆的一部分，所以 

1007
00:51:40,071 --> 00:51:44,079
为存储 在 例如指针 

1008
00:51:43,017 --> 00:51:48,686
存储 在 所述堆栈指针 

1009
00:51:45,051 --> 00:51:49,077
寄存器它们指向的存储器位置

1010
00:51:48,839 --> 00:51:54,960
在堆

1011
00:51:49,077 --> 00:51:56,121
但没有什么和但是有 

1012
00:51:54,096 --> 00:51:58,125
热量 ，使 之外 ，我们呼吁那些 

1013
00:51:57,021 --> 00:52:00,069
根音所以没有点对他们或 

1014
00:51:59,025 --> 00:52:02,033
至少，如果事情不指向它们 

1015
00:52:00,069 --> 00:52:04,110
我们不关心 什么 是好的 

1016
00:52:03,005 --> 00:52:08,094
我们只是我们只关心 

1017
00:52:05,001 --> 00:52:12,083
对应于表征节点 

1018
00:52:08,094 --> 00:52:14,163
内存堆，所以我我们说 

1019
00:52:12,092 --> 00:52:19,140
节点或 块是可到达的，如果有 

1020
00:52:15,063 --> 00:52:22,086
从根节点 从根一些路径

1021
00:52:20,004 --> 00:52:24,057
节点到该块左右，我们已经记

1022
00:52:22,086 --> 00:52:26,100
那些绿色的 ，因此所有 这些绿色的 

1023
00:52:24,093 --> 00:52:27,159
在堆块是可到达的，因为 

1024
00:52:27,000 --> 00:52:31,008
你可以在根节点处开始，只是 

1025
00:52:28,059 --> 00:52:33,155
跟随指针的一些部分序列

1026
00:52:31,008 --> 00:52:39,039
到达该节点 好吗 

1027
00:52:34,055 --> 00:52:41,067
注释所有不可 被称为 

1028
00:52:39,039 --> 00:52:43,101
我们的垃圾 ，因为没有有 

1029
00:52:41,067 --> 00:52:45,153
没有办法让他们从根 

1030
00:52:44,001 --> 00:52:48,009
节点好了，里面有无节点 

1031
00:52:46,053 --> 00:52:51,060
热指向他们，而且也没有

1032
00:52:48,081 --> 00:52:52,125
节点有指向没有根节点 

1033
00:52:51,006 --> 00:52:54,084
他们所以基本上只是 没有路径 

1034
00:52:53,025 --> 00:52:58,074
从根节点是会得到你 一个 

1035
00:52:55,038 --> 00:53:02,115
这些非可到达 或垃圾节点 

1036
00:52:58,074 --> 00:53:03,081
而因为他们是不可到达的 

1037
00:53:03,015 --> 00:53:06,054
应用程序将永远无法

1038
00:53:04,044 --> 00:53:08,091
引用他们的未来，所以我们 可以 

1039
00:53:06,054 --> 00:53:11,150
肯定地说， 这些预测

1040
00:53:08,091 --> 00:53:14,103
都是垃圾，他们可以 没事 被释放 

1041
00:53:12,005 --> 00:53:17,054
所以基本上我们后释放这些 再 

1042
00:53:15,003 --> 00:53:17,099
他们从图中移除

1043
00:53:22,051 --> 00:53:28,097
所以现在我们可以我们可以建立一个简单的

1044
00:53:27,079 --> 00:53:30,920
在现有的顶部垃圾收集器

1045
00:53:28,097 --> 00:53:31,966
malloc和free包装正​​确，因此您

1046
00:53:30,092 --> 00:53:38,120
现在实行我可以自由就像 

1047
00:53:32,839 --> 00:53:42,230
之前， 然后你如果程序调用 

1048
00:53:39,002 --> 00:53:43,891
malloc的只是像以前一样，你 只是你 

1049
00:53:42,023 --> 00:53:46,025
做的malloc完全相同的方式，直到你 

1050
00:53:44,089 --> 00:53:47,188
不论如何定义 运行的 空间 

1051
00:53:46,043 --> 00:53:49,139
要使用空间耗尽的 

1052
00:53:48,079 --> 00:53:52,156
也许你有某种形式的最大 每一 

1053
00:53:50,039 --> 00:53:54,047
大小你愿意在一些使用或 

1054
00:53:52,849 --> 00:53:58,926
点OS将只是停止给你 

1055
00:53:54,047 --> 00:53:59,196
当你运行 的空间虚拟内存

1056
00:54:00,028 --> 00:54:06,104
你，你添加一个额外的标志位进入 

1057
00:54:05,021 --> 00:54:08,044
每个块的首标所以这可能 是 

1058
00:54:07,004 --> 00:54:11,006
你知道我们有像三个或四个 

1059
00:54:08,044 --> 00:54:12,973
我们可以在标题中使用备用位

1060
00:54:11,024 --> 00:54:16,052
所以我们可以表示 其中的一个是这样的 

1061
00:54:13,369 --> 00:54:21,170
标志位，然后我们都是垃圾

1062
00:54:16,052 --> 00:54:23,113
我们收集的垃圾收集阶段 

1063
00:54:21,017 --> 00:54:26,096
当我们运行的空间由两

1064
00:54:24,013 --> 00:54:28,702
两个不同的子阶段之一是该标记 

1065
00:54:26,096 --> 00:54:31,130
阶段开始于所有的根和 

1066
00:54:28,819 --> 00:54:35,660
然后，它只是遍历这个从 

1067
00:54:32,003 --> 00:54:37,042
根遍历集合 的节点 

1068
00:54:35,066 --> 00:54:38,114
是从 根和 它 到达 

1069
00:54:37,339 --> 00:54:43,460
设定标记的是在每个各一个 

1070
00:54:39,014 --> 00:54:46,453
这些节点确定，然后后 你 一次 

1071
00:54:43,046 --> 00:54:47,144
完成标志着所有的所有的 

1072
00:54:46,579 --> 00:54:50,270
可到达的块，然后你通过扫

1073
00:54:48,044 --> 00:54:53,433
整个堆起始于 非常 

1074
00:54:50,027 --> 00:54:56,054
堆的 开始 ，你看 

1075
00:54:53,829 --> 00:54:58,831
你看所有分配的块是 

1076
00:54:56,054 --> 00:54:59,117
因为他们不是 没有标记 好吗 

1077
00:54:58,849 --> 00:55:01,875
标志着他们在没有到达他们的 

1078
00:55:00,017 --> 00:55:06,080
垃圾

1079
00:55:02,109 --> 00:55:10,490
sofirst所以你这样做，所以你之类 的做 

1080
00:55:06,008 --> 00:55:11,033
-你从从做搜索 

1081
00:55:10,049 --> 00:55:14,065
根， 那么你做的扫描 

1082
00:55:12,005 --> 00:55:14,011
整个热 

1083
00:55:17,007 --> 00:55:24,064
所以我们说， 以前 的标志，我们有 

1084
00:55:20,014 --> 00:55:26,017
一个标记阶段之前，我们有一个 堆 

1085
00:55:24,064 --> 00:55:29,086
看起来像这一点，我们有一个单一的 

1086
00:55:26,017 --> 00:55:30,022
根指向此块什么 

1087
00:55:29,086 --> 00:55:32,155
我们要在这里做 我们总是 

1088
00:55:30,067 --> 00:55:35,089
要指出的有效载荷权 

1089
00:55:33,055 --> 00:55:38,110
该块只是一个约定 

1090
00:55:35,089 --> 00:55:40,105
我们使用所以我们指向 

1091
00:55:39,001 --> 00:55:44,047
块的 开始 ，因为我们知道 

1092
00:55:41,005 --> 00:55:49,039
这是我们知道的是，标题是 

1093
00:55:44,056 --> 00:55:52,141
一个一个字背后，并让我们说 

1094
00:55:49,039 --> 00:55:54,115
并且在这种情况下，边缘表示 

1095
00:55:53,041 --> 00:55:56,092
中包含的块的指针

1096
00:55:55,015 --> 00:55:58,051
所以他们不是 一个和 下一个 

1097
00:55:56,092 --> 00:55:59,119
三分球是我们 维护这些 

1098
00:55:58,051 --> 00:56:04,084
仅会指向应用程序 

1099
00:56:00,019 --> 00:56:06,048
已投产 的区块，所以我们 有这么 

1100
00:56:04,084 --> 00:56:09,151
在这里，我们有根指向这个 

1101
00:56:06,048 --> 00:56:11,122
中央 块，然后有 和和 

1102
00:56:10,051 --> 00:56:13,102
还有一个指向该指针

1103
00:56:12,022 --> 00:56:16,045
阻止和有另一个指针 

1104
00:56:14,002 --> 00:56:18,004
指向该块，并有一个

1105
00:56:16,045 --> 00:56:21,097
指针在该块中指向 

1106
00:56:18,004 --> 00:56:25,027
该块所以我们做了标记后 

1107
00:56:21,097 --> 00:56:27,246
我们搜索这个我们寻找这些块 

1108
00:56:25,027 --> 00:56:30,031
和所有可达块的有 

1109
00:56:28,119 --> 00:56:33,400
标志位组是由天衣表示 

1110
00:56:30,031 --> 00:56:35,044
所以，你看到一个网， 然后 

1111
00:56:33,004 --> 00:56:39,007
未未标记块 

1112
00:56:35,044 --> 00:56:41,046
那么我们可以免费并返回到自由

1113
00:56:39,043 --> 00:56:41,046
名单

1114
00:56:42,072 --> 00:56:46,089
好了，让我们来看看假设 

1115
00:56:44,849 --> 00:56:49,650
一个简单的实现 只是为了让 

1116
00:56:46,089 --> 00:56:51,150
确保这是明显的，因此

1117
00:56:49,065 --> 00:56:53,139
应用程序调用新获取一个指针 

1118
00:56:52,005 --> 00:56:58,071
到块与所有这些值 

1119
00:56:54,039 --> 00:57:02,048
清除它调用读 DI阅读 

1120
00:56:59,016 --> 00:57:07,023
B座的位置，我和它使用 的写 

1121
00:57:03,029 --> 00:57:09,608
DIV写值 V 到我的位置 

1122
00:57:07,023 --> 00:57:11,118
嵌段B的那么每个块将有 一个 

1123
00:57:09,869 --> 00:57:17,640
报头字将解决作为乙

1124
00:57:12,018 --> 00:57:21,102
减1，然后将垃圾收集器 

1125
00:57:17,064 --> 00:57:24,147
拥有它，使用它来功能

1126
00:57:22,002 --> 00:57:27,581
识别是否指针是否其 

1127
00:57:25,047 --> 00:57:28,646
输入参数确实是一个指针确定 

1128
00:57:27,599 --> 00:57:31,800
所以有一些方法来区分 

1129
00:57:29,069 --> 00:57:34,740
从指针上的指针 ，它可以 

1130
00:57:31,008 --> 00:57:35,052
得到一些块的长度不 

1131
00:57:34,074 --> 00:57:41,129
包括头，它可以得到一个 

1132
00:57:36,024 --> 00:57:45,066
将所有所以给出的路线的 

1133
00:57:42,029 --> 00:57:50,588
鉴于这些假设我们我们 

1134
00:57:45,066 --> 00:57:53,139
伪代码标记为一步需要这么 

1135
00:57:50,849 --> 00:57:58,920
这最初是一个是一个指针的 路线 

1136
00:57:54,039 --> 00:58:01,068
指针好 ，然后我们检查作为我们的 

1137
00:57:58,092 --> 00:58:03,011
中止条件，我们检查，看看 是否 

1138
00:58:01,068 --> 00:58:07,149
这是输入确实是一个指针，

1139
00:58:03,839 --> 00:58:10,865
如果是这样，我们返回没关系，然后那么我们呢 

1140
00:58:08,049 --> 00:58:15,123
的的一个深度优先遍历

1141
00:58:11,099 --> 00:58:17,880
图所以如果这个，所以我们正在做一个 

1142
00:58:16,023 --> 00:58:18,902
该图的深度优先遍历和 

1143
00:58:17,088 --> 00:58:20,297
这是指针是那种我们

1144
00:58:19,109 --> 00:58:24,660
终止条件为的是 

1145
00:58:21,089 --> 00:58:26,460
深度优先遍历然后我们检查 

1146
00:58:24,066 --> 00:58:27,275
标志位，如果它被设置 那么这 

1147
00:58:26,046 --> 00:58:30,099
另一个终止条件没有

1148
00:58:27,869 --> 00:58:34,892
没有理由进行搜索，一旦发现 

1149
00:58:30,099 --> 00:58:35,978
一个明显的标记点，我们知道，所有的 

1150
00:58:35,099 --> 00:58:39,720
一切从到达该节点 

1151
00:58:36,869 --> 00:58:42,930
被标记，所以我们 就可以终止我们 

1152
00:58:39,072 --> 00:58:44,441
返回，只是停止搜索，如果它是

1153
00:58:42,093 --> 00:58:49,252
没有设置那么我们设置 标志位和 

1154
00:58:45,089 --> 00:58:50,089
接下来我们来看看每个字块中 

1155
00:58:50,082 --> 00:58:54,135
我们递归调用每个1马克

1156
00:58:53,043 --> 00:58:56,112
的那些 字现在 那些 中的每一个 

1157
00:58:55,035 --> 00:58:59,082
字可以 是 或可以 不是一个正确的指针 

1158
00:58:57,012 --> 00:59:03,054
所以，如果它不是一个指针，然后标记将 

1159
00:58:59,082 --> 00:59:04,145
刚刚返回瞬间立即如果

1160
00:59:03,054 --> 00:59:08,118
是一个指针，那么它将继续 

1161
00:59:05,045 --> 00:59:10,068
递归深度优先搜索好了， 

1162
00:59:09,018 --> 00:59:13,065
这是否感觉它只是 一个 

1163
00:59:10,068 --> 00:59:18,071
熟悉熟悉的深度优先图表 

1164
00:59:13,065 --> 00:59:22,113
它穿越我们都知道 

1165
00:59:18,071 --> 00:59:24,120
没关系， 然后扫描扫取 

1166
00:59:23,013 --> 00:59:27,021
指针热的开始 

1167
00:59:25,002 --> 00:59:29,079
这第一个 带指针到第一 

1168
00:59:27,021 --> 00:59:33,096
块在热，然后一些指针 

1169
00:59:29,097 --> 00:59:35,190
到热的端部，然后在 

1170
00:59:33,096 --> 00:59:39,150
while循环然后它扫描每个堆 

1171
00:59:36,009 --> 00:59:41,093
如果阻断标志位被设置它清除 

1172
00:59:40,005 --> 00:59:42,029
它

1173
00:59:44,077 --> 00:59:51,093
如果它，如果它的分配它释放它 

1174
00:59:49,051 --> 00:59:51,093
对

1175
00:59:53,007 --> 00:59:57,012
然后它更新，然后得到 

1176
00:59:55,023 --> 01:00:05,067
的 下一个块 ， 然后 的地址

1177
00:59:57,057 --> 01:00:06,150
只是一直持续到年底好了，所以如何 

1178
01:00:05,067 --> 01:00:08,070
我们用 C正确的，因为做这样的事情

1179
01:00:07,005 --> 01:00:10,080
所有这些假设我做的不 

1180
01:00:08,097 --> 01:00:12,129
持有和C，你不能告诉从一个指针 

1181
01:00:11,025 --> 01:00:19,059
一个上指示器指针可以指向 

1182
01:00:13,029 --> 01:00:27,077
任何地方，所以你可以做的这么大 

1183
01:00:19,059 --> 01:00:29,118
问题是，如果我们得到了一些价值，我们就 

1184
01:00:27,077 --> 01:00:33,083
即使它是一个指针它可以指向 

1185
01:00:30,018 --> 01:00:33,083
权成块的中间 如此 

1186
01:00:34,016 --> 01:00:38,091
鉴于所以首先 我们不知道 

1187
01:00:37,023 --> 01:00:40,116
如果该值 确实是一个指针，它 

1188
01:00:38,091 --> 01:00:41,184
可能仅仅是一个大的整数，但它也 

1189
01:00:41,016 --> 01:00:46,077
可能是已指向指针

1190
01:00:42,084 --> 01:00:48,126
一些数据结构，所以如果它是一个

1191
01:00:46,077 --> 01:00:52,080
指针，我们怎么办，我们怎么找 

1192
01:00:49,026 --> 01:00:55,077
块的开始，使我们能 

1193
01:00:52,008 --> 01:00:57,102
要做的仅仅是假设每个值是 

1194
01:00:55,077 --> 01:00:59,154
指针，然后我们保持平衡 

1195
01:00:58,074 --> 01:01:01,173
树来跟踪 所有分配 

1196
01:01:00,054 --> 01:01:04,128
块，所以每当我们遇到 

1197
01:01:02,073 --> 01:01:07,155
特别是价值，我们将搜索该 

1198
01:01:05,028 --> 01:01:11,034
二叉树，看它是否假设它是 

1199
01:01:08,055 --> 01:01:13,077
一个指针是它属于内的

1200
01:01:11,088 --> 01:01:16,095
开始，分配的一些终端 

1201
01:01:13,077 --> 01:01:18,165
阻止没关系，如果如果条件为真 

1202
01:01:17,058 --> 01:01:20,142
那么我们假设 它指向的是 

1203
01:01:19,065 --> 01:01:23,139
这是一个指向 分配的 块 

1204
01:01:21,042 --> 01:01:25,137
我们假设该块是 

1205
01:01:24,039 --> 01:01:27,108
到达现在它的原因 

1206
01:01:26,037 --> 01:01:28,125
保守是因为它确实可能 

1207
01:01:28,008 --> 01:01:31,011
没有它可能是这个指针 

1208
01:01:29,025 --> 01:01:33,072
整数，我们将我们假设这是一个 

1209
01:01:31,038 --> 01:01:35,136
指针并假定块 

1210
01:01:33,072 --> 01:01:38,076
据称它指向被分配 

1211
01:01:36,036 --> 01:01:40,113
但它实际上可能不会是一个指针

1212
01:01:39,012 --> 01:01:43,044
和它指向该块是 

1213
01:01:41,013 --> 01:01:46,089
垃圾权等什么与此同 

1214
01:01:43,044 --> 01:01:50,142
这个方案我们会留下一些一些非 

1215
01:01:46,089 --> 01:01:52,095
非可达块，我们将指示 

1216
01:01:51,042 --> 01:01:55,130
一些非可达块是 

1217
01:01:53,049 --> 01:01:55,130
真正到达

1218
01:01:56,064 --> 01:02:02,943
好了，所以一旦现在，我们已经有了这个 

1219
01:02:01,359 --> 01:02:07,450
伟大的工具来动态分配 

1220
01:02:03,519 --> 01:02:08,616
内存我们可以在 程序中 使用它 ， 

1221
01:02:07,045 --> 01:02:10,884
拍摄自己在所有的脚

1222
01:02:09,489 --> 01:02:13,494
各种不同的 方式好了，所以我 

1223
01:02:11,289 --> 01:02:16,344
要我要 尽力帮助帮助 

1224
01:02:13,989 --> 01:02:18,910
你在这里通过识别某些 

1225
01:02:16,839 --> 01:02:21,390
危险和陷阱是，我们可以运行

1226
01:02:18,091 --> 01:02:25,113
把 它与内存相关 

1227
01:02:21,039 --> 01:02:29,065
内存操作或操作 和 

1228
01:02:26,013 --> 01:02:34,096
涉及内存歌剧错误错误 

1229
01:02:29,065 --> 01:02:36,984
最坏最坏的类型的bug 尝试 

1230
01:02:34,096 --> 01:02:38,745
找出其原因是， 

1231
01:02:37,569 --> 01:02:42,190
他们在遥远的空间和 时间 

1232
01:02:39,609 --> 01:02:43,650
让我们说你写了错误的 

1233
01:02:42,019 --> 01:02:47,598
内存位置和腐败的一些数据

1234
01:02:44,019 --> 01:02:51,075
结构的权利并不引起任何 

1235
01:02:47,769 --> 01:02:53,769
错误只了解这 意利 

1236
01:02:51,579 --> 01:02:55,450
当您尝试错误权 

1237
01:02:53,769 --> 01:02:56,790
参考该数据结构或 

1238
01:02:55,045 --> 01:02:58,914
的数据结构 的特定部分 

1239
01:02:56,979 --> 01:03:00,984
其可以是在代码的一部分

1240
01:02:59,319 --> 01:03:04,341
这是方式远离正确 的， 

1241
01:03:01,479 --> 01:03:06,460
造成这个问题无论是在你的空间

1242
01:03:04,539 --> 01:03:07,539
知道在远方的你知道的代码行 

1243
01:03:06,046 --> 01:03:08,445
它可能是一个完全不同的 

1244
01:03:07,539 --> 01:03:11,541
功能和 一个完全不同的 

1245
01:03:08,859 --> 01:03:12,945
模块还要及时也可能没有你

1246
01:03:11,739 --> 01:03:16,746
不知道你会做正确的， 然后永世 

1247
01:03:13,719 --> 01:03:18,160
后来其他一些阅读和失败的权利 

1248
01:03:16,809 --> 01:03:19,905
所以这是 一个基本的东西 ， 

1249
01:03:18,016 --> 01:03:25,113
使得内存相关的错误只是这么讨厌 

1250
01:03:20,769 --> 01:03:30,700
另有 一件大事另一件事 

1251
01:03:26,013 --> 01:03:32,068
使他们很难 处理是人们 

1252
01:03:30,007 --> 01:03:33,103
误解和指针的滥用

1253
01:03:32,068 --> 01:03:37,144
右所以通常的错误权是 

1254
01:03:34,066 --> 01:03:40,069
一些是一些或者是误解 

1255
01:03:38,044 --> 01:03:42,118
的指针或不正确初始化

1256
01:03:40,096 --> 01:03:47,715
指针，这一切都归结到这些 

1257
01:03:43,018 --> 01:03:52,557
指针可以的，所以我要 告诉 

1258
01:03:48,579 --> 01:03:55,650
你如何理解指针为好 

1259
01:03:52,719 --> 01:03:55,650
第一次在你的生活 

1260
01:03:55,069 --> 01:04:01,075
我不知道你 ，但 我 

1261
01:03:57,064 --> 01:04:03,115
据悉 CI了解我的指针 

1262
01:04:02,029 --> 01:04:06,031
只知道什么几个不同 

1263
01:04:04,015 --> 01:04:08,098
类型的指针被我做到了 

1264
01:04:06,031 --> 01:04:12,064
通过模式匹配，所以我知道这个 int 

1265
01:04:08,098 --> 01:04:14,149
星p在指向 我知道 一个int 

1266
01:04:12,064 --> 01:04:18,073
这个int星星p在是一个阵列 

1267
01:04:15,049 --> 01:04:21,073
我知道，INT星号键打开支架 

1268
01:04:19,054 --> 01:04:23,146
闭括号也是阵列只是 一个 

1269
01:04:21,073 --> 01:04:27,073
不同的方式来表达 那一场比赛我 

1270
01:04:24,046 --> 01:04:29,065
有指针类型一小撮

1271
01:04:27,073 --> 01:04:31,081
我能对付，但我没有 

1272
01:04:29,065 --> 01:04:32,754
根本的是什么的认识 

1273
01:04:31,081 --> 01:04:35,100
意味着什么 的只是纯粹的模式 

1274
01:04:33,339 --> 01:04:37,340
匹配和 我敢打赌，你就是这样 

1275
01:04:35,829 --> 01:04:39,190
你这样做太 

1276
01:04:37,349 --> 01:04:40,397
好的 ，但是这一切都将改变 

1277
01:04:39,019 --> 01:04:44,448
今天 

1278
01:04:40,829 --> 01:04:47,140
没事如此，才能真正 

1279
01:04:44,619 --> 01:04:50,290
了解指针你需要 

1280
01:04:47,014 --> 01:04:53,089
了解各种优先

1281
01:04:50,029 --> 01:04:55,090
在C运算因为指针类型 

1282
01:04:53,089 --> 01:04:58,171
使用这些运营商都宣布和 

1283
01:04:55,009 --> 01:05:02,448
所以我的K和R其副本有一个折角 

1284
01:04:59,071 --> 01:05:05,113
在53页的这张表 来自53页 

1285
01:05:03,339 --> 01:05:09,630
KNR的，你应该有一个 文件夹 

1286
01:05:06,013 --> 01:05:13,090
或具有折叠以供参考 

1287
01:05:09,063 --> 01:05:15,139
现在要注意的一点是，函数 

1288
01:05:13,009 --> 01:05:17,928
和数组，然后和这些结构 

1289
01:05:16,039 --> 01:05:22,095
这些不同的结构运营商具备

1290
01:05:18,819 --> 01:05:26,230
最高 优先级最高优先级 和 

1291
01:05:22,095 --> 01:05:27,264
这一点，那么，再接一元 

1292
01:05:26,023 --> 01:05:30,094
所以运营商的明星，这是 

1293
01:05:28,119 --> 01:05:34,690
引用操作，然后将 

1294
01:05:30,094 --> 01:05:38,122
这些运营商中有他们的地址 

1295
01:05:34,069 --> 01:05:41,958
落在下方的最高最高 

1296
01:05:39,022 --> 01:05:44,077
优先级运营商，然后二进制

1297
01:05:42,579 --> 01:05:47,579
为了 在 使用运营商的版本

1298
01:05:44,077 --> 01:05:50,098
算术运算是低于

1299
01:05:47,579 --> 01:05:56,320
好了，只记得函数 

1300
01:05:50,098 --> 01:05:59,182
数组比明星更高好吗

1301
01:05:56,032 --> 01:06:02,116
是做现在取消引用伟大

1302
01:06:00,082 --> 01:06:04,168
关于指针虽然他们的事 

1303
01:06:03,016 --> 01:06:08,110
似乎总是很复杂 的是， 

1304
01:06:05,068 --> 01:06:11,116
有有一个算法，它 

1305
01:06:09,001 --> 01:06:13,096
还有一种构造的算法 

1306
01:06:12,016 --> 01:06:17,028
英语句子 正好 说明 

1307
01:06:14,005 --> 01:06:21,052
什么什么是指针什么 

1308
01:06:17,028 --> 01:06:22,126
指针 的定义是指行和 

1309
01:06:21,052 --> 01:06:27,061
如果你有兴趣它在 KN是 

1310
01:06:23,026 --> 01:06:31,033
5.1节-但我会我会解释 

1311
01:06:27,061 --> 01:06:32,062
它现在现在我不知道，我不 

1312
01:06:31,033 --> 01:06:34,108
知道 你 有多少在 这个类 中 去 

1313
01:06:32,062 --> 01:06:35,140
记得不错，但我向你保证 

1314
01:06:35,008 --> 01:06:40,062
你要记住这为天 

1315
01:06:36,004 --> 01:06:40,026
你终于明白了指针好了， 

1316
01:06:42,009 --> 01:06:47,098
好吧 所以这里的它是如何运作的 ，你 

1317
01:06:44,004 --> 01:06:50,098
始终启动它，这是一个定义 

1318
01:06:47,098 --> 01:06:55,107
指针 某种你总是 启动 

1319
01:06:51,034 --> 01:06:55,107
变量名称 

1320
01:07:00,002 --> 01:07:04,065
然后你用你的优先级，然后 

1321
01:07:02,094 --> 01:07:05,172
你看运营商的两边 

1322
01:07:04,065 --> 01:07:08,150
你选择维里的变量名 

1323
01:07:06,072 --> 01:07:12,087
具有最高 优先级的一个 

1324
01:07:09,005 --> 01:07:17,052
好了，所以我们先从变量，所以我们 

1325
01:07:12,087 --> 01:07:18,090
说T 是接下来我们来看看 左， 

1326
01:07:17,097 --> 01:07:20,103
没有什么是 对的权利 

1327
01:07:19,017 --> 01:07:25,050
但有一个有一个指针符号 

1328
01:07:21,003 --> 01:07:27,039
向左所以我们 说 t 是一个指针， 

1329
01:07:25,005 --> 01:07:28,089
没有什么更多的，然后我们始终 

1330
01:07:27,039 --> 01:07:34,121
结束了 的东西的类型 

1331
01:07:29,034 --> 01:07:34,121
它指出，如此P是一个指针为int 

1332
01:07:43,003 --> 01:07:50,092
像的Sookie是P作为指针一些到 

1333
01:07:48,091 --> 01:07:52,147
在内存的整数好了 ，所以大家都 

1334
01:07:50,092 --> 01:07:55,120
知道，一说是很 容易 没关系 

1335
01:07:53,047 --> 01:07:57,054
你可能已经 对下 一个是什么

1336
01:07:56,002 --> 01:08:01,006
看到这样的事情 

1337
01:07:58,017 --> 01:08:05,029
某些程序中声明使用此我们ð 

1338
01:08:01,024 --> 01:08:11,026
符号所以这个你可以有一个 

1339
01:08:05,029 --> 01:08:15,037
可选的大小或并非 如此，所以我们总是 

1340
01:08:11,026 --> 01:08:16,090
开始时我们说T 是现在好了在这个 

1341
01:08:15,037 --> 01:08:17,044
万一有公司运营的左侧和 

1342
01:08:16,009 --> 01:08:18,028
正确的 

1343
01:08:17,044 --> 01:08:21,121
记得数组运算符具有较高

1344
01:08:19,009 --> 01:08:23,107
优先级高于该 

1345
01:08:22,021 --> 01:08:29,080
对其操作的指针 

1346
01:08:24,007 --> 01:08:35,092
运营商所以我们说所以T是阵列 13 

1347
01:08:29,008 --> 01:08:38,014
尺寸13的阵列所以没有什么 

1348
01:08:35,092 --> 01:08:44,169
更使我们去指针的左边，这样 

1349
01:08:39,004 --> 01:08:45,033
T是一个指针数组13到端部

1350
01:08:49,929 --> 01:09:04,933
所以t是 每13个指针 的数组 

1351
01:09:00,044 --> 01:09:06,092
它指向该结束的权利 

1352
01:09:05,329 --> 01:09:12,020
情况P 就是这样 的名字 

1353
01:09:06,092 --> 01:09:12,188
阵列所以默认 字节 P P是是 

1354
01:09:12,002 --> 01:09:16,261
当量是 数组 的地址 

1355
01:09:13,088 --> 01:09:17,737
当你引用 你是 一个数组名 

1356
01:09:16,279 --> 01:09:20,302
你是 你在解决您 主动 

1357
01:09:18,529 --> 01:09:26,587
穿衣第一的地址

1358
01:09:20,509 --> 01:09:28,543
元素好吗怎么样在这里下单 

1359
01:09:27,109 --> 01:09:31,114
我们是如果我们把周围的括号

1360
01:09:28,849 --> 01:09:33,770
接下来的事情，我们可以明确的很好，而且 

1361
01:09:31,159 --> 01:09:36,178
这 是一个很好的做法，让我们在这里是 

1362
01:09:33,077 --> 01:09:39,646
说T和我们来看看 这个 

1363
01:09:36,349 --> 01:09:43,040
第一因为 括号 所以T是 

1364
01:09:40,339 --> 01:09:44,404
指针数组13以 端部，从而 

1365
01:09:43,004 --> 01:09:46,143
这是同样的事情 ，在这里我们是 

1366
01:09:44,989 --> 01:09:51,064
只是被更明确 

1367
01:09:46,179 --> 01:09:56,233
现在关注的明星一T因此P是什么 

1368
01:09:51,739 --> 01:10:00,070
指针的指针为int好了， 

1369
01:09:56,719 --> 01:10:00,070
这是一个不同类型的数组 

1370
01:10:01,036 --> 01:10:15,097
所以P是一个指针 的指针 结束 

1371
01:10:09,081 --> 01:10:20,098
很好，而且和一般，所以这是 

1372
01:10:15,097 --> 01:10:22,146
另一种方式做到加薪 所以同样 

1373
01:10:20,098 --> 01:10:27,103
这样的炭星点为一个字符串

1374
01:10:23,046 --> 01:10:30,058
这本可以指向它指向它 

1375
01:10:28,048 --> 01:10:32,095
指向了一个指针，但那么你就可以 

1376
01:10:30,058 --> 01:10:40,087
上， 这些中的每一个索引VEN 

1377
01:10:32,095 --> 01:10:45,127
点对应于指针哎呦

1378
01:10:40,087 --> 01:10:46,093
还好这里的另一个现在 一个 P，因为 

1379
01:10:46,027 --> 01:10:50,086
因为括号的 ，我们有 

1380
01:10:47,047 --> 01:10:56,140
向左走所以P是一个指针 数组 

1381
01:10:50,086 --> 01:11:02,172
印象数的13行，从而P 不是 指针 

1382
01:10:57,004 --> 01:11:03,036
的 13英寸 的阵列 

1383
01:11:10,062 --> 01:11:19,090
现在好了这个怎么样 

1384
01:11:13,041 --> 01:11:23,047
f是函数或者是一个功能或 

1385
01:11:19,009 --> 01:11:27,012
指针F是因为正确的函数

1386
01:11:24,001 --> 01:11:32,095
的优先，因此f 是 F是函数 

1387
01:11:27,093 --> 01:11:38,179
返回指针为int好了，所以如果我们 

1388
01:11:32,095 --> 01:11:44,139
去，如果我们去P等于˚F那么回报 

1389
01:11:39,079 --> 01:11:44,085
该初始化p来指向一些INT 

1390
01:11:48,076 --> 01:11:55,153
没事，我要 做到这一点一个 

1391
01:11:53,006 --> 01:11:58,097
让我们跳下来的时间关系 

1392
01:11:56,053 --> 01:12:00,136
完全荒谬的情况下， 只是让你可以 

1393
01:11:58,097 --> 01:12:06,143
看到这个算法的工作 

1394
01:12:01,036 --> 01:12:15,044
所有 权利，使X是一个指针数组 

1395
01:12:07,043 --> 01:12:19,097
在返回 指针到一个 功能 

1396
01:12:16,016 --> 01:12:22,082
阵列五个 事件，如果你曾经使用 

1397
01:12:19,097 --> 01:12:26,105
类似 的事情在你的 代码 的耻辱 

1398
01:12:22,082 --> 01:12:27,173
你没事吧所以 你去 

1399
01:12:27,005 --> 01:12:30,014
所以这就是现在你已经知道你 

1400
01:12:28,073 --> 01:12:33,074
明白最简单的指针可以 和 

1401
01:12:30,095 --> 01:12:36,095
你需要的是 KNR 的53页 是 

1402
01:12:33,074 --> 01:12:37,136
便利的参考没事所以让我们 

1403
01:12:36,095 --> 01:12:40,142
采取最后五 分钟 ，我会告诉 

1404
01:12:38,036 --> 01:12:43,088
你有的一些 可以跳闸方式 

1405
01:12:41,042 --> 01:12:46,061
你自己了，当你访问内存 

1406
01:12:43,088 --> 01:12:47,093
好了，首先它是一个典型的错误的scanf 

1407
01:12:46,061 --> 01:12:49,142
你可能只是可能都做到了这一点 

1408
01:12:48,038 --> 01:12:54,071
在那里你忘了默契地址 

1409
01:12:50,042 --> 01:12:57,077
一个变量，而不是给它传递 

1410
01:12:54,071 --> 01:13:03,137
地址，以便scanf函数不知道在哪里 

1411
01:12:57,077 --> 01:13:05,102
把你知道把把数据确定 

1412
01:13:04,037 --> 01:13:07,109
另一另一个常见的错误是 

1413
01:13:06,002 --> 01:13:09,050
读未初始化的内存，所以你不能 

1414
01:13:08,009 --> 01:13:13,016
真以为你的堆数据 

1415
01:13:09,005 --> 01:13:16,070
初始化为零所以在这里我们是我们 

1416
01:13:13,079 --> 01:13:17,126
马拉奇int的数组，然后 

1417
01:13:17,015 --> 01:13:21,086
我们正在经历，我们正在 做的 

1418
01:13:18,026 --> 01:13:24,050
我们在这个向量这个 ÿ更新

1419
01:13:21,086 --> 01:13:27,101
矢量我们正在阅读 YI 

1420
01:13:24,005 --> 01:13:31,022
我们正在采取Ÿ这就是为什么我等于 易加 

1421
01:13:28,001 --> 01:13:35,056
一IJ倍XJ 好了，所以我们使用了我们 

1422
01:13:31,067 --> 01:13:37,148
假设是Y确定malloc回报 

1423
01:13:35,056 --> 01:13:40,069
内存是所有 零， 这样 会得到 

1424
01:13:38,048 --> 01:13:40,069
您

1425
01:13:42,028 --> 01:13:47,080
它也很容易分配错误

1426
01:13:45,013 --> 01:13:53,071
大小的物体所以在这里我们 要创建 

1427
01:13:47,008 --> 01:13:55,105
n个指针 的端指针数组

1428
01:13:53,071 --> 01:13:58,114
到结束好，然后为每 一个我们 

1429
01:13:56,077 --> 01:14:00,115
要分配 时间在 没事所以这 

1430
01:13:59,014 --> 01:14:06,108
工作中，我们要创建一个二维 

1431
01:14:01,015 --> 01:14:06,108
数组，你可以看到的错误， 

1432
01:14:09,026 --> 01:14:21,054
该线是越野车这一个这一个或 

1433
01:14:18,009 --> 01:14:24,042
这其中的第 一个 正确的，因为 我们 

1434
01:14:21,054 --> 01:14:25,107
真想大小事件是对如此

1435
01:14:24,042 --> 01:14:28,053
我们是我们的错误错误

1436
01:14:26,007 --> 01:14:33,084
假设intz是尺寸为相同的

1437
01:14:28,053 --> 01:14:35,058
三分球，这是对这个经典 

1438
01:14:33,084 --> 01:14:37,086
假设是真对32位 代码和 

1439
01:14:36,003 --> 01:14:40,080
指针的大小相同，但它不是 

1440
01:14:38,004 --> 01:14:43,050
真正的64位，因此这就是为什么当 

1441
01:14:40,008 --> 01:14:46,020
当您端口时， 人口 

1442
01:14:43,005 --> 01:14:48,009
32位代码，以64位机 很多 

1443
01:14:46,092 --> 01:14:52,104
次它打破了，因为他们有这 

1444
01:14:48,054 --> 01:14:56,106
假设确定另一种方式可以很容易地 

1445
01:14:53,004 --> 01:14:59,052
所以在这里我们要创建覆盖内存

1446
01:14:57,006 --> 01:15:01,625
正确地创建此数组 但随后 

1447
01:14:59,052 --> 01:15:04,128
当我们创建各 各的 

1448
01:15:01,679 --> 01:15:07,080
子阵列的代替我小于 或 

1449
01:15:05,028 --> 01:15:08,100
等于 n 我们实际上只是我们 

1450
01:15:07,008 --> 01:15:10,083
创造这些东西n，而是我们 

1451
01:15:09,000 --> 01:15:12,081
遍历因为 这款 N加1 

1452
01:15:10,083 --> 01:15:16,140
教训是相等的 ，所以这是一个经典 

1453
01:15:12,081 --> 01:15:18,135
关闭的一个错误OK另一另一 

1454
01:15:17,004 --> 01:15:20,723
问题你的代码看到它 

1455
01:15:19,035 --> 01:15:24,042
从你的攻击实验室注入攻击 

1456
01:15:21,119 --> 01:15:27,650
不检查缓冲区的大小，以便 

1457
01:15:24,042 --> 01:15:30,134
处获得的就是一个典型的 例子 

1458
01:15:27,065 --> 01:15:30,134
这样就会让你陷入 困境 

1459
01:15:31,083 --> 01:15:35,088
另又一个经典的错误是

1460
01:15:33,009 --> 01:15:41,024
误解指针运算全部 

1461
01:15:36,033 --> 01:15:44,040
正确因此，如果 您增量指针则 

1462
01:15:42,005 --> 01:15:47,100
它点通过的大小递增 

1463
01:15:45,003 --> 01:15:50,612
该对象指针指向权

1464
01:15:48,000 --> 01:15:53,006
所以，如果你通过一个递增的 int 星级 

1465
01:15:50,639 --> 01:15:57,050
它实际上增加4它

1466
01:15:53,006 --> 01:15:56,105
因为这是一个int的大小 

1467
01:15:57,062 --> 01:16:03,104
得到了这是一个非常重要的 

1468
01:15:59,033 --> 01:16:05,129
区别等人经常因此在这里 

1469
01:16:04,004 --> 01:16:08,048
它假定递增因此P是 

1470
01:16:06,029 --> 01:16:09,128
指针和这里的程序员 

1471
01:16:08,048 --> 01:16:12,083
假定他要递增 

1472
01:16:10,028 --> 01:16:14,042
指针排序遍历数组所以 

1473
01:16:12,083 --> 01:16:17,120
他他不明白指针 

1474
01:16:14,042 --> 01:16:21,059
算术等得到下 一个中 

1475
01:16:18,002 --> 01:16:23,069
按大小事件增加P 好吧，这 

1476
01:16:21,059 --> 01:16:28,142
真的会十六个不会递增它

1477
01:16:23,087 --> 01:16:31,172
不过 四和好压倒一切的记忆 ，这是一个 

1478
01:16:29,042 --> 01:16:34,091
真是可恶之一，很多 时候，这 

1479
01:16:32,072 --> 01:16:38,087
如果你不明白的可以发生 

1480
01:16:34,091 --> 01:16:40,115
的运营商的优先级是 

1481
01:16:38,087 --> 01:16:41,150
你的工作有 ，所以这 是一个热 

1482
01:16:41,015 --> 01:16:43,022
不是没有那种堆 ，我们已经 

1483
01:16:42,005 --> 01:16:45,092
谈到但 哦堆数据 

1484
01:16:43,085 --> 01:16:47,123
结构，这是 一个，这是一个 

1485
01:16:46,037 --> 01:16:49,073
函数从该热删除

1486
01:16:48,023 --> 01:16:54,095
其实从我自己的代码，我有 

1487
01:16:49,073 --> 01:16:58,121
承认，所以我想 LEET我想 

1488
01:16:54,095 --> 01:17:00,128
删除元素我要删除 

1489
01:16:59,021 --> 01:17:03,116
堆的第一元件右侧，然后 

1490
01:17:01,028 --> 01:17:05,114
我要重新加热砸进好了，所以我 

1491
01:17:04,016 --> 01:17:08,093
然后我想回到我 想 

1492
01:17:06,014 --> 01:17:14,060
返回所以II获得的第一个元素 

1493
01:17:08,093 --> 01:17:16,142
堆 我该 堆的大小 或 

1494
01:17:14,006 --> 01:17:22,088
我把最后一个元素，并作出这样的 

1495
01:17:17,042 --> 01:17:25,076
第一个元素，而现在我想 

1496
01:17:23,042 --> 01:17:27,113
减少热量，因为大小 

1497
01:17:25,076 --> 01:17:30,122
此删除操作将删除

1498
01:17:28,013 --> 01:17:33,107
通过一个堆大小，以便通知我们在这里

1499
01:17:31,022 --> 01:17:35,120
通过大小n作为一个指针，并且当该 

1500
01:17:34,007 --> 01:17:37,076
当此功能终止时 

1501
01:17:36,002 --> 01:17:40,094
函数返回 的大小应 更新 

1502
01:17:37,076 --> 01:17:41,114
指针的大小过时的值，该值 

1503
01:17:41,012 --> 01:17:44,093
它指向你应该递减 

1504
01:17:42,014 --> 01:17:46,067
还好这是我们的目的 ，我们做 

1505
01:17:44,093 --> 01:17:47,099
这里有大小减去减 

1506
01:17:46,067 --> 01:17:51,146
明星所以我们想要做的是，我们要 

1507
01:17:48,053 --> 01:17:57,125
非关联尺寸，然后递减 该 

1508
01:17:52,046 --> 01:18:01,088
值，但因为一元减减 

1509
01:17:58,025 --> 01:18:04,043
具有比则更高的优先级

1510
01:18:01,088 --> 01:18:06,107
提领我们真正做的是 

1511
01:18:04,043 --> 01:18:08,138
我们正在递减的指针，然后 

1512
01:18:07,007 --> 01:18:14,075
被引用这就是价值

1513
01:18:09,038 --> 01:18:16,109
一个字比我们规模可变减去所有 

1514
01:18:14,075 --> 01:18:20,254
右所以这些都是讨厌的， 它会 

1515
01:18:17,009 --> 01:18:23,084
已经干净多了，如果我只是把 

1516
01:18:20,929 --> 01:18:27,770
括号周围像我 刚 打算 

1517
01:18:23,084 --> 01:18:28,109
括号星 大小 括号所有 

1518
01:18:27,077 --> 01:18:30,152
正确的另一个另一种方式，你可以乱 

1519
01:18:29,009 --> 01:18:33,092
最多是引用忘记本地 

1520
01:18:31,052 --> 01:18:35,126
变量消失，所以如果你有一个

1521
01:18:33,092 --> 01:18:38,177
函数返回的地址 

1522
01:18:36,026 --> 01:18:42,385
局部变量没有好 还好一点好处 

1523
01:18:39,077 --> 01:18:44,156
所有这可能是好的一段 时间，直到 

1524
01:18:42,619 --> 01:18:47,960
有人另一个功能是重用

1525
01:18:45,056 --> 01:18:49,735
空间也可以是返回地址是 

1526
01:18:47,096 --> 01:18:54,985
可能是另一个另一个地方的功能

1527
01:18:50,239 --> 01:18:57,590
可变另一个可怕的错误那是 

1528
01:18:55,849 --> 01:19:00,530
一个非常糟糕的 一个被释放的块 

1529
01:18:57,059 --> 01:19:01,918
现在您从多个知道时间

1530
01:19:00,053 --> 01:19:04,492
现在你的理解为 是 的malloc 

1531
01:19:02,449 --> 01:19:06,478
免费其实写到 堆 权 

1532
01:19:04,969 --> 01:19:09,980
它凝聚它的变化指针

1533
01:19:06,739 --> 01:19:11,750
它改变大小的块大小，所以如果你 

1534
01:19:09,098 --> 01:19:16,127
免费这已经被释放的块 

1535
01:19:11,075 --> 01:19:18,274
可怕的事情会发生 另一 

1536
01:19:17,027 --> 01:19:20,206
你可以做错误的事情就是 引用 

1537
01:19:18,949 --> 01:19:22,190
阻止你 忘了，你释放块 

1538
01:19:20,449 --> 01:19:24,514
然后 你引用它 因此在这里我们 

1539
01:19:22,019 --> 01:19:28,115
免费这个块X的，然后我们

1540
01:19:25,099 --> 01:19:31,610
这里引用它的另一个另一大 

1541
01:19:29,015 --> 01:19:34,073
问题是内存泄漏所以未能 

1542
01:19:31,061 --> 01:19:36,107
空闲块所以分配的一些块

1543
01:19:34,073 --> 01:19:37,148
函数，然后返回该块 

1544
01:19:37,007 --> 01:19:40,806
将永远呆在那里正确的，因为 

1545
01:19:38,048 --> 01:19:40,437
这是垃圾

1546
01:19:42,058 --> 01:19:47,083
好了，有一个有 许多 

1547
01:19:45,062 --> 01:19:49,411
方法来处理内存错误是GDB 

1548
01:19:47,083 --> 01:19:51,170
有时好，至少它会告诉你 

1549
01:19:49,969 --> 01:19:55,160
其中赛格故障发生，然后你得 

1550
01:19:52,007 --> 01:19:58,043
追查什么是正确的，诸如此类的 

1551
01:19:55,016 --> 01:20:01,088
引起的赛格故障的最好的事情 你 

1552
01:19:59,006 --> 01:20:04,100
可以做，但GDB倒下时 

1553
01:20:01,088 --> 01:20:05,089
你做复杂的操作

1554
01:20:05,000 --> 01:20:08,018
数据结构 

1555
01:20:05,089 --> 01:20:09,110
它只是简单的排序寻找一个 

1556
01:20:08,018 --> 01:20:12,077
同时指令你真的 

1557
01:20:10,001 --> 01:20:15,007
需要做的是找出任何 复杂的数据 

1558
01:20:12,077 --> 01:20:16,139
像例如堆结构是 

1559
01:20:15,016 --> 01:20:18,107
确定 不变性 为结构 

1560
01:20:17,039 --> 01:20:21,388
该数据结构 要经常 

1561
01:20:19,007 --> 01:20:23,105
维护和那么你就写一个函数 

1562
01:20:21,739 --> 01:20:25,850
了在该结构 是 迭代 

1563
01:20:24,005 --> 01:20:28,070
数据结构，并且检查所有 这些 

1564
01:20:25,085 --> 01:20:32,117
变量是真如此，例如在它 

1565
01:20:28,007 --> 01:20:35,018
和分配器不变性之一 

1566
01:20:33,017 --> 01:20:37,043
是不应该有应该有 

1567
01:20:35,081 --> 01:20:39,104
永远是两个连续的自由块

1568
01:20:37,043 --> 01:20:41,078
右所以你对你的一致性检查

1569
01:20:40,004 --> 01:20:46,006
应该通过热量，并确保 

1570
01:20:41,078 --> 01:20:47,084
有没有不连续的空闲块或

1571
01:20:46,006 --> 01:20:50,014
另一个不变的是，每一个免费

1572
01:20:48,038 --> 01:20:52,106
块应该是一个自由的地方名单 

1573
01:20:50,014 --> 01:20:54,107
右所以你会，你会，你 会 

1574
01:20:53,006 --> 01:20:56,012
您的一致性检查程序将扫描

1575
01:20:55,007 --> 01:20:58,064
堆计数的空闲块的数目

1576
01:20:56,066 --> 01:20:59,162
然后扫描空闲列表和使 

1577
01:20:58,064 --> 01:21:01,073
确保在块数 

1578
01:21:00,062 --> 01:21:04,079
空闲列表相同的数 

1579
01:21:02,054 --> 01:21:05,117
空闲块好了，所以这个想法的 

1580
01:21:04,079 --> 01:21:06,176
一致性检查的东西，你会

1581
01:21:06,017 --> 01:21:09,098
在你的malloc实验室使用，但它的 

1582
01:21:07,076 --> 01:21:11,078
东西它也是东西你 应该 

1583
01:21:09,098 --> 01:21:14,189
每当你更新你应该使用

1584
01:21:11,096 --> 01:21:17,120
任何种类的复杂的数据结构，并 

1585
01:21:15,089 --> 01:21:18,170
在你了解 的valgrind 但 

1586
01:21:18,002 --> 01:21:22,070
这些深跳棋伟大的事情 

1587
01:21:19,007 --> 01:21:25,010
我热爱热跳棋或 

1588
01:21:22,088 --> 01:21:27,089
一致性跳棋这是一个非常 

1589
01:21:26,000 --> 01:21:30,092
关于他们强大的东西是 你写的 

1590
01:21:27,089 --> 01:21:31,918
他们默默运行不打印 

1591
01:21:30,092 --> 01:21:35,165
任何东西，除非 他们发现 一个 

1592
01:21:32,719 --> 01:21:38,570
不变量的侵犯，如果你写 

1593
01:21:36,065 --> 01:21:40,088
您的 一致性检查这样便 

1594
01:21:38,057 --> 01:21:43,079
你可以使用它 像一个探头，使您的 

1595
01:21:40,088 --> 01:21:44,162
程序崩溃，所以你 如果用 做 

1596
01:21:43,079 --> 01:21:48,778
这堆检查做二进制搜索 

1597
01:21:45,062 --> 01:21:51,109
事业隔离，所以你知道你把 

1598
01:21:49,489 --> 01:21:54,920
你把你的堆在这里检查 

1599
01:21:52,009 --> 01:21:55,034
一切都没有问题，再后来的 

1600
01:21:54,092 --> 01:21:56,165
程序 

1601
01:21:55,034 --> 01:22:01,040
崩溃的所以现在你坚持的协 

1602
01:21:57,065 --> 01:22:03,904
检查器在这里，现在我崩溃 协 

1603
01:22:01,004 --> 01:22:06,029
检查发现违反，所以你 

1604
01:22:04,489 --> 01:22:07,760
知道问题是这里的某个地方 

1605
01:22:06,065 --> 01:22:09,131
你可以只保留缩小 下来 

1606
01:22:07,076 --> 01:22:11,153
因此它就像一个探头手术探头 

1607
01:22:10,031 --> 01:22:16,570
你可以用它来追踪错误

1608
01:22:12,053 --> 01:22:17,150
所以，如果你这样做就像是我 

1609
01:22:16,849 --> 01:22:21,882
不知道任何人 现在 怎么 样 调试 

1610
01:22:18,005 --> 01:22:21,684
没有这种 工具 

1611
01:22:24,021 --> 01:22:31,118
好了，这就是它 今天有 一个好 

1612
01:22:28,008 --> 01:22:31,046
周末，我们会看到你在星期二

