1
00:00:00,000 --> 00:00:05,085
我们仍然通过苦读

2
00:00:02,179 --> 00:00:08,790
在机器语言材料 

3
00:00:05,085 --> 00:00:10,124
这是 我对你前面谈过，我认为 

4
00:00:08,079 --> 00:00:12,141
在某些方面这门课程的核心 

5
00:00:10,889 --> 00:00:16,710
那么多剩下的材料构建 

6
00:00:13,041 --> 00:00:20,049
在，希望你们都过 

7
00:00:16,071 --> 00:00:22,107
机会来看看实验室-和你的 炸弹 

8
00:00:20,049 --> 00:00:25,080
实验室，你已经得到了开始对

9
00:00:23,007 --> 00:00:27,012
当然你的时间是 

10
00:00:25,008 --> 00:00:29,013
从今天的材料完成

11
00:00:27,057 --> 00:00:32,130
你会很好的 方式解决 

12
00:00:30,003 --> 00:00:36,014
所有，但最后一个阶段或两阶段 

13
00:00:33,003 --> 00:00:38,085
炸弹的网络，所以我强烈建议 您 

14
00:00:36,041 --> 00:00:43,370
让事情，不是把它摘下来的 

15
00:00:39,012 --> 00:00:48,131
最后一分钟 左右，我们正在谈论 

16
00:00:43,739 --> 00:00:50,070
今天的程序是如何进行的 

17
00:00:48,239 --> 00:00:50,303
我将使用相同的术语 

18
00:00:50,007 --> 00:00:54,036
这里

19
00:00:50,879 --> 00:00:56,730
无论它是一个功能的程序或 

20
00:00:54,036 --> 00:00:58,985
一个面向对象的程序设计的方法 

21
00:00:56,073 --> 00:01:00,102
这些都是大致 相同的事情， 

22
00:00:59,309 --> 00:01:03,361
我们将谈论覆盖上

23
00:01:01,002 --> 00:01:03,811
总体 

24
00:01:09,024 --> 00:01:16,027
我还将提到在一开始的 

25
00:01:13,015 --> 00:01:17,104
这个方法在程序处理

26
00:01:16,027 --> 00:01:21,046
我们将谈论 今天是 

27
00:01:18,004 --> 00:01:24,100
实际x86硬件的组合 

28
00:01:21,046 --> 00:01:26,101
以及它如何支持它，而且在一些 

29
00:01:25,000 --> 00:01:30,009
方法更重要的是一组

30
00:01:27,001 --> 00:01:32,095
所 开发的 该公约 

31
00:01:30,009 --> 00:01:36,045
基本上每个人都同意，它是 

32
00:01:32,095 --> 00:01:38,131
被称为ABI 这就是为什么我要 

33
00:01:36,045 --> 00:01:50,122
木代表的应用程序二进制 

34
00:01:39,031 --> 00:01:54,130
接口这样的想法是文档

35
00:01:51,022 --> 00:01:58,084
你可以得到它在网上是和它的

36
00:01:55,003 --> 00:02:01,030
在书中引用它的文档 

37
00:01:58,084 --> 00:02:04,117
人们放在一起 的初始版本 

38
00:02:01,057 --> 00:02:07,105
当第一86 64 机器名 

39
00:02:05,017 --> 00:02:10,084
第一正在开发和具体地 

40
00:02:08,005 --> 00:02:15,022
适用于Linux，他们说好了所有的Linux 

41
00:02:10,084 --> 00:02:16,141
程序，所有的编译器 的所有 

42
00:02:15,022 --> 00:02:20,035
操作系统的所有不同部分

43
00:02:17,041 --> 00:02:22,069
这需要有一些系统的

44
00:02:20,035 --> 00:02:25,054
如何管理共识 

45
00:02:22,069 --> 00:02:28,131
机器上的资源会同意 

46
00:02:25,054 --> 00:02:31,105
坚持 这套规则，所以它 

47
00:02:29,031 --> 00:02:34,048
它超越了实际的东西 

48
00:02:32,005 --> 00:02:37,009
硬件确实给一套软件 

49
00:02:34,048 --> 00:02:38,062
标准，这就是所谓 的应用 

50
00:02:37,009 --> 00:02:40,087
二进制接口，因为它是

51
00:02:38,062 --> 00:02:42,114
特别是在该接口 

52
00:02:40,087 --> 00:02:45,178
机器级 机器语言 

53
00:02:43,014 --> 00:02:49,015
本机程序级别等这 

54
00:02:46,078 --> 00:02:50,161
我们会在今天覆盖这样的人 

55
00:02:49,015 --> 00:02:53,047
问那种好，你 知道是谁弥补 

56
00:02:51,061 --> 00:02:54,103
这些规则 和事物和观点是 

57
00:02:53,047 --> 00:02:57,085
还有的是，这样做的一个工作组 

58
00:02:55,003 --> 00:03:00,462
并有 针对 Windows 单独 ABI 

59
00:02:57,085 --> 00:03:03,474
这是相似但不相同 

60
00:03:00,489 --> 00:03:08,560
还有的 OSX 苹果单独ABI 

61
00:03:04,239 --> 00:03:11,560
甚至FreeBSD下的不同变种 

62
00:03:08,056 --> 00:03:13,132
类似Unix的操作系统都有自己的 

63
00:03:11,056 --> 00:03:18,057
ABI，他们都在共同分享了很多

64
00:03:14,032 --> 00:03:18,066
但一些细节上有所不同

65
00:03:19,054 --> 00:03:23,153
所以，如果你想想在继续 

66
00:03:22,055 --> 00:03:26,141
程序甚至用C这是一个 

67
00:03:24,053 --> 00:03:30,592
在相对简单的语言

68
00:03:27,041 --> 00:03:32,045
很多方面还有很多事情等 

69
00:03:31,069 --> 00:03:34,880
这是值得打破那些和 

70
00:03:32,081 --> 00:03:36,167
思考它一个是有 一个 

71
00:03:34,088 --> 00:03:39,164
控制的概念，所以在我的例子中， 我 

72
00:03:37,067 --> 00:03:44,116
显示步骤P调用一个方法Q

73
00:03:40,064 --> 00:03:47,141
所以当P调用Q时发生后来不知怎的 

74
00:03:45,016 --> 00:03:51,095
该方案具有 跳下 ，并开始 

75
00:03:48,041 --> 00:03:55,046
执行所述的代码Q上的线

76
00:03:51,095 --> 00:03:57,173
然后当Q达到其出口点 是 

77
00:03:55,091 --> 00:04:00,098
不知何故退回的一点 是要回 

78
00:03:58,073 --> 00:04:03,862
P和不只是任何老地方P中，但 

79
00:04:01,061 --> 00:04:07,073
专门不管它来到自带 

80
00:04:04,519 --> 00:04:09,980
在P 中的通话至Q之后使 

81
00:04:07,073 --> 00:04:11,084
不知何故，我们必须 记录 

82
00:04:09,098 --> 00:04:13,133
哪里的返回信息 

83
00:04:11,084 --> 00:04:15,181
应该是能够返回到 

84
00:04:14,033 --> 00:04:20,048
正确的地方所以这是首先的

85
00:04:16,081 --> 00:04:21,119
将控制传递给功能 ，并且具有 

86
00:04:20,048 --> 00:04:25,072
该函数返回回到它 

87
00:04:22,019 --> 00:04:29,057
回过头来看看我们的第二个丢失数据 

88
00:04:25,072 --> 00:04:31,076
我们怎样才能操作数也因此，在此 

89
00:04:29,057 --> 00:04:33,143
特定情况下，Q 是一个函数，它 

90
00:04:32,012 --> 00:04:37,049
需要 它调用一个参数 

91
00:04:34,043 --> 00:04:39,137
在内部调用和 我 在这里哪里 

92
00:04:37,049 --> 00:04:43,097
p被称之为它的传递一定的价值 

93
00:04:40,037 --> 00:04:47,039
p称为X内，以某种方式驼背那 

94
00:04:43,097 --> 00:04:49,133
X的数据值必须被记录在一个 

95
00:04:47,039 --> 00:04:54,068
形成内e它可以访问 

96
00:04:50,033 --> 00:04:58,040
该信息 并且类似地当q 

97
00:04:54,068 --> 00:05:00,101
要返回一个值备份，然后 

98
00:04:59,003 --> 00:05:03,031
P将使用该值的存在

99
00:05:01,001 --> 00:05:08,012
要怎么该数据的一些约定

100
00:05:03,031 --> 00:05:11,113
被传递回，最后 

101
00:05:08,012 --> 00:05:15,074
在功能可能有一些本地数据 

102
00:05:12,013 --> 00:05:18,112
这需要一定量的分配 

103
00:05:15,074 --> 00:05:19,115
的空间，那么，这是否空间 

104
00:05:18,229 --> 00:05:23,060
获得分配我们如何确保 它 

105
00:05:20,015 --> 00:05:25,015
被适当地分配特别是在 

106
00:05:23,006 --> 00:05:28,100
C作为你知道当一个函数返回 

107
00:05:25,015 --> 00:05:31,046
它分配任何本地数据应 

108
00:05:29,000 --> 00:05:34,025
得到ð分配应该被释放

109
00:05:31,046 --> 00:05:36,134
所以，我们不排序的消耗开始 

110
00:05:34,025 --> 00:05:38,117
存储的无限量，怎么办 

111
00:05:37,034 --> 00:05:41,108
我们做这些都是何许 

112
00:05:39,017 --> 00:05:45,022
不同的方面 ， 一个过程调用 

113
00:05:42,008 --> 00:05:47,042
和返回必须以某种方式处理 和 

114
00:05:45,022 --> 00:05:51,097
为 打破下来 的部分原因 

115
00:05:47,042 --> 00:05:54,101
入这些 小片段是在86 64 

116
00:05:51,097 --> 00:05:56,183
他们做了巧妙的事情之一是 

117
00:05:55,001 --> 00:05:59,045
尽量减少 程序的 开销 

118
00:05:57,083 --> 00:06:01,115
要求尽可能地

119
00:05:59,045 --> 00:06:05,066
因为 当你在良好的编程知道 

120
00:06:02,015 --> 00:06:07,106
风格你经常写这些功能 

121
00:06:05,066 --> 00:06:11,069
该做的实际量非常小 

122
00:06:08,006 --> 00:06:13,085
有用的东西，这有点好 

123
00:06:11,069 --> 00:06:15,074
编程风格做特别 

124
00:06:13,085 --> 00:06:17,147
在一个更面向对象编程 

125
00:06:15,074 --> 00:06:19,148
款式等你不想开销 

126
00:06:18,047 --> 00:06:22,076
所 采取的 步骤额外的数 

127
00:06:20,048 --> 00:06:23,051
调用过程和处理所有 

128
00:06:22,076 --> 00:06:26,102
这是一个 SPECT 

129
00:06:23,078 --> 00:06:29,143
采取更多的时间比实际需要 的 

130
00:06:27,002 --> 00:06:33,011
因为这是一个相当关键的开销 

131
00:06:30,043 --> 00:06:36,095
所以他们在这做的事情之一

132
00:06:33,092 --> 00:06:39,104
是他们唯一做的一切是绝对

133
00:06:36,095 --> 00:06:42,143
需要所以特别 是如果没有 本地 

134
00:06:40,004 --> 00:06:45,020
存储需要对这个数据然后 

135
00:06:43,043 --> 00:06:47,090
不分配它， 因此不 

136
00:06:45,002 --> 00:06:51,047
释放它，如果你不传递任何值 

137
00:06:47,009 --> 00:06:53,042
不通过他们，并 在常规排序 

138
00:06:51,065 --> 00:06:55,094
怎么一点你可以脱身， 

139
00:06:54,023 --> 00:06:58,028
这使得它有点混乱 

140
00:06:55,094 --> 00:06:59,189
从视图和示教点 

141
00:06:58,073 --> 00:07:02,081
没有它遵循一套模板

142
00:07:00,089 --> 00:07:04,187
每次有那种你 有时间给每个 

143
00:07:03,053 --> 00:07:10,061
情况是怎样 一个特例

144
00:07:05,087 --> 00:07:13,109
特别程序 得到实施这样 

145
00:07:11,033 --> 00:07:15,095
我们将通过所有 这些部分，看看 

146
00:07:14,009 --> 00:07:18,032
他们是如何发生的，你已经看到了

147
00:07:15,095 --> 00:07:18,179
他们的小一瞥 ，我们会得到 

148
00:07:18,032 --> 00:07:24,071
代码的小片段 ，我们已经 

149
00:07:19,079 --> 00:07:25,151
已经显示出这样的第一个和排序 

150
00:07:24,071 --> 00:07:29,102
最关键的是，我们如何把 

151
00:07:26,051 --> 00:07:31,064
控制功能，但我们可以前 

152
00:07:30,002 --> 00:07:34,079
甚至谈到 ，我们要谈谈 

153
00:07:31,064 --> 00:07:37,160
有关堆栈所以，你听说过， 

154
00:07:34,079 --> 00:07:40,085
术语各种方式堆栈中的堆栈

155
00:07:38,006 --> 00:07:43,088
实在不是一个特殊的内存，它只是 

156
00:07:41,039 --> 00:07:47,123
正常存储的区域记 

157
00:07:44,042 --> 00:07:50,123
给程序员透视 装配 

158
00:07:48,023 --> 00:07:53,038
级的程序员的观点是存储器 

159
00:07:51,023 --> 00:07:55,118
是字节的只是一个大阵列 

160
00:07:53,038 --> 00:07:58,046
内的一堆字节的地方

161
00:07:56,018 --> 00:08:01,091
我们要称之为堆栈和 

162
00:07:59,018 --> 00:08:04,109
堆栈用于通过程序 来管理 

163
00:08:01,091 --> 00:08:07,142
与程序相关联的状态

164
00:08:05,009 --> 00:08:11,057
它调用 和他们返回所以它的 

165
00:08:08,042 --> 00:08:14,101
它把所有这些潜在的 

166
00:08:11,057 --> 00:08:18,146
信息的控制信息 

167
00:08:15,001 --> 00:08:21,044
数据并分配本地数据和 

168
00:08:19,046 --> 00:08:24,053
之所以可以管理是一个堆栈 

169
00:08:21,044 --> 00:08:26,069
是因为整个的性质

170
00:08:24,053 --> 00:08:28,142
过程调用和返回的想法， 

171
00:08:26,069 --> 00:08:31,091
您 拨打一个电话 ，你可能需要一些 

172
00:08:29,042 --> 00:08:33,050
信息，但是 当你 从 一个 返回 

173
00:08:31,091 --> 00:08:37,100
调用所有这些 信息可以 

174
00:08:34,022 --> 00:08:40,076
丢弃，所以它使用的 是 

175
00:08:38,000 --> 00:08:43,016
排序后进先出分配

176
00:08:40,076 --> 00:08:46,081
原则网是非常好，这 

177
00:08:43,016 --> 00:08:51,107
过程调用和返回，以便在理念

178
00:08:47,026 --> 00:08:55,057
86 栈实际上很启动 

179
00:08:52,007 --> 00:08:59,018
高编号的地址，当他们长大 

180
00:08:55,057 --> 00:09:01,148
当更多的数据被分配给该 

181
00:08:59,018 --> 00:09:05,051
甲板它是由递减 栈 完成 

182
00:09:02,048 --> 00:09:08,099
指针，以便你知道堆栈指针 

183
00:09:05,051 --> 00:09:11,084
只是一个普通的寄存器RSP 及其 

184
00:09:08,099 --> 00:09:13,166
值是当前 顶部 的地址 

185
00:09:11,084 --> 00:09:15,170
堆栈，每次分配时间 

186
00:09:14,066 --> 00:09:19,097
它通过做它在堆栈上更多的空间 

187
00:09:16,007 --> 00:09:23,063
现在递减该指针只是一个 

188
00:09:19,097 --> 00:09:25,183
约定，我不知道为什么这

189
00:09:24,026 --> 00:09:30,041
发生但这是我们做的事情是这样的 

190
00:09:26,083 --> 00:09:33,158
我们得出栈倒挂， 使得 

191
00:09:30,041 --> 00:09:37,054
称之为顶部的堆栈 实际上 是 

192
00:09:34,058 --> 00:09:36,154
在底部示出

193
00:09:37,087 --> 00:09:45,115
而只是添加到混乱 和 

194
00:09:42,019 --> 00:09:47,032
还记得地址从去 

195
00:09:46,015 --> 00:09:49,063
自下而上 

196
00:09:47,032 --> 00:09:51,091
不是从上到下，所以当你添加 

197
00:09:49,063 --> 00:09:53,152
堆栈你递减堆栈 

198
00:09:51,091 --> 00:09:56,143
指针既不那些样 网格 的 

199
00:09:54,052 --> 00:09:58,144
用你的直觉可能是，但你就是 

200
00:09:57,043 --> 00:10:04,075
已经习惯了 它 ，因为我们 不 

201
00:09:59,044 --> 00:10:07,135
要重绘了所有这一个，这样 

202
00:10:04,075 --> 00:10:09,124
反正这只是记住了 

203
00:10:08,035 --> 00:10:12,121
一遍又一遍 它，这就是为什么这些 

204
00:10:10,024 --> 00:10:15,031
箭头显示 ，如果我们列举 

205
00:10:13,021 --> 00:10:17,083
这些不同的字节的地址

206
00:10:15,031 --> 00:10:20,062
在数据他们会在这个越来越大 

207
00:10:17,083 --> 00:10:22,129
方向 ，当我们添加到堆栈 

208
00:10:20,062 --> 00:10:25,075
堆栈顶部位于的底部

209
00:10:23,029 --> 00:10:30,034
图片， 我们 通过递减做 

210
00:10:25,075 --> 00:10:33,082
堆栈指针所以特别他人 

211
00:10:30,079 --> 00:10:37,083
看到明确的指示push和pop 

212
00:10:33,082 --> 00:10:41,086
使使用栈和它的 

213
00:10:38,019 --> 00:10:46,027
常写推送 提示和弹出提示，但 

214
00:10:41,086 --> 00:10:49,108
这提示实际上是一个可选的后缀

215
00:10:46,027 --> 00:10:52,044
在指令做的想法

216
00:10:50,008 --> 00:10:56,008
东西推到 堆栈则是 

217
00:10:52,044 --> 00:10:59,077
有一些源操作数也可能是

218
00:10:56,008 --> 00:11:02,023
从寄存器或 存储器 或 

219
00:10:59,077 --> 00:11:05,104
即时所以这有点像 一招 

220
00:11:02,023 --> 00:11:08,067
但指令的目的地 

221
00:11:06,004 --> 00:11:11,005
此举将是对内存和 

222
00:11:08,067 --> 00:11:12,133
存储器的地址由下式确定 

223
00:11:11,014 --> 00:11:16,071
第一递减 堆栈指针和 

224
00:11:13,033 --> 00:11:16,071
然后做一个正确的

225
00:11:18,099 --> 00:11:24,136
类似地弹出指令需要

226
00:11:22,009 --> 00:11:26,047
从堆栈 并存储读取数据

227
00:11:25,036 --> 00:11:30,061
在目的地必须是一个 

228
00:11:27,028 --> 00:11:33,037
寄存器对于该特定指令 

229
00:11:30,061 --> 00:11:35,128
我想推必须是注册过，现在 

230
00:11:34,018 --> 00:11:41,074
我认为它立即您 

231
00:11:36,028 --> 00:11:44,104
不能从内存推到 如此流行读取 

232
00:11:41,074 --> 00:11:47,170
从内存中 读取自 地址 

233
00:11:45,004 --> 00:11:50,089
由当前的堆栈指针给出它

234
00:11:48,007 --> 00:11:54,010
然后递增堆栈指针 

235
00:11:50,089 --> 00:11:55,176
8这些 都在 8个字节的 唯一工作 

236
00:11:54,073 --> 00:12:00,076
操作数我会得到你在第二和 

237
00:11:56,076 --> 00:12:06,082
然后，该结果被存储在一个 

238
00:12:01,003 --> 00:12:10,078
注册问题pop 和push或只是 

239
00:12:06,082 --> 00:12:12,109
喜欢 做清算 就像是有 

240
00:12:10,078 --> 00:12:15,121
像使用等之间的差

241
00:12:13,009 --> 00:12:19,071
顶哦， 你 能不能 把它写成一组 

242
00:12:16,021 --> 00:12:22,084
指令是啊，你居然可以 

243
00:12:19,071 --> 00:12:24,117
除了一些怪异的极端情况写 

244
00:12:22,084 --> 00:12:28,132
它作为一组独立的指令 

245
00:12:25,017 --> 00:12:31,092
但它是一个足够常见的事情， 它的 

246
00:12:29,032 --> 00:12:34,069
那种建立 在作为作为 操作 

247
00:12:31,092 --> 00:12:37,153
而调用和返回是特殊的，他们 

248
00:12:34,069 --> 00:12:39,163
无法模拟这么一件事

249
00:12:38,053 --> 00:12:43,102
记住太多 是 很重要的，在 

250
00:12:40,063 --> 00:12:45,151
一个情况下，你递减你做的 

251
00:12:44,002 --> 00:12:48,100
算术上之前，堆栈指针 

252
00:12:46,051 --> 00:12:50,122
你写的，因为当你第一次启动 

253
00:12:49,000 --> 00:12:52,081
其 从堆栈指针所 指向的 

254
00:12:51,022 --> 00:12:54,031
无论是的顶级元素 

255
00:12:52,081 --> 00:12:55,168
堆，我们要创建一个新的顶级 

256
00:12:55,012 --> 00:13:00,043
元素，以便我们将 递减 

257
00:12:56,068 --> 00:13:02,131
第一，然后做而右边

258
00:13:00,043 --> 00:13:04,078
会想 其他方向 

259
00:13:03,031 --> 00:13:07,045
读出堆栈的当前顶 

260
00:13:04,078 --> 00:13:09,151
元素，然后你要增加 

261
00:13:07,045 --> 00:13:11,137
堆栈指针进行排序解除分配的 

262
00:13:10,051 --> 00:13:13,150
它和一两件事在这里你会发现是 

263
00:13:12,037 --> 00:13:17,098
当我说释放它不喜欢我

264
00:13:14,005 --> 00:13:19,006
奇迹般地抹去这或什么的 

265
00:13:17,098 --> 00:13:21,193
我做的只是移动堆栈 

266
00:13:19,006 --> 00:13:24,070
指针无论是那里的顶部 

267
00:13:22,093 --> 00:13:28,104
堆栈还在内存中，它只是 

268
00:13:25,024 --> 00:13:28,032
堆栈不再被认为是部分 

269
00:13:31,003 --> 00:13:38,071
好了，这就是堆栈的想法， 

270
00:13:34,069 --> 00:13:41,388
指令push和pop是 对 

271
00:13:38,098 --> 00:13:43,187
把数据在栈上把它关闭，但 

272
00:13:42,009 --> 00:13:50,053
我们使用相同的基本 想法 通话 

273
00:13:44,087 --> 00:13:51,556
并返回 所以让我们看看一些 

274
00:13:50,449 --> 00:13:55,550
例子， 有很多的东西了 

275
00:13:52,339 --> 00:13:58,344
在这里 ，但这个被称为见功能 

276
00:13:55,055 --> 00:14:02,069
MULT存储，然后这是输出 

277
00:13:58,839 --> 00:14:05,170
从 稍微 清理输出 

278
00:14:02,069 --> 00:14:06,898
该确切功能的拆装和

279
00:14:05,017 --> 00:14:10,073
同样，这是一个函数调用MULT 

280
00:14:07,519 --> 00:14:12,544
对 ，这就是 它的拆卸版本 

281
00:14:10,073 --> 00:14:14,602
其原因我展示这是 

282
00:14:12,769 --> 00:14:17,800
因为我想利用的 

283
00:14:15,259 --> 00:14:20,000
解决了这些指令在 

284
00:14:18,079 --> 00:14:22,490
你没有看到，当你把它写 的 

285
00:14:20,000 --> 00:14:27,005
汇编代码，所以我展示它的 

286
00:14:22,049 --> 00:14:28,198
拆卸版本和所有的理由

287
00:14:27,005 --> 00:14:33,023
这是在这里是 因为你会看到 

288
00:14:28,639 --> 00:14:37,810
功能多，所以我想 展示如何 

289
00:14:33,023 --> 00:14:39,110
该工程 ，以便有两家 

290
00:14:37,081 --> 00:14:42,083
你已经在看到这些说明

291
00:14:40,001 --> 00:14:46,058
某种形式的只是调用函数 你 

292
00:14:43,001 --> 00:14:48,940
调用它，你给一个标签，但保留 

293
00:14:46,067 --> 00:14:50,296
记住，这两个指令 

294
00:14:48,949 --> 00:14:53,120
另一种是当你准备好 

295
00:14:50,899 --> 00:14:56,120
回到你刚才执行RET 

296
00:14:53,012 --> 00:14:58,161
指令并牢记 尽管这 

297
00:14:56,012 --> 00:15:00,661
这些功能不会做全 

298
00:14:58,269 --> 00:15:02,600
过程调用和 返回 的业务 

299
00:15:00,769 --> 00:15:04,940
他们只是做了它的控制部分 

300
00:15:02,006 --> 00:15:09,115
这是我们看到的仅仅是三选一 

301
00:15:04,094 --> 00:15:12,101
程序方面也不在话下 

302
00:15:09,709 --> 00:15:18,350
你会在有时特别是看到它

303
00:15:13,001 --> 00:15:21,700
会说RET分号RET，您可以 

304
00:15:18,035 --> 00:15:24,098
非常简单，只是忽略了，这是一个 

305
00:15:21,709 --> 00:15:27,714
略显晦涩为什么它甚至有那么它的 

306
00:15:24,098 --> 00:15:26,877
真的是同样的想法 

307
00:15:29,679 --> 00:15:36,691
好了，所以让我们来打破这种分解 成 

308
00:15:32,809 --> 00:15:40,882
其最简单的一部分，所以，让我们 想象 

309
00:15:36,799 --> 00:15:43,873
场景，其中堆栈的顶部是在 

310
00:15:41,539 --> 00:15:46,636
十六进制为0地址1，其为未 

311
00:15:44,539 --> 00:15:49,567
顺便说一下，程序现实 

312
00:15:47,509 --> 00:15:54,582
计数器被称为 我们的IP是 

313
00:15:49,819 --> 00:15:56,827
没有任何与死亡 是 

314
00:15:55,239 --> 00:16:02,275
指示当前指令 

315
00:15:57,619 --> 00:16:05,623
这是在5:44这是该呼叫 

316
00:16:02,599 --> 00:16:08,692
指令等会发生什么 

317
00:16:05,659 --> 00:16:13,687
call指令 是它会做 

318
00:16:09,529 --> 00:16:15,541
两件事情它会实际上有三个 

319
00:16:13,939 --> 00:16:18,940
事情会递减堆栈 

320
00:16:15,649 --> 00:16:21,736
指针等 从1到0进行8 

321
00:16:18,949 --> 00:16:25,950
和六角给你1 1 8，它会 

322
00:16:22,519 --> 00:16:30,532
写指令的地址

323
00:16:25,959 --> 00:16:33,037
以下调用 到 的顶部 

324
00:16:30,649 --> 00:16:36,685
栈，它很重要， 它 是 

325
00:16:33,739 --> 00:16:39,747
在一个 呼叫 以下 是这 

326
00:16:37,009 --> 00:16:43,018
这是指导我要回

327
00:16:39,819 --> 00:16:46,903
用于我的 返回地址，我想 

328
00:16:43,099 --> 00:16:49,156
在该此功能恢复执行

329
00:16:47,659 --> 00:16:50,740
指令后调用不要 打电话 

330
00:16:49,669 --> 00:16:56,755
本身否则你就得 无限 

331
00:16:51,469 --> 00:17:00,496
循环，它也是这个调用指令 

332
00:16:57,529 --> 00:17:03,610
也嵌入在的编码 

333
00:17:00,739 --> 00:17:09,350
指令是目的地地址 

334
00:17:04,339 --> 00:17:11,480
它，这恰好是 

335
00:17:09,035 --> 00:17:14,134
这个特别的起始地址 

336
00:17:11,048 --> 00:17:18,757
功能，使程序计数器会 

337
00:17:14,449 --> 00:17:21,457
设置为该 值和现在的 

338
00:17:19,189 --> 00:17:22,285
处理器刚开始一起执行 

339
00:17:21,529 --> 00:17:25,730
这些指令所以它做了一个 

340
00:17:23,149 --> 00:17:27,740
跳 和推组合 

341
00:17:25,073 --> 00:17:30,124
这就是为什么有人提问 

342
00:17:27,074 --> 00:17:32,983
早期是推指令 你 能 

343
00:17:31,024 --> 00:17:35,323
组装该淘汰现有的 

344
00:17:33,649 --> 00:17:39,651
说明答案是肯定的推 

345
00:17:35,539 --> 00:17:39,552
但不是呼叫问题回到那里 

346
00:17:40,021 --> 00:17:48,034
颠簸像故事都 将投入 

347
00:17:42,085 --> 00:17:51,169
在众多 RIT 的地址不，不它做 

348
00:17:48,034 --> 00:17:54,093
那你RIT从未明确存在

349
00:17:52,069 --> 00:17:56,388
不操纵该指令

350
00:17:54,399 --> 00:17:59,710
直接它的隐含部分， 

351
00:17:57,009 --> 00:18:03,038
调用指令调用指令 

352
00:17:59,071 --> 00:18:07,108
将采取我没有实际 

353
00:18:03,299 --> 00:18:09,850
编码，但嵌入在此调用 

354
00:18:08,008 --> 00:18:11,457
指令你看，它的五个字节 

355
00:18:09,085 --> 00:18:13,164
长我不告诉你 的自行车编码 

356
00:18:11,529 --> 00:18:17,710
但 嵌在它的目标地址 

357
00:18:13,929 --> 00:18:19,330
所以它会采取该地址，并使用 

358
00:18:17,071 --> 00:18:22,132
它对于程序的新价值 

359
00:18:19,033 --> 00:18:25,033
计数器，以便调用确实既 

360
00:18:23,032 --> 00:18:27,711
旧的返回指针 推 

361
00:18:25,033 --> 00:18:33,252
并设置程序计数器到 

362
00:18:27,999 --> 00:18:36,038
新的新的 目标 ，以便它确实 

363
00:18:33,549 --> 00:18:35,633
这两点 

364
00:18:37,094 --> 00:18:39,178
题

365
00:18:45,059 --> 00:18:54,148
我不认为 这样 会致电或 

366
00:18:48,799 --> 00:18:58,861
返回如果是的话这将是非常晦涩 

367
00:18:55,048 --> 00:19:01,627
不，我不这么认为没有那么打电话 

368
00:18:59,419 --> 00:19:03,457
回报是在可能有一些奇怪的 

369
00:19:02,059 --> 00:19:05,510
系统指令，让你这样做

370
00:19:03,799 --> 00:19:10,340
但不是你在任何正常看 

371
00:19:05,051 --> 00:19:16,960
问题好 问题 的 方案 ，以便 

372
00:19:10,034 --> 00:19:22,843
这样好了，所以，显示你的 控制 

373
00:19:17,419 --> 00:19:26,090
麦考尔的作品，然后 所以现在 想象 

374
00:19:23,149 --> 00:19:28,370
这大军沿一班班和它击中 

375
00:19:26,009 --> 00:19:30,958
它的回归点，并达到这个销售代表 

376
00:19:28,037 --> 00:19:36,058
顺便说一句指令再次 RET Q和 

377
00:19:31,039 --> 00:19:39,950
而相同的指令和RET则 

378
00:19:36,058 --> 00:19:42,907
其目的是为了扭转的效果

379
00:19:39,095 --> 00:19:46,148
一个称之为假定的顶部 

380
00:19:43,429 --> 00:19:51,470
堆栈有要一个地址 

381
00:19:47,048 --> 00:19:53,377
跳到因此它将关闭弹出该地址 

382
00:19:51,047 --> 00:19:55,109
堆栈 这意味着将 递增 

383
00:19:53,809 --> 00:19:57,814
堆栈指针如我说的值 

384
00:19:56,009 --> 00:20:00,448
并没有真正从记忆中消失 

385
00:19:58,309 --> 00:20:03,860
它只是不再被认为的一部分

386
00:20:00,529 --> 00:20:05,542
堆栈，然后它将设置 

387
00:20:03,086 --> 00:20:07,175
程序计数器 是 什么，它只是弹出 

388
00:20:05,659 --> 00:20:10,723
从堆栈 ，这将导致 

389
00:20:08,075 --> 00:20:11,086
程序恢复回到它原来的地方 

390
00:20:11,299 --> 00:20:15,110
从

391
00:20:11,086 --> 00:20:17,155
所以你看，要的聪明的想法 

392
00:20:15,011 --> 00:20:20,080
推下一个地址 

393
00:20:17,929 --> 00:20:22,610
指令所以当回报是它

394
00:20:20,179 --> 00:20:25,120
将它得到的地步， 它应该 

395
00:20:22,061 --> 00:20:24,112
恢复执行

396
00:20:26,006 --> 00:20:30,048
还好，这样的传球控制它

397
00:20:29,007 --> 00:20:33,045
很简单， 所有这些事情由 

398
00:20:31,002 --> 00:20:35,097
方式仅仅是本质机器码 

399
00:20:33,045 --> 00:20:38,524
它的每一个部分非常简单 

400
00:20:35,097 --> 00:20:41,306
因为 它的设计由执行 

401
00:20:38,929 --> 00:20:45,360
原有的硬件是相当简单 

402
00:20:42,179 --> 00:20:48,278
它没有 任何更多 ，但它是真正的 

403
00:20:45,036 --> 00:20:50,133
基本思路是的，我们使用那种 

404
00:20:49,169 --> 00:20:53,630
指令组合来建立 

405
00:20:51,033 --> 00:20:55,089
所有的层具有相关联 

406
00:20:53,063 --> 00:20:59,732
像过程调用操作和

407
00:20:55,089 --> 00:21:01,161
现在我们要回到好了，所以传递数据 

408
00:21:00,299 --> 00:21:06,120
已经看到的 几个 小例子 

409
00:21:02,061 --> 00:21:07,110
通过数据我们已经看到一对夫妇 

410
00:21:06,012 --> 00:21:10,053
当您能够轻松使用的寄存器

411
00:21:08,001 --> 00:21:13,038
参数传递给 函数， 

412
00:21:10,053 --> 00:21:15,060
我们已经看到了寄存器RA X获得 

413
00:21:13,047 --> 00:21:18,144
用于从函数返回值 

414
00:21:15,006 --> 00:21:21,053
所以那些是基本的思路和 

415
00:21:19,044 --> 00:21:24,072
再次，这是所有内置到这个ABI 

416
00:21:22,007 --> 00:21:27,078
你知道定义为 一组 约定 

417
00:21:24,072 --> 00:21:28,161
硬件没有特别一部分，从而 

418
00:21:27,078 --> 00:21:34,146
特别是，规则是 第一 

419
00:21:29,061 --> 00:21:40,062
六个参数得到内这些传递

420
00:21:35,046 --> 00:21:43,062
特别寄存器你不得不

421
00:21:40,062 --> 00:21:45,096
记住 它们的顺序，或者有 

422
00:21:43,062 --> 00:21:47,351
表方便看或类似的东西 

423
00:21:45,096 --> 00:21:55,101
因为没有 特定的逻辑 

424
00:21:47,909 --> 00:21:58,590
它并返回返回值 

425
00:21:56,001 --> 00:22:00,670
寄存器RA X，并用的方式，这是 

426
00:21:58,059 --> 00:22:04,388
所有四个参数 是要么 

427
00:22:00,679 --> 00:22:06,750
整数或指针好，我想我已经 

428
00:22:04,919 --> 00:22:08,190
得到了一点点展开的点 

429
00:22:06,075 --> 00:22:09,171
在一组单独 的 传递 

430
00:22:08,019 --> 00:22:12,638
寄存器，这样这些都只是 假定 

431
00:22:10,071 --> 00:22:15,147
现在我们只是在处理 整数 

432
00:22:12,809 --> 00:22:18,450
数据指针数据，然后你问好 

433
00:22:16,047 --> 00:22:20,082
如果您有 六个 以上会发生什么

434
00:22:18,045 --> 00:22:22,053
参数的函数，而不是很 

435
00:22:20,082 --> 00:22:24,171
共同但有它发生以及规则上 

436
00:22:23,025 --> 00:22:28,184
所得到的那些放置在内存上 

437
00:22:25,071 --> 00:22:30,078
栈，我会告诉笔直我是什么意思 

438
00:22:28,409 --> 00:22:32,880
通过 这样他们传递给 

439
00:22:30,078 --> 00:22:35,123
函数， 然后将函数必须 

440
00:22:32,088 --> 00:22:38,135
检索这些值从堆栈

441
00:22:36,023 --> 00:22:41,032
早在由坏日子IA-32 

442
00:22:39,035 --> 00:22:44,344
这样所有的参数得以通过的 

443
00:22:41,239 --> 00:22:46,318
叠 ，而 现在你 通过 大部分 

444
00:22:44,659 --> 00:22:49,340
参数和寄存器和 

445
00:22:47,029 --> 00:22:53,062
原因是寄存器访问 

446
00:22:49,034 --> 00:22:56,048
方式比内存访问速度更快好 了， 

447
00:22:53,359 --> 00:22:59,416
这里有一种凌乱的 一堆代码 

448
00:22:56,048 --> 00:23:03,997
但只是为了告诉你他们如何现身 

449
00:22:59,929 --> 00:23:08,210
在功能上不存储所有的 时间 

450
00:23:04,429 --> 00:23:10,820
三个参数XY和咨询台 ，您 

451
00:23:08,021 --> 00:23:14,680
可以 将此代码 ，它是 内 只看到 

452
00:23:10,082 --> 00:23:19,094
利用像 RDI 寄存器 

453
00:23:14,869 --> 00:23:22,921
并且它显示出在哪里以及其他 

454
00:23:19,094 --> 00:23:25,094
像 MULT 的地方 -因为 两个参数， 

455
00:23:23,389 --> 00:23:28,453
你可以看到它是如何利用我们的 

456
00:23:25,094 --> 00:23:29,953
GI和我们的SI和代码，所以基本上 

457
00:23:29,029 --> 00:23:32,128
该代码是根据所产生的 

458
00:23:30,799 --> 00:23:34,858
假设，无论是参数 

459
00:23:33,019 --> 00:23:37,700
被传递给它会被传入 

460
00:23:35,389 --> 00:23:39,442
该特定组寄存器和的

461
00:23:37,007 --> 00:23:41,356
特别是订单已列出，

462
00:23:39,919 --> 00:23:43,995
代码排序使得 这些假设 

463
00:23:42,049 --> 00:23:47,110
然后同样 

464
00:23:44,679 --> 00:23:49,728
当你从一个返回值 

465
00:23:47,659 --> 00:23:49,710
功能

466
00:23:50,289 --> 00:23:58,291
它是多店没有 

467
00:23:52,073 --> 00:24:00,202
返回值MUL，但是 -不和 

468
00:23:58,309 --> 00:24:04,850
它的方式是存款的价值 

469
00:24:00,859 --> 00:24:09,830
到我们的斧头，然后当返回 

470
00:24:04,085 --> 00:24:15,146
从我们的X发生骚乱商店，你看 

471
00:24:09,083 --> 00:24:18,772
它现在假定MULT店 

472
00:24:16,046 --> 00:24:22,121
代码可以假设寄存器 RA X装 

473
00:24:19,519 --> 00:24:25,618
返回值的 价值 ，它可以 

474
00:24:23,021 --> 00:24:28,600
请将其目标寄存器和 

475
00:24:26,509 --> 00:24:31,573
我们来看看在一分钟 为什么RB x被 

476
00:24:28,789 --> 00:24:34,970
这里使用我们将介绍一些在 短短 的 

477
00:24:32,149 --> 00:24:36,235
过了一会儿 ， 但是 这就是点 

478
00:24:34,097 --> 00:24:39,098
只要大家坚持这个 

479
00:24:37,009 --> 00:24:42,950
通用接口标准，那么你可以 

480
00:24:40,007 --> 00:24:47,296
即使使用不同的编译器来编译 

481
00:24:42,095 --> 00:24:48,544
代码，让他们能够合作 

482
00:24:47,359 --> 00:24:49,730
与顺便而言彼此 

483
00:24:49,399 --> 00:24:52,400
争论

484
00:24:49,073 --> 00:24:56,074
它的返回数据 ，这就是 

485
00:24:52,004 --> 00:24:56,038
你之所以要该公约是 

486
00:24:58,024 --> 00:25:03,065
八个字节 ，因为良好的第一 

487
00:25:02,039 --> 00:25:06,080
所有调用和返回 

488
00:25:03,065 --> 00:25:09,158
这是一个64位的机器 把所有地址 

489
00:25:06,008 --> 00:25:12,092
为64 位或8 个字节，而且即使是 

490
00:25:10,058 --> 00:25:17,075
推在弹出指令只能 工作于 

491
00:25:13,064 --> 00:25:19,130
如果 8个字节的值 ，如果你说推 大号 

492
00:25:17,075 --> 00:25:21,133
试图 写 在 64位代码 的 X 

493
00:25:20,003 --> 00:25:30,005
它会回来 ， 有语法错误 

494
00:25:22,033 --> 00:25:32,042
如果您在 装配所以 不得不 说 的哦 

495
00:25:30,032 --> 00:25:39,059
这就是不同的我三 到那里会 

496
00:25:32,042 --> 00:25:41,045
在这里 四个字节值 好了，所以我喜欢 

497
00:25:39,059 --> 00:25:42,092
说你 一定看到 隐 

498
00:25:41,045 --> 00:25:44,054
和一些代码，你已经去过

499
00:25:42,092 --> 00:25:47,093
看，它是相当 

500
00:25:44,054 --> 00:25:50,117
直截了当地得到一个例子 

501
00:25:47,093 --> 00:25:52,100
显示你必须有传递参数 

502
00:25:51,017 --> 00:25:55,019
至少有七个参数的函数

503
00:25:53,000 --> 00:25:58,096
做这是相当混乱，所以我不会 

504
00:25:55,019 --> 00:25:58,096
这样做，但 有 例子在书中 

505
00:25:59,047 --> 00:26:06,049
但现在我们会有点把它捡起来 

506
00:26:02,048 --> 00:26:10,052
我还会告诉你在这个后期 

507
00:26:06,049 --> 00:26:12,083
现在它的第三部分， 又是 

508
00:26:10,088 --> 00:26:15,119
如果有一些地方的数据，我们 

509
00:26:12,083 --> 00:26:18,115
需要利用等，以获取

510
00:26:16,019 --> 00:26:22,046
想法跨越我 生病到另一个 

511
00:26:19,015 --> 00:26:27,047
的概念，它被称为堆栈帧 

512
00:26:22,046 --> 00:26:29,072
所以这是一个特别强烈 

513
00:26:27,047 --> 00:26:32,114
它在内存中的使用，并为我所提到的 

514
00:26:29,072 --> 00:26:35,075
的通话的功能较早的企业之一 

515
00:26:33,014 --> 00:26:39,101
和返回是你能 想象当 

516
00:26:36,002 --> 00:26:42,089
你有一个嵌套的一系列调用到的 

517
00:26:40,001 --> 00:26:48,092
功能时，一个特定的功能是

518
00:26:42,089 --> 00:26:50,126
执行仅它只需要 

519
00:26:48,092 --> 00:26:53,105
该函数内引用数据

520
00:26:51,026 --> 00:26:56,039
已传递 给它 或值 

521
00:26:54,005 --> 00:26:58,070
其中一些可能是指针和 

522
00:26:56,039 --> 00:27:01,103
因此指向在其它位置

523
00:26:58,007 --> 00:27:02,070
内存但问题是排序其余的 

524
00:27:02,003 --> 00:27:06,021
功能

525
00:27:03,033 --> 00:27:07,131
在你的代码然而，许多却已是 

526
00:27:06,021 --> 00:27:10,047
在那一刻， 那种 冰冻真 

527
00:27:08,031 --> 00:27:13,118
只有一个在执行功能 

528
00:27:10,047 --> 00:27:16,050
任何给定的时间我假设的西装 

529
00:27:14,018 --> 00:27:21,054
你会打电话单线程模型 

530
00:27:16,077 --> 00:27:23,172
在这里，所以我们可以只分配上 

531
00:27:21,054 --> 00:27:26,061
无论是需要空间的栈

532
00:27:24,072 --> 00:27:29,094
这个特殊的功能， 然后当 

533
00:27:27,024 --> 00:27:32,073
我们从该函数返回哦，我们 

534
00:27:29,094 --> 00:27:33,183
应该不会，如果它的正确写入需要 

535
00:27:32,073 --> 00:27:35,127
任何与相关联的信息 

536
00:27:34,083 --> 00:27:37,137
该 功能可以只是有点 

537
00:27:36,027 --> 00:27:41,075
永远消失，这就是 为什么这个 

538
00:27:38,037 --> 00:27:43,113
堆栈的想法你分配什么 

539
00:27:41,075 --> 00:27:45,159
如果你赚更多的电话你保持 

540
00:27:44,013 --> 00:27:48,099
分配更多的东西， 但是，当他们返回 

541
00:27:46,059 --> 00:27:51,090
你有种背出栈 和 

542
00:27:48,099 --> 00:27:54,111
和免费的东西了，因此堆栈 

543
00:27:51,009 --> 00:27:56,013
纪律是完全正确的匹配 

544
00:27:55,011 --> 00:28:00,048
过程，以及这个整体思路 

545
00:27:56,094 --> 00:28:02,100
调用了回报，每次我们使用的块

546
00:28:00,048 --> 00:28:08,111
特定的呼叫，然后它被称为 

547
00:28:03,000 --> 00:28:12,096
栈帧和要suitum 更 

548
00:28:09,011 --> 00:28:15,015
技术我们会说这是对的一框 

549
00:28:12,096 --> 00:28:18,183
的过程的特定实例

550
00:28:15,051 --> 00:28:22,125
对一个过程特定呼叫所以才 

551
00:28:19,083 --> 00:28:25,092
想象我们有一组 功能中的一个 

552
00:28:23,025 --> 00:28:30,033
叫你这就要求调用函数 

553
00:28:25,092 --> 00:28:32,139
谁和谁拥有多个呼叫

554
00:28:30,033 --> 00:28:35,037
所谓的MI和MI的另一个功能是 

555
00:28:33,039 --> 00:28:41,100
本身复发递归调用 

556
00:28:35,073 --> 00:28:44,109
本身这样的想象，我们有一个链 

557
00:28:42,000 --> 00:28:48,051
在那里你拨打两个电话通话 

558
00:28:45,009 --> 00:28:52,017
MI 自称递归两次 

559
00:28:48,051 --> 00:28:54,123
然后我们将退出MI出来，并得到 

560
00:28:52,089 --> 00:28:57,171
回到谁和谁就会 打 

561
00:28:55,023 --> 00:29:01,070
第二次调用英里， 不会去任何 

562
00:28:58,071 --> 00:29:04,083
进一步，这将是它所以这 

563
00:29:01,007 --> 00:29:07,100
此 图为整个灵魂 

564
00:29:04,083 --> 00:29:12,146
所有这些调用，获得由历史

565
00:29:08,063 --> 00:29:12,146
但在堆的条款 

566
00:29:13,065 --> 00:29:19,084
所有我们需要的 将保持框架 

567
00:29:17,044 --> 00:29:24,097
各样程序已 

568
00:29:19,084 --> 00:29:27,663
所谓但这甲板上还没有恢复

569
00:29:24,097 --> 00:29:30,163
和一般这种甲板的被分隔的

570
00:29:28,419 --> 00:29:33,400
由两个指针界定一个是 

571
00:29:31,063 --> 00:29:35,074
堆栈指针这是我们所熟悉的 

572
00:29:33,004 --> 00:29:39,018
再有另一个 称为 基 

573
00:29:35,074 --> 00:29:43,165
指针哪个寄存器RB P表示 

574
00:29:39,054 --> 00:29:47,062
但 一个实际功能是现在 

575
00:29:44,065 --> 00:29:51,076
成为IA32的特点，以及 是 

576
00:29:48,034 --> 00:29:53,076
这是一个可选的指针和在

577
00:29:51,076 --> 00:29:56,128
特别是我们将看到的代码

578
00:29:53,076 --> 00:30:00,172
不使用基址指针除了在 

579
00:29:57,028 --> 00:30:04,917
一些非常特殊的情况下， 所以这本 

580
00:30:01,072 --> 00:30:07,081
寄存器并没有真正 将不会出现 在 

581
00:30:05,169 --> 00:30:10,245
在一个特殊的使用你的程序 

582
00:30:08,062 --> 00:30:13,138
的方式作为一个帧指针将使用它 

583
00:30:10,929 --> 00:30:16,450
而不是仅仅作为一个经常性寄存器， 

584
00:30:14,038 --> 00:30:17,089
通常那么你唯一会 

585
00:30:16,045 --> 00:30:18,100
知道堆栈指针你 

586
00:30:17,089 --> 00:30:22,096
甚至不能够 搞清楚 

587
00:30:19,000 --> 00:30:25,096
其中框架正是在那里你会 

588
00:30:22,096 --> 00:30:27,184
只知道堆栈的顶部 

589
00:30:25,096 --> 00:30:32,104
是 用于 最上面 的 顶部 框架 

590
00:30:28,084 --> 00:30:37,123
功能，这 是所有被管理 

591
00:30:33,004 --> 00:30:39,076
代码本身，这是相同的堆栈 

592
00:30:38,023 --> 00:30:42,085
顺便说一下在你推和 

593
00:30:39,076 --> 00:30:44,148
弹出地址 -他们都挺 

594
00:30:42,085 --> 00:30:44,148
得到混合在一起 

595
00:30:46,083 --> 00:30:51,087
所以我们还没有真正看到 任何代码了 

596
00:30:49,086 --> 00:30:53,154
直到现在，让你做 任何 

597
00:30:52,023 --> 00:30:56,030
堆栈因为明确的管理

598
00:30:54,054 --> 00:31:00,105
我们所有的例子 都非常简单， 

599
00:30:56,093 --> 00:31:03,135
只是做了一个利用堆栈的唯一 

600
00:31:01,005 --> 00:31:07,044
对于返回地址 ， 但 我们会看到一些 

601
00:31:04,035 --> 00:31:09,120
在一般的使用更多，但这样的话 

602
00:31:07,044 --> 00:31:13,062
可以想象，每次 开始 

603
00:31:10,002 --> 00:31:16,005
功能精巧的一些空格键 

604
00:31:13,062 --> 00:31:21,077
潜在地在堆叠其帧 

605
00:31:16,005 --> 00:31:25,028
然后和帧由指示 

606
00:31:21,077 --> 00:31:30,111
任一个指针只或两个指针 

607
00:31:25,073 --> 00:31:32,100
所以现在，你叫谁那么 

608
00:31:31,011 --> 00:31:36,033
将创建 谁 一个新的堆栈帧 

609
00:31:33,000 --> 00:31:38,097
当MI被调用的一些方法 

610
00:31:36,033 --> 00:31:40,038
创建新的堆栈帧和我们 

611
00:31:38,097 --> 00:31:41,175
继续与 这些递归调用 

612
00:31:40,083 --> 00:31:44,145
我们只是增加了更多的东西给 

613
00:31:42,075 --> 00:31:46,098
堆越来越深 ，并且 

614
00:31:45,045 --> 00:31:48,123
将继续发生它的一个 

615
00:31:46,098 --> 00:31:51,150
原因是递归一点点

616
00:31:49,023 --> 00:31:55,092
冒险的一件事是，它比 

617
00:31:52,005 --> 00:31:58,047
迭代它不断要求更多的空间

618
00:31:55,092 --> 00:32:02,121
如您在递归和走向深入

619
00:31:58,092 --> 00:32:07,107
特别是大多数系统限制总 

620
00:32:03,021 --> 00:32:09,114
堆栈的深度，你能有什么 

621
00:32:08,007 --> 00:32:11,073
因为他们是他们害怕 的 

622
00:32:10,014 --> 00:32:13,113
排序的无限循环 版本 

623
00:32:11,073 --> 00:32:14,172
递归失控递归的地方 

624
00:32:14,013 --> 00:32:20,045
只是不断努力推动更多 

625
00:32:15,072 --> 00:32:25,119
东西到堆栈 这是一个一边 ， 

626
00:32:20,045 --> 00:32:28,047
然后这些开始返回他们的

627
00:32:26,019 --> 00:32:32,055
帧需要解除分配从取出 

628
00:32:28,065 --> 00:32:34,134
所以堆栈的一部分它 的好处 

629
00:32:32,055 --> 00:32:38,079
关于这是不是就意味着我 每次 

630
00:32:35,034 --> 00:32:41,073
如果我有多个呼叫MI因为 

631
00:32:38,079 --> 00:32:44,097
我已经深深的递归的每一个 

632
00:32:41,073 --> 00:32:48,114
他们将有自己的本地状态 

633
00:32:44,097 --> 00:32:50,100
它需要管理和再整 

634
00:32:49,014 --> 00:32:54,111
堆栈规则是 什么使得它的工作 

635
00:32:51,027 --> 00:32:57,032
而我们会发现 ，特别是 

636
00:32:55,011 --> 00:32:59,067
因为 这种 方式 设置 

637
00:32:57,032 --> 00:33:00,371
递归调用 相同的方式处理 

638
00:32:59,067 --> 00:33:01,706
那 

639
00:33:00,659 --> 00:33:03,743
普通电话是没有什么 

640
00:33:02,309 --> 00:33:06,392
特别之处他们所有的心脏一切 

641
00:33:04,499 --> 00:33:09,210
排序的基础设施要求 

642
00:33:07,139 --> 00:33:12,166
支持递归内置到该 

643
00:33:09,021 --> 00:33:12,220
整个堆栈纪律

644
00:33:13,019 --> 00:33:19,478
所以反正想象所有这些电话

645
00:33:16,549 --> 00:33:24,090
返回到谁，那谁愿意 

646
00:33:19,649 --> 00:33:25,727
再 一次 ，然后 调用 宓 为我们退出 

647
00:33:24,009 --> 00:33:29,348
我们有点重新分配这些堆栈 

648
00:33:26,429 --> 00:33:30,200
帧，又回到了起点 

649
00:33:29,429 --> 00:33:38,474
点

650
00:33:30,002 --> 00:33:40,301
是的问题是如此的问题是，如果 

651
00:33:38,879 --> 00:33:42,932
RB P是可选 

652
00:33:40,499 --> 00:33:45,515
然后程序如何 知道该怎么办 

653
00:33:43,409 --> 00:33:47,486
对D分配如何才能重置

654
00:33:45,659 --> 00:33:49,748
堆栈恢复正确的地方和 

655
00:33:48,179 --> 00:33:54,450
答案是，我们将看到的例子是 

656
00:33:50,549 --> 00:33:58,080
在编译代码，以便它知道了 

657
00:33:54,045 --> 00:34:00,404
当 它 例子 的分配是 

658
00:33:58,008 --> 00:34:02,657
要分配16个字节，然后将 它 

659
00:34:00,809 --> 00:34:04,844
知道在最后，它可以是 

660
00:34:02,729 --> 00:34:05,822
分配的 16个字节，它 实际上 

661
00:34:05,159 --> 00:34:09,203
带来了一个好点的有几分 

662
00:34:06,659 --> 00:34:11,700
这本书的一个不起眼的一部分去 

663
00:34:09,599 --> 00:34:14,460
在这个有一些特殊情况 

664
00:34:11,007 --> 00:34:16,136
它不能提前知道 多少 

665
00:34:14,046 --> 00:34:21,075
当有空间将被分配 

666
00:34:16,829 --> 00:34:24,450
分配的阵列或存储器缓冲器 

667
00:34:21,075 --> 00:34:27,102
变量的大小，然后它实际上将 

668
00:34:24,045 --> 00:34:30,274
使用的RB p在这些情况下， 为 

669
00:34:28,002 --> 00:34:30,661
正是目的

670
00:34:33,007 --> 00:34:41,406
还好 ，因此普遍 认为是什么 

671
00:34:38,799 --> 00:34:44,826
栈帧将看起来像在之一 

672
00:34:42,099 --> 00:34:49,131
这些 机器将会像 

673
00:34:45,069 --> 00:34:53,200
这 看起来，你会看到 这是 

674
00:34:49,419 --> 00:34:56,457
来电者，然后这是的 

675
00:34:53,002 --> 00:35:02,029
的，进行了该函数的堆栈帧

676
00:34:56,799 --> 00:35:05,470
调用，所以工作回来的路上，如果 我们 

677
00:35:02,047 --> 00:35:08,128
必须通过六年多的争论 

678
00:35:05,047 --> 00:35:15,103
主叫方会真正使用它自己的堆栈

679
00:35:09,028 --> 00:35:17,817
帧存储这些参数等 

680
00:35:16,003 --> 00:35:21,019
他们会是可用的，而且我们已经 

681
00:35:18,069 --> 00:35:24,700
看到当你调用它会推动 

682
00:35:21,019 --> 00:35:27,091
返回地址 压入堆栈如此前 

683
00:35:24,007 --> 00:35:30,061
功能甚至开始 这一切 

684
00:35:27,091 --> 00:35:34,500
信息会 在堆栈上，如果现在 

685
00:35:31,024 --> 00:35:37,078
有一个，如果这个特殊的，如果我们 

686
00:35:35,319 --> 00:35:39,700
利用 基类指针 的 那么我们 

687
00:35:37,078 --> 00:35:40,917
必须有某种方式在哪里存储 

688
00:35:39,007 --> 00:35:44,041
基指针的旧值， 使我们 

689
00:35:41,619 --> 00:35:47,140
可以修复它回来时，我们回到 我们 

690
00:35:45,004 --> 00:35:49,093
不会显示任何代码，这样做，所以在这里 

691
00:35:47,014 --> 00:35:53,017
这是可选的，但 一般来说，如果 

692
00:35:49,093 --> 00:35:53,188
有一些地方的国家像一些 

693
00:35:53,017 --> 00:35:57,040
需要保存的寄存器可以 

694
00:35:54,088 --> 00:35:59,104
我们将看到 一个或一个数组 的例子 

695
00:35:57,004 --> 00:36:02,053
这需要在本地所分配 

696
00:36:00,004 --> 00:36:05,053
将被存储在堆栈帧中

697
00:36:02,089 --> 00:36:07,090
并有可能对某些要求

698
00:36:05,053 --> 00:36:10,066
在栈帧的一些额外的空间

699
00:36:07,099 --> 00:36:11,167
特别是其他的东西，如果我们 

700
00:36:10,066 --> 00:36:14,235
要通过七年多的参数 

701
00:36:12,067 --> 00:36:15,076
这一需求空间，在堆栈的某处

702
00:36:14,829 --> 00:36:19,210
框架做

703
00:36:15,076 --> 00:36:21,144
而我们将在典型的看到一码 

704
00:36:19,021 --> 00:36:25,096
这个堆栈指针被递减 

705
00:36:22,044 --> 00:36:28,090
不一会儿程序开始后， 

706
00:36:25,096 --> 00:36:28,174
它被加回之前 

707
00:36:28,009 --> 00:36:33,978
它返回 

708
00:36:29,074 --> 00:36:37,119
这是怎么管理这个平台 让我们 

709
00:36:34,869 --> 00:36:38,190
做一些例子 

710
00:36:41,006 --> 00:36:50,012
嗯 什么，他看着这之前，但 

711
00:36:48,053 --> 00:36:51,152
这 是一个功能哦，我想 

712
00:36:50,066 --> 00:36:54,097
关于这个功能有趣的 是 ， 

713
00:36:52,052 --> 00:36:57,125
它有一个指针被传递给它 

714
00:36:54,097 --> 00:36:59,152
所以这个功能需要一个 参数一个 

715
00:36:58,025 --> 00:37:05,063
参数 是一个指针或另一种是 

716
00:37:00,052 --> 00:37:07,061
整数值，你可以看到它 

717
00:37:05,063 --> 00:37:12,139
确实是取消引用该指针 

718
00:37:08,042 --> 00:37:16,079
得到一个值码 X是一个计算 

719
00:37:13,039 --> 00:37:21,041
通过总结X和 值值Y 

720
00:37:16,079 --> 00:37:23,177
传递给它，它存储Y内为P，但 

721
00:37:21,041 --> 00:37:26,090
它返回X 的原始值 

722
00:37:24,077 --> 00:37:28,130
指针没有更新的版本 

723
00:37:26,009 --> 00:37:31,070
指针，你可以看到，在代码 

724
00:37:29,003 --> 00:37:34,097
在这里它的代码很短 记得 

725
00:37:32,051 --> 00:37:37,100
在一般的 路我将举行 第一次 

726
00:37:35,024 --> 00:37:39,098
在这种情况下，争论它是一个指针 ，以便 

727
00:37:38,000 --> 00:37:43,004
它将从指针做一个读和 

728
00:37:39,098 --> 00:37:45,101
它会把这是 我们 的斧头价值

729
00:37:43,004 --> 00:37:50,006
在返回值应该是无论如何 

730
00:37:46,001 --> 00:37:53,009
然后它会增加我们的SI其 

731
00:37:50,024 --> 00:37:56,033
有一个叫瓦尔这里最初的价值

732
00:37:53,081 --> 00:38:05,096
现在它有 X加瓦尔的 价值 

733
00:37:56,033 --> 00:38:08,111
然后将其存储 在值 

734
00:38:05,096 --> 00:38:10,097
指向P和它会做一回

735
00:38:09,011 --> 00:38:13,085
所以 你看 ， 这三个指令做 

736
00:38:11,006 --> 00:38:16,073
这一点，并为所有不同的部分 

737
00:38:13,085 --> 00:38:18,092
这说明一般也知道 

738
00:38:16,073 --> 00:38:19,145
顺便说来注册使用它的方便 

739
00:38:18,092 --> 00:38:24,116
这个文件时，你在 看 

740
00:38:20,045 --> 00:38:27,077
代码RGI是第一个参数 RSI变 

741
00:38:25,016 --> 00:38:30,110
最初使用它的瓦尔但现在它会 

742
00:38:27,077 --> 00:38:35,102
在通话过程中被设定为Y和 

743
00:38:31,001 --> 00:38:39,029
同样我们的斧最初 值 

744
00:38:36,002 --> 00:38:41,065
那么这是 它的两个 是在这里 什么X 和 

745
00:38:39,038 --> 00:38:45,089
它被用来作为返回值 

746
00:38:41,065 --> 00:38:46,118
好了，什么是 要经过 的 原因 

747
00:38:45,089 --> 00:38:48,143
所有这些都是真正告诉你 

748
00:38:47,018 --> 00:38:52,046
调用这个实例，以及如何

749
00:38:49,043 --> 00:38:55,108
参数得到传递给函数和

750
00:38:52,046 --> 00:38:55,108
它是如何利用堆栈 

751
00:38:56,038 --> 00:39:02,090
所以现在有一个函数调用调用

752
00:38:58,088 --> 00:39:06,104
增量值和它要 创建一个值 

753
00:39:02,009 --> 00:39:09,107
所谓的兽医 v1和具有生成 

754
00:39:07,004 --> 00:39:13,022
指针， 所以这是什么意思为v1 

755
00:39:10,088 --> 00:39:13,169
不能仅仅停留在一个寄存器 ，因为 

756
00:39:13,022 --> 00:39:17,030
您不能创建的地址 

757
00:39:14,069 --> 00:39:18,077
注册它必须被存储在存储器 

758
00:39:17,003 --> 00:39:23,024
这样的地方， 你 可以创建一个 

759
00:39:19,049 --> 00:39:26,051
指针是一个地址，在哪里呢 

760
00:39:23,051 --> 00:39:28,082
其存储 该怎么把它在栈中，以便 

761
00:39:26,051 --> 00:39:31,097
它是如何找到堆栈空间将 

762
00:39:28,082 --> 00:39:32,168
这样分配的函数调用着墨然后 

763
00:39:31,097 --> 00:39:35,105
我们会经历 各种 不同的 

764
00:39:33,068 --> 00:39:41,102
它的 一部分 ，但你看到这个红色 

765
00:39:36,077 --> 00:39:44,098
这里生成的代码生成这些 

766
00:39:42,002 --> 00:39:44,098
两个指令 

