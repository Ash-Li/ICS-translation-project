1
00:00:00,003 --> 00:00:08,025
好了，继续上的传奇 

2
00:00:05,043 --> 00:00:12,002
机器语言时数 

3
00:00:08,025 --> 00:00:14,294
我们这个 系列的四个，我 认为 

4
00:00:12,389 --> 00:00:18,150
该总量将有五个所以我们 

5
00:00:14,519 --> 00:00:19,553
几乎通过和 往常一样，这 是一个 

6
00:00:18,015 --> 00:00:21,057
很多材料的那课程 

7
00:00:19,859 --> 00:00:23,927
本质上，如果你的课程第三

8
00:00:21,057 --> 00:00:27,356
想想还有没有没有那么多，但 

9
00:00:24,539 --> 00:00:30,840
它的很多 课程和一部分 的 

10
00:00:27,869 --> 00:00:33,450
我们认为非常核心的它，因此很多 

11
00:00:30,084 --> 00:00:35,138
这涉及到，因为我们正在 谈论 

12
00:00:33,045 --> 00:00:39,084
有关特定机器的英特尔的x86 

13
00:00:36,038 --> 00:00:42,066
64台机器有很多同类的 

14
00:00:39,084 --> 00:00:44,157
低层次的细节问题的东西，但部分 

15
00:00:42,066 --> 00:00:46,074
我们希望你也理解 

16
00:00:45,057 --> 00:00:49,136
所涉及 的一些基本原则 

17
00:00:47,046 --> 00:00:53,094
过，如果你从移动，你会发现 

18
00:00:49,649 --> 00:00:54,740
这台机器到另一台机器 排序 

19
00:00:53,094 --> 00:00:56,783
学习你的第一个汇编语言 

20
00:00:55,559 --> 00:01:02,250
你最难的一个 连续的学习 

21
00:00:57,629 --> 00:01:03,725
那些轻松了很多所以今天我们要 

22
00:01:02,025 --> 00:01:06,644
谈论数据表示我们已经 

23
00:01:04,589 --> 00:01:11,670
到目前为止 ， 所有 我们已经看了节目 

24
00:01:06,869 --> 00:01:14,250
已要么只是操纵 

25
00:01:11,067 --> 00:01:15,135
整数或长整型和指针

26
00:01:14,025 --> 00:01:19,004
所以这一切就是我们会打电话标量数据 

27
00:01:16,035 --> 00:01:22,092
数据是不以任何形式汇总

28
00:01:19,229 --> 00:01:25,320
今天我们来看看地方数据 

29
00:01:22,092 --> 00:01:26,157
被收集到你放在一起

30
00:01:25,032 --> 00:01:29,079
多个数据 元素 ， 然后看到 

31
00:01:27,057 --> 00:01:33,111
没什么两种方法可以做到这一个 

32
00:01:29,079 --> 00:01:36,338
与数组，您可以创建许多

33
00:01:34,011 --> 00:01:38,097
副本或相同的许多拷贝

34
00:01:37,049 --> 00:01:43,070
数据类型可以有一个 int 数组 

35
00:01:38,097 --> 00:01:46,276
和指针阵列的第二种情况是

36
00:01:43,259 --> 00:01:49,860
你打了，所以你创建一个小的

37
00:01:47,149 --> 00:01:52,170
值的集合， 可以是 

38
00:01:49,086 --> 00:01:56,121
不同的数据类型 和每一个你 

39
00:01:52,017 --> 00:01:59,079
它的名字或标记 ，它原来的访问

40
00:01:57,021 --> 00:02:01,068
从这些定义可以是递归

41
00:01:59,079 --> 00:02:04,095
所以你可以有结构的阵列和 

42
00:02:01,068 --> 00:02:06,117
与阵列结构和它嵌套到一 

43
00:02:04,095 --> 00:02:08,172
任意度

44
00:02:07,017 --> 00:02:11,064
而我们将看到的是 两个怎样 的 

45
00:02:09,072 --> 00:02:12,171
在机器存储器表示，并且 

46
00:02:11,064 --> 00:02:15,069
还那么什么代码看起来 像 

47
00:02:13,071 --> 00:02:17,166
将操纵这些不同的数据 

48
00:02:16,014 --> 00:02:24,021
结构和看到的是主要的事情

49
00:02:18,066 --> 00:02:26,093
有没有对在机器 代码 

50
00:02:24,021 --> 00:02:29,085
水平没有 阵列的 概念 

51
00:02:26,093 --> 00:02:32,109
那你就必须在不同的较高水平 

52
00:02:29,085 --> 00:02:35,148
把它作为一个字节的集合 

53
00:02:33,009 --> 00:02:39,041
你可以在连续的一部分 

54
00:02:36,048 --> 00:02:41,079
存储和同一个结构就是

55
00:02:39,041 --> 00:02:43,125
分配为字节的集合， 

56
00:02:41,079 --> 00:02:45,090
它的 C编译器 的工作，然后到 

57
00:02:44,025 --> 00:02:50,034
生成相应的代码以 

58
00:02:45,009 --> 00:02:52,050
分配内存以获得正确的 

59
00:02:51,015 --> 00:02:56,109
当你指的是有些元素值

60
00:02:53,031 --> 00:03:01,055
一个结构或读，但好 消息 

61
00:02:57,009 --> 00:03:01,055
是这是这样一个 普遍型的 

62
00:03:01,094 --> 00:03:05,190
为编程语言要求

63
00:03:03,081 --> 00:03:08,142
该 机器可以让你排序 

64
00:03:06,009 --> 00:03:10,032
你会看到，现在他们的指令

65
00:03:09,042 --> 00:03:12,105
非常清楚了，他们说的完全 

66
00:03:11,013 --> 00:03:17,054
专为这一特定类的 

67
00:03:13,005 --> 00:03:20,444
应用程序，因此我们将谈论 

68
00:03:17,054 --> 00:03:22,101
结构A的第一，然后结构 

69
00:03:20,489 --> 00:03:24,810
谁击中我也将提到我们 

70
00:03:23,001 --> 00:03:26,087
做一点点 我给你的 一瞥 

71
00:03:24,081 --> 00:03:28,134
浮点今天 也 因为它是 

72
00:03:26,087 --> 00:03:30,236
这是值得知道如何浮点

73
00:03:29,034 --> 00:03:33,108
算法实现，以及在 

74
00:03:31,019 --> 00:03:36,900
机所以阵列的基本思想 

75
00:03:34,008 --> 00:03:40,014
分配是，如果相当简单

76
00:03:36,009 --> 00:03:44,010
您有n个具有n个元素的数组然后 

77
00:03:40,014 --> 00:03:49,062
多数民众赞成在足够的字节表示

78
00:03:45,000 --> 00:03:52,056
内存都在一个跨度来保存多 

79
00:03:49,062 --> 00:03:55,134
数据，以便如果基础 数据类型说 

80
00:03:52,056 --> 00:03:59,142
它是一个int 或 保健 是一个单字节 

81
00:03:56,034 --> 00:04:03,090
数据的类型，以便为具有 12 的阵列 

82
00:04:00,042 --> 00:04:06,087
管它需要12个字节和INT需要四个 

83
00:04:03,009 --> 00:04:09,012
字节，因此以具有 五个 int 数组 

84
00:04:06,087 --> 00:04:11,106
需要20个字节你的想法 ，你刚 

85
00:04:09,093 --> 00:04:13,104
乘以大小 底层数据 

86
00:04:12,006 --> 00:04:15,995
通过 元件 的数量 和类型

87
00:04:14,004 --> 00:04:17,040
这就是数组有多大是 在 

88
00:04:16,049 --> 00:04:21,060
字节为单位

89
00:04:17,004 --> 00:04:24,053
我们已经看到 ， 在护理 

90
00:04:21,006 --> 00:04:26,094
是一个咬合，它为双键或

91
00:04:24,449 --> 00:04:30,750
长是八个字节，因此会 

92
00:04:26,094 --> 00:04:32,543
是一个指针 ，以便那些都 不同 

93
00:04:30,075 --> 00:04:37,122
的存储空间，你在这看 

94
00:04:33,389 --> 00:04:39,464
图中我们用X表示起点 

95
00:04:38,022 --> 00:04:44,031
该区域的开始地址

96
00:04:40,139 --> 00:04:51,300
记忆，所以我们可以利用地址 

97
00:04:45,012 --> 00:04:53,031
计算来计算，加入偏移

98
00:04:51,003 --> 00:04:55,005
号码X 得到 的地址 

99
00:04:53,031 --> 00:04:59,130
该阵列的细节，这就是 

100
00:04:55,005 --> 00:05:03,060
正是代码一般做什么等等

101
00:05:00,003 --> 00:05:06,036
那么，如果你想象阵列有一些 

102
00:05:04,005 --> 00:05:08,654
底层类型 T什么的元素 

103
00:05:06,063 --> 00:05:09,662
该阵列是和若干 

104
00:05:08,699 --> 00:05:17,580
在该数组中的元素

105
00:05:10,229 --> 00:05:20,210
声明大号 那么我们会说 

106
00:05:17,058 --> 00:05:22,517
声明实际上做了两件事

107
00:05:20,021 --> 00:05:26,025
一个是它分配的足够的字节

108
00:05:23,039 --> 00:05:27,870
存储保存整个 阵列与所述 

109
00:05:26,061 --> 00:05:30,740
第二，从一种编程语言 

110
00:05:27,087 --> 00:05:33,099
透视它 的 识别符 

111
00:05:31,289 --> 00:05:35,970
阵列中的某些方面的罐等处理

112
00:05:33,099 --> 00:05:36,998
一个指针， 你 可以做指针 

113
00:05:35,097 --> 00:05:40,182
它的算术关闭， 这是一 

114
00:05:37,889 --> 00:05:43,970
C的特点是 是一个相当 

115
00:05:41,082 --> 00:05:46,128
唯一 看到它的创建 ，是 当 

116
00:05:44,699 --> 00:05:48,780
仍然是独一无二的，这一天这个想法 

117
00:05:47,028 --> 00:05:54,137
排序的互换性 

118
00:05:48,078 --> 00:05:56,100
指针和数组数组标识符，以便 

119
00:05:54,389 --> 00:06:00,690
例如我可以 使用数组符号 

120
00:05:57,000 --> 00:06:02,094
说四瓦尔是元素4 

121
00:06:00,069 --> 00:06:05,168
这阵， 这是一个五元阵 

122
00:06:02,094 --> 00:06:10,152
所以这将仅仅是这最后一个元素 

123
00:06:06,068 --> 00:06:14,237
但我也可以只指瓦尔和其 

124
00:06:11,052 --> 00:06:17,127
底层数据类型是作为int 星 

125
00:06:14,849 --> 00:06:21,270
所以指针小鬼 ，其价值将是 

126
00:06:18,027 --> 00:06:23,055
X，它只是 一个指针的指针 是 

127
00:06:21,027 --> 00:06:24,093
记得一个地址，它只是

128
00:06:23,055 --> 00:06:28,604
在 阵列 的起始地址

129
00:06:24,093 --> 00:06:30,148
我可以做瓦尔指针运算 

130
00:06:29,099 --> 00:06:34,690
正如你知道的 

131
00:06:31,048 --> 00:06:35,137
II，这是一个有点混乱，我们将 

132
00:06:34,069 --> 00:06:39,127
有我们来回走，因为 

133
00:06:36,037 --> 00:06:43,042
用C当 你指针运算 像 

134
00:06:40,027 --> 00:06:48,118
你说你知道八方停顿了 

135
00:06:43,042 --> 00:06:51,061
指针我们只是举一个例子 因此 

136
00:06:49,018 --> 00:06:55,027
如果你有这样的事情护理星数p作为

137
00:06:51,061 --> 00:06:59,089
声明和你说的P等于 

138
00:06:55,027 --> 00:07:04,032
一些字符串s，然后你说八方 

139
00:06:59,089 --> 00:07:03,177
加上所以你增加该指针 

140
00:07:05,082 --> 00:07:09,124
一个在这种 情况下，你就递增 

141
00:07:08,029 --> 00:07:17,080
由之一，因为基础数据类型 

142
00:07:10,024 --> 00:07:24,066
一个是照顾，但如果你说了些什么 

143
00:07:17,008 --> 00:07:27,009
像明星或 捕获 IP和我 

144
00:07:24,066 --> 00:07:27,090
不同的笔

145
00:07:35,094 --> 00:07:47,099
我说你知道IP加再加然后IP 

146
00:07:43,083 --> 00:07:55,125
将获得IP加什么没有人知道 

147
00:07:48,044 --> 00:07:58,059
（是）所以这是一个混乱和看到这 

148
00:07:56,025 --> 00:08:02,049
记得 是一样的话说IP加 

149
00:07:58,059 --> 00:08:04,152
等于1，但你实际上在做什么 

150
00:08:02,049 --> 00:08:09,123
被递增该的数 

151
00:08:05,052 --> 00:08:12,057
通过4 P的值，因为你要 

152
00:08:10,023 --> 00:08:15,117
指针，当你从一个 地方跳到 

153
00:08:13,002 --> 00:08:18,018
另一个你想让 它通过递增 

154
00:08:16,017 --> 00:08:26,040
足够的字节指向下一个

155
00:08:18,018 --> 00:08:31,086
整数在这种情况下，对于IP等 

156
00:08:26,004 --> 00:08:36,045
类似阀的 1表示该值X 

157
00:08:31,086 --> 00:08:40,134
再加上4，因为它是一个的地址 

158
00:08:36,081 --> 00:08:42,180
顺便说阵列中的下一个整数的

159
00:08:41,034 --> 00:08:46,092
一件事的阵列之间不同

160
00:08:43,008 --> 00:08:48,087
一个指针是我不能说瓦尔加上加 

161
00:08:46,092 --> 00:08:51,165
好吧 ，我不能改变的 有效 价值 

162
00:08:49,059 --> 00:08:55,092
固定由该声明 而 

163
00:08:52,065 --> 00:08:57,138
指针我可以增加它，我可以 改变 

164
00:08:55,092 --> 00:09:03,092
它以不同的 方式 和同样 

165
00:08:58,038 --> 00:09:06,072
2符号大号说给我 

166
00:09:03,092 --> 00:09:09,188
的 第二元件的地址 

167
00:09:06,072 --> 00:09:12,159
阵列所以这将 是在X 加上8和 

168
00:09:10,088 --> 00:09:17,126
这又是根本的一个 

169
00:09:13,059 --> 00:09:17,126
的性质看到，

170
00:09:22,097 --> 00:09:28,148
基本上在NC，如果你把一个指针

171
00:09:37,075 --> 00:09:40,093
这是粗鲁 

172
00:09:43,024 --> 00:09:51,068
这是不是写得很好的眼睛 

173
00:09:45,068 --> 00:09:53,069
这些 是等价的说法对 

174
00:09:51,068 --> 00:09:53,117
有 只有 两个符号 的相同 

175
00:09:53,069 --> 00:09:56,150
事情

176
00:09:54,017 --> 00:10:03,046
等上半部分它说，IP 加 二 

177
00:09:57,005 --> 00:10:05,060
实际上这意味着增加 8〜我撒尿，然后 

178
00:10:03,046 --> 00:10:08,072
解引用它的同 

179
00:10:06,005 --> 00:10:13,043
发现阵列的的第二个元素 

180
00:10:08,072 --> 00:10:14,081
的其中IP 是假想数组指示 

181
00:10:13,043 --> 00:10:17,105
数组的开头，这样的一个 

182
00:10:15,062 --> 00:10:19,103
看的 非常基本原则 

183
00:10:18,005 --> 00:10:22,022
指针再次这一整体思路

184
00:10:20,003 --> 00:10:27,011
算术是相当独特的，看 

185
00:10:22,022 --> 00:10:32,039
问题是 

186
00:10:27,011 --> 00:10:36,086
编译器会很乐意让你使用 

187
00:10:32,039 --> 00:10:39,041
对数组的下标，它的负值 

188
00:10:36,086 --> 00:10:42,113
会给你一个潜在的不确定

189
00:10:39,059 --> 00:10:44,117
价值，但没有什么用C是

190
00:10:43,013 --> 00:10:47,039
防止你界发放 

191
00:10:45,017 --> 00:10:49,031
无论是数字，是太大的 

192
00:10:47,039 --> 00:10:53,135
阵列或太小的数组有 

193
00:10:49,031 --> 00:10:57,067
没有边界检查， 这是如果我们有 

194
00:10:54,035 --> 00:11:00,064
一些有趣的 梅根 和灾难 

195
00:10:57,067 --> 00:11:03,094
对这个 问题这一点变得什么 

196
00:11:00,064 --> 00:11:07,099
关于负指数和 答案 

197
00:11:03,094 --> 00:11:15,160
因为在换句话说很简单

198
00:11:07,099 --> 00:11:17,101
一般 像IP 加X也许 

199
00:11:16,006 --> 00:11:24,013
那里可以看到它 

200
00:11:18,019 --> 00:11:32,028
我应该尝试一种突破是真的 

201
00:11:25,003 --> 00:11:32,082
相当于IT加4倍

202
00:11:34,589 --> 00:11:46,690
所以这是符号，直到我们 

203
00:11:44,062 --> 00:11:49,069
导你和右侧 

204
00:11:46,069 --> 00:11:52,138
是计算的 ，所以你看你 

205
00:11:50,032 --> 00:11:54,921
使用你不必给它写

206
00:11:53,038 --> 00:11:56,187
比例因子对你的数据类型 

207
00:11:55,209 --> 00:11:58,380
否则会把你 出 你的 

208
00:11:56,529 --> 00:12:02,290
心神

209
00:11:58,038 --> 00:12:03,807
但你偷偷下当

210
00:12:02,029 --> 00:12:06,085
编译器生成我们将看到的代码 

211
00:12:04,149 --> 00:12:09,670
这方面的例子是缩放 一切 

212
00:12:06,085 --> 00:12:10,141
所以现在 被问 的 问题 

213
00:12:09,067 --> 00:12:13,108
是，如果X是什么负数 

214
00:12:11,041 --> 00:12:15,133
以及规则仍然适用， 这只是 

215
00:12:14,008 --> 00:12:19,060
最后的结果 将 小于 

216
00:12:16,033 --> 00:12:21,912
IP而不是比IP更高，但它的 

217
00:12:19,006 --> 00:12:23,083
完全有效的 C，实际上有 

218
00:12:22,209 --> 00:12:32,350
有时你会在这学期我可以用它

219
00:12:24,037 --> 00:12:36,058
答应你的问题是 你怎么知道 

220
00:12:32,035 --> 00:12:38,088
你不能写加IP试试吧 

221
00:12:36,058 --> 00:12:42,091
我敢肯定你不能这样做，在

222
00:12:38,088 --> 00:12:43,737
指针算法尝试，如果有人 

223
00:12:42,091 --> 00:12:45,190
要搞键入一些代码，做我 

224
00:12:44,529 --> 00:12:48,700
不要以为 你能做到这一点，但如果你 

225
00:12:46,009 --> 00:12:50,023
没那就要 弄清楚 的是 

226
00:12:48,007 --> 00:12:53,041
你知道解析器知道数据类型 

227
00:12:51,004 --> 00:12:56,008
它的两个参数所以是你能 

228
00:12:54,004 --> 00:12:57,055
可能做到 这一点我从来没有 见过这个你 

229
00:12:56,008 --> 00:12:59,047
能做到这一点，但是编译器会知道 

230
00:12:57,055 --> 00:13:01,081
该的参数之一是一个指针 

231
00:12:59,047 --> 00:13:04,123
因此，缩放等你 

232
00:13:01,081 --> 00:13:07,123
不能做的就是添加两个指针，你 可以 

233
00:13:05,023 --> 00:13:09,070
走差异化，以两个指针这个

234
00:13:08,023 --> 00:13:13,039
是模糊的，我也不打算告诉 

235
00:13:09,007 --> 00:13:15,016
你这个把它挂在 KNR 但你 

236
00:13:13,039 --> 00:13:17,068
可以做算术，但你只能 为 

237
00:13:15,079 --> 00:13:19,068
此外，它只能是 一个指针， 

238
00:13:17,068 --> 00:13:21,136
一个，然后另一个必须是一个 

239
00:13:19,779 --> 00:13:24,790
定期整数值，它会扩展 

240
00:13:22,036 --> 00:13:27,088
它适当地让我相信 你能做到 

241
00:13:24,079 --> 00:13:28,138
它它只是有人将上揍你 

242
00:13:27,088 --> 00:13:32,145
在手背上 ，如果你真的 

243
00:13:29,038 --> 00:13:38,187
写代码不够好，但不是编译 

244
00:13:33,045 --> 00:13:41,098
所以特别是你知道你可以的，如果你 

245
00:13:38,529 --> 00:13:44,500
超越了这样的一个数组的边界 

246
00:13:41,098 --> 00:13:44,190
你会得到什么是登天 

247
00:13:44,005 --> 00:13:47,534
该数组的 

248
00:13:45,009 --> 00:13:49,050
它可能是一个无效的 或者它可能 

249
00:13:48,029 --> 00:13:52,320
甚至不是 一个有效的地址，你会得到 

250
00:13:50,031 --> 00:13:56,058
段故障 但更典型地 

251
00:13:52,032 --> 00:13:59,055
你会得到一些随便多 

252
00:13:56,058 --> 00:14:00,090
在那里，这不是那么糟糕，当你 

253
00:13:59,055 --> 00:14:03,057
读它，但你也可以潜在地 

254
00:14:00,009 --> 00:14:06,045
把它写在我们之前看到的腐败 

255
00:14:03,075 --> 00:14:08,118
数据中已有的内存中，因此这里的 

256
00:14:07,026 --> 00:14:13,095
再次相同的 语句我正在 

257
00:14:09,018 --> 00:14:15,117
该IP 阀前加我只是得到 

258
00:14:13,095 --> 00:14:17,174
缩放计算将是的值

259
00:14:16,017 --> 00:14:20,626
起始地址加 四倍 

260
00:14:18,029 --> 00:14:20,104
无论眼睛

261
00:14:23,091 --> 00:14:28,186
让我们看一下，这样的 排序 

262
00:14:27,052 --> 00:14:33,058
这是所有看到的一切我之前说的 

263
00:14:29,086 --> 00:14:34,138
只是基本 看 的东西，现在让我们开始 

264
00:14:33,058 --> 00:14:38,065
看实际的机器 代码 

265
00:14:35,038 --> 00:14:43,132
参与等我提出了 这个例子 

266
00:14:38,065 --> 00:14:47,089
在这儿，我宣布每三个数组

267
00:14:44,032 --> 00:14:50,040
与五和我通过什么 

268
00:14:47,089 --> 00:14:53,107
考虑排序的，当 你 的好形式 

269
00:14:50,004 --> 00:14:55,072
建立数据 ，而不必 

270
00:14:54,007 --> 00:14:58,093
任意常数通过洒

271
00:14:56,008 --> 00:15:02,008
你的程序通常被称为幻数 

272
00:14:58,093 --> 00:15:02,188
您改用一斤定义和

273
00:15:02,008 --> 00:15:06,103
你给它一个有意义的名字和 

274
00:15:03,088 --> 00:15:09,136
在顶部的一些文件，通常 

275
00:15:07,003 --> 00:15:12,055
一个文件或 一个点.h文件，然后 

276
00:15:10,036 --> 00:15:14,041
类型定义是一个非常方便的方式，如果你是 

277
00:15:12,055 --> 00:15:16,141
要创建复杂的数据结构 

278
00:15:14,086 --> 00:15:19,158
我强烈建议你排序突破 

279
00:15:17,041 --> 00:15:22,126
到这类型的死亡， 因为 

280
00:15:20,058 --> 00:15:25,069
在C声明符号变得相当 

281
00:15:23,026 --> 00:15:29,050
掩盖相当迅速，但是这一切都是

282
00:15:25,069 --> 00:15:32,167
俗话说是数据类型我要去 

283
00:15:29,005 --> 00:15:36,046
调用一个zip didge被定义为五 

284
00:15:33,067 --> 00:15:39,124
5个int数组， 现在每当我 

285
00:15:36,091 --> 00:15:41,137
说拉链做了什么，我 只是突然出现 

286
00:15:40,024 --> 00:15:46,105
下来我说这是五个数组 

287
00:15:42,037 --> 00:15:48,079
诠释，所以我创造了 他们 三人 用 

288
00:15:47,005 --> 00:15:53,023
为适当的深度码 

289
00:15:48,079 --> 00:15:56,094
这里的学校代表，现在我

290
00:15:53,023 --> 00:16:00,028
只是弥补了演示着想 

291
00:15:56,094 --> 00:16:01,132
一般这些实际地址 

292
00:16:00,028 --> 00:16:05,032
你没有 过任何 的控制 和 

293
00:16:02,032 --> 00:16:06,124
我做起来 ， 使 它们都发生在 

294
00:16:05,032 --> 00:16:09,079
在连续的内存部分和 

295
00:16:07,024 --> 00:16:11,068
再没有根本的原因，

296
00:16:09,079 --> 00:16:13,123
这样你就可以 永远不要相信应该是真实的

297
00:16:11,068 --> 00:16:15,076
什么特定的地址什么是有史以来 

298
00:16:14,023 --> 00:16:18,058
要在被分配但你 

299
00:16:16,048 --> 00:16:22,086
肯定的是， 这些块的 每 将 

300
00:16:18,058 --> 00:16:22,086
是20个字节的连续集合

301
00:16:23,035 --> 00:16:30,067
所以这里的一些示例代码，然后说

302
00:16:27,007 --> 00:16:34,026
我想检索其中之一

303
00:16:30,067 --> 00:16:38,089
阵列我想检索元素

304
00:16:34,089 --> 00:16:40,092
其索引数字，这得到 

305
00:16:38,089 --> 00:16:42,127
变成下面的代码，以便 

306
00:16:40,092 --> 00:16:45,118
还记得第一个参数这将 

307
00:16:43,027 --> 00:16:49,054
是指针现在将被传递

308
00:16:46,018 --> 00:16:51,082
寄存器RDI和第二将它会 

309
00:16:49,054 --> 00:16:54,133
为 INT将被传递并注册 

310
00:16:51,082 --> 00:16:58,084
RSI， 我想 离开这里什么

311
00:16:55,033 --> 00:17:01,087
是一个int， 所以 你看 它这里的 

312
00:16:59,002 --> 00:17:04,017
该缩放处理，这是其中

313
00:17:01,087 --> 00:17:05,182
正是它的设计 以及为什么 

314
00:17:04,017 --> 00:17:10,066
为什么他们去加入的麻烦 

315
00:17:06,082 --> 00:17:12,087
那种花哨的地址模式的x86 

316
00:17:10,066 --> 00:17:15,070
因为这是这样一个共同的 东西 ，所以 

317
00:17:13,032 --> 00:17:18,291
记住这说的是采取RDI 

318
00:17:16,006 --> 00:17:21,100
并加入到它，你将得到什么 

319
00:17:18,579 --> 00:17:24,670
四，所以你的规模乘以RSI 

320
00:17:22,000 --> 00:17:26,008
那当然这也 正是 

321
00:17:24,067 --> 00:17:29,125
计算我们想如果我们比较做

322
00:17:26,008 --> 00:17:36,061
它给 你知道 这是什么 ，我们在做 什么 

323
00:17:30,025 --> 00:17:44,047
试图让计算它正是它的 

324
00:17:37,033 --> 00:17:45,100
这里正是这种计算和 

325
00:17:44,047 --> 00:17:48,100
为我们提供了一个地址，然后我们 

326
00:17:46,000 --> 00:17:51,067
从该 地址读取和我们 

327
00:17:49,000 --> 00:17:53,083
将它复制EAX记住这是 

328
00:17:51,067 --> 00:17:57,118
在一个总是在e-版本的 

329
00:17:53,083 --> 00:17:59,089
下4个字节寄存器RAF的，这就是 

330
00:17:58,018 --> 00:18:02,107
所有的代码才能实现这个 

331
00:17:59,089 --> 00:18:07,174
特定操作 是RDI是基 

332
00:18:03,007 --> 00:18:09,104
地址与 没事 啊，我 

333
00:18:08,074 --> 00:18:13,085
右边

334
00:18:10,004 --> 00:18:17,026
是啊，这是一个错字谢谢谢谢

335
00:18:13,085 --> 00:18:20,120
指点一下，我会记下那 

336
00:18:17,026 --> 00:18:23,117
右所以这张幻灯片是不正确的，

337
00:18:21,002 --> 00:18:29,063
我会解决它 所以这 应该是我们的二 

338
00:18:24,017 --> 00:18:32,074
加上RSI正确的感谢注意 

339
00:18:29,081 --> 00:18:31,174
这让我使它 

340
00:18:36,047 --> 00:18:51,062
还好所以现在 就让我们来看 一个 

341
00:18:43,097 --> 00:18:52,154
特别另一个遥远的代码 是什么 

342
00:18:51,062 --> 00:18:55,148
如果我想 经历这些中的一个 

343
00:18:53,054 --> 00:18:58,070
阵列和对于的每个元素

344
00:18:56,048 --> 00:19:01,064
阵列添加一个给它 如此每递增 

345
00:18:58,007 --> 00:19:02,075
通过一个孔首先单个元件

346
00:19:01,064 --> 00:19:05,137
你可以看到， 我们正在建立一个循环 

347
00:19:03,038 --> 00:19:10,073
并且它采用跳到中间 

348
00:19:06,037 --> 00:19:13,037
企业里最初的部分是 

349
00:19:10,073 --> 00:19:17,129
跳转到测试，所有测试 

350
00:19:13,037 --> 00:19:20,063
包括增加了我们对X对 我 

351
00:19:18,029 --> 00:19:28,057
在这里，我们正在增加，并 

352
00:19:20,063 --> 00:19:32,072
在不同的地方 ，但比较庵 它 

353
00:19:28,057 --> 00:19:37,064
这里的代码，不会对行 

354
00:19:32,072 --> 00:19:41,087
所有的实际工作再次它采取 的 

355
00:19:37,064 --> 00:19:44,159
冰元素这是我们的斧头 缩放 

356
00:19:41,087 --> 00:19:47,141
由四个它添加到的基 

357
00:19:45,059 --> 00:19:50,120
阵列，并且为我们提供了一个地址 ， 

358
00:19:48,041 --> 00:19:52,124
现在还记得，你可以 有一个 

359
00:19:51,002 --> 00:19:56,006
算术指令，其中所述第二

360
00:19:53,024 --> 00:19:57,119
操作数目的地是存储器 

361
00:19:56,024 --> 00:20:01,031
参考什么这实际上 

362
00:19:58,019 --> 00:20:05,105
要求是先读取原来的 

363
00:20:01,094 --> 00:20:07,115
从内存值 做加法 

364
00:20:06,005 --> 00:20:11,069
然后将结果存储回内存 

365
00:20:08,015 --> 00:20:14,048
所以这一个指令是完全 

366
00:20:11,069 --> 00:20:18,076
加密这样加上加操作 

367
00:20:14,048 --> 00:20:18,076
对数组中的该存储的数据

368
00:20:21,036 --> 00:20:29,088
哦，对了，我应该提全 

369
00:20:25,098 --> 00:20:32,166
指针运算和和Si的想法

370
00:20:29,088 --> 00:20:35,100
是一个SI是真正的人，谁知道 

371
00:20:33,066 --> 00:20:38,067
编程的汇编代码的大部分 

372
00:20:36,000 --> 00:20:40,008
他们的生活想着 我 怎么可能 

373
00:20:38,076 --> 00:20:42,084
让这个看起来像一个 高层次的 

374
00:20:40,008 --> 00:20:44,064
语言 ，但把所有的灵活性 

375
00:20:42,084 --> 00:20:46,133
所有的招数我学会在 玩 

376
00:20:44,064 --> 00:20:48,111
在编程语言汇编代码 

377
00:20:47,033 --> 00:20:50,037
因为它的设计 是 

378
00:20:49,011 --> 00:20:52,023
最初设计到实施 

379
00:20:50,073 --> 00:20:54,162
操作系统UNIX操作系统 

380
00:20:52,023 --> 00:20:56,097
系统和历史操作 

381
00:20:55,062 --> 00:20:59,121
系统是在直接写

382
00:20:56,097 --> 00:21:04,098
汇编代码和这些人Kernighan的 

383
00:21:00,021 --> 00:21:08,073
里奇丹尼斯·里奇，并意识到， 

384
00:21:04,098 --> 00:21:10,182
要做到这一点的方式是那种 建立 

385
00:21:08,073 --> 00:21:14,130
浮点运算成编程 

386
00:21:11,082 --> 00:21:17,135
语言，所以反正 我 之所以 敢 

387
00:21:15,003 --> 00:21:21,012
说你看这是一个相当接近 

388
00:21:18,035 --> 00:21:24,087
对应此指令之间 

389
00:21:21,039 --> 00:21:26,067
和机器代码和构建体 在一个 

390
00:21:24,087 --> 00:21:28,131
方案C编程语言 

391
00:21:26,067 --> 00:21:31,071
而全加加上运营商和 

392
00:21:29,031 --> 00:21:35,037
加等于就是那种你看到的东西

393
00:21:31,071 --> 00:21:37,110
机构的变化和我们代码 确定 

394
00:21:35,091 --> 00:21:43,104
所以这是一种单一 维度 的 

395
00:21:38,001 --> 00:21:51,015
阵列，我想 只是改变的事情 

396
00:21:44,004 --> 00:21:55,005
增长在 看看 有点 什么 

397
00:21:51,024 --> 00:21:57,030
真正的区别是阵列之间

398
00:21:55,014 --> 00:22:02,037
在编程语言指针

399
00:21:57,084 --> 00:22:05,087
在C等我有一对夫妇的 这些 

400
00:22:02,037 --> 00:22:09,075
我会 通过一个 带出 一个 实例 

401
00:22:06,014 --> 00:22:12,038
但这个想法是你看 

402
00:22:09,075 --> 00:22:14,076
声明在左边 有 

403
00:22:12,038 --> 00:22:19,080
一些所谓的A1和 被叫的东西 

404
00:22:14,085 --> 00:22:23,091
2 这样称呼那些子 米，现在 我 什么 

405
00:22:19,008 --> 00:22:26,025
想知道这些IS的呢 

406
00:22:24,045 --> 00:22:29,139
它编译这是一个 有效的声明 

407
00:22:26,097 --> 00:22:31,128
C II有这种可能给我一个 

408
00:22:30,039 --> 00:22:34,056
空指针引用，因为我是 

409
00:22:32,028 --> 00:22:37,115
引用指针 

410
00:22:34,056 --> 00:22:41,091
对于其中我还没有 实际 

411
00:22:38,015 --> 00:22:44,022
对于所分配的空间

412
00:22:41,091 --> 00:22:45,150
指针指示我没有我没有 

413
00:22:44,022 --> 00:22:49,053
初始化指向有效

414
00:22:46,005 --> 00:22:51,102
内存参考，最后，如果我 

415
00:22:49,053 --> 00:22:59,145
在其上使用的 sizeof操作符

416
00:22:52,047 --> 00:23:01,122
与和包括特定值

417
00:23:00,045 --> 00:23:12,090
对那里的以星形的情况下 

418
00:23:02,022 --> 00:23:14,025
它的前面和 其中的一部分 是 

419
00:23:12,009 --> 00:23:16,011
理解上的差异则之间

420
00:23:14,025 --> 00:23:20,027
数组和一个指针和主 

421
00:23:17,001 --> 00:23:23,001
原因， 这主要因素是一个数组 

422
00:23:20,027 --> 00:23:26,111
当你声明一个数组，看看你 

423
00:23:23,001 --> 00:23:29,070
双方你实际分配空间

424
00:23:27,011 --> 00:23:33,030
空间被 分配 的地方 

425
00:23:29,079 --> 00:23:36,105
对于它，你要创建一个使用 

426
00:23:33,003 --> 00:23:39,081
允许现在使用的雷名 

427
00:23:37,005 --> 00:23:42,066
指针运算而当你刚 

428
00:23:40,008 --> 00:23:44,013
在退役声明指针所有你 

429
00:23:42,066 --> 00:23:46,095
分配是指针的空间 

430
00:23:44,058 --> 00:23:55,059
本身，而不是任何东西，它的 

431
00:23:46,095 --> 00:23:56,124
你指着所以只是-你 

432
00:23:55,068 --> 00:23:59,087
大概想通了 ，这些都 

433
00:23:57,024 --> 00:23:59,087
编

434
00:24:00,094 --> 00:24:11,763
让我得到我的首席首席安迪很好，但

435
00:24:04,539 --> 00:24:15,620
这将是 在这里如果一个一个的大小 

436
00:24:12,609 --> 00:24:15,683
我跑了运营商的规模上 

437
00:24:23,078 --> 00:24:34,133
让我们做一个更容易的什么大小 

438
00:24:26,028 --> 00:24:38,082
一二八因为 指针 

439
00:24:35,033 --> 00:24:44,090
什么是一个大小的一个是一个 

440
00:24:38,082 --> 00:24:44,090
在 12右侧 三 的阵列

441
00:24:47,179 --> 00:24:53,440
噢，那这些都不是 没有哎呀 

442
00:24:55,033 --> 00:25:13,132
现在如果我说 一个 明星 或发起一个 

443
00:25:02,021 --> 00:25:15,240
-那些既能编译既可以 

444
00:25:13,429 --> 00:25:26,485
他们可能的给你一个空 

445
00:25:15,429 --> 00:25:31,522
提领哦，是指针本身是 

446
00:25:26,989 --> 00:25:34,820
没有但我已不会解除引用 

447
00:25:32,359 --> 00:25:37,410
这又是一个空指针，但我没有

448
00:25:34,082 --> 00:25:40,133
这不是一个坏的潜在的不良参考

449
00:25:37,869 --> 00:25:43,870
右它不是一个 运行时我将创建一个 

450
00:25:41,033 --> 00:25:46,432
运行时错误，如果我只是说了 -在我 

451
00:25:43,969 --> 00:25:49,033
码好了，所以我前面的你的脚步 

452
00:25:46,729 --> 00:25:51,950
所以基本上它你有种回答 

453
00:25:49,609 --> 00:25:53,707
虽然这一个第二个问题

454
00:25:51,095 --> 00:25:55,234
可以给你一个空指针错误，如果 

455
00:25:54,589 --> 00:25:57,682
您尝试 取消引用 指针 

456
00:25:56,089 --> 00:26:02,182
尚未初始化 它没有指向 

457
00:25:58,519 --> 00:26:07,560
任何东西，而这一次是罚款和 

458
00:26:03,019 --> 00:26:15,070
现在什么是明星的一个的大小

459
00:26:07,929 --> 00:26:17,962
1/4和大约明星2/4什么呀 

460
00:26:15,007 --> 00:26:20,476
因为他们都指向结束，因此 

461
00:26:18,259 --> 00:26:24,264
考虑这个问题的一种方式是作为

462
00:26:20,539 --> 00:26:24,561
图片一 

463
00:26:26,094 --> 00:26:34,683
就像我们一直在这里展示它是一个 

464
00:26:30,097 --> 00:26:38,736
的阵列， 用于intz 并且当我声明 

465
00:26:35,529 --> 00:26:42,543
一个我分配所有这样的程序 

466
00:26:39,609 --> 00:26:46,090
被分配12个字节的存储空间这是的 

467
00:26:42,669 --> 00:26:54,720
可以认为， 一个 2， 另一方面 

468
00:26:46,009 --> 00:26:57,708
只是一个指针 ，我会告诉那里 

469
00:26:54,072 --> 00:26:59,841
直到它的8个字节长，但它不 

470
00:26:57,789 --> 00:27:03,846
点什么，这样的 话是什么意思 

471
00:27:00,489 --> 00:27:05,505
如果你想 对我说星2 你 

472
00:27:04,359 --> 00:27:09,384
潜在地具有一个空指针 

473
00:27:05,649 --> 00:27:12,702
参考提领在那里等 

474
00:27:09,609 --> 00:27:15,100
这就是为什么这 是8，这是12这样 

475
00:27:13,179 --> 00:27:17,225
这些都是热身 1，让我们使它 

476
00:27:15,001 --> 00:27:17,540
更有趣 

477
00:27:27,034 --> 00:27:31,088
这些都不是在幻灯片中，你会发现 

478
00:27:29,096 --> 00:27:36,185
但我会我会更新的幻灯片 

479
00:27:31,088 --> 00:27:39,161
后来包括这些我会，但我 认为 

480
00:27:37,085 --> 00:27:42,179
如果你觉得这点

481
00:27:40,061 --> 00:27:45,158
混乱这是一个迹象，表明你真的 

482
00:27:43,079 --> 00:27:49,148
真的 需要了解什么 

483
00:27:46,058 --> 00:27:51,083
指针是什么一个数组，以及如何

484
00:27:50,048 --> 00:27:55,121
它们是相同的，他们是如何 

485
00:27:51,083 --> 00:27:57,170
不同的，因为这是它的一个它是一个 

486
00:27:56,021 --> 00:28:01,240
规划的核心部分，并看到 

487
00:27:58,007 --> 00:28:02,051
会导致混乱的无尽小时 

488
00:28:01,429 --> 00:28:09,380
如果你真的没有这个有线下来 

489
00:28:03,014 --> 00:28:11,683
相当强烈，所以让我给你 

490
00:28:09,038 --> 00:28:13,052
什么是如此有趣的一个预览 

491
00:28:11,809 --> 00:28:16,070
这是我要给你一些 

492
00:28:13,052 --> 00:28:19,057
数字，然后我们将 不得不 

493
00:28:16,007 --> 00:28:19,102
解释这些数字是如何来到我身边 

494
00:28:31,027 --> 00:28:40,070
好了，所以让我们尝试和了解什么是 

495
00:28:38,051 --> 00:28:42,100
发生在这里，你会看到， 所有的 

496
00:28:40,007 --> 00:28:45,008
这些声明涉及一些 

497
00:28:42,559 --> 00:28:48,260
指针和阵列和的组合

498
00:28:45,008 --> 00:28:53,045
的问题是它是一个指向数组的指针 

499
00:28:48,026 --> 00:28:56,045
是它的指针 和所述 的阵列 

500
00:28:54,017 --> 00:28:58,115
回答这些将取决于

501
00:28:56,045 --> 00:29:00,116
特定语法所以当然第一 

502
00:28:59,015 --> 00:29:05,018
一个 是一个你 以前 已经看过 

503
00:29:01,016 --> 00:29:07,085
所以你知道，编译和它的 

504
00:29:05,045 --> 00:29:10,112
不知道， 你可以取消对它的引用和 

505
00:29:07,085 --> 00:29:15,107
它不为空，但如果你试着说 明星 

506
00:29:11,012 --> 00:29:18,029
星一 ，这不是 有效的它不会 

507
00:29:16,007 --> 00:29:23,015
甚至编译 ，因为你想 

508
00:29:18,029 --> 00:29:24,113
这里需要明星的 数据类型 ，是 

509
00:29:23,015 --> 00:29:28,022
诠释，然后你想 坐 

510
00:29:25,013 --> 00:29:32,020
解引用一个int，以便将编译 

511
00:29:28,085 --> 00:29:35,087
因此，你甚至不能进行测试 

512
00:29:32,083 --> 00:29:40,088
还好 ，问题 是这些 其他 

513
00:29:36,005 --> 00:29:45,037
你们三个可以看到， 不知怎的 ， 一个是 

514
00:29:41,033 --> 00:29:50,069
那么让我们来看看在底部的两个第一 

515
00:29:45,037 --> 00:29:52,055
所以底部的一个说，和 

516
00:29:50,069 --> 00:29:53,132
这是一部分，实际上是一个有

517
00:29:52,055 --> 00:29:55,124
在 Kernighan的 真正 伟大的部分 

518
00:29:54,032 --> 00:29:58,094
里奇，我强烈建议你 

519
00:29:56,024 --> 00:30:01,049
这是怎么 读指针如何 

520
00:29:58,094 --> 00:30:02,165
阅读声明并看到和基本 

521
00:30:01,049 --> 00:30:06,095
规则是你从内开始， 

522
00:30:03,065 --> 00:30:12,151
你的工作你的 方式向外使 

523
00:30:06,095 --> 00:30:12,151
的 A3 说， 声明 

524
00:30:15,048 --> 00:30:21,113
与括号说三是 

525
00:30:24,289 --> 00:30:27,860
什么是 胜利 

526
00:30:30,014 --> 00:30:32,020
您

527
00:30:32,045 --> 00:30:38,048
三是一个指针 ，以括号 

528
00:30:37,001 --> 00:30:41,069
周围

529
00:30:38,048 --> 00:30:43,069
这是什么指向它指向一个 

530
00:30:41,069 --> 00:30:54,077
三英寸阵列

531
00:30:43,069 --> 00:31:02,152
好了，所以我们可以关系图三再到 

532
00:30:55,049 --> 00:31:03,052
是这样的

533
00:31:11,054 --> 00:31:16,095
三是一个指针，就像我所说的阅读 

534
00:31:16,011 --> 00:31:21,090
由内而外 

535
00:31:16,095 --> 00:31:23,133
三为指针，是什么 

536
00:31:21,009 --> 00:31:25,098
指向它指向3的阵列 

537
00:31:24,033 --> 00:31:31,047
元素和什么类型的元素是 

538
00:31:26,079 --> 00:31:33,120
他们在那里，所以 你要排序的阅读 

539
00:31:31,047 --> 00:31:35,085
向外和拾取从比萨饼 

540
00:31:34,002 --> 00:31:39,039
右和左，你这样做 

541
00:31:35,085 --> 00:31:42,144
所以，当你知道 ，这 一切都使 

542
00:31:39,057 --> 00:31:46,119
某种意义上说 ， 这些 数字A3大小 

543
00:31:43,044 --> 00:31:50,112
本身是八，但因为它指向 

544
00:31:47,019 --> 00:31:56,106
三个星一个的尺寸的阵列

545
00:31:51,012 --> 00:31:59,070
三是十二点那么 明星明星 

546
00:31:57,006 --> 00:32:02,031
其中3位表示这个特定的

547
00:31:59,007 --> 00:32:06,012
该阵列的元件，所以它尺寸 

548
00:32:02,031 --> 00:32:08,058
四个，这些都编译，但其中的 

549
00:32:06,075 --> 00:32:12,137
他们可能会导致空指针

550
00:32:08,058 --> 00:32:12,137
解引用其中左边 两个 

551
00:32:16,087 --> 00:32:28,266
是的，你可以翻转硬币是很好，我只 

552
00:32:27,007 --> 00:32:32,059
看着它我试图填写 

553
00:32:29,049 --> 00:32:35,320
3，现在这样 三是不错，但 

554
00:32:33,022 --> 00:32:42,971
如果我说明星三可能是有 

555
00:32:35,032 --> 00:32:46,033
问题空指针是为什么，因为 

556
00:32:43,169 --> 00:32:48,820
当我在这里宣布了三 所有我 

557
00:32:46,033 --> 00:32:50,050
声明是这个特殊的，我只是 

558
00:32:48,082 --> 00:32:52,671
分配为足够的存储空间 

559
00:32:50,005 --> 00:32:54,079
指针我有一个 初步的很多我没有 

560
00:32:53,409 --> 00:32:57,250
分配的空间用于阵列我

561
00:32:55,024 --> 00:32:59,062
没有初始化的三到实际 

562
00:32:57,025 --> 00:33:01,069
指向的数组所以它 可能 是一个空 

563
00:32:59,062 --> 00:33:03,085
指针时，它可以是任意的，但垃圾

564
00:33:01,069 --> 00:33:04,135
它它的机会实际上是指向 

565
00:33:03,085 --> 00:33:08,110
到三英寸 的阵列 是高度 

566
00:33:05,035 --> 00:33:11,083
不可能因此这将是一个潜在的 

567
00:33:09,001 --> 00:33:16,440
糟糕，因此双星双 

568
00:33:11,083 --> 00:33:23,086
往右打死好了，现在让我们来看看一个 

569
00:33:16,539 --> 00:33:29,980
四个，四个明白，你 

570
00:33:24,013 --> 00:33:33,094
其实有看走势图和 

571
00:33:29,098 --> 00:33:35,098
看看你是哪的先例图 

572
00:33:33,094 --> 00:33:37,177
像我这样你的书落在持开放 的态度 

573
00:33:35,098 --> 00:33:40,177
优先图表不同的运营商 

574
00:33:38,077 --> 00:33:44,113
和他们是什么水平，一件事 

575
00:33:41,077 --> 00:33:45,148
你会看到的是一个级别 的 一个 

576
00:33:45,013 --> 00:33:51,015
优先级最高的优先级 

577
00:33:46,048 --> 00:33:55,737
包括方括号和水平 

578
00:33:51,033 --> 00:33:59,742
包括换句话说星托架是

579
00:33:56,169 --> 00:34:03,194
更高的优先级和星级所以这

580
00:34:00,039 --> 00:34:08,640
这里特别声明

581
00:34:03,419 --> 00:34:08,640
绑定是实际上是这样的 

582
00:34:11,339 --> 00:34:22,365
它说， 四为 三 的数组 

583
00:34:17,379 --> 00:34:35,381
元素，并且这些元素是指针 

584
00:34:22,599 --> 00:34:41,740
他们还指出，在 高 ，所以四是 

585
00:34:35,399 --> 00:34:48,790
一个数组，你可以看到这一点，但每个

586
00:34:41,074 --> 00:34:51,683
这些元素是指向一个 INT 

587
00:34:48,079 --> 00:34:51,638
希望某处

588
00:34:54,046 --> 00:34:59,119
还等什么脂肪的数量相匹配

589
00:34:57,069 --> 00:35:02,250
我们有这么四个大小二 十岁 

590
00:35:00,019 --> 00:35:07,024
4周 ，因为它的八个时间的三个 

591
00:35:02,025 --> 00:35:12,121
如果我要提领的四它会 

592
00:35:07,069 --> 00:35:15,166
只是表明这个特定的指针

593
00:35:13,021 --> 00:35:20,026
右 四是一个指针数组 ，以便 

594
00:35:16,066 --> 00:35:24,975
当我得到一个元素的 是阵列的 

595
00:35:20,026 --> 00:35:28,625
我会得到一个指针等的 

596
00:35:25,569 --> 00:35:31,950
四是一个指针，所以它也可以是八个 

597
00:35:28,859 --> 00:35:35,800
但如果我现在做了第二次提领

598
00:35:31,095 --> 00:35:39,138
然后， 我会得到一个int和 它的大小是 

599
00:35:35,008 --> 00:35:39,066
4好吗 

600
00:35:42,074 --> 00:35:55,167
这些所有的 编译，所以我可以有它 

601
00:35:51,092 --> 00:36:00,128
可以开始他们的事业问题 

602
00:35:56,067 --> 00:36:00,128
只要一个空指针或床上指针 

603
00:36:01,085 --> 00:36:11,160
没有这是正确的没有是正确答案 

604
00:36:07,029 --> 00:36:16,032
无是肯定的，因为你一本您 

605
00:36:12,006 --> 00:36:19,098
一对是你们一定数组已经定义 

606
00:36:16,032 --> 00:36:22,101
数组并得到数组 分配由 

607
00:36:20,052 --> 00:36:24,135
他们作为一个LM的三个声明

608
00:36:23,001 --> 00:36:28,059
在另一方面 元件阵列 本 

609
00:36:25,035 --> 00:36:29,127
可以给你一个空指针，因为我

610
00:36:28,059 --> 00:36:34,059
没有初始化数组

611
00:36:30,027 --> 00:36:36,027
任何因此，例如，如果它是 

612
00:36:34,059 --> 00:36:39,113
初始化为全零 它只是 

613
00:36:36,027 --> 00:36:44,058
是三个该阵列中没有空指针 

614
00:36:40,013 --> 00:36:50,037
所以这是有点那个东西 

615
00:36:44,058 --> 00:36:52,074
ç 问题 的一些本质gritties 是如何 

616
00:36:50,037 --> 00:36:54,099
它知道 尺寸 其他 十二 

617
00:36:52,074 --> 00:36:56,082
正面c真的不知道多少 

618
00:36:54,099 --> 00:37:01,134
事情是在阵列中复合材料中的 

619
00:36:57,054 --> 00:37:04,122
如何编译器的问题是什么 

620
00:37:02,034 --> 00:37:08,109
我是我会到你的问题说 

621
00:37:05,022 --> 00:37:10,083
记得 编译器知道 了很多，所以在 

622
00:37:09,009 --> 00:37:13,062
特别是我已经声明这 是 

623
00:37:10,083 --> 00:37:14,136
的三分，我编译的数组

624
00:37:13,062 --> 00:37:17,091
一台机器，其中三分球八 

625
00:37:15,036 --> 00:37:22,038
字节，因此编译器 知道SP 

626
00:37:17,091 --> 00:37:24,096
24个字节一般，当你的时候 

627
00:37:22,038 --> 00:37:26,136
如果引用， 看看有没有 

628
00:37:24,096 --> 00:37:28,104
你知道机器没有内置 

629
00:37:27,036 --> 00:37:31,043
到任何边界和不做界限 

630
00:37:29,076 --> 00:37:38,109
检查你 ，但是这是在 

631
00:37:32,006 --> 00:37:41,049
运行时执行，如果但在 C，如果我当 

632
00:37:39,009 --> 00:37:43,053
我宣布的东西它是已知它有 

633
00:37:41,049 --> 00:37:45,398
在这一点上是已知的，当 

634
00:37:43,053 --> 00:37:49,512
声明 出现 

635
00:37:45,839 --> 00:37:55,630
问题回到那里所以不是 

636
00:37:49,989 --> 00:37:58,440
做了 三 我只是 想空架 

637
00:37:55,063 --> 00:38:03,672
是的，我认为闲置的支架是 它只是 

638
00:37:58,044 --> 00:38:05,883
另一名指针它通常是 

639
00:38:04,239 --> 00:38:07,293
它只是给出一些参数 

640
00:38:06,279 --> 00:38:10,287
它限制，但是当你使用 

641
00:38:07,779 --> 00:38:11,811
空括号标记，看看 它的 

642
00:38:10,359 --> 00:38:13,690
相当于做一个指针 

643
00:38:12,099 --> 00:38:21,114
声明你没有分配任何 

644
00:38:13,069 --> 00:38:23,958
它 一个现实 截然不同的空间

645
00:38:21,249 --> 00:38:26,880
区域是 在这里 它的真正 含义时， 

646
00:38:24,579 --> 00:38:28,674
声明数组，你给一个 

647
00:38:26,088 --> 00:38:35,037
确实许多阵列它的大小 

648
00:38:29,529 --> 00:38:37,536
分配是回忆，如果问题是 

649
00:38:35,829 --> 00:38:40,450
哦，是的， 这就是 最后一个，你会 

650
00:38:37,599 --> 00:38:42,670
注意到对于 a 2和a 4 中的数字 

651
00:38:40,045 --> 00:38:44,874
相同的， 原因是它的同 

652
00:38:42,067 --> 00:38:50,016
件事，再由去 

653
00:38:45,279 --> 00:38:55,305
优先规则看到， 第2 

654
00:38:50,619 --> 00:38:58,630
结合这样的，那么这个方式等 

655
00:38:55,539 --> 00:39:01,556
A 2和A 4都只是用同义

656
00:38:58,063 --> 00:39:01,142
括号少

657
00:39:02,009 --> 00:39:08,060
好了，所以这是 一个有点 题外话，但 

658
00:39:06,014 --> 00:39:10,097
你可以看到，我认为这是种 

659
00:39:09,041 --> 00:39:13,139
那 真的 会 探测你的 事 

660
00:39:10,097 --> 00:39:14,180
你的理解， 现在虽然它是一个 

661
00:39:14,039 --> 00:39:17,045
开始种子程序员，你 

662
00:39:15,008 --> 00:39:18,083
没有一个很好 的 感觉 

663
00:39:17,045 --> 00:39:20,132
程序的基本表示 

664
00:39:19,055 --> 00:39:24,056
这真的很难想这些东西 

665
00:39:21,032 --> 00:39:26,033
了，但现在你知道这意味着什么 

666
00:39:24,056 --> 00:39:28,067
编译代码， 实际上 ，你可以

667
00:39:26,033 --> 00:39:32,111
看看编译代码，会有点 

668
00:39:28,067 --> 00:39:40,130
清理了很多 什么是真正的 

669
00:39:33,011 --> 00:39:43,025
在程序正在进行所以现在让我们 

670
00:39:41,003 --> 00:39:44,006
概括从一名维两个 

671
00:39:43,025 --> 00:39:47,072
只是为了让生活多一点 

672
00:39:44,006 --> 00:39:50,027
有趣的 又一次 这是一个重要 

673
00:39:47,072 --> 00:39:51,119
原则上要明白，在一 

674
00:39:50,081 --> 00:39:55,103
要声明多维 

675
00:39:52,019 --> 00:39:57,115
数组，看看你用的序列做 

676
00:39:56,003 --> 00:40:00,098
与每一个平衡支架

677
00:39:58,015 --> 00:40:03,028
而其中的原因 其实 是 

678
00:40:00,098 --> 00:40:02,101
那里

679
00:40:06,028 --> 00:40:13,034
它会看到它有这个做 

680
00:40:11,063 --> 00:40:15,142
符号，我们刚刚 通过 ，所以如果 去 

681
00:40:13,088 --> 00:40:15,142
I段 

682
00:40:30,094 --> 00:40:40,148
事实证明，我可以读它像 

683
00:40:35,033 --> 00:40:46,040
此a 是 3 的阵列 

684
00:40:41,048 --> 00:40:48,095
元素，其中每一 元素是 

685
00:40:46,004 --> 00:40:54,011
本身五个元件的阵列

686
00:40:48,095 --> 00:40:56,144
int类型，我们会回来这一点，但 

687
00:40:54,047 --> 00:41:00,074
那种解释一切我 

688
00:40:57,044 --> 00:41:04,073
要告诉 你 在这张照片 中如此 

689
00:41:00,074 --> 00:41:07,151
特别地，如果我声明与阵列 

690
00:41:04,073 --> 00:41:10,162
我们行C列，你想到的 

691
00:41:08,051 --> 00:41:15,077
它数学上 排序的矩阵的 

692
00:41:11,062 --> 00:41:24,068
二维矩阵 它到底 

693
00:41:15,077 --> 00:41:28,133
所做的就是它说 看他是对 是的 

694
00:41:25,022 --> 00:41:31,043
有时会看到实际上结束了作为 

695
00:41:29,033 --> 00:41:38,041
内部元件它说， 首先我的 

696
00:41:31,043 --> 00:41:39,140
想行 0将 是 C的 阵列 中 的 

697
00:41:38,041 --> 00:41:42,065
是列数

698
00:41:40,004 --> 00:41:44,099
我会把0行 ，这样所有的元素 

699
00:41:42,065 --> 00:41:47,123
会首先 行 的所有元素 

700
00:41:45,035 --> 00:41:50,120
1来下并依此类推， 直到 结束 

701
00:41:48,023 --> 00:41:54,032
这一切，并因此总分配 

702
00:41:51,002 --> 00:41:56,048
将4倍的数据大小倍 

703
00:41:55,013 --> 00:41:59,090
的行数的次数 

704
00:41:56,066 --> 00:42:01,160
列字节，但为什么他们的原因 

705
00:41:59,009 --> 00:42:03,062
在被称为行主要是为了

706
00:42:02,006 --> 00:42:05,099
为了因为如果我们认为它的这些 

707
00:42:04,043 --> 00:42:08,128
我们经历了第一排的条款和 

708
00:42:06,053 --> 00:42:16,105
然后 在第三行中的第二行是 

709
00:42:09,028 --> 00:42:16,105
正是 因为 这一点 

710
00:42:18,004 --> 00:42:29,039
符号让我写 下来， 这样 

711
00:42:22,004 --> 00:42:32,069
的井INT让我使用 

712
00:42:29,075 --> 00:42:38,170
一个我说你可以这样写出来的

713
00:42:32,069 --> 00:42:39,070
一个是一个阵列 的自由所有可能是正确 

714
00:42:49,066 --> 00:42:53,101
超过一半 并选择2/3 

715
00:42:56,829 --> 00:43:04,831
我只是把它在这里 好了， 一个是 

716
00:43:01,067 --> 00:43:07,115
3元件阵列和或泛化 

717
00:43:04,849 --> 00:43:11,720
这张 图a是一个数组我们 

718
00:43:08,015 --> 00:43:14,024
元件，这 是第 一个元素这 

719
00:43:11,072 --> 00:43:17,221
为 第二元件，这是 

720
00:43:14,024 --> 00:43:26,092
艺术元素，但什么样的元素 

721
00:43:17,869 --> 00:43:26,920
是那些各自的阵列

722
00:43:28,005 --> 00:43:31,062
五分钟 

723
00:43:35,088 --> 00:43:47,121
所以阵列内的位置的一个子部分的每个

724
00:43:42,024 --> 00:43:49,116
然后是C的阵列中的和所以这是 

725
00:43:48,021 --> 00:43:53,039
为什么逻辑的方式 这些都 

726
00:43:50,016 --> 00:43:58,074
其实组织源于此 

727
00:43:53,039 --> 00:44:03,137
声明符号直接的，什么是 

728
00:43:58,074 --> 00:44:08,109
的，这些实施例，以便， 例如，如果我 

729
00:44:04,037 --> 00:44:12,054
想延长我的 拉链tidge想法和 

730
00:44:09,009 --> 00:44:18,032
介绍的这些 I 四个阵列 

731
00:44:12,054 --> 00:44:20,103
可以宣布它这种方式 ，再次用 

732
00:44:18,032 --> 00:44:23,037
记得我用 一个类型DEF声明 

733
00:44:21,003 --> 00:44:26,010
拉链tidge但如果 我是扩大这个 

734
00:44:23,082 --> 00:44:29,151
出 它会像如果我是 

735
00:44:26,073 --> 00:44:32,073
声明此数组PGH是一个四 

736
00:44:30,051 --> 00:44:35,088
五列，但它真正的

737
00:44:32,073 --> 00:44:38,124
是在 四个 元件中的 一个 的 两个 阵列 

738
00:44:35,088 --> 00:44:42,126
三四 其中 的每 一个是阵列 

739
00:44:39,024 --> 00:44:46,029
5分钟好了，所以想到的 

740
00:44:43,026 --> 00:44:48,125
当你阅读声明你筑巢

741
00:44:46,074 --> 00:44:51,150
从元素 的名称开始， 

742
00:44:49,025 --> 00:44:56,027
您完成这些工作的方式向外 

743
00:44:52,005 --> 00:44:55,100
支架和恒星以某种顺序 

744
00:44:57,509 --> 00:45:05,531
哦，所以特别是如果我想 

745
00:45:03,239 --> 00:45:07,276
引用 的 特定元件 

746
00:45:05,729 --> 00:45:16,766
排列

747
00:45:07,609 --> 00:45:18,695
总的原则 是错在这里哦 

748
00:45:17,099 --> 00:45:24,172
一般的规则是，如果我想这一个

749
00:45:19,469 --> 00:45:24,505
参考字面上 

750
00:45:25,056 --> 00:45:38,139
所以我建立它，因此这是 

751
00:45:34,074 --> 00:45:40,140
表明，第II实际上只是做 

752
00:45:39,039 --> 00:45:44,100
的II的参考不必 

753
00:45:41,004 --> 00:45:48,072
给出J的我在 C和什么 

754
00:45:45,000 --> 00:45:51,072
表示这些是 我们 的行 之一 

755
00:45:49,008 --> 00:45:56,040
阵列和其各自是阵列 

756
00:45:51,072 --> 00:45:59,085
看到int类型的元素， 因此想象 

757
00:45:56,004 --> 00:46:01,065
在一般我们有 一个数据 k字节 

758
00:45:59,085 --> 00:46:04,134
类型T在此基础数据类型 

759
00:46:02,001 --> 00:46:07,098
的T的情况下是一个int和K等于 四 

760
00:46:05,034 --> 00:46:12,063
但在一般的起始地址，然后 

761
00:46:07,098 --> 00:46:15,161
行我会通过乘以得到 

762
00:46:12,063 --> 00:46:20,141
列由K和然后 数 

763
00:46:16,061 --> 00:46:20,069
乘以由行号 

764
00:46:23,026 --> 00:46:30,079
现在如果在阵列内我想 

765
00:46:25,075 --> 00:46:32,134
引用 射线元件 的子IJ那么它 

766
00:46:30,079 --> 00:46:35,131
出现这种计算你拿 

767
00:46:33,034 --> 00:46:38,125
起始地址您缩放行

768
00:46:36,031 --> 00:46:41,038
通过列数号码添加到 

769
00:46:39,025 --> 00:46:44,098
它的列你想，然后 

770
00:46:41,038 --> 00:46:48,115
乘上所有好 了，顺便 

771
00:46:44,098 --> 00:46:53,170
看到 这里 ，我可以得到行号 

772
00:46:49,015 --> 00:46:56,101
我通过刚才的数字缩放我 

773
00:46:54,007 --> 00:47:00,076
元件的列倍大小 

774
00:46:57,001 --> 00:47:05,005
四，现在我想给JC 

775
00:47:01,039 --> 00:47:07,135
这里该子排列元素，我可以 

776
00:47:05,005 --> 00:47:10,093
做到这一点的四个缩放J 和添加 

777
00:47:08,035 --> 00:47:13,126
它 这个子数组的开头 

778
00:47:10,093 --> 00:47:15,160
现在我可以只 收集力 

779
00:47:14,026 --> 00:47:18,049
在一起，这就是将其拉 

780
00:47:16,006 --> 00:47:23,059
这里之外，这就是给你这个 

781
00:47:18,049 --> 00:47:26,068
式，以便再次在的这一点 

782
00:47:24,013 --> 00:47:30,076
是， 这都挺是一种天然 

783
00:47:26,068 --> 00:47:32,131
宣言 的结果 ，很容易 

784
00:47:30,076 --> 00:47:36,185
想起来在这个存储方面 

785
00:47:33,031 --> 00:47:39,590
模型的实际阵列是如何在这里 

786
00:47:36,869 --> 00:47:39,869
分配

787
00:47:41,066 --> 00:47:49,140
现在没事了不同风格的 

788
00:47:45,000 --> 00:47:54,033
声明想象我创造三 

789
00:47:50,004 --> 00:48:01,068
这些阵列现在我想 创建一个 

790
00:47:54,033 --> 00:48:05,058
阵列包含任命到 

791
00:48:02,004 --> 00:48:07,008
这些所以这是一个不同的数据

792
00:48:05,058 --> 00:48:09,117
结构，你会从之前观察

793
00:48:07,044 --> 00:48:12,107
什么 大学，现在是三个数组 

794
00:48:10,017 --> 00:48:17,046
在每个 这些指针的指针

795
00:48:13,007 --> 00:48:19,079
指向五个这些阵列的一个

796
00:48:17,046 --> 00:48:19,079
结束

797
00:48:21,008 --> 00:48:23,014
您

798
00:48:24,219 --> 00:48:31,223
以及由他们的基础数据类型 

799
00:48:26,041 --> 00:48:34,117
这些元素的方式是正确的星星 

800
00:48:31,619 --> 00:48:36,700
和C不区分 当你 

801
00:48:35,017 --> 00:48:38,316
要声明环这样的你 

802
00:48:36,007 --> 00:48:41,856
只说这是一个int星你不说 

803
00:48:38,469 --> 00:48:45,531
有多少元素的底层 

804
00:48:42,549 --> 00:48:48,210
数组是这样，你会被 这些图片中 看到 

805
00:48:46,089 --> 00:48:52,107
这些是不同的数据结构 

806
00:48:48,021 --> 00:48:53,880
所以现在让我们通过 什么 

807
00:48:52,269 --> 00:49:01,317
汇编代码看起来像到参考 

808
00:48:54,069 --> 00:49:07,180
这两个数据结构，我们没有做 

809
00:49:01,749 --> 00:49:12,700
我们 做了对不起我还 以为 

810
00:49:07,018 --> 00:49:16,887
我不得不汇编代码系统可能是 一个 

811
00:49:12,007 --> 00:49:19,916
缺少幻灯片你，所以我们会看到这样 

812
00:49:17,049 --> 00:49:20,105
想象一下，我想引用 

813
00:49:24,051 --> 00:49:29,084
我很抱歉， 我很困惑，为什么没有 

814
00:49:32,039 --> 00:49:34,039
啊

815
00:49:46,031 --> 00:49:49,035
他们应该已经对不起，这是 

816
00:49:49,005 --> 00:49:52,020
呃 

817
00:49:49,035 --> 00:49:58,059
因为我觉得我的意思是 ，我在这里暂停

818
00:49:52,002 --> 00:50:02,015
有一个幻灯片，将显示什么 

819
00:49:58,059 --> 00:50:01,133
代码如下，我不 

820
00:50:02,041 --> 00:50:06,045
还好我们将不得不临场发挥 

821
00:50:08,058 --> 00:50:16,125
所以，如果你想在汇编 代码 

822
00:50:12,049 --> 00:50:19,096
然后引用的阵列的元件

823
00:50:17,025 --> 00:50:21,106
像这样 的多维数组什么 

824
00:50:19,096 --> 00:50:25,131
你会看到的是，代码那种 

825
00:50:22,006 --> 00:50:30,034
建立了这样和计算

826
00:50:26,031 --> 00:50:33,040
通常在已编译的代码的值 

827
00:50:30,034 --> 00:50:36,097
钾是一种恒定值 和 

828
00:50:34,021 --> 00:50:40,042
如果它是一个已经宣布了 雷 

829
00:50:36,097 --> 00:50:43,138
恒定的界限，则C的值 

830
00:50:40,042 --> 00:50:46,048
也将是一个常数，因此一块 

831
00:50:44,038 --> 00:50:49,084
对于这段代码，这就是为什么有 

832
00:50:46,048 --> 00:50:51,121
偶然省略基本上 会 采取 

833
00:50:49,084 --> 00:50:54,088
这个值和使用的某种组合 

834
00:50:52,021 --> 00:50:58,033
存储器引用和移位和

835
00:50:55,024 --> 00:51:00,109
le.a指导等方式 来 

836
00:50:58,033 --> 00:51:04,105
实现这个计算，然后做一个

837
00:51:01,009 --> 00:51:07,051
取消引用所以让我们来看看第二

838
00:51:05,005 --> 00:51:09,007
例如并 有代码本和 

839
00:51:07,051 --> 00:51:11,077
它实际上是一个 更有点复杂 

840
00:51:09,007 --> 00:51:15,013
因为这是经历两个级别 

841
00:51:11,077 --> 00:51:21,160
间接的，所以你会看到，为了获得 

842
00:51:15,013 --> 00:51:26,086
数字从一个特定的数字 

843
00:51:22,006 --> 00:51:31,074
特别是，这些大学之一 

844
00:51:26,086 --> 00:51:35,095
那么它必须首先弄清楚 

845
00:51:32,028 --> 00:51:39,040
这样做三维引用获得一个指针 

846
00:51:36,076 --> 00:51:42,141
到数组的 开头 ，这就是 

847
00:51:39,004 --> 00:51:43,005
这是什么参考这里做什么 

848
00:51:48,031 --> 00:51:55,040
不错，但首先它在做什么是 

849
00:51:51,038 --> 00:51:58,097
换档RSA余留由 两个其 

850
00:51:55,004 --> 00:52:02,018
等效于由缩放数字 

851
00:51:58,097 --> 00:52:04,163
4，因为它准备 参加 

852
00:52:02,054 --> 00:52:11,090
参数的这一位 ，它的规模 

853
00:52:05,063 --> 00:52:19,064
适当地 ，然后需要的是 

854
00:52:11,009 --> 00:52:25,078
数量和添加到它我得到的价值 

855
00:52:19,073 --> 00:52:29,171
从 他们的排列 读 大学，但使用 

856
00:52:26,059 --> 00:52:32,123
该指数八缩放它 

857
00:52:30,071 --> 00:52:34,154
其实做一个内存引用这样 

858
00:52:33,023 --> 00:52:37,037
记住这个指令，然后它

859
00:52:35,054 --> 00:52:40,061
看起来有点怪异实际上是做了 

860
00:52:37,037 --> 00:52:43,049
这里这三个内存引用 

861
00:52:40,061 --> 00:52:45,104
称为单元的元件阵列所以它的

862
00:52:43,049 --> 00:52:48,116
从存储器中读出 和操作的方式的阵列 

863
00:52:46,004 --> 00:52:52,010
指数直接在这里通过缩放和现在 

864
00:52:49,016 --> 00:52:56,042
从 一个指针增加越来越

865
00:52:52,064 --> 00:52:59,078
该的的经缩放的值

866
00:52:56,042 --> 00:53:08,066
数字， 所以现在 给我 一个指针 

867
00:52:59,078 --> 00:53:09,143
因为这个符号表示向 

868
00:53:08,066 --> 00:53:12,134
特定元素我想，现在

869
00:53:10,043 --> 00:53:15,119
做了这么解引用这是一个非常

870
00:53:13,034 --> 00:53:18,121
例如艰难获得尽可能你的一个 

871
00:53:16,019 --> 00:53:19,021
你的第一个数组

872
00:53:22,022 --> 00:53:29,057
正如我说我失踪道歉 

873
00:53:25,004 --> 00:53:32,077
提及的 特定元素 

874
00:53:29,057 --> 00:53:35,093
这种阵列是通过计算完全完成 

875
00:53:33,013 --> 00:53:41,041
以适当的方式缩放你的索引 

876
00:53:35,093 --> 00:53:44,102
要采取的阵列和缩放 

877
00:53:41,041 --> 00:53:48,095
第一索引20，因为每一行是20 

878
00:53:45,083 --> 00:53:52,106
元素是 5次4，你想 

879
00:53:48,095 --> 00:53:54,101
由4 缩放 位选择 

880
00:53:53,006 --> 00:53:59,051
该 数组 内的特定元件 和 

881
00:53:55,001 --> 00:54:01,013
所以你这一切的地址计算 

882
00:53:59,051 --> 00:54:03,053
发生，然后有一个 

883
00:54:01,013 --> 00:54:04,088
存储器参考而在此数据 

884
00:54:03,053 --> 00:54:06,116
结构，必须要 经过 

885
00:54:04,088 --> 00:54:08,135
首先是内存引用您 

886
00:54:07,016 --> 00:54:11,087
有索引，并获得相应的 

887
00:54:09,035 --> 00:54:14,090
这里元素，但是这只是一个指针 

888
00:54:11,087 --> 00:54:15,170
现在，然后我们加一个偏移量是 

889
00:54:14,009 --> 00:54:19,031
指针，以获得适当的元素 

890
00:54:16,007 --> 00:54:21,071
此阵在这里，然后我们从阅读

891
00:54:20,012 --> 00:54:24,017
这所以 这就是这个 符号表示 

892
00:54:22,034 --> 00:54:26,108
是， 我做 两个内存引用 

893
00:54:24,062 --> 00:54:27,146
在这里，只是一个人也没有，这是一个

894
00:54:27,008 --> 00:54:32,045
有点好奇， 因为如果你看 

895
00:54:28,046 --> 00:54:34,055
在C代码看起来相同的 ，但 

896
00:54:32,045 --> 00:54:37,099
底层数据的类型是不同的，并且 

897
00:54:34,055 --> 00:54:37,099
所以引用是不同的 

898
00:54:39,091 --> 00:54:45,030
好了，让我们来看看其他一些 

899
00:54:43,349 --> 00:54:48,700
在此代码，并且这些变化是 

900
00:54:45,849 --> 00:54:51,894
所有我们要做 的， 从这些脱落 

901
00:54:48,007 --> 00:54:54,010
我这样描述的一般原则 

902
00:54:52,299 --> 00:54:56,220
首先 ， 介绍了 什么 一个数组 

903
00:54:55,000 --> 00:54:59,002
两个两个 

904
00:54:56,022 --> 00:55:03,091
我十六个阵列对不起16

905
00:54:59,002 --> 00:55:06,111
intz和它曾经是 ，看看你 

906
00:55:03,091 --> 00:55:07,123
想做多维数组 

907
00:55:06,309 --> 00:55:10,900
其中阵列的尺寸不

908
00:55:08,023 --> 00:55:12,118
固定在编译的时候，你基本上有 

909
00:55:10,009 --> 00:55:16,418
要实现自己的这个版本 

910
00:55:13,018 --> 00:55:21,417
计算我发现之前 的缩放 

911
00:55:17,309 --> 00:55:26,230
通过数量的行号 

912
00:55:21,579 --> 00:55:28,210
列和增加它 Ĵ所以这是 

913
00:55:26,023 --> 00:55:30,028
那种经典的C我写它作为一个 

914
00:55:28,021 --> 00:55:33,088
宏在这里，但你可以看到它，它只是 

915
00:55:30,073 --> 00:55:36,088
直接做行大尺度 

916
00:55:33,088 --> 00:55:39,237
这里是地址运算，因为现在 

917
00:55:36,088 --> 00:55:42,115
更近的一代的C 

918
00:55:40,029 --> 00:55:52,750
编译他们所谓的C99是 

919
00:55:43,015 --> 00:55:56,424
1999年推出实际上你可以 通过 

920
00:55:52,075 --> 00:55:58,614
作为参数的阵列，其中所述数 

921
00:55:56,559 --> 00:56:01,634
数组中元素的也是 

922
00:55:59,289 --> 00:56:05,170
多数民众赞成被传递到参数 

923
00:56:02,309 --> 00:56:07,407
功能，同样可以声明 

924
00:56:05,017 --> 00:56:10,063
阵列是 n个 元素 的 ，只要 

925
00:56:08,289 --> 00:56:13,150
n所计算在击中前 

926
00:56:10,063 --> 00:56:14,071
数组声明和编译器将 

927
00:56:13,015 --> 00:56:18,063
这样做将分配正确的事

928
00:56:15,043 --> 00:56:18,045
元素的适当数量

929
00:56:19,055 --> 00:56:34,079
嗯所以我们就来看看一些 这 

930
00:56:26,018 --> 00:56:36,056
代码示例，并再次我们会看到

931
00:56:34,079 --> 00:56:37,175
在这里，这将 告诉 你一个例子 

932
00:56:36,056 --> 00:56:39,152
两个塔楼 的那种 的 

933
00:56:38,075 --> 00:56:42,164
地址计算，发生 

934
00:56:40,052 --> 00:56:46,088
在 此 二维阵列 

935
00:56:43,064 --> 00:56:50,090
情况下， 我知道C是16，K是4，所以如果我 

936
00:56:46,088 --> 00:56:56,110
想获得元素i个子ĴIJ出来的 

937
00:56:50,009 --> 00:57:03,056
这个数组然后通过首先规模 我的

938
00:56:57,001 --> 00:57:09,001
64，因为这是我将它添加到

939
00:57:04,037 --> 00:57:13,094
基地，然后我就规模RDX 4 

940
00:57:09,001 --> 00:57:16,004
这就是J和它添加 到这个阵列 等 

941
00:57:13,094 --> 00:57:18,122
然后做一个内存引用有这么 

942
00:57:16,013 --> 00:57:22,042
到底我做你看这两个

943
00:57:19,022 --> 00:57:24,086
说明也做了相应的 

944
00:57:22,042 --> 00:57:27,095
这 三个指令已完成 

945
00:57:24,086 --> 00:57:29,111
的I和J适当的缩放作为 

946
00:57:27,095 --> 00:57:35,102
他们的起始地址和

947
00:57:30,011 --> 00:57:41,057
我已经做了计算上的其他 

948
00:57:36,002 --> 00:57:43,094
另一方面，如果它是一个1个的第三个例子我 

949
00:57:41,057 --> 00:57:45,083
结果显示，其中N是一个参数， 这是 

950
00:57:43,094 --> 00:57:45,173
传递给函数，所以它不是已知

951
00:57:45,083 --> 00:57:50,096
在编译时

952
00:57:46,073 --> 00:57:51,158
有多大比例因子使用 你看 

953
00:57:50,096 --> 00:57:54,139
它必须使用一个乘法 

954
00:57:52,058 --> 00:57:57,086
指令做这是一个 

955
00:57:55,039 --> 00:58:00,128
在相对昂贵的指令 

956
00:57:57,086 --> 00:58:03,119
性能方面， 然后，一旦 

957
00:58:01,028 --> 00:58:07,028
有这只是N次我再 

958
00:58:04,019 --> 00:58:11,023
它采用的勒 着的各种组合

959
00:58:07,028 --> 00:58:13,034
和缩放符号从之前 

960
00:58:11,023 --> 00:58:17,081
计算一个适当的偏移到 

961
00:58:13,088 --> 00:58:22,172
数组做参照，以便我在这里

962
00:58:17,081 --> 00:58:24,173
可以用一个轮班做，在这里我有 

963
00:58:23,072 --> 00:58:30,077
引进乘法，因为我不 

964
00:58:25,073 --> 00:58:42,131
事先知道它到底有多大，如果你 

965
00:58:31,022 --> 00:58:51,026
想折磨自己在这里是一个

966
00:58:43,031 --> 00:58:54,047
例如，我 是去的三重过 

967
00:58:51,026 --> 00:59:00,098
嵌套的可能性和非关联化

968
00:58:54,047 --> 00:59:06,053
同样的想法， 但让我们继续 

969
00:59:00,098 --> 00:59:07,153
三分球哦，它只是使药物的想法 

970
00:59:06,053 --> 00:59:11,072
一个结构其实很简单哦 

971
00:59:08,053 --> 00:59:12,062
良好的基础理念 是因为它得到的时候 

972
00:59:11,072 --> 00:59:17,171
更复杂

973
00:59:12,062 --> 00:59:20,078
噢， 那是 想法 我想 我声明 

974
00:59:18,071 --> 00:59:23,129
一个结构有领域的一些数 

975
00:59:20,078 --> 00:59:26,120
其中的每一个可以是一个int，或者它可以 

976
00:59:24,029 --> 00:59:29,093
在这种情况下，一个指针，也可能是 

977
00:59:27,002 --> 00:59:31,040
阵列本身，而是该规则是

978
00:59:29,093 --> 00:59:35,102
基本上是我要做的就是分配 

979
00:59:31,058 --> 00:59:37,109
足够的空间，如果我介绍的这些中的一个 

980
00:59:36,002 --> 00:59:41,096
药物对所有 不同的阵列 

981
00:59:38,009 --> 00:59:44,090
要素领域和我们的结构和 

982
00:59:41,096 --> 00:59:46,097
然后 我会 ，我会 基本保持跟踪 

983
00:59:44,009 --> 00:59:50,018
编译器会跟踪每个 的 

984
00:59:47,006 --> 00:59:53,024
这些领域的开始，并生成 

985
00:59:50,099 --> 00:59:54,188
适当的代码来从偏移 

986
00:59:53,024 --> 00:59:57,041
所以开始的结构本身的 

987
00:59:55,088 --> 00:59:59,090
提到这将 是 开始 

988
00:59:57,041 --> 01:00:01,133
该结构的地址， 然后我将 使用 

989
00:59:59,009 --> 01:00:08,018
适当偏移去的 

990
01:00:02,033 --> 01:00:13,039
不同的字段 ，因此这里有一个例子 

991
01:00:09,008 --> 01:00:12,067
一些代码想象我 

992
01:00:14,073 --> 01:00:20,121
有一个结构的指针 ，其中之一 

993
01:00:17,028 --> 01:00:23,037
结构和我有一个索引，哪些 

994
01:00:21,021 --> 01:00:29,082
我想要做的就是在那 

995
01:00:24,018 --> 01:00:32,037
内此阵列的适当部分

996
01:00:29,082 --> 01:00:33,099
结构以及阵列的是正确的 

997
01:00:32,037 --> 01:00:35,124
结构 的开始 ，所以我可以 

998
01:00:33,099 --> 01:00:39,141
对待这就像我想任何数组 

999
01:00:36,024 --> 01:00:42,072
由 4缩放IDX 和添加的参考

1000
01:00:40,041 --> 01:00:43,119
它基本能得到 相应的 

1001
01:00:42,072 --> 01:00:44,118
元素，所以我真的没有做 

1002
01:00:44,019 --> 01:00:48,084
什么特别的 

1003
01:00:45,018 --> 01:00:52,077
这一个让我们去得到一些其他的 

1004
01:00:48,084 --> 01:00:56,148
代码，您通常会真正看到 

1005
01:00:52,077 --> 01:00:58,095
这个例子是相当参与，所以我 

1006
01:00:57,048 --> 01:01:01,107
实际上做了一大堆 的东西 

1007
01:00:58,095 --> 01:01:03,153
这里所有的这一个结构第一 

1008
01:01:02,007 --> 01:01:10,106
我试图 从 检索元素 我 

1009
01:01:04,053 --> 01:01:14,127
结构然后我使用到 

1010
01:01:11,006 --> 01:01:19,014
索引阵列的和，并插入一个 

1011
01:01:15,027 --> 01:01:23,126
值到那里，然后我更新 

1012
01:01:19,014 --> 01:01:24,026
这个指针指向下一个 

1013
01:01:26,034 --> 01:01:31,065
我 如果这是一个 扭曲 链接 

1014
01:01:30,036 --> 01:01:34,127
我想要做的是一步到下一步 

1015
01:01:31,065 --> 01:01:38,154
店主是一个列表，所以我需要找回 

1016
01:01:35,027 --> 01:01:41,064
从这里 等等这些 在未来的领域 

1017
01:01:39,054 --> 01:01:43,119
所以实际上 ，我拍三级引用 

1018
01:01:41,064 --> 01:01:45,069
这种结构 ， 这一个相当 

1019
01:01:44,019 --> 01:01:51,024
小功能，所以让我们尝试和数字

1020
01:01:46,014 --> 01:01:53,061
这一切所以 首先我要 

1021
01:01:51,024 --> 01:01:55,086
我从它这里找回元素你 

1022
01:01:53,061 --> 01:01:59,070
看到我们知道元素 我是 

1023
01:01:55,086 --> 01:02:01,086
偏移16等，在这里就是你

1024
01:01:59,007 --> 01:02:03,093
看到位移场使用 

1025
01:02:01,086 --> 01:02:07,131
在存储器参考恰好为此

1026
01:02:04,056 --> 01:02:10,110
目的我想利用[R但增加16 

1027
01:02:08,031 --> 01:02:13,064
它得到 一个内存 地址， 我可以 

1028
01:02:11,001 --> 01:02:13,055
用于

1029
01:02:14,049 --> 01:02:26,082
因为我和它，你看到它实际上 使用 

1030
01:02:21,015 --> 01:02:28,080
移动SLQ因为 我本身就是一个 int，但 

1031
01:02:26,082 --> 01:02:32,127
我将 用它作为数组 索引 

1032
01:02:28,008 --> 01:02:35,057
我有这种情况下，以它的规模我要 

1033
01:02:33,027 --> 01:02:37,119
不要使用8个字节的地址运算

1034
01:02:35,849 --> 01:02:40,830
批量所以实际上检索

1035
01:02:38,019 --> 01:02:46,026
4字节值和做了 标志 

1036
01:02:40,083 --> 01:02:53,100
扩展它，现在我 想做的 

1037
01:02:46,026 --> 01:02:57,081
做的是存储在瓦尔的元素我等 

1038
01:02:54,000 --> 01:03:02,119
在这里你会看到，它的使用 我们的斧头 

1039
01:02:57,081 --> 01:03:01,390
是 仅仅计算了我的价值 

1040
01:03:02,045 --> 01:03:09,138
规模由 4 连接 并使用起始 

1041
01:03:07,068 --> 01:03:12,072
将R的地址，其恰好是 

1042
01:03:10,038 --> 01:03:14,747
开始的地址，以及和做

1043
01:03:12,072 --> 01:03:19,131
商店所以这是某种数组 

1044
01:03:15,089 --> 01:03:26,165
操作那里，然后下一部分 

1045
01:03:20,031 --> 01:03:30,126
是我要 弥补24这是 

1046
01:03:26,849 --> 01:03:35,060
从该位置下一次读取的位置

1047
01:03:31,026 --> 01:03:37,095
并存储 在 我们的 GI AA级 [R 

1048
01:03:35,006 --> 01:03:41,022
所以这是操作argit的我们 

1049
01:03:37,095 --> 01:03:42,183
旁边的箭头，然后循环是我 

1050
01:03:41,022 --> 01:03:47,024
试验，直到R是没有那么这回事 

1051
01:03:43,083 --> 01:03:49,164
在这里，所以你看，这三个 

1052
01:03:47,024 --> 01:03:53,025
引用破坏我们正在实施 

1053
01:03:50,064 --> 01:03:55,143
使用三个指令这里，所以它是一个 

1054
01:03:53,025 --> 01:03:59,384
该代码之间有非常直接的映射

1055
01:03:56,043 --> 01:04:01,131
这里与x86指令和部分 

1056
01:03:59,609 --> 01:04:04,230
因为这个的x86指令 

1057
01:04:02,031 --> 01:04:06,090
这种东西 是非常普遍 

1058
01:04:04,023 --> 01:04:08,091
节目他们那种所做的 

1059
01:04:06,009 --> 01:04:12,042
说明很直接朝地图

1060
01:04:08,091 --> 01:04:14,178
这些操作， 现在你 应该 

1061
01:04:13,023 --> 01:04:17,088
大概明白为什么所有的钟声和

1062
01:04:15,078 --> 01:04:21,113
口哨 在那里为这些地址 

1063
01:04:17,088 --> 01:04:27,152
引用的问题是什么，如果我是 

1064
01:04:22,013 --> 01:04:35,075
如果我是三我很抱歉，因为 

1065
01:04:28,052 --> 01:04:39,085
他们他妈的名300 有一个眼睛调查 

1066
01:04:35,075 --> 01:04:39,076
元素是它将访问 

1067
01:04:41,064 --> 01:04:49,092
其实我觉得这是错字 海耶斯 

1068
01:04:45,049 --> 01:04:52,103
应该参观他们 因此，如果 

1069
01:04:49,092 --> 01:04:55,511
我因为它将访问本身是啊，它 

1070
01:04:52,589 --> 01:05:03,596
会误事的问题，这 是一个 

1071
01:04:56,339 --> 01:05:09,140
错字的方式应该是4级是一个 

1072
01:05:04,289 --> 01:05:09,140
空指针我知道是0 

1073
01:05:12,076 --> 01:05:16,115
所以这就是那种 简单 版 

1074
01:05:15,035 --> 01:05:20,066
现在结构让我们让他们一点点 

1075
01:05:17,015 --> 01:05:25,022
困难之一是该 有点 原因 

1076
01:05:20,066 --> 01:05:26,147
模糊机通常更 

1077
01:05:25,022 --> 01:05:30,029
如果你有一个数据类型和 

1078
01:05:27,047 --> 01:05:32,090
的K基础数据类型字节 ，所述 

1079
01:05:30,092 --> 01:05:37,147
解决始于是 

1080
01:05:32,009 --> 01:05:41,018
的K多，并且使得引入了一个 

1081
01:05:38,047 --> 01:05:44,095
属性我们称之为对准这将

1082
01:05:42,008 --> 01:05:47,066
实际上，当一个 结构被分配 

1083
01:05:44,095 --> 01:05:50,096
以及该 编译器将实际 

1084
01:05:48,038 --> 01:05:54,125
中插入一些空白未使用的字节

1085
01:05:50,096 --> 01:05:56,159
在分配 数据 结构只是让 

1086
01:05:55,025 --> 01:06:02,111
它可以保持调，以便 

1087
01:05:57,059 --> 01:06:04,103
例如这里我是作为一个int 和我 

1088
01:06:03,011 --> 01:06:08,057
希望它解决是的倍数 

1089
01:06:05,003 --> 01:06:09,049
四岁了，我给你 一分钟 为什么 

1090
01:06:08,057 --> 01:06:11,144
确实如此

1091
01:06:09,049 --> 01:06:15,074
我就这么信任我一分钟 ， 

1092
01:06:12,044 --> 01:06:18,050
所以它会 实际上有三个字节 

1093
01:06:15,074 --> 01:06:20,135
这里，是因为第一个字节是被

1094
01:06:18,005 --> 01:06:22,034
使用C和一般我们会看到 

1095
01:06:21,035 --> 01:06:24,086
我们要确保分配

1096
01:06:22,079 --> 01:06:26,162
指针到该数据结构 

1097
01:06:24,086 --> 01:06:28,124
本身是 八和 多 

1098
01:06:27,062 --> 01:06:32,125
原因是 因为有一个 

1099
01:06:29,024 --> 01:06:35,057
这里的两倍，它应该驻留在

1100
01:06:33,025 --> 01:06:38,036
边界， 它的起始地址 

1101
01:06:35,057 --> 01:06:40,076
应该是 八 和你 多 

1102
01:06:38,036 --> 01:06:43,070
看到只要这是 八的倍数 

1103
01:06:40,076 --> 01:06:44,168
8，在这里这个偏移量是多 

1104
01:06:43,007 --> 01:06:47,102
的8则此地址将 是一个 

1105
01:06:45,068 --> 01:06:52,154
八个多 所以这是 的想法 

1106
01:06:48,065 --> 01:06:55,097
对齐和为什么是真的 好 

1107
01:06:53,054 --> 01:07:00,059
这真是一个硬件问题了 

1108
01:06:55,097 --> 01:07:01,106
存储系统，而不是实际 

1109
01:07:00,059 --> 01:07:05,147
硬件存储器不引用 一个 

1110
01:07:02,087 --> 01:07:08,138
在以引用的时间其实字节

1111
01:07:06,047 --> 01:07:11,126
大多数机器目前约在64个字节 

1112
01:07:09,038 --> 01:07:15,080
一个时间或 取决于各种宽度 

1113
01:07:12,026 --> 01:07:18,101
在硬件中和一般如果要是 

1114
01:07:15,008 --> 01:07:21,037
数据的 特定部分 横跨 是 

1115
01:07:19,001 --> 01:07:23,003
的 该 2块之间的边界 

1116
01:07:22,009 --> 01:07:25,073
该

1117
01:07:23,021 --> 01:07:27,400
这将需要未对齐的地址

1118
01:07:25,073 --> 01:07:29,114
由硬件额外的步骤 和 

1119
01:07:27,589 --> 01:07:32,510
甚至可能操作系统 

1120
01:07:30,014 --> 01:07:35,973
对付这样只是为了效率的原因 

1121
01:07:32,051 --> 01:07:39,098
他们说，这样做比对信任我 

1122
01:07:36,099 --> 01:07:42,170
x86 上 ，如果您有未对齐数据 

1123
01:07:39,098 --> 01:07:43,139
它会执行得很好，它只是可能

1124
01:07:42,017 --> 01:07:46,070
在某些运行一点点更 慢 

1125
01:07:44,039 --> 01:07:48,097
如果你尝试做的其他机器

1126
01:07:46,007 --> 01:08:02,009
放松访问它实际上会造成 

1127
01:07:48,097 --> 01:08:03,131
内存故障问题是 盲肠 

1128
01:08:02,072 --> 01:08:07,124
问题是， 你怎么可能强制 

1129
01:08:04,031 --> 01:08:12,098
产生展开数据 我不知道，如果你 

1130
01:08:08,024 --> 01:08:15,065
能和我们谈谈方法 可以 

1131
01:08:12,098 --> 01:08:19,227
排序的是你怎么做更聪明

1132
01:08:15,065 --> 01:08:23,072
你的配置，以避免浪费空间 

1133
01:08:20,109 --> 01:08:25,201
所以一般那么 我们有我们大多 

1134
01:08:24,035 --> 01:08:30,077
看这里是数据类型 

1135
01:08:26,029 --> 01:08:34,102
是1个 或 2 4 8字节长有 

1136
01:08:30,077 --> 01:08:36,086
一些16字节的数据类型，但我们不会 

1137
01:08:34,759 --> 01:08:40,250
看着那些 和一般会 

1138
01:08:37,067 --> 01:08:42,110
地址，然后你可以告诉对齐 

1139
01:08:40,025 --> 01:08:45,062
由多少 个零的地址 ，如果是 

1140
01:08:43,001 --> 01:08:46,079
2对齐的功率有多少 个零 

1141
01:08:45,062 --> 01:08:50,120
是在比特级别的端部 

1142
01:08:46,088 --> 01:08:52,777
该地址等作为表示 

1143
01:08:51,002 --> 01:08:56,791
我们发现在一般的C 编译器时 

1144
01:08:53,569 --> 01:09:01,730
它创造了一个结构布局

1145
01:08:56,989 --> 01:09:06,020
一个结构 将投入 填充字节 

1146
01:09:01,073 --> 01:09:07,114
有使对准工作

1147
01:09:06,002 --> 01:09:11,491
其他的事情会做的是，如果需要的话 

1148
01:09:08,014 --> 01:09:13,043
这将增加 字节到底做 

1149
01:09:11,509 --> 01:09:15,950
确保数据的整体大小 

1150
01:09:13,043 --> 01:09:17,452
结构满足任何潜在的

1151
01:09:15,095 --> 01:09:19,654
对齐要求有这 

1152
01:09:17,839 --> 01:09:22,370
之一，因为它包含一个双 

1153
01:09:20,509 --> 01:09:25,620
总体数据结构具有对齐 

1154
01:09:22,037 --> 01:09:28,051
在8字节边界 

1155
01:09:25,062 --> 01:09:33,124
和该推理 想象我 

1156
01:09:28,051 --> 01:09:37,117
有这些卡车的 结构的数组

1157
01:09:34,024 --> 01:09:41,035
尤其是那么如果我可以假设， 

1158
01:09:38,017 --> 01:09:43,038
如果我能保证这个阵列是一个 

1159
01:09:41,035 --> 01:09:45,504
多地址的 八个 多 

1160
01:09:43,038 --> 01:09:48,099
然后你可以看到，每个连续 

1161
01:09:45,819 --> 01:09:51,867
这个数组这些卡车的的元件是 

1162
01:09:48,099 --> 01:09:54,103
八，然后多内

1163
01:09:52,299 --> 01:09:58,110
结构我保证每个字段 

1164
01:09:55,003 --> 01:10:00,064
需要八个的对准 是 

1165
01:09:58,011 --> 01:10:02,062
定位偏移是这样的 

1166
01:10:00,064 --> 01:10:04,069
八个多，所以它的所有作品 

1167
01:10:02,062 --> 01:10:08,080
了，但如果你试图 用 这个 鼓捣 

1168
01:10:05,014 --> 01:10:11,022
通过使该过短，那么你开始 

1169
01:10:08,008 --> 01:10:11,022
越来越错位参考 

1170
01:10:18,409 --> 01:10:24,210
而这么一件事，你将看到的是，每 

1171
01:10:22,002 --> 01:10:27,101
袭击实际对齐要求 

1172
01:10:24,021 --> 01:10:29,085
取决于什么是那种最坏情况

1173
01:10:27,119 --> 01:10:32,150
对准的最大对齐 

1174
01:10:29,085 --> 01:10:36,117
因此这种特殊的结构的任何元件 

1175
01:10:32,429 --> 01:10:39,527
例如含有氨基酸浮子 v哪种 

1176
01:10:37,017 --> 01:10:44,816
有四个大小，因此这将 是 

1177
01:10:40,409 --> 01:10:49,650
四个对齐，你会看到

1178
01:10:44,969 --> 01:10:52,260
一般的代码 时， 它有这个 

1179
01:10:49,065 --> 01:10:53,153
所有我们已经看到了这个地址运算

1180
01:10:52,026 --> 01:10:57,033
得到融合各种不同的方式来 

1181
01:10:54,053 --> 01:11:01,142
刻度值计算偏移等 

1182
01:10:57,096 --> 01:11:04,128
第四，以获得 相应的元素，因此 

1183
01:11:02,042 --> 01:11:07,083
你的问题之前，也是我可以告诉 

1184
01:11:05,028 --> 01:11:12,075
编译器不能做比对和 

1185
01:11:07,083 --> 01:11:13,176
更好的办法是宣布你的字段 

1186
01:11:12,075 --> 01:11:19,103
最小化的量的方法

1187
01:11:14,076 --> 01:11:21,935
浪费的空间，所以 在这里我举例 

1188
01:11:20,003 --> 01:11:24,009
浪费了三个字节在这里和三个字节 

1189
01:11:22,619 --> 01:11:27,630
在这里，以满足对齐要求

1190
01:11:24,063 --> 01:11:29,115
但如果我 只是把我在开始和 

1191
01:11:27,063 --> 01:11:34,112
那么C和DI会不仅浪费 

1192
01:11:30,015 --> 01:11:36,021
两个字节总数和一般，因为 

1193
01:11:34,679 --> 01:11:38,681
所有的走线要求

1194
01:11:36,021 --> 01:11:40,077
两个的那种 贪婪的权力

1195
01:11:38,699 --> 01:11:41,741
算法的工作，它说如果我只拿

1196
01:11:40,077 --> 01:11:44,082
把最大的东西在开始 

1197
01:11:42,119 --> 01:11:48,210
然后 顺利较小的元素 我 

1198
01:11:45,027 --> 01:11:53,726
将能够最大限度 地 减少浪费任何 

1199
01:11:48,021 --> 01:11:56,025
空间， 这是一个普遍特性，但 

1200
01:11:53,969 --> 01:11:59,042
这是你 是作家 的情况下， 

1201
01:11:56,025 --> 01:12:01,056
的C代码 有，如果该效果 

1202
01:11:59,699 --> 01:12:04,772
编译器不会 为 你 做这 

1203
01:12:01,056 --> 01:12:06,092
自动质疑 哦耶稣以及 

1204
01:12:05,429 --> 01:12:10,430
进来

1205
01:12:06,092 --> 01:12:12,098
在比赛那是什么 哦，但是要记住 

1206
01:12:10,043 --> 01:12:14,084
数组我不关心我阵

1207
01:12:12,098 --> 01:12:16,127
关心的阵列的元件 

1208
01:12:14,084 --> 01:12:18,101
因为这是唯一下降的最低的 

1209
01:12:17,027 --> 01:12:22,043
水平，我访问无论是 

1210
01:12:19,001 --> 01:12:24,095
单个int 单个双键或一个指针 

1211
01:12:22,043 --> 01:12:26,126
而不是所有的东西休息 

1212
01:12:24,095 --> 01:12:29,183
记得我 从来不看整个数组 

1213
01:12:27,026 --> 01:12:33,035
从存储器中 ，以便 对准仅指 

1214
01:12:30,083 --> 01:12:38,084
下到最原始类型不 

1215
01:12:33,035 --> 01:12:43,091
聚集类型，如果这是令人困惑 

1216
01:12:38,093 --> 01:12:44,096
这本书 相当仔细地 覆盖该 如此 

1217
01:12:43,091 --> 01:12:48,176
让我只是完成了 一点点 

1218
01:12:45,023 --> 01:12:53,057
浮点浮点一瞥 

1219
01:12:49,076 --> 01:12:55,114
在86 怎么回 一个复杂的历史 

1220
01:12:53,057 --> 01:12:58,109
在真远古时代 

1221
01:12:56,014 --> 01:13:02,096
还有， 与8086走 了芯片 

1222
01:12:59,009 --> 01:13:06,038
处理器称为8087，并在 

1223
01:13:02,096 --> 01:13:08,108
一次是工程 的杰作

1224
01:13:06,038 --> 01:13:11,063
要能够走到所有的硬件 

1225
01:13:09,008 --> 01:13:15,083
要落实全我三è

1226
01:13:11,063 --> 01:13:18,089
浮点单个芯片和它上 

1227
01:13:15,083 --> 01:13:20,135
是它 实际上 类型的第一个 它 

1228
01:13:18,089 --> 01:13:22,165
是一种与我共同开发

1229
01:13:21,035 --> 01:13:26,069
三重É浮点标准本身 

1230
01:13:23,065 --> 01:13:29,162
但它的编程模型 

1231
01:13:26,069 --> 01:13:32,108
可怕的窘况和丑陋的我用的 

1232
01:13:30,062 --> 01:13:34,115
旧的除了书有它

1233
01:13:33,008 --> 01:13:37,046
在第一版是在 

1234
01:13:35,015 --> 01:13:39,110
网站的 第二版 ，现在 

1235
01:13:37,046 --> 01:13:44,054
它被完全抹去因

1236
01:13:40,001 --> 01:13:48,026
它最近是如此可怕，但在 

1237
01:13:45,026 --> 01:13:50,102
86的世界里，他们认识到， 

1238
01:13:48,035 --> 01:13:52,076
支持诸如视频和所有的 

1239
01:13:51,002 --> 01:13:56,006
东西的人其实与他们的 

1240
01:13:52,076 --> 01:13:58,130
机器，他们需要更多一些

1241
01:13:56,042 --> 01:14:01,139
马力在数字处理 和 

1242
01:13:59,003 --> 01:14:09,100
他们实施了类指令 

1243
01:14:02,039 --> 01:14:09,127
叫SSE它代表SIMð 

1244
01:14:10,006 --> 01:14:14,092
辛迪的东西反正执行和 

1245
01:14:14,002 --> 01:14:18,067
我会告诉你 在一 分钟内什么 

1246
01:14:15,046 --> 01:14:21,091
手段和现在的 更近 

1247
01:14:18,085 --> 01:14:26,104
86版本已经榨汁达 

1248
01:14:21,091 --> 01:14:28,156
一种叫做VX这可是

1249
01:14:27,004 --> 01:14:31,081
鲨鱼机支持这个版本的 

1250
01:14:29,056 --> 01:14:33,097
什么叫SSE，所以让我只给 

1251
01:14:31,081 --> 01:14:34,165
你对于 和 感觉 

1252
01:14:33,097 --> 01:14:37,105
特别是鲨鱼机支持

1253
01:14:35,065 --> 01:14:40,072
什么叫SSE 3版以及它 

1254
01:14:38,077 --> 01:14:42,103
是的是 ， 有 16个特殊 

1255
01:14:40,072 --> 01:14:44,161
记录来自其它不同

1256
01:14:43,003 --> 01:14:48,009
我们每个人以前讲过寄存器

1257
01:14:45,061 --> 01:14:51,064
其中有16个字节，然后有 

1258
01:14:48,063 --> 01:14:52,150
可以对那些操作的操作和 

1259
01:14:51,064 --> 01:14:55,162
对待他们以不同的方式，使一个是 

1260
01:14:53,005 --> 01:15:00,012
治疗寄存器的这一部分作为 

1261
01:14:56,062 --> 01:15:06,141
的16只关心阵列或八个 

1262
01:15:00,057 --> 01:15:11,062
短裤或四个是或并且还支持 

1263
01:15:07,041 --> 01:15:13,108
双浮点运算等等 

1264
01:15:12,007 --> 01:15:16,069
这东西肯定是怎么回事，并 

1265
01:15:14,008 --> 01:15:19,075
有人曾认为观察 

1266
01:15:16,069 --> 01:15:20,071
还有我可以再排序 的子集 

1267
01:15:19,075 --> 01:15:22,162
这一切和实施

1268
01:15:20,089 --> 01:15:27,094
直接使用浮点运算 

1269
01:15:23,062 --> 01:15:30,064
这SSE东西，并跳过旧的x87

1270
01:15:28,039 --> 01:15:33,040
的东西，所以这是 浮动 的方式 

1271
01:15:30,082 --> 01:15:36,088
现在上说， 鲨鱼 产生点 

1272
01:15:33,004 --> 01:15:40,012
机器和最近该机器

1273
01:15:36,088 --> 01:15:41,146
是这个 被再次 的其中 一个 例子 

1274
01:15:40,048 --> 01:15:44,092
世界是比它 更复杂 

1275
01:15:42,046 --> 01:15:48,085
应该有例如如此有 

1276
01:15:44,092 --> 01:15:50,116
是说增加SS这样的指令 

1277
01:15:48,085 --> 01:15:54,177
添加一个标是什么 

1278
01:15:51,016 --> 01:15:55,077
符号添加一个单精度标 

1279
01:15:57,449 --> 01:16:04,110
在缩放器单精度和它 

1280
01:16:01,035 --> 01:16:06,614
看上去有点像add指令 

1281
01:16:04,011 --> 01:16:11,037
你已经看到了加Q指令 

1282
01:16:06,929 --> 01:16:15,360
它它增加它添加源 

1283
01:16:11,037 --> 01:16:18,042
目标 有方法 ，我可以做 

1284
01:16:15,036 --> 01:16:21,039
使用 在同一 时间 在所有广告 

1285
01:16:18,087 --> 01:16:22,152
这就是他们所谓的辛迪执行 

1286
01:16:21,039 --> 01:16:26,117
它代表单指令 

1287
01:16:23,052 --> 01:16:29,135
多个数据中的一个指令加载 

1288
01:16:27,017 --> 01:16:34,086
PSP自repect

1289
01:16:30,035 --> 01:16:36,674
会做 的意愿将执行 一个 

1290
01:16:34,086 --> 01:16:40,131
指令会做的广告有四个 

1291
01:16:36,989 --> 01:16:44,040
不同数量 和类似，你可以 做 

1292
01:16:41,031 --> 01:16:46,940
它与双精度，你可以 做一个 

1293
01:16:44,004 --> 01:16:49,083
他们可以做宠物 等 实际 

1294
01:16:47,219 --> 01:16:52,320
底层 ， 我们将看到这个 时 

1295
01:16:49,083 --> 01:16:53,091
我们看一下代码优化，如果你 

1296
01:16:52,032 --> 01:16:55,086
写代码才能利用这些 

1297
01:16:53,091 --> 01:16:58,400
说明你 才能 真正提振 

1298
01:16:55,086 --> 01:16:59,094
计算机的性能，但这种 

1299
01:16:59,219 --> 01:17:03,120
只是给你一个什么样的味道 

1300
01:17:00,066 --> 01:17:04,113
浮点代码看起来像和 

1301
01:17:03,012 --> 01:17:07,020
规则很简单，正如我们 

1302
01:17:05,013 --> 01:17:10,044
看到之前那个论点得到 

1303
01:17:07,092 --> 01:17:11,187
在寄存器中传递而在14点 

1304
01:17:10,044 --> 01:17:16,343
论点得到这些XMM传递

1305
01:17:12,087 --> 01:17:18,686
寄存器 X嗯0您不必 

1306
01:17:16,739 --> 01:17:22,890
记住我们的目录SI RDX 

1307
01:17:19,469 --> 01:17:25,920
在X MMM有0 1 2这一切都非常 

1308
01:17:22,089 --> 01:17:27,141
逻辑和返回 值 是在 X MMM 

1309
01:17:25,092 --> 01:17:30,123
0和所有的寄存器被 调用 

1310
01:17:28,041 --> 01:17:32,870
来电者的安全有没有打电话的安全 ，这样 

1311
01:17:31,023 --> 01:17:37,026
像添加2 浮点 

1312
01:17:33,239 --> 01:17:41,280
数字将只是看起来像一个单一的 

1313
01:17:37,026 --> 01:17:45,051
浮点加法指令相同 

1314
01:17:41,028 --> 01:17:48,677
双如果你混合在一起 码 

1315
01:17:45,051 --> 01:17:51,087
具有一个指针和一个浮点 

1316
01:17:48,929 --> 01:17:55,230
操作指针 会在传递 

1317
01:17:51,087 --> 01:17:57,146
定期寄存器RDI 和这双 

1318
01:17:55,023 --> 01:18:00,084
将因此它排序 X毫米0被传递

1319
01:17:57,929 --> 01:18:04,290
因为它不用通过参数列表，你 

1320
01:18:00,084 --> 01:18:05,181
那种在特定的顺序，如果是 

1321
01:18:04,029 --> 01:18:09,117
的整数或者指针它在一个 

1322
01:18:06,081 --> 01:18:10,125
在我们的寄存器，如果它是浮动

1323
01:18:10,017 --> 01:18:14,025
点值 是 

1324
01:18:11,025 --> 01:18:16,076
的XMM寄存器中的一个的和潜在 

1325
01:18:14,025 --> 01:18:16,076
交错

1326
01:18:17,024 --> 01:18:24,078
几乎完成，所以这是一个代码 ， 

1327
01:18:21,096 --> 01:18:25,170
执行此特定的 操作，它的 

1328
01:18:24,078 --> 01:18:29,175
有趣的，因为它 返回了 

1329
01:18:26,007 --> 01:18:31,098
它做的内存，以便再次引用

1330
01:18:30,075 --> 01:18:35,151
还有，将读取指令

1331
01:18:32,061 --> 01:18:39,087
内存和复制到 一个XML您注册 

1332
01:18:36,051 --> 01:18:42,096
可以添加寄存器 可以使副本 

1333
01:18:39,087 --> 01:18:45,099
从一个XML M寄存器到另一个 

1334
01:18:42,096 --> 01:18:47,178
你可以存储结果， 所以这段代码看起来 

1335
01:18:45,099 --> 01:18:50,154
很像 你 在整数 做 什么 

1336
01:18:48,078 --> 01:18:52,136
除了它的运算是一个使用XML和 

1337
01:18:51,054 --> 01:18:55,055
特殊的浮点指令

1338
01:18:53,036 --> 01:18:58,109
而不是你 以前 见过的那些 

1339
01:18:55,064 --> 01:19:01,110
所以 它的 基本思想 是相当简单 

1340
01:18:59,009 --> 01:19:05,037
它获取的方式更加复杂，因为 

1341
01:19:02,001 --> 01:19:08,082
有很多的双重指示

1342
01:19:05,037 --> 01:19:10,071
漂浮在和和有特殊 

1343
01:19:08,091 --> 01:19:12,144
指令做平方根和所有 

1344
01:19:10,071 --> 01:19:15,072
这个东西和比较的东西 

1345
01:19:13,044 --> 01:19:19,140
真是可恶和杂乱， 很难 

1346
01:19:15,081 --> 01:19:21,168
了解，然后你会看到各种 

1347
01:19:20,004 --> 01:19:23,070
招数用常数值所以它的 

1348
01:19:22,068 --> 01:19:24,165
覆盖我们不打算书 

1349
01:19:24,006 --> 01:19:28,065
真正谈论 它更 在此 

1350
01:19:25,065 --> 01:19:29,091
当然，但潜在的基本 

1351
01:19:28,065 --> 01:19:31,074
它的原理是相当 

1352
01:19:29,091 --> 01:19:33,176
简单的确定这会尽我们 

1353
01:19:32,055 --> 01:19:34,076
今天

