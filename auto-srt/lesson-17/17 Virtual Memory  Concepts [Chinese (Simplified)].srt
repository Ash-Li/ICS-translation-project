1
00:00:00,003 --> 00:00:05,272
下午好欢迎大家好 

2
00:00:02,085 --> 00:00:08,164
看到你一如既往 

3
00:00:05,299 --> 00:00:11,130
今天我们要了解一个 

4
00:00:08,929 --> 00:00:19,930
在计算机科学中很重要的概念

5
00:00:11,013 --> 00:00:23,252
称为虚拟内存，以便考虑 

6
00:00:20,029 --> 00:00:25,034
使用物理地址系统

7
00:00:23,369 --> 00:00:27,452
正确的，我们一直 我们对记忆的想法 

8
00:00:25,529 --> 00:00:31,586
到目前为止那么，它是一个 连续的 

9
00:00:28,199 --> 00:00:34,170
的物理物理字节阵列， 我们 

10
00:00:32,099 --> 00:00:36,480
可以访问

11
00:00:34,017 --> 00:00:39,066
尽管给予一定的偏移称为 

12
00:00:36,048 --> 00:00:44,127
一个地址，以便在使用的系统

13
00:00:39,066 --> 00:00:47,085
物理寻址CPU执行 

14
00:00:45,027 --> 00:00:49,080
好比说一招指令， 

15
00:00:47,085 --> 00:00:51,134
产生一个有效地址的 

16
00:00:49,008 --> 00:00:53,016
物理地址和该 地址 

17
00:00:51,899 --> 00:00:57,270
实际上是一个字节的主偏移 

18
00:00:54,006 --> 00:01:01,053
内存让你知道这里的 CPU有 

19
00:00:57,027 --> 00:01:04,088
产生 的4美分 的物理 地址 

20
00:01:02,007 --> 00:01:08,846
该地址给到内存和 

21
00:01:04,088 --> 00:01:10,095
那么内存取的字 

22
00:01:08,909 --> 00:01:17,100
从该地址，然后发送它 

23
00:01:10,095 --> 00:01:18,183
回到 CPU 现在这实际上是在 

24
00:01:17,001 --> 00:01:22,080
方式很简单的微控制器 

25
00:01:19,083 --> 00:01:25,083
工作，但它不是像大多数系统 

26
00:01:22,089 --> 00:01:28,748
工作包括你的手机你

27
00:01:25,083 --> 00:01:31,179
桌面您的服务器，这些系统 

28
00:01:29,549 --> 00:01:36,930
而不是虚拟化这个这个主 

29
00:01:32,079 --> 00:01:38,120
现在内存虚拟化的思想是 

30
00:01:36,093 --> 00:01:42,117
一个很重要的一个计算机科学

31
00:01:39,002 --> 00:01:45,096
它扩展了很多它适用于 

32
00:01:43,017 --> 00:01:49,092
很多 计算机系统的领域，现在 

33
00:01:46,014 --> 00:01:51,111
当您虚拟化的资源你你

34
00:01:49,092 --> 00:01:53,291
呈现资源的与所述用户

35
00:01:52,011 --> 00:01:57,980
一番别样的认为 ， 

36
00:01:54,119 --> 00:02:00,000
资源时通常存在某种 

37
00:01:58,079 --> 00:02:03,450
抽象或某种形式的的

38
00:02:00,000 --> 00:02:06,054
资源和你 的不同看法

39
00:02:03,045 --> 00:02:07,096
通过插在做访问 到 

40
00:02:06,054 --> 00:02:09,106
资源

41
00:02:07,096 --> 00:02:11,185
所以在所有的情况下， 有一些资源 

42
00:02:10,006 --> 00:02:15,064
并要虚拟化它，你做

43
00:02:12,085 --> 00:02:18,085
通过截取或插入上 

44
00:02:15,064 --> 00:02:20,110
在访问该资源很好，而且 

45
00:02:18,085 --> 00:02:23,094
那么一旦你，我们看到这个时候，我们 

46
00:02:21,001 --> 00:02:25,009
对于像创建包装函数

47
00:02:23,094 --> 00:02:27,157
当我向您展示间的malloc 

48
00:02:25,009 --> 00:02:31,054
定位相同的技术被用于

49
00:02:28,057 --> 00:02:33,133
虚拟化资源，并有一次 

50
00:02:32,035 --> 00:02:35,113
你拦截的访问，那么你 

51
00:02:34,033 --> 00:02:37,098
可以对付它，你要等任何一种方式

52
00:02:36,013 --> 00:02:41,047
这就是你怎么会有那种充满力量

53
00:02:37,098 --> 00:02:43,180
改变一个人改变看法 

54
00:02:41,047 --> 00:02:48,066
该资源 好 了，一个很好的例子 ，你 

55
00:02:44,008 --> 00:02:49,057
看到这个，当我们看着 盘，并 

56
00:02:48,489 --> 00:02:53,350
知道物理磁盘组成的 

57
00:02:50,029 --> 00:02:57,030
气瓶跟踪部门拼盘 

58
00:02:53,035 --> 00:02:59,086
表面和与访问特定 

59
00:02:57,039 --> 00:03:02,056
部门对那些你必须有一个磁盘 

60
00:02:59,086 --> 00:03:05,104
指定所述气缸和所述轨道和

61
00:03:02,056 --> 00:03:07,078
表面上不错，但我们看到， 

62
00:03:06,004 --> 00:03:09,016
查看这个控制器是本 

63
00:03:07,078 --> 00:03:12,082
它实际上是不同的这是一个 

64
00:03:09,016 --> 00:03:14,047
磁盘和的虚拟化视图

65
00:03:12,082 --> 00:03:15,088
控制器，而不是呈现给

66
00:03:14,047 --> 00:03:20,128
盘面来看的内核系列

67
00:03:16,042 --> 00:03:23,053
逻辑块和它的一个序列的

68
00:03:21,028 --> 00:03:25,707
提出这一观点被拦截 

69
00:03:23,053 --> 00:03:29,232
从请求从内核 寻求 

70
00:03:25,959 --> 00:03:32,320
用于I / O 和改变这些逻辑块 

71
00:03:29,709 --> 00:03:34,740
数字， 该内核发送 

72
00:03:32,032 --> 00:03:41,035
到 实际的物理地址 好了， 

73
00:03:35,019 --> 00:03:45,580
这是一个非常非常重要的例子 

74
00:03:41,062 --> 00:03:51,073
在系统虚拟化 的 现在 

75
00:03:45,058 --> 00:03:53,065
该内存是一个很是关键 

76
00:03:51,073 --> 00:03:55,111
资源在系统中， 我们发现 了什么 

77
00:03:53,065 --> 00:03:59,092
是它的虚拟化是非常有用 

78
00:03:56,011 --> 00:04:03,037
该内存资源 好 和 

79
00:03:59,092 --> 00:04:05,191
办法做到这一点 ，我们 还记得 之前 

80
00:04:03,037 --> 00:04:09,082
通过具有磁盘虚拟磁盘

81
00:04:06,091 --> 00:04:12,142
在的情况下控制器监听请求

82
00:04:09,082 --> 00:04:14,131
的主 存储器资源 

83
00:04:13,042 --> 00:04:17,391
请求由实际截获

84
00:04:15,031 --> 00:04:18,930
一块硬件 称为 MMU的 

85
00:04:17,769 --> 00:04:21,812
内存管理单元 

86
00:04:19,209 --> 00:04:25,360
所以这种工作方式是 CPU 

87
00:04:22,199 --> 00:04:27,130
执行指令说这是一招 

88
00:04:25,036 --> 00:04:29,107
指令可生成 一些 

89
00:04:27,013 --> 00:04:31,041
有效的地址，这其实是一个 

90
00:04:30,007 --> 00:04:35,053
虚拟地址 

91
00:04:31,041 --> 00:04:36,110
它的CPU发送一个地址给 

92
00:04:35,053 --> 00:04:38,472
MMU

93
00:04:36,479 --> 00:04:40,900
它经过 这个过程被称为 

94
00:04:38,949 --> 00:04:43,720
地址转换将将就

95
00:04:40,009 --> 00:04:45,648
今天研究后，将其 转换是 

96
00:04:43,072 --> 00:04:49,135
在这种 情况下的虚拟地址为1 0 0 

97
00:04:46,539 --> 00:04:52,860
转换成 物理 地址 ，其为 

98
00:04:50,035 --> 00:04:56,634
实际上对应的地址 

99
00:04:52,086 --> 00:04:58,183
数据对象，我们要 确定这样 

100
00:04:56,949 --> 00:05:03,190
一次一次的MMU将虚拟 

101
00:04:59,083 --> 00:05:04,108
地址到物理地址， 则 

102
00:05:03,019 --> 00:05:07,086
内存将在返回 的字 

103
00:05:05,008 --> 00:05:07,086
在该地址 

104
00:05:08,039 --> 00:05:14,590
所以这可能会奇怪，为什么在世界上

105
00:05:13,015 --> 00:05:16,096
你想做好这一点事实 

106
00:05:14,059 --> 00:05:20,086
出有各种各样的好理由 

107
00:05:16,096 --> 00:05:22,102
虚拟化的地址空间等 

108
00:05:20,086 --> 00:05:26,113
之前， 我可以解释一下那些你让我 

109
00:05:23,002 --> 00:05:31,033
我只是定义了几个几个教了 几 

110
00:05:27,013 --> 00:05:33,792
术语所以地址空间是一组 

111
00:05:31,033 --> 00:05:37,090
解决好了，所以 地址空间 是 

112
00:05:33,909 --> 00:05:40,932
设置不是没有的数据字节，但的 

113
00:05:37,009 --> 00:05:43,047
这些字节和线性的地址 

114
00:05:41,139 --> 00:05:47,280
地址空间是一个内容 是 

115
00:05:44,028 --> 00:05:51,477
组连续的连续的

116
00:05:47,028 --> 00:05:55,033
非负整数好了，所以只是0 1 2

117
00:05:51,729 --> 00:05:57,801
3 4 5等的虚拟 地址 

118
00:05:55,078 --> 00:06:00,027
空间是一组n个等于2的N个 

119
00:05:58,449 --> 00:06:03,610
虚拟地址的线性这是一个线性 

120
00:06:00,729 --> 00:06:06,460
地址空间 和物理 地址 

121
00:06:03,061 --> 00:06:11,990
空间是一组中的m 等于 n物理 

122
00:06:06,046 --> 00:06:16,102
地址确定，因此通常 

123
00:06:12,539 --> 00:06:18,970
延期的地址空间通常是 

124
00:06:17,002 --> 00:06:20,047
比物理 地址大得多

125
00:06:18,097 --> 00:06:22,102
空间确定的物理地址空间 

126
00:06:20,047 --> 00:06:24,966
对应于 DRAM 的量 

127
00:06:23,002 --> 00:06:27,043
你确实有在 系统中 

128
00:06:25,389 --> 00:06:31,780
虚拟地址空间是相同的 

129
00:06:27,043 --> 00:06:36,079
该系统上运行的所有的所有进程

130
00:06:31,078 --> 00:06:39,082
现在没事了，为什么，为什么我们要实现 

131
00:06:36,079 --> 00:06:42,168
虚拟内存为什么做这个，为什么我做的 

132
00:06:39,082 --> 00:06:45,145
这个级别的间接与MMU 

133
00:06:43,068 --> 00:06:49,156
也没什么三大原因 使 

134
00:06:46,045 --> 00:06:53,053
第一是虚拟存储器使用 

135
00:06:50,056 --> 00:06:56,110
在采用DRAM 作为高速缓存 

136
00:06:54,025 --> 00:06:58,104
存储 在磁盘上 的实际数据 好了，所以你 

137
00:06:57,001 --> 00:07:02,089
可以认为虚拟内存的作为 

138
00:06:59,004 --> 00:07:07,051
DRAM高速缓存存储在磁盘上的数据

139
00:07:02,098 --> 00:07:08,164
这允许我们 使用内存 

140
00:07:07,051 --> 00:07:11,080
更高效，因为 我们只 

141
00:07:09,064 --> 00:07:12,145
需要被频繁缓存项 

142
00:07:11,008 --> 00:07:15,010
正确的使用一样的 想法， 我们 

143
00:07:13,045 --> 00:07:19,108
据悉，当我们我们谈到缓存 

144
00:07:16,000 --> 00:07:21,091
和地方所以这是一两件事，我们 可以 

145
00:07:20,008 --> 00:07:24,061
使用我们可以 使用内存更 

146
00:07:21,091 --> 00:07:25,350
有效地通过仅使用部分 

147
00:07:24,061 --> 00:07:27,103
仅由虚拟地址空间 

148
00:07:26,169 --> 00:07:30,100
实际存储的部分 

149
00:07:28,003 --> 00:07:32,095
在物理虚拟地址空间 

150
00:07:30,001 --> 00:07:35,095
内存还好第二件事 是 

151
00:07:32,095 --> 00:07:38,146
大大简化了存储管理， 

152
00:07:36,004 --> 00:07:41,077
我们看到它的每一个进程 都拥有相同的 

153
00:07:39,046 --> 00:07:43,005
同样的观点在那里代码加载在 

154
00:07:41,077 --> 00:07:45,786
代码和数据总是被载入在 

155
00:07:43,419 --> 00:07:50,470
相同的地址 堆栈在顶部 

156
00:07:46,479 --> 00:07:52,560
用户可见的地址空间，所以每 

157
00:07:50,047 --> 00:07:56,122
过程具有 相同的 外观类似的 

158
00:07:53,289 --> 00:08:00,760
虚拟地址空间 ，但在实际中 

159
00:07:57,022 --> 00:08:02,101
现实是，在 内存 

160
00:08:00,076 --> 00:08:05,103
对应于那些那些地址被 

161
00:08:03,001 --> 00:08:10,220
实际上分散在主存

162
00:08:06,003 --> 00:08:14,055
好了，所以这是一个非常重要的 

163
00:08:10,229 --> 00:08:17,770
重要的中心设置 虚拟内存 

164
00:08:14,055 --> 00:08:24,234
然后最后它 使我们 能够保护 

165
00:08:17,077 --> 00:08:25,150
存取所以记得我们有一个过程 

166
00:08:24,729 --> 00:08:29,110
我们看到的是一个过程提供 

167
00:08:26,005 --> 00:08:30,049
独立的地址空间是这 

168
00:08:29,011 --> 00:08:31,090
其他保护访问

169
00:08:30,094 --> 00:08:33,118
流程

170
00:08:31,009 --> 00:08:35,838
好了，所以虚拟内存可以让我们 

171
00:08:34,018 --> 00:08:38,100
创建这些这些 单独的保护 

172
00:08:36,729 --> 00:08:41,490
私有地址空间好吗 

173
00:08:39,000 --> 00:08:44,699
而我们今天会做所以我们将看看在 

174
00:08:41,049 --> 00:08:47,198
在这三个理念更多的细节和 

175
00:08:44,699 --> 00:08:49,700
然后我们会，然后我们会进入 

176
00:08:47,639 --> 00:08:52,688
地址转换的细节，所以我 

177
00:08:49,709 --> 00:08:54,750
要为第一的第一部分 

178
00:08:53,129 --> 00:08:57,000
本次讲座我们要谈 

179
00:08:54,075 --> 00:08:58,122
只是那种地址转换 

180
00:08:57,000 --> 00:09:00,093
高层次的条件，但随后我们将进入 

181
00:08:59,022 --> 00:09:03,641
在最后 的细节 ，你可以看到 

182
00:09:00,093 --> 00:09:06,111
它是如何真的工作好让 我们 

183
00:09:03,839 --> 00:09:09,720
看看VM作为高速缓存的工具，所以 

184
00:09:07,011 --> 00:09:12,036
概念上，你能想到的你 

185
00:09:09,072 --> 00:09:16,077
虚拟存储器作为字节序列 

186
00:09:12,036 --> 00:09:20,255
存储在磁盘上没关系，然后 

187
00:09:17,022 --> 00:09:23,081
那中的内容内容

188
00:09:20,579 --> 00:09:26,630
存储在磁盘上虚拟内存是 

189
00:09:23,279 --> 00:09:31,110
在DRAM缓存好了，所以想到的 

190
00:09:27,089 --> 00:09:34,138
DRAM 是此这个阵列的高速缓冲存储器 

191
00:09:31,011 --> 00:09:37,035
存储在盘上 连续 的字节 和 

192
00:09:34,579 --> 00:09:40,920
就像任何高速缓存中的数据是 

193
00:09:37,035 --> 00:09:43,214
分解成块 行不行 ，然后我们 

194
00:09:40,092 --> 00:09:44,130
有那么这里 我们有那些 

195
00:09:43,529 --> 00:09:48,870
用于虚拟存储器系统块是

196
00:09:45,003 --> 00:09:50,972
所谓网页他们通常一般 

197
00:09:48,087 --> 00:09:54,090
比大于高速缓存大得多大

198
00:09:51,269 --> 00:09:57,323
我们认为我们的研究做了这么块

199
00:09:55,017 --> 00:09:59,546
千字节，而不是通常的64个 

200
00:09:57,809 --> 00:10:01,892
字节喜欢我们，我们了解了 

201
00:09:59,699 --> 00:10:04,500
在我们研究的高速缓冲存储器，所以 

202
00:10:02,639 --> 00:10:06,683
这个虚拟内存概念，你可以 

203
00:10:04,005 --> 00:10:09,054
把它看作是页面序列 

204
00:10:07,079 --> 00:10:14,670
存储所谓的虚拟磁盘上 

205
00:10:09,099 --> 00:10:15,174
页面和这些页面会 

206
00:10:14,067 --> 00:10:19,125
与一些识别所以这里的虚拟

207
00:10:16,074 --> 00:10:21,653
第零 虚拟页面之一，然后一 

208
00:10:20,025 --> 00:10:24,854
这些页面的子集存储在 

209
00:10:22,319 --> 00:10:28,160
在物理DRAM的物理存储器 

210
00:10:25,079 --> 00:10:32,084
内存中，然后有一些映射

211
00:10:28,016 --> 00:10:34,023
函数，告诉我们有哪些网页 

212
00:10:32,579 --> 00:10:36,647
在这种情况下， 我已经缓存好了， 

213
00:10:34,086 --> 00:10:39,174
只是显示一个快照，我们有 

214
00:10:37,259 --> 00:10:44,730
三个虚拟缓存的页面某处 

215
00:10:40,074 --> 00:10:46,100
DRAM 没关系，有没有关系 

216
00:10:44,073 --> 00:10:49,852
虚拟页码和之间 

217
00:10:47,000 --> 00:10:52,035
，它的映射到物理页号 

218
00:10:50,509 --> 00:10:54,450
一些网页

219
00:10:52,035 --> 00:10:57,090
不缓存 ，因此 他们在他们 

220
00:10:54,045 --> 00:11:00,120
仍然存储在磁盘上，以便在这种情况下VP 

221
00:10:57,009 --> 00:11:02,016
2仍然存储在磁盘上并有 

222
00:11:01,002 --> 00:11:04,008
它甚至不分配一些网页

223
00:11:02,097 --> 00:11:06,099
所以他们不 磁盘上存在 

224
00:11:04,008 --> 00:11:07,013
但它认为该权利的方式

225
00:11:06,099 --> 00:11:10,101
因为 我们真的不希望 存储 

226
00:11:08,003 --> 00:11:13,071
每一个单页的地址空间 

227
00:11:11,019 --> 00:11:15,081
这是对大小为48， 我们真的 

228
00:11:13,098 --> 00:11:19,113
不想存储所有的这些 

229
00:11:15,081 --> 00:11:28,170
在磁盘上所以大部分的地址空间是 

230
00:11:20,013 --> 00:11:32,096
未分配的确定，所以我们可以试想的 

231
00:11:29,007 --> 00:11:35,031
这使该DRAM这仅仅是一个高速缓存 

232
00:11:32,096 --> 00:11:36,174
但它有很多不同的组织 

233
00:11:35,094 --> 00:11:38,169
比高速缓冲存储器我们研究 

234
00:11:37,074 --> 00:11:41,102
更早这些差别 

235
00:11:39,069 --> 00:11:44,148
通过巨大的命中判罚驱动

236
00:11:42,002 --> 00:11:49,077
当你从如果你有一个缓存去 

237
00:11:45,048 --> 00:11:53,097
DRAM 的小姐处罚会这样 

238
00:11:49,077 --> 00:11:56,109
从磁盘中的数据项是巨大的，我们这么 

239
00:11:53,097 --> 00:11:58,149
这个虚拟内存缓存设计

240
00:11:57,009 --> 00:12:03,024
完全被这个巨大的推动小姐 

241
00:11:59,049 --> 00:12:04,098
罚分和所以作为结果的块 

242
00:12:03,024 --> 00:12:06,087
较大所以记得我们谈到了

243
00:12:04,098 --> 00:12:11,115
该块尺寸是 种一 

244
00:12:06,087 --> 00:12:14,106
排序的有用之间权衡获得 

245
00:12:12,015 --> 00:12:18,072
使用能有效地分摊

246
00:12:15,006 --> 00:12:20,067
取的成本，阻止与排序 

247
00:12:18,072 --> 00:12:24,084
中消耗了太多这种稀缺的 

248
00:12:20,067 --> 00:12:27,122
缓存空间 权所以在这种 情况下，我们 

249
00:12:24,084 --> 00:12:29,181
高速缓冲存储器，分别为64字节的块

250
00:12:28,022 --> 00:12:33,027
虚拟大多数虚拟内存系统具有 

251
00:12:30,081 --> 00:12:36,093
像，并用4个KB字节的块 

252
00:12:33,072 --> 00:12:41,091
选项来增加在4兆字节 

253
00:12:36,093 --> 00:12:42,165
86的情况下，现在这个现金及其他 

254
00:12:41,091 --> 00:12:47,100
巨大的缺失损失的后果

255
00:12:43,065 --> 00:12:49,140
是，你真的想有大 

256
00:12:48,000 --> 00:12:51,087
关联你能记住我们看到 

257
00:12:50,004 --> 00:12:54,018
与直接映射缓存是为 

258
00:12:51,087 --> 00:12:55,164
受 这些冲突未和 

259
00:12:54,054 --> 00:12:58,059
如果你，如果你增加 

260
00:12:56,064 --> 00:13:00,087
您减少缓存的关联性

261
00:12:58,059 --> 00:13:02,103
这些冲突的概率 

262
00:13:00,087 --> 00:13:04,185
未命中但你永远不完全 

263
00:13:03,003 --> 00:13:08,010
消灭他们，直到你有一个完全如此 

264
00:13:05,085 --> 00:13:10,089
我应该 现金只用一套好吗 

265
00:13:08,001 --> 00:13:14,720
所以在虚拟存储器中的虚拟 

266
00:13:11,025 --> 00:13:16,122
内存缓存 是完全关联 

267
00:13:14,819 --> 00:13:21,857
有一组和每个虚拟页面 

268
00:13:17,022 --> 00:13:24,011
可以在高速缓存中去任何地方好了， 

269
00:13:22,199 --> 00:13:26,100
这需要一个非常复杂的 

270
00:13:24,209 --> 00:13:29,100
映射功能在某种程度上 ， 我们要 

271
00:13:26,001 --> 00:13:33,003
跟踪所有这些缓存 

272
00:13:29,001 --> 00:13:35,360
页面，我们真的不能做 

273
00:13:33,003 --> 00:13:36,842
搜索，这将是这将是这样 

274
00:13:35,459 --> 00:13:39,720
太便宜的，所以你还记得我们 

275
00:13:37,139 --> 00:13:41,146
与高速缓冲存储器硬件 

276
00:13:39,072 --> 00:13:45,191
实际上做了 一个 集内搜索 

277
00:13:41,839 --> 00:13:48,881
并行搜索 来 找到试图找到 

278
00:13:45,839 --> 00:13:51,600
高速缓存行，但与软件缓存 

279
00:13:49,259 --> 00:13:53,190
像这样的，这不是可行 

280
00:13:51,006 --> 00:13:54,075
没事所以在某种程度上我们将 有 

281
00:13:53,019 --> 00:14:00,278
要记住，这些缓存块 

282
00:13:55,029 --> 00:14:02,638
在这个非常大集，并再次 因为 

283
00:14:00,449 --> 00:14:05,490
它是如此昂贵，如果你犯了一个 错误 

284
00:14:02,899 --> 00:14:08,936
当你试图找出 运行 

285
00:14:05,049 --> 00:14:10,958
受害者的受害者页面，如果你犯了一个错误 

286
00:14:09,269 --> 00:14:13,331
你驱逐一个页面，然后是 

287
00:14:11,399 --> 00:14:15,485
在不久的将来再次引用您 

288
00:14:13,889 --> 00:14:18,902
付出大代价 好吗 

289
00:14:16,259 --> 00:14:20,790
所以虚拟内存高速缓存有更 

290
00:14:19,019 --> 00:14:23,075
复杂的替换算法

291
00:14:20,079 --> 00:14:25,358
不是像我们看到用简单的LRU

292
00:14:23,579 --> 00:14:26,666
高速缓冲存储器，现在他们这些 

293
00:14:26,069 --> 00:14:29,114
替换算法是外

294
00:14:27,449 --> 00:14:32,730
本课程您将 学习 范围 

295
00:14:29,519 --> 00:14:34,538
关于他们，当你把 操作系统，但因为 

296
00:14:32,073 --> 00:14:37,162
它在软件，我们 可以，我们能负担得起 

297
00:14:34,709 --> 00:14:42,000
做的非常昂贵的 替换算法 

298
00:14:37,819 --> 00:14:45,930
我们需要很长的还算比较 

299
00:14:42,000 --> 00:14:49,819
很长一段时间来执行代码的 那些 

300
00:14:45,093 --> 00:14:52,922
算法，因为任何时候我们花 

301
00:14:49,819 --> 00:14:56,550
找出受害者块将大大 

302
00:14:53,759 --> 00:14:59,100
不到 制作的成本 

303
00:14:56,055 --> 00:15:01,122
错误和支付的访问时间 

304
00:14:59,001 --> 00:15:05,039
那么这一次的 错过 点球 ，以 

305
00:15:02,022 --> 00:15:07,029
磁盘， 然后也可 作为结果 

306
00:15:05,048 --> 00:15:09,075
虚拟内存系统从未使用权

307
00:15:07,092 --> 00:15:11,261
通过只是 因为它需要 一个 

308
00:15:09,075 --> 00:15:14,594
像这样他们总是用右后卫和 

309
00:15:12,089 --> 00:15:18,500
他们试图推迟写任何东西

310
00:15:15,269 --> 00:15:18,500
磁盘尽可能长 

311
00:15:18,078 --> 00:15:22,081
现在好了，我们如何跟踪 

312
00:15:21,004 --> 00:15:27,040
不知何故，我们必须跟踪这个 

313
00:15:23,008 --> 00:15:29,052
复杂的缓存和DRAM 及 数据 

314
00:15:27,076 --> 00:15:31,159
结构， 保持轨道 

315
00:15:29,052 --> 00:15:36,127
在虚拟页面 的位置

316
00:15:32,059 --> 00:15:39,064
现在的内存被称为页表 

317
00:15:37,027 --> 00:15:42,109
页表只是 在数据结构 

318
00:15:39,064 --> 00:15:44,140
内存内核维护用于为 

319
00:15:43,009 --> 00:15:47,073
每个进程上下文的一部分好了，所以 

320
00:15:45,004 --> 00:15:52,018
每个进程都有自己的页表 和 

321
00:15:47,073 --> 00:15:57,147
它只是一个 它是 所谓 的数组 

322
00:15:52,054 --> 00:16:00,090
页表项或PT ES其中PT EK 

323
00:15:58,047 --> 00:16:09,052
包含的物理地址

324
00:16:00,009 --> 00:16:11,032
D中拉姆物理页。K 好吧所以这里的 

325
00:16:09,097 --> 00:16:15,196
它是如何工作有有此页 

326
00:16:12,013 --> 00:16:19,062
表DRAM有虚拟页面 

327
00:16:16,096 --> 00:16:18,162
存储在磁盘上

328
00:16:21,057 --> 00:16:26,696
然后有自己的东西 ，然后 

329
00:16:25,056 --> 00:16:29,142
有身体有虚拟页 

330
00:16:27,209 --> 00:16:33,233
存储在DRAM各种物理页 

331
00:16:30,042 --> 00:16:35,049
然后页表跟踪 

332
00:16:33,449 --> 00:16:41,040
其中那些存储所以在这里我们有一个 

333
00:16:36,012 --> 00:16:44,031
情况下， 这 PTë1对应于虚拟 

334
00:16:41,004 --> 00:16:47,033
第1页，在这种情况下，它说， 

335
00:16:44,031 --> 00:16:52,098
虚拟页面1被映射到物理 

336
00:16:47,069 --> 00:16:57,990
第0页虚拟页2被映射到 

337
00:16:52,098 --> 00:17:01,757
物理页1和 现在 这样 的一些 

338
00:16:57,099 --> 00:17:04,161
这些不在内存的页面

339
00:17:02,639 --> 00:17:08,520
存储在磁盘上的分配页 

340
00:17:05,061 --> 00:17:09,069
所以对这些页面 的页表 

341
00:17:08,052 --> 00:17:13,065
条目包含的指针位置 

342
00:17:10,041 --> 00:17:15,680
那对磁盘页面，以便把它 

343
00:17:13,065 --> 00:17:18,066
作为逻辑块数，其中该 

344
00:17:16,049 --> 00:17:22,860
页面可以在磁盘上，然后找到 

345
00:17:18,066 --> 00:17:25,137
一些网页都没有这么分配 

346
00:17:22,086 --> 00:17:32,133
有有一个没有空条目的 

347
00:17:26,037 --> 00:17:34,119
页表打到现在一个页面，所以这是 

348
00:17:33,033 --> 00:17:37,128
只是缓存权，所以我们有命中和 

349
00:17:35,019 --> 00:17:40,107
错过这样一个页面时有发生尚 

350
00:17:38,028 --> 00:17:43,095
在一个字反相的参考

351
00:17:41,007 --> 00:17:47,102
多数民众赞成包含的虚拟地址空间 

352
00:17:43,095 --> 00:17:50,100
该公司在DRAM缓存 确定 一个页面 

353
00:17:48,002 --> 00:17:53,531
所以我们说，我们有你知道 

354
00:17:51,000 --> 00:17:58,073
CPU 执行这一点，移动 指令它 

355
00:17:53,549 --> 00:18:01,710
生成一个虚拟地址的MMU 

356
00:17:58,073 --> 00:18:03,101
在页表中查找并让我们说 

357
00:18:01,071 --> 00:18:10,113
这个虚拟地址内的某处 

358
00:18:04,001 --> 00:18:14,007
虚拟第 2 页 确定，这样的MMU 

359
00:18:11,013 --> 00:18:19,047
查找的页表项数2 

360
00:18:14,061 --> 00:18:22,148
和它打它提取物理 

361
00:18:19,047 --> 00:18:29,079
那虚拟页面2的地址

362
00:18:23,048 --> 00:18:31,134
好了 ，所以这是一个命中 因此，在这种情况下， 

363
00:18:29,079 --> 00:18:33,165
这种情况下， 

364
00:18:32,034 --> 00:18:39,038
该页面是在 内存 中 它的缓存中 

365
00:18:34,065 --> 00:18:44,136
记忆， 所以我们有一个 打了，现在 

366
00:18:39,074 --> 00:18:48,080
该内存可以可以返回，可 

367
00:18:45,036 --> 00:18:57,042
返回物理地址的MMU 

368
00:18:49,034 --> 00:19:00,051
现在没事了 一个 小姐是 一个字 一个参考 

369
00:18:57,096 --> 00:19:02,187
这不是在缓存中的物理 

370
00:19:00,051 --> 00:19:08,450
存储器中，从而在这种情况下虚拟页0 1

371
00:19:03,087 --> 00:19:12,183
2 3 没有在DRAM缓存 它的存储 

372
00:19:08,909 --> 00:19:17,640
它使现在，这是存储在磁盘上

373
00:19:13,083 --> 00:19:19,083
触发异常确定页面错误 

374
00:19:17,064 --> 00:19:21,123
除了在硬件硬件

375
00:19:19,083 --> 00:19:24,147
引发异常，并导致 

376
00:19:22,023 --> 00:19:26,094
控制 转移 到的大块 

377
00:19:25,047 --> 00:19:30,866
在内核代码中调用的页面错误

378
00:19:26,094 --> 00:19:34,122
处理程序，其然后选择一个牺牲品 

379
00:19:31,289 --> 00:19:40,620
在这种情况下， 虚拟第 4 页被驱逐 

380
00:19:35,022 --> 00:19:46,038
并从获取虚拟页3 

381
00:19:40,062 --> 00:19:50,111
磁盘加载它到内存中， 如果和 

382
00:19:46,038 --> 00:19:51,135
然后改变和再更新 此 

383
00:19:50,669 --> 00:19:53,744
页表项，以反映这一事实 

384
00:19:52,035 --> 00:19:56,744
虚拟第4页现在存储在 

385
00:19:54,419 --> 00:19:58,457
磁盘，并在虚拟页4已经

386
00:19:57,059 --> 00:20:00,068
在任何时候，将不得不 修改 

387
00:19:58,799 --> 00:20:07,835
写它的内容

388
00:20:00,149 --> 00:20:11,490
这是一个磁盘，以及因此一旦一次

389
00:20:08,159 --> 00:20:14,198
处理程序被复制虚拟页3 

390
00:20:11,049 --> 00:20:18,458
到存储器中导致该指令

391
00:20:14,549 --> 00:20:20,636
页面错误，现在可以重新确定执行 

392
00:20:18,899 --> 00:20:22,925
所以一旦所以当页面错误 

393
00:20:21,419 --> 00:20:25,110
处理程序和内核返回它 

394
00:20:23,159 --> 00:20:28,223
返回到错误指令 

395
00:20:25,011 --> 00:20:34,014
然后反应Acutes 和现在 

396
00:20:28,799 --> 00:20:36,812
当MMU检查该网页的私人 

397
00:20:34,014 --> 00:20:38,085
对应于该网页时发现， 

398
00:20:36,929 --> 00:20:42,240
它现在是确实缓存，以便使 

399
00:20:38,085 --> 00:20:43,142
指令可以继续，我们可以

400
00:20:42,024 --> 00:20:47,078
获取该 

401
00:20:44,042 --> 00:20:54,083
在虚拟无论什么字

402
00:20:47,078 --> 00:20:55,172
从DRAM还好现在我们解决

403
00:20:54,083 --> 00:20:59,180
我们可以分配一个新的 内存 页 

404
00:20:56,072 --> 00:21:06,107
所以在这个例子 虚拟页0 1 2 3 

405
00:21:00,008 --> 00:21:08,057
4 5不分配，所以如果你需要 

406
00:21:07,007 --> 00:21:12,101
假设你做的一个非常大的malloc

407
00:21:09,029 --> 00:21:15,032
虚拟地址空间的块，如果它是 

408
00:21:13,001 --> 00:21:17,006
这些页面如果 这些页面 中的一个 也没有 

409
00:21:15,032 --> 00:21:19,070
被分配又那么内核

410
00:21:17,006 --> 00:21:22,049
实际上或malloc函数 实际上 

411
00:21:19,007 --> 00:21:24,101
必须通过创建分配内存 

412
00:21:22,049 --> 00:21:27,131
调用叫 分手吧 OK功能和 

413
00:21:25,064 --> 00:21:34,082
那么什么分手吧不实际 

414
00:21:28,031 --> 00:21:36,032
此分配这个页面和记录 

415
00:21:34,082 --> 00:21:40,097
它现在加载大概会

416
00:21:36,032 --> 00:21:42,086
居然把它变成现在我猜

417
00:21:40,097 --> 00:21:43,190
会不会真正出现在 

418
00:21:42,086 --> 00:21:44,183
，在DRAM缓存中，直到它是 

419
00:21:44,009 --> 00:21:47,063
页面被感动

420
00:21:45,083 --> 00:21:51,122
好了，只是分配空间只 

421
00:21:48,044 --> 00:21:54,062
改变了这一页表项，然后 

422
00:21:52,022 --> 00:21:58,099
当页面被实际触摸然后 

423
00:21:54,062 --> 00:22:00,068
它会被带入高速缓存，所以我 

424
00:21:58,099 --> 00:22:02,102
不知道你，但第 一次 

425
00:22:01,022 --> 00:22:05,030
我得知这个情况我是我是 相当 

426
00:22:03,029 --> 00:22:09,041
震惊它只是似乎是最 

427
00:22:06,002 --> 00:22:10,100
权如何在效率低下的可怕的想法 

428
00:22:09,041 --> 00:22:16,067
世界你能负担得起每

429
00:22:11,000 --> 00:22:20,006
单每一个指令 

430
00:22:16,067 --> 00:22:22,070
使用内存做这一切的拷贝回来， 

431
00:22:20,006 --> 00:22:23,093
提出并以表和它仰视

432
00:22:22,007 --> 00:22:26,069
似乎只是一个可怕的想法 

433
00:22:23,093 --> 00:22:29,150
但再次局部性拯救我们确定， 

434
00:22:27,032 --> 00:22:33,101
它它的实际工作，因为方案 

435
00:22:30,005 --> 00:22:37,016
有局部性确定，它实际上是 

436
00:22:34,001 --> 00:22:40,064
相当有效，其原因在于 

437
00:22:37,061 --> 00:22:42,086
在时间程序的任何点往往 

438
00:22:40,064 --> 00:22:45,161
访问一组页面称为工作 

439
00:22:42,086 --> 00:22:47,123
设置OK只是局部性权由 

440
00:22:46,061 --> 00:22:50,089
时间局部性的原则

441
00:22:48,023 --> 00:22:53,069
时间局部性和空间局部性 

442
00:22:50,089 --> 00:22:55,948
你会 有点重复使用相同的 

443
00:22:53,069 --> 00:23:00,134
事情重用 OK 附近的东西 

444
00:22:56,749 --> 00:23:02,767
所以如果工作集小于 

445
00:23:01,034 --> 00:23:04,070
主存储器大小，那么所有的 

446
00:23:02,929 --> 00:23:05,965
在当前的工作集的页面将 

447
00:23:04,007 --> 00:23:09,676
适合在内存中，然后事情会 

448
00:23:06,289 --> 00:23:12,313
伟大的不错，但如果一些 

449
00:23:10,369 --> 00:23:13,456
工作集大小每个进程 

450
00:23:12,529 --> 00:23:16,531
就在我们 的系统上运行多个 

451
00:23:14,239 --> 00:23:19,270
如果它超过 主存储器处理

452
00:23:16,729 --> 00:23:23,090
大小，然后你有这个这个 危机 

453
00:23:19,549 --> 00:23:25,190
其中处理颠簸彼此

454
00:23:23,009 --> 00:23:27,071
而导致网页被复制回 

455
00:23:25,019 --> 00:23:29,998
第四，所以你永远不会知道过程 

456
00:23:27,071 --> 00:23:33,760
曾经被 其工作设置 完全进入 

457
00:23:30,169 --> 00:23:35,251
到内存没关系，我们来看看一个 

458
00:23:34,399 --> 00:23:36,484
当我们看地址技术

459
00:23:35,989 --> 00:23:39,046
翻译我们来看看一点点

460
00:23:37,249 --> 00:23:41,305
硬件高速缓存称为翻译 

461
00:23:39,559 --> 00:23:43,645
后备缓冲器进一步

462
00:23:41,809 --> 00:23:47,818
利用的局部性

463
00:23:44,419 --> 00:23:50,437
好规划，使虚拟内存

464
00:23:47,899 --> 00:23:52,951
是 其高速缓存 工具 也是一个成员 

465
00:23:50,599 --> 00:23:55,700
哦对内存管理 和IT 

466
00:23:53,419 --> 00:23:58,467
大大简化了各种方面的 

467
00:23:55,007 --> 00:24:02,086
内存管理 为核心 的 这样 

468
00:23:58,899 --> 00:24:05,914
其核心思想是，每个进程都有 

469
00:24:02,779 --> 00:24:07,852
自己的虚拟地址空间内核 

470
00:24:06,049 --> 00:24:10,093
内核实现此 咬伤 

471
00:24:08,509 --> 00:24:12,550
给每个进程自己单独

472
00:24:10,489 --> 00:24:14,542
在 该 背景下 页表 

473
00:24:12,919 --> 00:24:17,330
过程所以它只是一个数据结构 

474
00:24:15,019 --> 00:24:22,108
内核的过程中的关键是， 

475
00:24:17,033 --> 00:24:27,059
刑事保持该进程和 

476
00:24:22,909 --> 00:24:30,960
每个进程的页表的映射 

477
00:24:27,059 --> 00:24:30,888
该进程的虚拟地址空间 

478
00:24:31,045 --> 00:24:37,654
现在是什么让你有真有意思

479
00:24:34,399 --> 00:24:39,460
这些这些页的连续页

480
00:24:38,059 --> 00:24:42,088
虚拟地址空间 可以被映射 

481
00:24:40,009 --> 00:24:45,094
任何地方的在DRAM中 

482
00:24:42,349 --> 00:24:48,820
物理地址空间 ，所以 ，他们 

483
00:24:45,859 --> 00:24:51,440
可分散各地的 地方 ， 

484
00:24:48,082 --> 00:24:53,084
不同的虚拟 页面和不同 

485
00:24:51,044 --> 00:24:55,513
过程可以被映射到 不同 

486
00:24:53,084 --> 00:24:57,158
物理页面所以在这里，我们有虚拟 

487
00:24:55,909 --> 00:25:01,948
被映射到物理页面一个 

488
00:24:58,058 --> 00:25:04,327
第二页中的过程之一，但在过程中 

489
00:25:02,299 --> 00:25:07,383
两个虚拟页面一个被映射到 

490
00:25:04,849 --> 00:25:09,500
物理Page显效8 好了，所以用这种方式 

491
00:25:08,139 --> 00:25:12,560
我们可以

492
00:25:09,005 --> 00:25:15,092
你的气味两 到各 向 

493
00:25:12,056 --> 00:25:18,137
程序员和工具 ，每个 

494
00:25:16,037 --> 00:25:20,135
过程中有 一个非常相似的地址空间 

495
00:25:19,037 --> 00:25:22,094
虚拟地址空间大小相同地址 

496
00:25:21,035 --> 00:25:25,091
空间的代码和数据开始于相同

497
00:25:22,094 --> 00:25:26,192
地方 ，但那么实际 的页面 

498
00:25:25,091 --> 00:25:30,170
使用该过程可以将分散在 

499
00:25:27,092 --> 00:25:35,093
内存确定，然后它给了 我们最 

500
00:25:31,007 --> 00:25:37,013
如果使用内存有效的方式，我们 

501
00:25:35,093 --> 00:25:38,162
没有这个机制思考 

502
00:25:38,003 --> 00:25:41,078
你将如何跟踪假设您 

503
00:25:39,062 --> 00:25:43,115
已经在机器上运行50个进程

504
00:25:42,005 --> 00:25:47,083
在 时间 如何在世界上 的任何一点 

505
00:25:44,015 --> 00:25:51,083
你会跟踪 所有 的 的 

506
00:25:47,083 --> 00:25:52,178
数据的那些过程进行了使用公一个 

507
00:25:51,083 --> 00:25:55,088
技术， 你可以在事实上想象 

508
00:25:53,078 --> 00:25:58,112
它是在用在坏 日子 

509
00:25:55,088 --> 00:26:00,092
将 虚拟内存一件事你可以 

510
00:25:59,012 --> 00:26:02,087
可以想象的是，只给每个进程 

511
00:26:00,092 --> 00:26:04,115
其自身的物理地址块

512
00:26:02,087 --> 00:26:07,091
空间 只是把你的物理地址 

513
00:26:05,015 --> 00:26:10,016
空间划分它，然后将每个处理 

514
00:26:07,091 --> 00:26:11,177
得到加载和运行， 它是它自己 

515
00:26:10,016 --> 00:26:14,042
地址空间 的一部分， 以及该有 

516
00:26:12,077 --> 00:26:16,115
各种问题好吧， 我的意思是你 

517
00:26:14,042 --> 00:26:20,069
可如果你什么你，如果你添加一个做 

518
00:26:17,015 --> 00:26:22,016
过程所以你真的不能分区

519
00:26:20,069 --> 00:26:24,080
你真的 要地址空间

520
00:26:22,016 --> 00:26:26,060
那种说好每道工序得到一些 

521
00:26:24,008 --> 00:26:27,026
小块，我要去 准备金 

522
00:26:26,006 --> 00:26:30,058
在一些情况下 ，地址空间 

523
00:26:27,098 --> 00:26:32,132
有需要 的内存 新工艺 

524
00:26:31,012 --> 00:26:34,031
另一个问题是， 现在你必须 

525
00:26:33,032 --> 00:26:36,038
编写程序 

526
00:26:34,031 --> 00:26:39,113
你不能只是眨眼程序提前 

527
00:26:36,092 --> 00:26:41,176
的时间，因为它必须被重新定位 

528
00:26:40,013 --> 00:26:45,062
当它的加载 正确的，因为你 不知道 

529
00:26:42,076 --> 00:26:46,091
你知道一个过程中，你 不知道在哪里 

530
00:26:45,062 --> 00:26:48,158
在存储它会去它的 

531
00:26:46,091 --> 00:26:51,157
会 所以你必须 得到一些大块 

532
00:26:49,058 --> 00:26:55,103
要么重新定位的所有引用 

533
00:26:52,057 --> 00:26:58,112
在何时全局符号引用 

534
00:26:56,003 --> 00:27:01,079
它的实际加载 或你必须 

535
00:26:59,012 --> 00:27:03,068
创建一个系统 ，所有 的 

536
00:27:01,079 --> 00:27:06,080
指令是相对所以有

537
00:27:03,068 --> 00:27:08,105
没有绝对地址的所有 

538
00:27:06,008 --> 00:27:10,103
地址是相对的说法开始

539
00:27:09,005 --> 00:27:12,101
方案 类似 的东西 ，所以 

540
00:27:11,075 --> 00:27:15,077
反正所有 的这些东西都只是 

541
00:27:13,001 --> 00:27:21,067
非常复杂，他们都 

542
00:27:15,077 --> 00:27:20,086
通过虚拟存储解决精美

543
00:27:25,018 --> 00:27:30,050
因此每个虚拟页可以映射 

544
00:27:29,006 --> 00:27:33,047
任何物理页面，以便 真正 

545
00:27:30,005 --> 00:27:34,082
有助于简化的东西 ，甚至在 

546
00:27:33,047 --> 00:27:36,101
不同时间对同一虚拟页面

547
00:27:35,027 --> 00:27:39,032
可被存储 在不同的 物理 

548
00:27:37,001 --> 00:27:40,097
在不同的时间 正确 的网页 ，所以如果一个 

549
00:27:39,032 --> 00:27:42,128
它页了，虽然可能 

550
00:27:40,097 --> 00:27:43,160
缓存在一个物理页面，然后它会 

551
00:27:43,028 --> 00:27:46,046
换出， 下一次，它是 

552
00:27:44,006 --> 00:27:48,080
引用它可以获取缓存在

553
00:27:46,046 --> 00:27:50,123
不同的物理页面是 ， 如果它的 

554
00:27:49,034 --> 00:27:54,095
不再可用 右 所以它提供 

555
00:27:51,023 --> 00:28:00,026
排序最灵活的调度 

556
00:27:54,095 --> 00:28:02,138
自由 的方式，我们在路上 

557
00:28:00,026 --> 00:28:04,124
我们管理内存，它也 

558
00:28:03,038 --> 00:28:07,064
提供这种 非常灵巧的能力 

559
00:28:05,024 --> 00:28:10,027
在这里你可以映射虚拟页到 

560
00:28:07,064 --> 00:28:13,121
相同的物理页面 ，以便有，这是一个 

561
00:28:10,054 --> 00:28:17,066
对于非常简单直接的方法 

562
00:28:14,021 --> 00:28:20,114
多个进程共享某些代码

563
00:28:17,066 --> 00:28:25,073
或数据确定， 你 做 的 是你 

564
00:28:21,014 --> 00:28:28,019
只是 在这些 页表项 

565
00:28:26,036 --> 00:28:29,093
不同的进程刚刚指向 

566
00:28:28,019 --> 00:28:34,028
相同的物理页面所以在这种情况下， 

567
00:28:29,093 --> 00:28:35,186
虚拟页2分至6的物理页 

568
00:28:34,028 --> 00:28:41,036
每个在每个页表

569
00:28:36,086 --> 00:28:42,179
过程1和过程2，所以这是 

570
00:28:41,036 --> 00:28:46,067
如何共享库实现

571
00:28:43,079 --> 00:28:48,161
右所以 库C 是相同的代码 

572
00:28:46,067 --> 00:28:50,075
在系统上 运行的每个过程 ，以便 

573
00:28:49,061 --> 00:28:53,117
嘴唇娘家只需要加载一次 

574
00:28:51,047 --> 00:28:56,129
成物理到物理存储器和 

575
00:28:54,017 --> 00:29:00,035
那么想的进程访问 

576
00:28:57,029 --> 00:29:01,091
功能和数据在库Ç只是 映射 

577
00:29:00,035 --> 00:29:03,116
在他们的虚拟地址空间 的页面

578
00:29:01,091 --> 00:29:05,186
在那里 看到 的物理 页面 

579
00:29:04,016 --> 00:29:08,072
实际负载的确定，所以现在有只 

580
00:29:06,086 --> 00:29:10,118
让我们来看看无处不在 的的一个副本

581
00:29:08,072 --> 00:29:12,169
系统但是每个进程认为这是有

582
00:29:11,018 --> 00:29:13,069
自己的副本 

583
00:29:15,919 --> 00:29:24,950
现在遇到了这个这个虚拟内存 

584
00:29:22,609 --> 00:29:27,635
使用虚拟内存来帮助简化 

585
00:29:25,229 --> 00:29:30,302
内存管理大大简化 

586
00:29:27,869 --> 00:29:32,870
链接和加载确定的原因，我 

587
00:29:30,959 --> 00:29:35,048
现在的接头前面提到可以假设 

588
00:29:32,969 --> 00:29:37,067
每一个每一个 节目将是 

589
00:29:35,849 --> 00:29:38,897
加载在完全相同的地方，以便在 

590
00:29:37,949 --> 00:29:41,030
链接器知道的时间，其中提前

591
00:29:39,329 --> 00:29:43,376
一切都将是，然后 

592
00:29:41,759 --> 00:29:49,850
可以解决这个问题可以重新定位所有 

593
00:29:43,799 --> 00:29:55,847
因此现在引用它真的 

594
00:29:50,669 --> 00:30:00,692
使得加载简单等什么 

595
00:29:56,279 --> 00:30:02,366
所以完全加载器 ，如果你想 

596
00:30:00,899 --> 00:30:05,975
现在加载程序 鸡蛋XEE 着眼于 

597
00:30:03,149 --> 00:30:10,166
ELF二进制可执行二进制 OK 

598
00:30:06,659 --> 00:30:11,666
它认为它是如何确定多大

599
00:30:10,319 --> 00:30:15,377
在该代码和数据 部分 

600
00:30:11,729 --> 00:30:17,753
二进制是它分配的虚拟存储器 

601
00:30:15,899 --> 00:30:21,962
开始在一个固定地址的代码

602
00:30:17,969 --> 00:30:26,027
和数据看到为他们创造点和 

603
00:30:22,529 --> 00:30:31,535
标志着他们每个人是无效的确定，所以每个 

604
00:30:26,549 --> 00:30:31,648
每个私人包含一个有效的映射 ，以便 

605
00:30:31,589 --> 00:30:34,652
每个私人 

606
00:30:32,539 --> 00:30:37,607
这被映射到代码和数据包含

607
00:30:35,219 --> 00:30:40,244
有效的物理页面数量，但随后 

608
00:30:38,219 --> 00:30:45,305
将它设置的这一招

609
00:30:40,469 --> 00:30:49,505
有效位为零 ， 所以当时 

610
00:30:46,079 --> 00:30:53,111
MMU X遇到其有效位的私人 

611
00:30:49,829 --> 00:30:55,862
0它触发页面错误 正确的IT 

612
00:30:53,399 --> 00:30:57,443
看起来好像那个页面是不是还没有 

613
00:30:56,159 --> 00:31:00,197
尚未初始化， 所以这类型的 

614
00:30:57,839 --> 00:31:05,882
诱骗右侧，然后触发 一个 

615
00:31:00,539 --> 00:31:07,595
页错误的内核，然后 

616
00:31:06,269 --> 00:31:13,274
核心

617
00:31:08,099 --> 00:31:17,138
那么到那时可以复制该页面 

618
00:31:13,769 --> 00:31:20,813
进入到物理内存 确定，所以这 

619
00:31:17,489 --> 00:31:22,544
在装载实际的方案和 

620
00:31:21,209 --> 00:31:24,293
数据实际上并没有他们没有 加载 

621
00:31:23,039 --> 00:31:27,107
加载，可以知道他们是不一样 

622
00:31:25,049 --> 00:31:28,620
复制到存储器中它发生作为 

623
00:31:27,719 --> 00:31:31,860
结果 

624
00:31:28,062 --> 00:31:36,150
缺页的正好作为的 结果 

625
00:31:31,086 --> 00:31:39,515
当与它推迟到直到错过 

626
00:31:37,005 --> 00:31:42,078
咬在页面被访问好了， 

627
00:31:40,289 --> 00:31:44,351
这就是所谓的按需分页不错，但 

628
00:31:43,023 --> 00:31:46,047
它真的就像 任何任何 

629
00:31:44,909 --> 00:31:48,390
我们已经看了对你的其他缓存

630
00:31:46,047 --> 00:31:51,072
难道你不块装入

631
00:31:48,039 --> 00:31:57,102
缓存中，直到 该块 内的字 

632
00:31:51,072 --> 00:31:58,119
访问好了，所以实际上加载等等 

633
00:31:58,002 --> 00:32:01,541
加载其实这是一个 很 

634
00:31:59,019 --> 00:32:05,061
有效的机制正确的，因为你

635
00:32:01,559 --> 00:32:08,850
可能有 一个 蕴含着巨大 的程序 

636
00:32:05,061 --> 00:32:10,130
说一个巨大的数组大阵，但 

637
00:32:08,085 --> 00:32:13,784
你只能访问的那一部分

638
00:32:10,679 --> 00:32:17,370
阵列，以使得整个阵列不会 

639
00:32:14,549 --> 00:32:20,549
实际上分配的页面会

640
00:32:17,037 --> 00:32:22,101
只有进入 DRAM时，他们当 

641
00:32:20,549 --> 00:32:24,720
该页面中的文字被触摸，所以如果 

642
00:32:23,001 --> 00:32:27,099
你只访问其中的一部分 

643
00:32:24,072 --> 00:32:31,101
非常大的阵列仅 数据 

644
00:32:27,099 --> 00:32:34,658
您访问被被加载并使用，因此 

645
00:32:32,001 --> 00:32:38,097
这是一个它是一个非常非常聪明的机制

646
00:32:35,549 --> 00:32:42,562
并允许非常有帮助

647
00:32:38,097 --> 00:32:46,526
我们利用 这个宝贵的内存资源 

648
00:32:42,679 --> 00:32:52,070
好了，所以第三第三动机

649
00:32:47,399 --> 00:32:56,250
虚拟内存 ，它 可以帮助我们 

650
00:32:52,007 --> 00:32:58,034
保护的内存部分，所以你还记得 

651
00:32:56,025 --> 00:33:01,059
我们的流程 

652
00:32:58,034 --> 00:33:03,039
你知道我们的虚拟地址的部分

653
00:33:01,059 --> 00:33:06,126
空间或只读 类的代码 

654
00:33:03,084 --> 00:33:08,303
部分很好，而且还有 其他 

655
00:33:07,026 --> 00:33:13,032
地址空间 的部分 ， 可以 

656
00:33:09,059 --> 00:33:20,990
仅由内核好了，所以执行 

657
00:33:13,032 --> 00:33:25,089
关于像86 64系统

658
00:33:20,099 --> 00:33:28,508
这是一个64位 系统， 使指针 和 

659
00:33:25,089 --> 00:33:30,171
地址是64位，但 在实际中 

660
00:33:29,399 --> 00:33:35,570
真实虚拟地址空间是48

661
00:33:31,071 --> 00:33:38,900
位好吧，这只是 其对48和 

662
00:33:35,057 --> 00:33:41,266
然后比特后的高位比特 

663
00:33:39,539 --> 00:33:46,540
48要么全零

664
00:33:41,779 --> 00:33:49,807
全部为一 好了，那是如此 

665
00:33:46,549 --> 00:33:54,200
这仅仅是 这就是那种 

666
00:33:50,059 --> 00:33:56,065
英特尔的统治好 并因此在 

667
00:33:54,002 --> 00:33:58,201
其中高位比特是地址

668
00:33:56,659 --> 00:33:59,743
所有的人都保留给 上校 

669
00:33:58,399 --> 00:34:03,710
上校的代码和上校 

670
00:34:00,499 --> 00:34:05,590
数据还行 地址均在 

671
00:34:03,071 --> 00:34:08,890
位零保留用于用户代码 

672
00:34:05,059 --> 00:34:10,588
好了，所以任何引用任何地址 

673
00:34:09,529 --> 00:34:14,593
它包含了所有的人与那些高 

674
00:34:11,119 --> 00:34:20,480
阶位是由定义或者代码 

675
00:34:15,169 --> 00:34:23,960
或者在 内核 和 数据 ，因此你可以在你 

676
00:34:20,048 --> 00:34:26,617
可以位添加到 私人 指定 

677
00:34:23,096 --> 00:34:28,255
某些虚拟页面是否可以 

678
00:34:27,049 --> 00:34:31,060
用户代码或者，如果他们要访问

679
00:34:29,119 --> 00:34:33,740
内核因此受到访问 

680
00:34:31,159 --> 00:34:37,210
所谓的监督模式中，你可以 

681
00:34:33,074 --> 00:34:39,703
还要补充一点控制是否该位 

682
00:34:37,669 --> 00:34:43,669
可以读取页的书面或 

683
00:34:40,369 --> 00:34:46,393
执行好所以这此位执行 

684
00:34:43,669 --> 00:34:51,688
是新的x86 64它没有存在 

685
00:34:46,609 --> 00:34:54,628
32位x86系统 ，这 是这 

686
00:34:51,859 --> 00:34:57,928
是这是所使用的技术 

687
00:34:54,799 --> 00:35:01,130
现在就来试试， 防止对攻击实验室 

688
00:34:58,549 --> 00:35:03,410
代码注入式攻击，因为它

689
00:35:01,013 --> 00:35:06,038
使得它不可能，如果此位被设置 

690
00:35:03,041 --> 00:35:10,100
你不能从加载指令

691
00:35:06,038 --> 00:35:13,447
该网页，所以在内的任何人 

692
00:35:11,000 --> 00:35:15,799
事实上， 它是这个介绍 

693
00:35:13,789 --> 00:35:17,470
这是执行爵士就是导致 

694
00:35:15,799 --> 00:35:20,898
之类的东西返回导向编程

695
00:35:17,047 --> 00:35:21,366
像你这样的攻击在你的攻击实验室做

696
00:35:21,849 --> 00:35:29,180
好了，所以这仅通过简单的 

697
00:35:25,043 --> 00:35:32,182
添加添加比特到的技术

698
00:35:29,018 --> 00:35:34,094
PTE我们提供一个方式自动方式 

699
00:35:32,569 --> 00:35:37,596
保护的不同部分我们 

700
00:35:34,094 --> 00:35:41,141
未经授权的虚拟地址空间 

701
00:35:37,839 --> 00:35:43,858
访问 通道，然后MMU 

702
00:35:42,041 --> 00:35:45,098
实际上检查每个这些位

703
00:35:44,029 --> 00:35:48,140
访问，如果有，如果有一个 

704
00:35:45,098 --> 00:35:50,117
问题你知道，如果你想 

705
00:35:48,014 --> 00:35:53,042
做一个正确和权

706
00:35:51,017 --> 00:35:55,043
这不是启用，则它 抛出一个 

707
00:35:53,042 --> 00:35:55,481
例外然后内核 

708
00:35:55,043 --> 00:36:00,051
核心

709
00:35:55,859 --> 00:36:01,952
用好交易所以到目前为止， 我一直 

710
00:36:01,023 --> 00:36:05,040
谈论地址转换 和 

711
00:36:02,789 --> 00:36:06,872
一种高层次高水平的条款，以便 

712
00:36:05,004 --> 00:36:09,433
让我们，让我们坐下来详细看 

713
00:36:07,619 --> 00:36:13,910
它是如何真正起作用

714
00:36:09,829 --> 00:36:16,856
好了，所以我们给出的虚拟地址 

715
00:36:13,091 --> 00:36:20,930
n个元素M的物理地址 

716
00:36:17,099 --> 00:36:23,167
像I族元素，所述前 n通常是 

717
00:36:21,749 --> 00:36:26,783
大于M的，但它并没有被 

718
00:36:23,779 --> 00:36:29,960
还好这是完全没有理由米 

719
00:36:27,089 --> 00:36:33,390
米能比N和大得多的 

720
00:36:29,096 --> 00:36:35,705
有没有这通常 不是但却 

721
00:36:33,039 --> 00:36:38,043
它可以因此考虑到 这些调整 

722
00:36:36,569 --> 00:36:41,624
空间，我们有一个映射函数，它 

723
00:36:38,043 --> 00:36:44,882
即从 V 映射 至 P与可选 

724
00:36:42,119 --> 00:36:49,166
空集或者与另外的空 

725
00:36:45,269 --> 00:36:52,271
虚拟地址映射一个集等

726
00:36:49,589 --> 00:36:53,663
等于黄金如果数据在 

727
00:36:52,289 --> 00:36:56,400
虚拟地址是其物理 

728
00:36:54,329 --> 00:36:58,950
解决的首要好了，所以我的意思是 这 

729
00:36:56,004 --> 00:37:00,163
正是我们就把它更只是一个 小 

730
00:36:58,095 --> 00:37:02,974
正规的方式说好了，我们已经 

731
00:37:00,559 --> 00:37:07,170
前谈论我们的图 

732
00:37:03,829 --> 00:37:08,970
然后映射一个是空集，如果

733
00:37:07,017 --> 00:37:14,366
在虚拟地址的数据不在 

734
00:37:08,097 --> 00:37:15,406
物理内存 所以 只是 一个 好吗 

735
00:37:14,519 --> 00:37:18,630
总之我要去忍受的列表 

736
00:37:16,279 --> 00:37:20,730
我们将所有的符号被 使用 

737
00:37:18,063 --> 00:37:21,782
地址翻译，但是这仅仅是

738
00:37:20,073 --> 00:37:28,202
一些方法，这只是参考 

739
00:37:22,349 --> 00:37:30,368
如果你以后使用上 好的幻灯片

740
00:37:28,859 --> 00:37:34,898
所以这里的如何地址转换哪里 

741
00:37:30,539 --> 00:37:41,542
页表的作品所以我们给出了一些

742
00:37:35,249 --> 00:37:41,308
一个由n位的虚拟地址 

743
00:37:42,047 --> 00:37:51,133
我们有一个由它的块

744
00:37:46,049 --> 00:37:51,133
尺寸可以用 好P位 来表示 

745
00:37:52,038 --> 00:37:57,124
所以想想这个，现在 你 这样，这是 

746
00:37:56,074 --> 00:37:59,137
非常类似于我们看的时候 

747
00:37:58,024 --> 00:38:04,041
我们没有缓存你知道地址位 

748
00:38:00,037 --> 00:38:06,109
用于高速缓存等等这些第一P位 

749
00:38:04,041 --> 00:38:08,095
对应页偏移，所以这是

750
00:38:07,009 --> 00:38:14,053
类似于块偏移，我们 

751
00:38:08,095 --> 00:38:16,150
与高速缓存看到，然后剩下的

752
00:38:14,053 --> 00:38:19,129
位对应于虚拟页 

753
00:38:17,005 --> 00:38:22,033
数这 是 记住这 是完全 

754
00:38:20,029 --> 00:38:24,037
联想右所以，只有一个 

755
00:38:22,078 --> 00:38:27,106
在全关联缓存设置成 

756
00:38:25,009 --> 00:38:30,052
一切后，块偏移 

757
00:38:28,006 --> 00:38:33,007
标记所以认为 这 就像一个标签 

758
00:38:30,052 --> 00:38:37,108
这是 ，这是唯一什么 

759
00:38:33,016 --> 00:38:39,022
识别该块和我们在虚拟

760
00:38:38,008 --> 00:38:45,025
内存的说法，我们把它 称为一个 

761
00:38:39,076 --> 00:38:45,172
现在虚拟页码的页表 

762
00:38:45,025 --> 00:38:48,052
页表的开头是 

763
00:38:46,072 --> 00:38:50,110
基于 此 页表指出， 

764
00:38:48,052 --> 00:38:54,073
在 Intel系统 上注册 ，就是这样的 

765
00:38:51,001 --> 00:38:56,044
所谓的CR3 控制寄存器3但这 

766
00:38:54,073 --> 00:38:57,082
注册这个寄存器包含

767
00:38:56,053 --> 00:38:59,127
在页表 的物理地址 

768
00:38:58,063 --> 00:39:04,105
内存OK 

769
00:39:00,027 --> 00:39:07,120
那开始，所以当 

770
00:39:05,005 --> 00:39:12,088
当CPU呈现虚拟页面 

771
00:39:08,002 --> 00:39:15,079
虚拟地址到MMU所花费的 

772
00:39:12,088 --> 00:39:20,092
虚拟页码和使用， 作为一个 

773
00:39:15,097 --> 00:39:23,182
索引页表，然后将其 

774
00:39:21,028 --> 00:39:26,119
然后将其 int和标识 

775
00:39:24,082 --> 00:39:28,177
其中包含如果此页表项 

776
00:39:27,019 --> 00:39:31,063
被映射到存储器中所包含的 

777
00:39:29,077 --> 00:39:35,158
的物理地址

778
00:39:31,063 --> 00:39:37,135
对应的物理页 还好使 

779
00:39:36,058 --> 00:39:39,103
地址转换的全部目的就是 

780
00:39:38,035 --> 00:39:41,044
拿出 你给一个 虚拟 

781
00:39:40,003 --> 00:39:46,051
地址，并希望拿出一个 

782
00:39:42,025 --> 00:39:48,070
对应的物理地址确定，因此 

783
00:39:46,051 --> 00:39:50,146
物理地址的物理

784
00:39:48,007 --> 00:39:52,039
的物理页号部分 

785
00:39:51,046 --> 00:39:55,141
物理地址出来的页面 

786
00:39:53,002 --> 00:39:58,063
表项，这很 有趣的 

787
00:39:56,041 --> 00:40:00,046
物理页偏移的所述部分 

788
00:39:58,063 --> 00:40:02,161
物理地址出来的 

789
00:40:00,091 --> 00:40:04,096
虚拟页偏移 如果这些位 

790
00:40:03,061 --> 00:40:08,920
相同

791
00:40:05,041 --> 00:40:10,067
好了，现在 你 应该知道，你应该 

792
00:40:09,469 --> 00:40:14,545
说服自己，这是 真的 

793
00:40:10,067 --> 00:40:16,070
右在虚拟的所述偏移 

794
00:40:15,229 --> 00:40:19,240
块将是一样的 

795
00:40:16,007 --> 00:40:25,079
在物理块偏移他们是 

796
00:40:19,339 --> 00:40:28,428
同样大小的块，而你也可以 

797
00:40:26,042 --> 00:40:34,351
为什么这个虚拟页面数它 

798
00:40:29,229 --> 00:40:38,308
标识中的页码 

799
00:40:34,729 --> 00:40:41,815
页表，以便想象的那么想象 

800
00:40:39,019 --> 00:40:45,025
这样 行不行 是全零的虚拟地址

801
00:40:42,589 --> 00:40:49,591
全零所以它的虚拟地址零 

802
00:40:45,619 --> 00:40:53,707
而现在， 这将有一个虚拟 

803
00:40:49,789 --> 00:40:55,837
零页号 ，并 在该字节 

804
00:40:54,499 --> 00:41:00,380
地址都会被它抵消为零 

805
00:40:56,269 --> 00:41:03,410
现在没事了一个虚拟递增

806
00:41:00,038 --> 00:41:05,767
解决一个，这样 ，将在偏移 

807
00:41:03,041 --> 00:41:08,440
1，这将 是在相同的虚拟 

808
00:41:06,109 --> 00:41:11,158
零页， 现在不断递增 

809
00:41:08,809 --> 00:41:13,855
直到所有的 的所有 位 的 

810
00:41:11,599 --> 00:41:16,640
虚拟页偏移量是那些与 

811
00:41:14,269 --> 00:41:19,276
虚拟页码为零 好 了， 

812
00:41:16,064 --> 00:41:24,393
这是在虚拟的最后一个字节

813
00:41:19,969 --> 00:41:24,969
零页现在增加一个更多的时间 

814
00:41:25,089 --> 00:41:29,930
该一个比特延续到所述虚拟 

815
00:41:27,949 --> 00:41:32,900
页码所以现在 ，现在我们进入下一个 

816
00:41:29,093 --> 00:41:35,992
虚拟页面，它是在一个偏移

817
00:41:32,009 --> 00:41:37,858
零好吧，所以你能看到它的排序 

818
00:41:36,829 --> 00:41:40,882
那种明显，当你想想看 

819
00:41:38,749 --> 00:41:43,777
就像你知道为什么我们可以只取 

820
00:41:41,359 --> 00:41:46,368
虚拟页面后这些这些位

821
00:41:44,029 --> 00:41:48,124
偏移，并利用它们 来唯一标识 

822
00:41:46,449 --> 00:41:53,500
什么虚拟页面中我们一直在努力

823
00:41:48,979 --> 00:41:56,380
用好了，让我们看看如何让我们看看如何 

824
00:41:53,959 --> 00:41:59,050
它工作在本系统中 更详细 

825
00:41:56,038 --> 00:42:01,147
所以我们的系统中我们的CPU发送一个虚拟 

826
00:41:59,869 --> 00:42:05,911
地址到n菜单的结果 

827
00:42:01,489 --> 00:42:08,514
执行移动 指令或致电或 

828
00:42:06,289 --> 00:42:11,370
返回或任何形式的控制转移

829
00:42:08,739 --> 00:42:11,775
该MMU

830
00:42:13,089 --> 00:42:19,130
中查找的私人所以它 的 获取 

831
00:42:17,269 --> 00:42:21,230
私人从存储在页表 

832
00:42:19,013 --> 00:42:24,071
内存中，因此这实际上会 关闭 

833
00:42:21,023 --> 00:42:29,026
芯片上存储器到该私人存储 

834
00:42:24,071 --> 00:42:32,093
在内存中获取它取 的私人 

835
00:42:29,026 --> 00:42:35,111
提取并使用该 TTE来 

836
00:42:32,093 --> 00:42:37,190
构建物理地址和好 

837
00:42:36,011 --> 00:42:41,054
那么它 感应到物理地址 

838
00:42:38,009 --> 00:42:42,014
到高速缓冲存储器和系统，其 

839
00:42:41,054 --> 00:42:46,151
最终结果，数据会被

840
00:42:43,004 --> 00:42:47,096
返回到CPU 好了 ，所以即使 

841
00:42:47,051 --> 00:42:50,066
一击 

842
00:42:48,032 --> 00:42:52,079
我们仍然有内存引用权 

843
00:42:50,066 --> 00:43:00,092
因为我们必须获取该该页 

844
00:42:52,079 --> 00:43:02,141
表条目现在怀念的是在这个说法 

845
00:43:00,092 --> 00:43:04,115
被称为在这种情况下，页面错误等等 

846
00:43:03,041 --> 00:43:07,112
同样的事情发生，因为在此之前， 

847
00:43:05,015 --> 00:43:08,063
的CTU发送虚拟地址到 

848
00:43:08,012 --> 00:43:12,047
MMU

849
00:43:08,063 --> 00:43:14,084
MMU的获取，对于内存的TTE 

850
00:43:12,047 --> 00:43:18,071
但是当 它看起来那么MMU时 

851
00:43:14,084 --> 00:43:19,166
看着它看到还有的 TTE 

852
00:43:18,071 --> 00:43:24,122
一个无效的有效位或 零 

853
00:43:20,066 --> 00:43:29,138
有效位，或者它表明了

854
00:43:25,022 --> 00:43:34,076
数据被存储在磁盘上，因此在 

855
00:43:30,038 --> 00:43:36,134
它的MMU 这种情况下， 触发页面 

856
00:43:34,076 --> 00:43:40,133
故障异常将控制转移

857
00:43:37,034 --> 00:43:44,123
此页面错误处理程序来处理或 

858
00:43:41,033 --> 00:43:50,051
标识一个牺牲品，并且如果它已经

859
00:43:45,023 --> 00:43:53,024
修改其复制到磁盘上 ，然后它 

860
00:43:50,051 --> 00:43:54,104
从磁盘 获取 新的页面进入到 

861
00:43:53,024 --> 00:44:01,058
内存和多达通过高速缓存 

862
00:43:55,004 --> 00:44:04,007
层次好，然后，然后将其 

863
00:44:01,058 --> 00:44:08,126
引起了那么处理程序返回 

864
00:44:04,007 --> 00:44:12,059
到到过程， 当我 当 

865
00:44:09,026 --> 00:44:14,030
处理程序故障返回它 会导致 

866
00:44:12,059 --> 00:44:16,085
该错误指令重新 

867
00:44:14,003 --> 00:44:19,040
执行所以现在 的移动 指令 

868
00:44:16,085 --> 00:44:22,129
即该故障是 发生反应Acutes但 

869
00:44:19,067 --> 00:44:22,129
这时候有一个页面命中

870
00:44:26,008 --> 00:44:31,019
现在您可以您可能会感兴趣如何 

871
00:44:29,029 --> 00:44:32,098
现金是如何集成到所有的 

872
00:44:31,091 --> 00:44:38,102
这个

873
00:44:32,098 --> 00:44:40,142
所以MMU 发出诸如页表 

874
00:44:39,002 --> 00:44:43,030
项，以便它通过页表 

875
00:44:41,042 --> 00:44:46,141
地址现金 

876
00:44:43,003 --> 00:44:49,088
如果这些神话的去 记忆 

877
00:44:47,041 --> 00:44:52,106
内存返回这些页表 

878
00:44:50,015 --> 00:44:55,066
条目缓存，然后最终 

879
00:44:53,006 --> 00:44:58,093
到到MMU

880
00:44:55,066 --> 00:45:00,143
该MMU构造一个物理地址

881
00:44:58,093 --> 00:45:03,107
然后它的感觉， 物理地址 

882
00:45:01,043 --> 00:45:05,141
到缓存 正确的那么那么与高速缓存 

883
00:45:04,007 --> 00:45:10,085
我们一直在高速缓存方法是使用完成 

884
00:45:06,041 --> 00:45:13,055
在这种情况下还行物理地址

885
00:45:10,085 --> 00:45:16,144
它也可以构建高速缓存

886
00:45:13,055 --> 00:45:16,144
与虚拟地址，但没错的工作 

887
00:45:24,019 --> 00:45:28,103
是啊所以它会进入该 好了，所以 

888
00:45:27,044 --> 00:45:31,067
问题是如何如何是 

889
00:45:29,003 --> 00:45:35,015
虚拟地址空间中实现的 

890
00:45:31,067 --> 00:45:36,086
磁盘，并将其 它实际上 做了很多 

891
00:45:35,015 --> 00:45:39,074
比之类的更有效的事情

892
00:45:36,086 --> 00:45:41,174
我所描述的抽象模型 

893
00:45:39,074 --> 00:45:44,138
所以大多数的网页有，当你的选项

894
00:45:42,074 --> 00:45:47,143
您分配一个新的 虚拟内存页面 

895
00:45:45,038 --> 00:45:51,086
所以，这一切都可以零它分配 

896
00:45:48,043 --> 00:45:53,051
好 了，有一个特殊的 ，你可以说我 

897
00:45:51,086 --> 00:45:54,158
希望此我想分配 的页面 

898
00:45:53,051 --> 00:45:56,108
在这种情况下，全部为零你知道 

899
00:45:55,058 --> 00:45:59,084
页面并不需要永远得到存储在 

900
00:45:57,008 --> 00:46:01,037
盘右它只是 它的内存 

901
00:45:59,084 --> 00:46:03,119
虽然它在磁盘上， 然后 创建 

902
00:46:01,037 --> 00:46:07,045
加载到内存中，因此这些网页 是 

903
00:46:04,019 --> 00:46:13,082
全零，没有 在磁盘上不存在 

904
00:46:07,045 --> 00:46:16,082
你知道当网页被修改这是一个 

905
00:46:13,082 --> 00:46:18,098
多一点的页面可以映射到 

906
00:46:16,082 --> 00:46:22,118
例如特定的文件时，我们 

907
00:46:18,098 --> 00:46:23,183
加载ELF程序的页面是 

908
00:46:23,018 --> 00:46:28,051
对应于代码实际上是

909
00:46:24,083 --> 00:46:31,097
映射到于二进制的字节数 

910
00:46:28,051 --> 00:46:33,083
包含的代码 ， 这样， 当你 

911
00:46:31,097 --> 00:46:36,098
错过页面上它说，它带来的 

912
00:46:33,083 --> 00:46:41,101
这些代码页好了，所以某些页面可能 

913
00:46:36,098 --> 00:46:44,140
被映射 到用户级别的磁盘上的文件或 

914
00:46:42,001 --> 00:46:50,063
不是他们可以是匿名 和无法映射 

915
00:46:45,004 --> 00:46:52,010
所以，如果如果他们映射到用户级别，如果 

916
00:46:50,063 --> 00:46:53,132
他们映射到用户级别的文件和

917
00:46:52,046 --> 00:46:58,115
你写一个页，然后它会得到 

918
00:46:54,032 --> 00:47:00,131
写回到那个页面 是 

919
00:46:59,015 --> 00:47:03,083
它映射到如果它不映射到任何 

920
00:47:01,031 --> 00:47:08,128
它存储在这个区域页叫 

921
00:47:03,083 --> 00:47:08,128
交换区域或交换文件是没关系 

922
00:47:11,068 --> 00:47:22,144
哦，是这样的问题是，当你加载 

923
00:47:20,349 --> 00:47:24,426
从磁盘页面到内存做它 

924
00:47:23,044 --> 00:47:27,073
也得到缓存在高速缓存存储器 

925
00:47:25,119 --> 00:47:30,670
层次结构， 答案是肯定的，所以如果 

926
00:47:27,073 --> 00:47:32,712
您加载整个页面，页面会 

927
00:47:30,067 --> 00:47:36,073
被分解 成块64字节的数据块 

928
00:47:33,369 --> 00:47:39,414
和和和 加载到缓存中 

929
00:47:37,027 --> 00:47:41,053
所以一切的一切的一切， 

930
00:47:39,819 --> 00:47:43,660
您将获取从 缓存经过 

931
00:47:41,053 --> 00:47:54,150
从该内存穿过

932
00:47:43,066 --> 00:47:54,150
缓存缓存层次结构好了，所以我 

933
00:47:55,074 --> 00:48:03,139
声称， 虚拟内存，因为工作 

934
00:48:02,026 --> 00:48:06,855
局部性的，这就是真实的，但如果我们

935
00:48:04,039 --> 00:48:09,040
仍然有获取如果每次我们有时间 

936
00:48:07,089 --> 00:48:13,092
一个小姐，我们还是不得不去记忆它 

937
00:48:09,004 --> 00:48:14,693
未免太低效好这样 的 

938
00:48:13,119 --> 00:48:17,890
MMU

939
00:48:15,089 --> 00:48:22,210
加速了 这一转换过程 

940
00:48:17,089 --> 00:48:23,568
在一个高速缓存页表项

941
00:48:22,021 --> 00:48:28,021
在MMU内的硬件缓存，称为 

942
00:48:24,369 --> 00:48:31,418
转换后备缓冲器或TLB所以 

943
00:48:28,021 --> 00:48:37,650
该TLB是硬件缓存缓存 

944
00:48:31,859 --> 00:48:40,030
PGES 页表项，它包含 

945
00:48:37,839 --> 00:48:42,160
喜欢它包含了最高速缓存

946
00:48:40,003 --> 00:48:43,842
最近你知道这就像 任何 

947
00:48:42,016 --> 00:48:46,072
其他缓存使其包含的高速缓存 

948
00:48:43,869 --> 00:48:49,938
最近 使用 的 页表 

949
00:48:46,072 --> 00:48:53,181
条目， 所以你还记得MMM 

950
00:48:50,559 --> 00:48:56,440
虚拟地址的独特之处

951
00:48:53,829 --> 00:49:00,190
限定了虚拟页是

952
00:48:56,044 --> 00:49:04,051
虚页号位好，因此在 

953
00:49:00,019 --> 00:49:08,098
该TLD使用 的 该VPN 部 

954
00:49:04,051 --> 00:49:11,056
虚拟地址两年到两年 访问和 

955
00:49:08,098 --> 00:49:13,150
使 就像 任何其他的组有一个 

956
00:49:12,001 --> 00:49:16,350
设置索引的一组集合索引比特，其 

957
00:49:14,005 --> 00:49:18,100
只是被多少来确定多少 

958
00:49:16,359 --> 00:49:23,260
这是多少 设置TLB项

959
00:49:19,045 --> 00:49:25,087
有，它有四个标签

960
00:49:23,026 --> 00:49:29,062
剩余位的歧义的任何 

961
00:49:25,087 --> 00:49:32,182
并消除歧义任何现金或行

962
00:49:29,062 --> 00:49:38,065
PT的映射到同一 组好了， 

963
00:49:33,082 --> 00:49:43,096
在VPN或TLB 我TLB 指数映射到 

964
00:49:38,092 --> 00:49:48,120
这个特殊的设置，然后， 然后 

965
00:49:43,096 --> 00:49:53,143
使用所述 TLB 用作TLB同志 

966
00:49:49,002 --> 00:49:56,101
位的歧义，并确定是否 

967
00:49:54,043 --> 00:50:00,112
它在寻找的TTE是它 

968
00:49:57,019 --> 00:50:04,051
真正存储在缓存还好使 

969
00:50:01,012 --> 00:50:06,016
此方法的工作原理是CPU生成

970
00:50:04,051 --> 00:50:08,110
它通过MMU的 虚拟地址 

971
00:50:06,016 --> 00:50:12,048
MMU的，而不是在寻找记忆 

972
00:50:09,001 --> 00:50:15,064
直接到页表项 

973
00:50:12,048 --> 00:50:17,140
它首先要求TLB，如果有，它 

974
00:50:15,073 --> 00:50:19,168
把它的 VPN等你有这 

975
00:50:18,004 --> 00:50:24,019
虚拟页面此虚拟P键 

976
00:50:20,068 --> 00:50:26,101
页面，如果它的TLB返回

977
00:50:24,055 --> 00:50:28,138
打它返回的页表项 

978
00:50:27,001 --> 00:50:32,086
该MMU 然后可以用来构造 

979
00:50:29,038 --> 00:50:35,053
物理地址发送给 该 

980
00:50:32,086 --> 00:50:37,182
高速缓存和内存系统最终我 

981
00:50:35,053 --> 00:50:41,125
导致该数据被发送回 

982
00:50:38,082 --> 00:50:44,098
现在，当你有一个小姐则有 

983
00:50:42,025 --> 00:50:48,034
这一个MMU与TLB检查 

984
00:50:44,098 --> 00:50:49,126
在私人承认这一点所以那么 有 MMU 

985
00:50:48,034 --> 00:50:52,063
去记忆像以前一样 好 了， 

986
00:50:50,026 --> 00:50:56,083
这是一切然后是一样的

987
00:50:52,063 --> 00:51:00,127
内存返回到PT e将 

988
00:50:56,083 --> 00:51:02,116
MMU 其藏匿它在TLB 和公正 

989
00:51:01,027 --> 00:51:09,070
就像如果有前如果没有 

990
00:51:03,016 --> 00:51:11,038
房间中如果 如果PT戊己 耶 

991
00:51:09,007 --> 00:51:13,074
修改那么它必须被写 回 

992
00:51:11,038 --> 00:51:17,056
出好只是像任何其他高速缓存 

993
00:51:14,037 --> 00:51:18,130
并最终MMU使用它来

994
00:51:17,056 --> 00:51:21,117
构造一个物理地址，然后 

995
00:51:19,003 --> 00:51:21,090
该数据被发送回 

996
00:51:23,051 --> 00:51:31,103
好吧，如果你一直在关注 

997
00:51:24,094 --> 00:51:33,191
不像一对夫妇的人，如果你去过 

998
00:51:32,003 --> 00:51:36,098
注意你会很 

999
00:51:34,091 --> 00:51:43,091
关注这些页面的 大小 

1000
00:51:36,098 --> 00:51:45,106
我的意思是我们已经得到了4桌权

1001
00:51:43,091 --> 00:51:48,167
字节假设我们有4k的双页， 

1002
00:51:46,078 --> 00:51:53,084
我们的有效地址空间为48位 

1003
00:51:49,067 --> 00:51:58,069
像它是 具有86 64系统然后 

1004
00:51:54,038 --> 00:52:03,082
我们有一个8×8字节的页表项

1005
00:51:58,069 --> 00:52:06,071
我们需要一个页表512千兆字节 

1006
00:52:03,082 --> 00:52:12,101
还好 两到 地址空间中的两个给 

1007
00:52:06,089 --> 00:52:14,108
48个字节除以2到 第 12字节 

1008
00:52:13,001 --> 00:52:17,060
每没关系 使页面的数量 

1009
00:52:15,008 --> 00:52:19,043
我们需要再页表项 

1010
00:52:17,006 --> 00:52:24,007
每个页表项的大小为8 

1011
00:52:19,043 --> 00:52:26,051
字节，因此，我们需要的几乎万亿字节 

1012
00:52:24,007 --> 00:52:28,016
DRAM只是为了保存页面右表

1013
00:52:27,023 --> 00:52:32,059
那么那么那么显然它不会 

1014
00:52:29,006 --> 00:52:35,021
工作，这显然 不是他们如何 

1015
00:52:32,059 --> 00:52:38,060
页表真正落实等等

1016
00:52:35,075 --> 00:52:42,143
解决的办法是使用的层次 

1017
00:52:38,006 --> 00:52:47,006
页表所以，所以我们如果我们有一个

1018
00:52:43,043 --> 00:52:49,046
二级页表中有一个顶 

1019
00:52:47,006 --> 00:52:50,105
第一级页表的叫 

1020
00:52:49,046 --> 00:52:53,113
一级表，它总是在 

1021
00:52:51,059 --> 00:52:57,071
记忆是永远永远向下翻页和 

1022
00:52:54,013 --> 00:52:59,048
然后再有一个穿西装的序列 

1023
00:52:57,071 --> 00:53:03,164
的二级页表和他们都

1024
00:52:59,048 --> 00:53:06,056
大小相同的权利和第一 

1025
00:53:04,064 --> 00:53:09,068
一级表点开始 

1026
00:53:06,056 --> 00:53:11,105
第一级套装表 ， 因此它 

1027
00:53:09,068 --> 00:53:15,164
包含指向一个物理地址 

1028
00:53:12,005 --> 00:53:18,092
到基极的第二电平一个表 

1029
00:53:16,064 --> 00:53:21,097
指向第二二级表 

1030
00:53:18,092 --> 00:53:21,097
等等好吗 

1031
00:53:22,709 --> 00:53:26,787
所以，如果我们有这种系统 

1032
00:53:25,679 --> 00:53:30,717
记得最清楚的虚拟地址 

1033
00:53:27,489 --> 00:53:32,568
空间是未使用 正确的 ，所以如果我们有这样的 

1034
00:53:31,059 --> 00:53:36,066
样的系统，我们可以，我们能避免 

1035
00:53:33,279 --> 00:53:39,291
创造了许多不必要的页表 

1036
00:53:36,129 --> 00:53:44,163
好 了，想象一下，如果我们有一个两级 

1037
00:53:39,399 --> 00:53:47,436
层次结构，以便让我们来 看看我们的虚拟 

1038
00:53:44,469 --> 00:53:50,508
在这个例子中，哪些地址空间

1039
00:53:47,769 --> 00:53:53,808
我已经分配给 两个 代码k个页面和 

1040
00:53:50,859 --> 00:53:58,887
对这一计划的数据，然后有 

1041
00:53:54,159 --> 00:54:00,255
有6个K未分配的 页面 ，然后 

1042
00:53:59,139 --> 00:54:05,160
那么栈有一个页面是 

1043
00:54:01,119 --> 00:54:09,123
分配给堆栈 对不起 

1044
00:54:05,349 --> 00:54:11,355
还有的有一千个24 页 

1045
00:54:09,159 --> 00:54:17,187
分配给栈的最

1046
00:54:11,949 --> 00:54:21,981
是我对不起有记忆的区域 

1047
00:54:17,439 --> 00:54:23,445
那这是一个千 24 的尺寸 

1048
00:54:22,269 --> 00:54:26,304
网页，但其中大部分都是未分配 

1049
00:54:24,039 --> 00:54:30,072
而我只 分配一个顶部 

1050
00:54:26,619 --> 00:54:34,647
本作 的堆栈的 顶部 好吧， 

1051
00:54:30,369 --> 00:54:37,425
鉴于此布局为我的我的过程中，我 

1052
00:54:34,899 --> 00:54:41,904
只只需要三级 第二页 

1053
00:54:37,929 --> 00:54:43,965
表好吗第一的 第一 页 

1054
00:54:41,949 --> 00:54:48,030
表涵盖了我的代码本地区和 

1055
00:54:44,289 --> 00:54:50,328
数据第一千24页 

1056
00:54:48,759 --> 00:54:54,764
下页表涵盖剩余

1057
00:54:50,679 --> 00:54:57,723
千24页好了，所以这两个 

1058
00:54:55,259 --> 00:55:01,262
这两个二级页表覆盖 

1059
00:54:58,119 --> 00:55:04,161
所有的代码和数据好和 

1060
00:55:01,559 --> 00:55:06,624
同样，我需要为我的堆栈我

1061
00:55:04,539 --> 00:55:08,592
只需要一个页面表，它只有

1062
00:55:07,209 --> 00:55:12,237
一个一个有效的私人 

1063
00:55:09,069 --> 00:55:14,124
所以 在最后一个行不行，然后 我 

1064
00:55:12,489 --> 00:55:16,496
有一个级别一个表 

1065
00:55:14,619 --> 00:55:20,628
指向三级两个表

1066
00:55:17,189 --> 00:55:22,206
好了 ，所以 我有四个表 

1067
00:55:20,709 --> 00:55:25,900
我已经覆盖了整个虚拟地址 

1068
00:55:22,359 --> 00:55:28,480
现在空间

1069
00:55:25,009 --> 00:55:30,010
该方式使MMU使用方式

1070
00:55:28,048 --> 00:55:35,089
这些多页表做地址

1071
00:55:30,091 --> 00:55:37,135
翻译是再下面我们我们 

1072
00:55:35,089 --> 00:55:41,116
还有一个虚拟的页面偏移量 

1073
00:55:38,035 --> 00:55:47,064
由第一P磁盘中，然后 

1074
00:55:42,016 --> 00:55:50,089
的VPN中的剩余位是 VPN 

1075
00:55:47,064 --> 00:55:56,089
对于A K级页表被分解 

1076
00:55:50,089 --> 00:56:01,153
成K个子 DPNS，并且每个 各自是 

1077
00:55:56,089 --> 00:56:03,178
在这个系统中相同的大小，所以现在 

1078
00:56:02,053 --> 00:56:08,056
上VPN一个其中包括的 

1079
00:56:04,078 --> 00:56:11,125
该VPN的最高位不偏置 

1080
00:56:08,083 --> 00:56:13,129
成 1 级 表 ，该 表 是作为 

1081
00:56:12,025 --> 00:56:18,025
之前由 页表 指出， 

1082
00:56:14,029 --> 00:56:21,066
基址寄存器没关系 所以 PVP中 1是 

1083
00:56:18,025 --> 00:56:24,025
指数为 1 级页表 

1084
00:56:21,066 --> 00:56:26,089
记得 1级页表点 

1085
00:56:24,025 --> 00:56:30,025
到2级，但 我们的地址

1086
00:56:26,089 --> 00:56:32,101
在1级表分项中的PTê

1087
00:56:30,025 --> 00:56:35,026
一些 2 级 页面 的地址 

1088
00:56:33,001 --> 00:56:40,009
表或它包含的 一些地址

1089
00:56:35,035 --> 00:56:42,046
2级页表，以便指向 

1090
00:56:40,009 --> 00:56:46,021
这 2级页表的基极，然后 

1091
00:56:42,046 --> 00:56:48,097
的VPN 使用 2比特 作为一个指数 到 

1092
00:56:46,021 --> 00:56:55,024
该2级右表等 

1093
00:56:48,097 --> 00:56:57,172
确定，所以最终你得到的一个PTê 

1094
00:56:55,051 --> 00:57:00,082
和等级k减1个分 

1095
00:56:58,072 --> 00:57:05,074
在k级页表的开始

1096
00:57:00,082 --> 00:57:08,143
和DPÑK个点到一个内的偏移

1097
00:57:05,074 --> 00:57:10,105
该表并最终包含 

1098
00:57:09,043 --> 00:57:12,139
页面的物理地址，我们 

1099
00:57:11,005 --> 00:57:16,048
要 访问 行不行，然后说 

1100
00:57:13,039 --> 00:57:19,072
物理地址被用于形成所述

1101
00:57:16,048 --> 00:57:21,112
的物理地址的PP N部分 和 

1102
00:57:19,072 --> 00:57:24,100
就像虚拟页偏移前

1103
00:57:22,012 --> 00:57:27,090
只是直接复制我改变 

1104
00:57:25,000 --> 00:57:27,009
物理页偏移 

1105
00:57:28,033 --> 00:57:42,038
所以是清楚大家是 

1106
00:57:30,098 --> 00:57:45,104
问题让我们看到的是它总是一个电源 

1107
00:57:42,083 --> 00:57:47,090
2个是的，它的被定义 

1108
00:57:46,004 --> 00:57:51,011
体系结构，以便为英特尔是四

1109
00:57:47,009 --> 00:57:53,063
级系统现在为什么它会是和 

1110
00:57:51,074 --> 00:57:56,080
那么快能它将它总是 

1111
00:57:54,044 --> 00:57:56,053
少于 六位 

1112
00:58:02,098 --> 00:58:10,136
我给了 64位系统，是啊是啊 

1113
00:58:06,008 --> 00:58:14,009
这里只有块大小 是固定的 

1114
00:58:11,036 --> 00:58:18,109
右 使 这里 有 12位 -到 

1115
00:58:14,081 --> 00:58:20,168
第十二为 4k所以剩下的 就是 

1116
00:58:19,009 --> 00:58:27,020
你实际 有48位玩 

1117
00:58:21,068 --> 00:58:29,093
与这样其余48个比特所能 

1118
00:58:27,002 --> 00:58:32,090
这是正确的，所以如果它是四，如果它是 

1119
00:58:29,093 --> 00:58:34,187
个IT将是6， 所以你说得对 

1120
00:58:33,008 --> 00:58:38,095
在该方案也可能是在最多六个 

1121
00:58:35,087 --> 00:58:42,103
原来在它的设置它的做法

1122
00:58:38,095 --> 00:58:42,103
并有 在 这里 的一个问题 

1123
00:58:49,046 --> 00:58:59,165
有像这样多层次的系统哦 

1124
00:58:52,043 --> 00:59:01,952
好 了，问题是呀问题 

1125
00:58:59,579 --> 00:59:04,625
它是如何为您节省空间 ，因此 近期 

1126
00:59:02,339 --> 00:59:06,380
为您节省空间， 是你回到这个 

1127
00:59:05,039 --> 00:59:09,085
其他人物也许我没有解释这 

1128
00:59:06,749 --> 00:59:08,824
足够好 

1129
00:59:15,099 --> 00:59:28,146
所以你看这个，如果我们好了，所以我们说 

1130
00:59:26,097 --> 00:59:31,146
我们希望这个映射虚拟 地址 

1131
00:59:29,046 --> 00:59:34,080
用我们将单页表空间

1132
00:59:32,046 --> 00:59:39,075
需要PT E 对于内的每一页 

1133
00:59:34,008 --> 00:59:46,017
解决这一问题是否被使用或不好吗 

1134
00:59:39,075 --> 00:59:49,140
它可以追溯到如果我们有一个 48位 地址 

1135
00:59:46,089 --> 00:59:54,180
空间，我们需要足够的，我们 需要一个页面 

1136
00:59:50,004 --> 00:59:58,052
每个每一页的虚拟 表项 

1137
00:59:55,008 --> 00:59:58,016
在地址空间页

1138
01:00:00,004 --> 01:00:03,088
是否使用或不好吧该页 

1139
01:00:02,002 --> 01:00:10,048
所以 让 我想想 对XLVIII是 

1140
01:00:04,024 --> 01:00:12,813
一个X数数艾字节，我们需要一个 

1141
01:00:10,066 --> 01:00:15,765
这 将 有一个条目页表

1142
01:00:13,029 --> 01:00:19,660
每个虚拟页在给48位 

1143
01:00:16,359 --> 01:00:21,384
地址空间和大多数这些页面的

1144
01:00:19,066 --> 01:00:23,745
到目前为止， 绝大多数会永远 

1145
01:00:21,609 --> 01:00:28,683
使用好了，这就是浪费 

1146
01:00:24,339 --> 01:00:31,410
进来好了，所以这里有一个多层次

1147
01:00:29,349 --> 01:00:34,353
页面系统，这种多层次方案 

1148
01:00:32,049 --> 01:00:37,071
你只需要在这种情况下产生 

1149
01:00:34,749 --> 01:00:39,753
这些二级如果它是一个两级

1150
01:00:37,269 --> 01:00:41,322
系统只需要产生水平 

1151
01:00:39,789 --> 01:00:43,794
第二页表，有两个够级页 

1152
01:00:41,799 --> 01:00:45,420
以覆盖虚拟 的部分

1153
01:00:43,839 --> 01:00:47,410
你实际上正在使用地址空间 

1154
01:00:45,042 --> 01:00:49,221
好和 虚拟 的 那部分 

1155
01:00:47,041 --> 01:00:52,042
那你不使用地址空间 

1156
01:00:49,599 --> 01:00:57,940
这种差距就在这里有没有 

1157
01:00:52,042 --> 01:00:59,421
需要有一个页 表是明确 

1158
01:00:57,094 --> 01:01:13,203
那这是一个非常 好的重要 

1159
01:00:59,799 --> 01:01:15,970
的问题，但你看不服气好

1160
01:01:14,049 --> 01:01:23,052
是啊是啊，你还是需要你仍然需要

1161
01:01:15,097 --> 01:01:25,189
具有页表，让我们在 这 看 

1162
01:01:23,079 --> 01:01:31,210
万一有对字节TTE 4K字节的页 

1163
01:01:26,089 --> 01:01:33,163
所以有一个K你有1K PGES 

1164
01:01:31,021 --> 01:01:39,060
在此，所以你仍然需要你仍然需要 

1165
01:01:34,063 --> 01:01:40,962
有 1K PGES一个一级页表 

1166
01:01:39,249 --> 01:01:45,261
但这些只有 8个字节的权利 我 

1167
01:01:41,529 --> 01:01:46,626
这样意味着你仍然需要你仍然需要 

1168
01:01:45,369 --> 01:01:48,390
有空间，因为你不知道你 

1169
01:01:47,499 --> 01:01:50,502
知道你不知道 其中哪些 

1170
01:01:48,579 --> 01:01:53,470
其中原因，您的地址空间 

1171
01:01:50,799 --> 01:01:55,878
将 需要覆盖很好，而且它的 

1172
01:01:53,047 --> 01:01:58,596
在 这种情况下，在 这里同样的事情 

1173
01:01:56,589 --> 01:02:02,631
前两个PT前两个级别 

1174
01:01:59,019 --> 01:02:04,101
两页的表格 ，他们是他们的一部分 

1175
01:02:03,009 --> 01:02:07,062
地址 空间实际上 全部为 

1176
01:02:04,839 --> 01:02:10,931
用于右所以 在这些PGES中的 每一个 

1177
01:02:07,539 --> 01:02:13,930
二级必须是 亚历克它必须是 

1178
01:02:11,759 --> 01:02:16,930
初始化和使用

1179
01:02:13,093 --> 01:02:19,114
右但在此在 的 这 部分 

1180
01:02:16,093 --> 01:02:22,272
地址空间 包含堆栈 这 

1181
01:02:20,014 --> 01:02:28,683
第三第三级 页表有 

1182
01:02:23,109 --> 01:02:30,250
最大多数的患者中有或没有你仍然 

1183
01:02:28,809 --> 01:02:35,838
必须 为它们 分配空间 ，但 

1184
01:02:30,025 --> 01:02:38,364
他们有没有 好吧，这是一个 真正的 

1185
01:02:36,099 --> 01:02:46,176
很好的问题，重要的是我希望 

1186
01:02:38,589 --> 01:02:50,685
这是明确的其他任何问题，我们将 

1187
01:02:46,869 --> 01:03:01,869
去对不起

1188
01:02:51,549 --> 01:03:07,647
哦，还好问题，我们只是看着一部分 

1189
01:03:01,869 --> 01:03:09,918
演习 的 确切 才刚刚喜欢 

1190
01:03:08,529 --> 01:03:14,500
这里的MMU 记得做这一切 

1191
01:03:10,359 --> 01:03:18,190
这是所有的硬件逻辑，所以它和和 

1192
01:03:14,005 --> 01:03:22,054
艺术的 页表层次是 

1193
01:03:18,019 --> 01:03:23,070
通过该架构还行，以便限定 

1194
01:03:22,099 --> 01:03:24,948
MMU

1195
01:03:23,007 --> 01:03:30,636
采取这就是虚拟地址

1196
01:03:25,839 --> 01:03:34,200
呈现给它，它它 使用的部分 

1197
01:03:31,329 --> 01:03:39,430
这些比特的一个子集来访问每个 

1198
01:03:34,002 --> 01:03:42,007
每个页表好了，它就像 

1199
01:03:39,043 --> 01:03:45,142
为什么我回答你的问题 好了，所以它的 

1200
01:03:42,025 --> 01:03:51,894
就像在第四位等级k VPN 

1201
01:03:46,042 --> 01:03:54,050
K被用于计算一个指数到 

1202
01:03:52,119 --> 01:04:05,160
k级页面-是的 

1203
01:03:55,022 --> 01:04:06,108
在费用范围 还好，问题是为什么 

1204
01:04:05,016 --> 01:04:13,062
布置在右侧的索引到左 

1205
01:04:07,008 --> 01:04:15,057
在其图 哦 这些是位 

1206
01:04:13,062 --> 01:04:17,127
这是最显著位是 

1207
01:04:15,057 --> 01:04:18,150
总是零位是啊，这是一个很好的 

1208
01:04:18,027 --> 01:04:21,111
这样 的问题 ，问题是为啥 

1209
01:04:19,005 --> 01:04:23,091
这本图中为什么这些 

1210
01:04:22,011 --> 01:04:27,011
这些位标记从右到左 

1211
01:04:24,036 --> 01:04:30,036
从零开始 ，答案是 ， 

1212
01:04:27,011 --> 01:04:33,029
我们指示家伙位置， 

1213
01:04:30,036 --> 01:04:36,101
归零的至少显著尖端和n 

1214
01:04:33,029 --> 01:04:40,046
减去一个是最显著 位 

1215
01:04:37,001 --> 01:04:40,046
是问题 

1216
01:04:46,058 --> 01:04:50,085
是啊所以这个问题是有什么 

1217
01:04:48,066 --> 01:04:52,071
开销参与这些，当你有 

1218
01:04:50,085 --> 01:05:04,181
这些多层次的 ，现在是你 

1219
01:04:53,016 --> 01:05:08,061
谈到开销 - 是这么好

1220
01:05:05,081 --> 01:05:10,160
有清楚的，如果你没有得到TLB 

1221
01:05:08,061 --> 01:05:13,065
命中这将是一个很大的开销 

1222
01:05:11,006 --> 01:05:16,047
因为这将是你会 

1223
01:05:14,001 --> 01:05:20,070
从多个页表取PGES 

1224
01:05:17,001 --> 01:05:24,027
对于内存中， 以便但 由于 

1225
01:05:20,007 --> 01:05:25,062
当地的几率几乎是，

1226
01:05:24,027 --> 01:05:27,120
机会这个级别一个表涵盖 

1227
01:05:26,025 --> 01:05:32,072
整个地址空间，所以它总是 

1228
01:05:28,002 --> 01:05:35,043
将要 在 PG在 这些 TLB 

1229
01:05:32,072 --> 01:05:37,080
水平这些这些这些二级 

1230
01:05:35,061 --> 01:05:39,126
表覆盖的巨大的大片 

1231
01:05:37,008 --> 01:05:43,014
地址空间，所以很有可能他们 是 

1232
01:05:40,026 --> 01:05:47,075
要 在TLB中-右使，从而 

1233
01:05:44,004 --> 01:05:52,008
只要你的程序有合理 

1234
01:05:47,075 --> 01:05:53,127
当地大部分的大多数这些最 

1235
01:05:52,008 --> 01:05:56,040
这些查找的是要在打

1236
01:05:54,027 --> 01:05:58,080
TLB 好了， 事实 证明 ，在 

1237
01:05:57,012 --> 01:06:03,017
开销合理的书面 

1238
01:05:58,008 --> 01:06:06,086
程序是是可忽略不计

1239
01:06:03,017 --> 01:06:10,052
并且但这是一个非常这是一个非常 

1240
01:06:07,058 --> 01:06:12,062
你知道重要的考虑因素 

1241
01:06:10,052 --> 01:06:14,090
也许 ，也许这 对说话 

1242
01:06:12,062 --> 01:06:16,160
在某些时候增加，如果你有太多 

1243
01:06:14,009 --> 01:06:18,056
许多页表你可能你 可能 

1244
01:06:17,006 --> 01:06:21,010
增加未命中的概率 

1245
01:06:19,037 --> 01:06:27,131
在TLB 因此它可能是他们的东西 

1246
01:06:22,000 --> 01:06:31,082
非常仔细地考虑 好了其他任何 

1247
01:06:28,031 --> 01:06:34,052
问题是 啊 是 啊，我们用沉淀 

1248
01:06:31,082 --> 01:06:36,164
洪水分页所以 他的身份 

1249
01:06:34,052 --> 01:06:41,078
标签 建议丽娜对 沃德 

1250
01:06:37,064 --> 01:06:44,143
物业预算巨蟹座的问题是 

1251
01:06:41,078 --> 01:06:50,089
如何做分割适应这个和

1252
01:06:45,043 --> 01:06:56,131
我们不会去那里所以在 

1253
01:06:50,089 --> 01:06:58,097
早期的Intel系统如

1254
01:06:57,031 --> 01:07:04,049
实际上是第一个英特尔系统I 

1255
01:06:59,069 --> 01:07:07,100
程序是 在286 286 知道是 

1256
01:07:04,049 --> 01:07:09,107
整齐它是8086 反正前面 

1257
01:07:08,000 --> 01:07:13,021
早期的Intel系统有16位 

1258
01:07:10,007 --> 01:07:16,024
地址是 正确的 微小 这只是 

1259
01:07:13,021 --> 01:07:20,033
2至16 为您的地址空间， 

1260
01:07:16,024 --> 01:07:23,048
所以作为一个黑客，试图增加 

1261
01:07:20,033 --> 01:07:25,058
的这个地址的有效尺寸 

1262
01:07:23,048 --> 01:07:28,069
空间引入的概念 

1263
01:07:25,058 --> 01:07:33,083
分割等有四个 

1264
01:07:28,069 --> 01:07:35,114
段的4位 有一个寄存器 

1265
01:07:33,083 --> 01:07:36,170
包含四四段寄存器

1266
01:07:36,014 --> 01:07:42,110
可能被应用到所述位

1267
01:07:37,007 --> 01:07:44,039
地址，一个地址是的

1268
01:07:43,001 --> 01:07:46,096
该 段 的组合 更知道 

1269
01:07:45,002 --> 01:07:47,005
比

1270
01:07:48,044 --> 01:07:53,116
是的，你需要的段形成的 

1271
01:07:52,034 --> 01:07:57,035
地址枪是的组合

1272
01:07:54,016 --> 01:07:59,075
段位加上地址，以便您 

1273
01:07:57,035 --> 01:08:01,088
可以用段位来创建

1274
01:07:59,075 --> 01:08:04,088
偏移于是就出现了-这是它 

1275
01:08:01,088 --> 01:08:06,161
实际上是- 20/20 位地址 

1276
01:08:04,088 --> 01:08:09,161
空间，但你只能地址 ，您可以 

1277
01:08:07,061 --> 01:08:14,078
只访问它在2到16块 

1278
01:08:10,061 --> 01:08:18,074
权利，使该段会会 

1279
01:08:14,078 --> 01:08:20,153
确定的偏移量到的总和 

1280
01:08:18,074 --> 01:08:23,075
和偏移量，这20位 

1281
01:08:21,053 --> 01:08:27,106
地址空间，然后从 ， 你可以 

1282
01:08:23,075 --> 01:08:30,134
解决 16 位 所以这是这个非常 

1283
01:08:28,006 --> 01:08:35,018
不满意过分地硬编程 

1284
01:08:31,034 --> 01:08:37,121
的事情，因为你只能访问16位 

1285
01:08:35,018 --> 01:08:40,040
在一个时间块所以无论如何 我们 不 

1286
01:08:38,021 --> 01:08:42,026
打算几年后，他们 来到了 

1287
01:08:40,004 --> 01:08:44,066
他们的感觉和刚刚创建一个真正的 

1288
01:08:42,026 --> 01:08:53,068
虚拟存储器系统与线性

1289
01:08:45,002 --> 01:08:53,068
钻空间，但你知道真的存在 

1290
01:09:01,589 --> 01:09:09,420
是啊，我不知道，我们只是我不 

1291
01:09:06,066 --> 01:09:11,124
即使知道如果他们这样做地址

1292
01:09:09,042 --> 01:09:13,047
翻译对那些实际，所以我不 

1293
01:09:12,024 --> 01:09:15,120
知道，但你真的 不想去 

1294
01:09:13,047 --> 01:09:19,916
有啊 

1295
01:09:16,002 --> 01:09:21,027
哦，它确实它这样做的问题是， 

1296
01:09:20,339 --> 01:09:25,350
不存在 了 

1297
01:09:21,045 --> 01:09:28,139
一切英特尔一直非常的好 

1298
01:09:25,035 --> 01:09:33,099
关于保持向后兼容性 

1299
01:09:29,039 --> 01:09:35,058
所以这些东西的都在那里 ，但有 

1300
01:09:33,099 --> 01:09:36,192
的模式， 当你启动你 的 时候 

1301
01:09:35,058 --> 01:09:43,062
系统使用你所设置了一下，说我想 

1302
01:09:37,092 --> 01:09:45,104
一个线性地址空间行的任何 其它 

1303
01:09:43,062 --> 01:09:45,104
题

1304
01:09:47,065 --> 01:10:03,079
哦，不VT m2的 偏移还好使 

1305
01:10:01,078 --> 01:10:05,161
问题是，我们为什么要 关心VPN - 

1306
01:10:03,079 --> 01:10:09,085
因为它指向二级 

1307
01:10:06,061 --> 01:10:12,112
表，什么什么什么给你

1308
01:10:09,085 --> 01:10:16,123
一开始的水平两个表是 

1309
01:10:13,012 --> 01:10:19,551
在1级 表 私人入口 好了， 

1310
01:10:17,023 --> 01:10:21,108
所述1级表指向 

1311
01:10:19,659 --> 01:10:24,734
开始该级别的支付表 

1312
01:10:22,008 --> 01:10:27,377
VPN -让你的偏移成 

1313
01:10:25,409 --> 01:10:30,550
该2级表 

1314
01:10:27,449 --> 01:10:33,730
所以这些是通过采取查找地址

1315
01:10:30,055 --> 01:10:39,136
的基地址，然后DPN 2 

1316
01:10:33,073 --> 01:10:42,105
倍PT II 叹息 一般好 良好的任何 

1317
01:10:40,036 --> 01:10:42,105
其他问题

1318
01:10:48,085 --> 01:10:56,183
好清楚，会 为今天做 下一个 

1319
01:10:53,009 --> 01:10:58,100
一周周四，我们将看看如何 

1320
01:10:57,083 --> 01:11:02,742
虚拟内存在实际执行 

1321
01:10:59,081 --> 01:11:02,760
系统 说，而在Linux 

