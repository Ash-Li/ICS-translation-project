1
00:00:00,087 --> 00:00:08,178
下午 好 欢迎 大家 好 

2
00:00:04,589 --> 00:00:12,300
看你因此本周我们将 

3
00:00:09,078 --> 00:00:14,477
研究如何将并发

4
00:00:12,003 --> 00:00:17,040
进入到程序现在我们已经看到了 

5
00:00:15,179 --> 00:00:22,470
在之前的并发并发 

6
00:00:17,067 --> 00:00:24,072
预言异常处理的形式和 

7
00:00:22,047 --> 00:00:27,099
在中的处理的情况下它是 

8
00:00:25,017 --> 00:00:29,776
完美无暇的，我们 用我们 用预言作为 

9
00:00:27,099 --> 00:00:33,150
该机制运行多个 

10
00:00:29,929 --> 00:00:38,540
独立的应用程序现在没事了 

11
00:00:34,005 --> 00:00:40,634
但你可以 并发还 存在 于 

12
00:00:38,054 --> 00:00:43,073
应用程序现在我们已经看到了 

13
00:00:41,129 --> 00:00:45,660
这 一点 只有 当我们研究 

14
00:00:43,559 --> 00:00:48,840
信号处理 好这样一个 信号处理器 

15
00:00:45,066 --> 00:00:50,091
是运行并发流 

16
00:00:48,084 --> 00:00:53,533
同时与你与你的主 

17
00:00:50,091 --> 00:00:56,187
应用程序可以的，我们已经看到了 

18
00:00:54,289 --> 00:01:01,289
我们已经看到了如何一些 困难 

19
00:00:57,087 --> 00:01:07,766
当 我们介绍 可能出现 

20
00:01:01,289 --> 00:01:10,110
并发在我们的计划，使即使有 

21
00:01:08,549 --> 00:01:13,680
类似的信号处理器，其 

22
00:01:10,011 --> 00:01:15,054
没有做 很多这是非常困难的 

23
00:01:13,068 --> 00:01:16,167
我们来思考 这种 本 

24
00:01:15,054 --> 00:01:18,129
之类 的话 时，我们有二两 

25
00:01:17,067 --> 00:01:21,120
在相同的运行并发流

26
00:01:19,029 --> 00:01:23,082
像有一次是我们的大脑往往只

27
00:01:22,002 --> 00:01:25,005
是一种 连续的，我们要 

28
00:01:23,082 --> 00:01:27,108
想想事情 发生后一个 

29
00:01:25,005 --> 00:01:29,090
另外 ，你知道这是和它的多 

30
00:01:28,008 --> 00:01:32,052
我们更容易 推论说 

31
00:01:30,035 --> 00:01:35,264
推理多件事情

32
00:01:32,052 --> 00:01:38,261
发生在同一时间真的 会导致 

33
00:01:35,579 --> 00:01:41,970
问题和根本原因 

34
00:01:38,729 --> 00:01:45,840
是-真-真推理 

35
00:01:41,097 --> 00:01:47,606
说-两个独立的两个并行 

36
00:01:45,084 --> 00:01:49,089
流向我们必须考虑所有的 

37
00:01:48,479 --> 00:01:52,920
这些流的可能的交错 

38
00:01:50,034 --> 00:01:55,047
好吧 ，这就是在那里， 就是这样 

39
00:01:52,092 --> 00:01:57,138
配合饲料与指数增长

40
00:01:55,047 --> 00:01:59,109
流的数量好吧 ，你有你 

41
00:01:58,038 --> 00:02:03,557
看到这个与你的信号处理程序时， 

42
00:02:00,009 --> 00:02:06,218
你没有外壳实验室你有你有两个 

43
00:02:03,899 --> 00:02:09,932
并发流主程序和 

44
00:02:06,299 --> 00:02:12,270
和信号处理程序都访问

45
00:02:10,229 --> 00:02:14,970
在的形式共享资源

46
00:02:12,027 --> 00:02:17,115
作业列表中的权利，你必须是 

47
00:02:14,097 --> 00:02:21,129
非常小心，以 防止交织 

48
00:02:18,015 --> 00:02:23,082
如该其中该数据结构是 

49
00:02:22,029 --> 00:02:26,037
在 不一致的被引用 

50
00:02:23,082 --> 00:02:28,113
状态 好了，所以我们要做的 

51
00:02:27,009 --> 00:02:30,072
本周到下周，是我们 

52
00:02:29,013 --> 00:02:33,039
要我们要去 看看那个 

53
00:02:30,072 --> 00:02:35,133
各种应用级别的并发 

54
00:02:33,039 --> 00:02:38,052
但在一个更加原则性的更 

55
00:02:36,033 --> 00:02:46,035
比我们遇到了原则的方式

56
00:02:38,052 --> 00:02:48,069
与信号处理函数，以便只要你

57
00:02:46,035 --> 00:02:52,071
已经多个流访问共享

58
00:02:48,069 --> 00:02:55,098
资源各种不好的 东西 可以 

59
00:02:52,071 --> 00:02:59,097
发生在你的 程序和这些这些 

60
00:02:55,098 --> 00:03:01,143
已经这些 这些不好的东西，这些 

61
00:02:59,097 --> 00:03:03,099
发生那么的对象问题

62
00:03:02,043 --> 00:03:06,045
研究和计算机科学四个 

63
00:03:04,017 --> 00:03:09,024
几十年来， 但 种 的东西， 

64
00:03:06,063 --> 00:03:13,074
可能 发生，我们 在 看到有比赛 

65
00:03:09,087 --> 00:03:15,096
当我们做了壳的实验室，其中的 

66
00:03:13,074 --> 00:03:17,133
结果， 不管是好的还是坏的结果 

67
00:03:15,096 --> 00:03:19,101
取决于一些一些任意

68
00:03:18,033 --> 00:03:23,049
调度权的情况下决定

69
00:03:20,046 --> 00:03:25,065
你知道 我们在看到比赛之一 

70
00:03:23,049 --> 00:03:27,054
壳的情况下， 是 的情况下一个 

71
00:03:25,065 --> 00:03:29,154
孩子仅仅 因为一个调度 

72
00:03:27,054 --> 00:03:32,058
通过运行的内核决定，

73
00:03:30,054 --> 00:03:34,092
完成家长有机会之前 

74
00:03:32,094 --> 00:03:37,101
给孩子添加到任务列表中 好 

75
00:03:34,092 --> 00:03:40,188
所以这是这是一个经典的例子 

76
00:03:38,001 --> 00:03:43,037
种族和同样，如果你 有两个 

77
00:03:41,088 --> 00:03:45,161
那些试图 使 人们 

78
00:03:43,037 --> 00:03:47,109
访问对鸟预约系统

79
00:03:46,061 --> 00:03:51,093
为航空公司 

80
00:03:48,009 --> 00:03:54,051
谁得到在该如果他们都访问

81
00:03:51,093 --> 00:03:56,145
究竟是谁得到一个座位正好同一时间

82
00:03:54,051 --> 00:03:59,052
取决于不同的调度决策 

83
00:03:57,045 --> 00:04:03,120
在预约的事

84
00:03:59,052 --> 00:04:06,075
系统另外一种问题， 那 

85
00:04:04,002 --> 00:04:09,006
发生死锁是 这样一个僵局是 

86
00:04:06,075 --> 00:04:12,099
存在，你必须条件

87
00:04:09,006 --> 00:04:16,074
多个流等待一个事件 

88
00:04:12,099 --> 00:04:18,144
所以用printf将不会发生好吗 

89
00:04:17,028 --> 00:04:21,116
的信号处理程序是这样的一个例子 

90
00:04:19,044 --> 00:04:23,109
的一种这样那样的问题，或者 

91
00:04:22,016 --> 00:04:24,113
介绍了潜在的那种

92
00:04:24,009 --> 00:04:29,042
问题

93
00:04:25,013 --> 00:04:33,016
好了，所以在你的主程序 UX你 

94
00:04:29,042 --> 00:04:36,119
执行一个printf 和printf的 

95
00:04:33,016 --> 00:04:42,020
获得一些系统资源的锁定

96
00:04:37,019 --> 00:04:45,050
我 我认为 这是一个终端 锁，然后 

97
00:04:42,002 --> 00:04:47,048
之后是主要获取的printf 

98
00:04:45,005 --> 00:04:50,066
这个锁它被通过 信号 中断 

99
00:04:47,066 --> 00:04:54,140
处理器和现在的信号处理程序 ，如果它 

100
00:04:51,011 --> 00:04:57,053
这是否将printf的尝试给 printf 

101
00:04:55,004 --> 00:04:59,021
获得该锁，但它不能 

102
00:04:57,053 --> 00:05:02,057
得到它，因为在对中的printf 

103
00:04:59,057 --> 00:05:03,065
主程序所以现在有它的信号

104
00:05:02,057 --> 00:05:05,138
火腿的printf在信号处理程序是 

105
00:05:04,037 --> 00:05:07,109
等待事件永远不会 

106
00:05:06,038 --> 00:05:10,123
它发生在等待该锁是 

107
00:05:08,009 --> 00:05:13,103
释放，它永远不会发生 ，因为 

108
00:05:11,023 --> 00:05:17,066
在主程序主中的printf

109
00:05:14,003 --> 00:05:20,015
无法解除锁定， 直到 信号 

110
00:05:17,066 --> 00:05:21,152
处理退货和信号处理程序 

111
00:05:20,015 --> 00:05:24,104
无法获取锁，直到中的printf 

112
00:05:22,052 --> 00:05:26,141
在主程序终止所以这

113
00:05:25,004 --> 00:05:31,019
这是僵局的一个典型的例子 

114
00:05:27,041 --> 00:05:33,062
另一个更来自现实生活中的 想象 

115
00:05:31,019 --> 00:05:36,113
那想象一下 ， 你是所有驱动程序 

116
00:05:33,062 --> 00:05:39,119
遵守规则 非常精确，并与 

117
00:05:37,013 --> 00:05:44,036
对于 四路站 的规则 是， 

118
00:05:40,019 --> 00:05:48,103
谁抢先 获得去 

119
00:05:44,036 --> 00:05:51,104
第一好了，所以如果四个车在到达 

120
00:05:49,003 --> 00:05:54,077
相交完全相同的时间，然后

121
00:05:52,004 --> 00:05:57,020
你已经死锁你有没有 的 

122
00:05:54,077 --> 00:05:58,118
司机是第一次所以没有没有 的 

123
00:05:57,002 --> 00:06:02,065
司机去，所以他们都在等 

124
00:05:59,018 --> 00:06:05,024
对于 将永远不会 发生 的 条件 

125
00:06:02,083 --> 00:06:06,100
然后等经典的东西，可以 

126
00:06:05,024 --> 00:06:11,072
出问题或之类的东西活跃度 

127
00:06:07,000 --> 00:06:14,099
这个饥饿的 饥饿公平 

128
00:06:11,072 --> 00:06:15,155
当你驶向 你正在试图做的发生

129
00:06:14,099 --> 00:06:17,177
的东西，但你无法取得进展， 

130
00:06:16,055 --> 00:06:21,107
因为别人不断得到所有 

131
00:06:18,077 --> 00:06:23,108
工作权 ，所以如果你是，如果你 有 

132
00:06:22,007 --> 00:06:27,052
两个过程始终内核 

133
00:06:24,008 --> 00:06:29,057
调度处理的代替处理B的 

134
00:06:27,052 --> 00:06:31,057
处理B，这将是 的 一个例子 

135
00:06:29,057 --> 00:06:34,151
处理B饿死因为一个出

136
00:06:32,002 --> 00:06:37,050
不正确的调度决策和我们 

137
00:06:35,051 --> 00:06:39,135
要说的是，那这就是 

138
00:06:37,005 --> 00:06:42,057
政策总是附表D是不公平 的权利 

139
00:06:40,035 --> 00:06:45,114
所以它 不具备这个这个属性 

140
00:06:43,002 --> 00:06:49,031
公平，每一个每一个实体在 

141
00:06:46,014 --> 00:06:55,014
系统得到得到某种合理的

142
00:06:49,031 --> 00:06:56,118
处理器的块所以像我说 我 

143
00:06:55,014 --> 00:06:59,072
这意味着并发性进行了研究

144
00:06:57,018 --> 00:07:02,049
多年来这是一个非常这是一个 非常深刻的 

145
00:06:59,072 --> 00:07:04,083
因为这一点，因为很难话题 

146
00:07:02,049 --> 00:07:07,107
这种指数爆炸中 

147
00:07:04,083 --> 00:07:09,126
的交错的数量 ，所以我们不能 

148
00:07:08,007 --> 00:07:12,051
我们不打算覆盖所有的人都在 

149
00:07:10,026 --> 00:07:16,029
但是，我们将介绍一些使你得到一个 

150
00:07:12,051 --> 00:07:18,059
那合理的想法如何 

151
00:07:16,056 --> 00:07:21,141
合并并发在你的程序

152
00:07:18,059 --> 00:07:23,124
现在我们的应用研究

153
00:07:22,041 --> 00:07:26,127
级并发，我们要使用 

154
00:07:24,024 --> 00:07:29,100
服务器作为激励例子 和和 

155
00:07:27,027 --> 00:07:33,065
其原因是，你可以不写 

156
00:07:30,000 --> 00:07:37,026
正确的服务器，而无需使用并发 

157
00:07:33,065 --> 00:07:41,112
所以这是一个很好的它是一个 非常不错的好 

158
00:07:37,026 --> 00:07:43,107
动机和这里的原因， 所以这样 

159
00:07:42,012 --> 00:07:46,020
到目前为止，我们已经看了那些服务器

160
00:07:44,007 --> 00:07:48,078
迭代好了，所以他们也 只是他们 

161
00:07:46,002 --> 00:07:51,281
从一个客户端进程请求

162
00:07:48,078 --> 00:07:53,777
时间，一旦他们完成处理或 

163
00:07:51,479 --> 00:07:59,970
从客户端 之后，他们去 申请 

164
00:07:54,479 --> 00:08:03,000
下一个客户端，以便他们这么喜欢我们的 

165
00:07:59,097 --> 00:08:05,184
迭代回声服务器，你可以看到

166
00:08:03,000 --> 00:08:12,003
每个这些客户 使得 

167
00:08:06,084 --> 00:08:13,179
连接请求 然后将它 写入一个线 

168
00:08:12,003 --> 00:08:17,049
文本到服务器， 然后等待 

169
00:08:14,079 --> 00:08:19,080
服务器呼应在背部 和 

170
00:08:17,076 --> 00:08:22,152
这种情况下，这个简单的情况下，就在这时， 

171
00:08:19,089 --> 00:08:26,108
它只是关闭好和服务器等待 

172
00:08:23,052 --> 00:08:30,701
用于连接请求，并接受与 

173
00:08:27,008 --> 00:08:32,094
然后再等待等待再

174
00:08:31,169 --> 00:08:37,172
一旦接受连接 请求 

175
00:08:32,094 --> 00:08:38,178
它读取并等待对于等待什么 

176
00:08:37,469 --> 00:08:42,300
该客户端对 写 东西 

177
00:08:39,078 --> 00:08:46,307
该连接，然后呼应它 

178
00:08:42,003 --> 00:08:50,061
回来，然后，然后等待 

179
00:08:47,009 --> 00:08:53,085
对于未来九个月， 直到 ，直到 

180
00:08:50,088 --> 00:08:55,047
客户端关闭该该连接 

181
00:08:53,769 --> 00:08:57,430
然后服务器关闭其 

182
00:08:55,839 --> 00:08:59,920
连接，然后才做它 

183
00:08:57,043 --> 00:09:02,104
它做的是另除了等待 

184
00:08:59,092 --> 00:09:05,121
下一个连接请求 好了，所以在 

185
00:09:03,004 --> 00:09:10,011
在本实施例的客户端 2也是 

186
00:09:05,949 --> 00:09:14,050
建立连接的 请求 ，但它 从来没有 

187
00:09:10,011 --> 00:09:18,063
它从来没有运行 它必须等待，直到 

188
00:09:14,005 --> 00:09:20,784
服务器实际上回显应答 

189
00:09:18,063 --> 00:09:25,572
现在有有一点点微妙 

190
00:09:20,829 --> 00:09:29,847
在这里，在正是这 

191
00:09:26,139 --> 00:09:31,990
客户等待 这样 的语义 

192
00:09:30,009 --> 00:09:34,035
连接 你会认为 连接 

193
00:09:31,099 --> 00:09:35,173
将阻塞，直到连接 是 

194
00:09:34,269 --> 00:09:41,160
成立但实际上，如果你试图 

195
00:09:36,073 --> 00:09:42,130
这一点， 事实证明， 连接 

196
00:09:41,016 --> 00:09:45,025
实际上发起连接

197
00:09:43,003 --> 00:09:48,102
在内核中，但随后的过程

198
00:09:45,025 --> 00:09:52,048
在连接之前返回好吗 

199
00:09:48,399 --> 00:09:57,130
已经建立 ，然后它做了 

200
00:09:52,048 --> 00:09:58,081
权，这种权利也回报 

201
00:09:57,013 --> 00:10:02,037
立即向右所以也 没有它 

202
00:09:58,081 --> 00:10:06,720
不等到服务器将读取

203
00:10:02,037 --> 00:10:10,506
这是书面和它的字符串 

204
00:10:07,449 --> 00:10:14,493
不阻止 ，直到它调用读 

205
00:10:10,839 --> 00:10:18,250
功能等待 ， 等待回应 

206
00:10:14,889 --> 00:10:20,680
从服务器， 所以它响应

207
00:10:18,025 --> 00:10:22,614
实际上它不会阻止，直到遇到 

208
00:10:20,068 --> 00:10:24,124
这种阅读，然后花一切 

209
00:10:22,839 --> 00:10:28,630
等待等待等待等待，终于 

210
00:10:25,024 --> 00:10:31,563
服务器接受该连接请求 

211
00:10:28,063 --> 00:10:34,952
然后写入写入字符串

212
00:10:31,779 --> 00:10:34,853
相呼应的字符串返回给客户端 

213
00:10:40,269 --> 00:10:48,350
因此调用实际连接

214
00:10:44,000 --> 00:10:49,073
立即返回 ，它利用 了 

215
00:10:48,035 --> 00:10:51,086
功能在内核中可以排队 

216
00:10:49,073 --> 00:10:54,086
这些连接请求 还好使 

217
00:10:51,086 --> 00:10:56,117
内核现在正在经历的一切 

218
00:10:54,086 --> 00:10:59,365
建立连接的过程，但 

219
00:10:57,017 --> 00:11:03,106
该应用程序将继续和 

220
00:11:00,139 --> 00:11:06,202
再右边里面的右

221
00:11:03,259 --> 00:11:08,317
客户端不会阻止，因为该 

222
00:11:06,769 --> 00:11:09,838
内核还可以排队 是这样的数据 

223
00:11:08,839 --> 00:11:12,290
书面所以它会，它会排队起来 

224
00:11:10,459 --> 00:11:14,470
请记住，这是 写在 

225
00:11:12,029 --> 00:11:18,047
连接 实际上被创建 ，然后它 

226
00:11:14,569 --> 00:11:19,651
将它会沿着发送数据，但 

227
00:11:18,047 --> 00:11:22,094
有没有办法避免读 

228
00:11:20,389 --> 00:11:25,432
从阻塞写读不能 

229
00:11:22,094 --> 00:11:29,150
返回，直到它得到了一些数据好了， 

230
00:11:25,819 --> 00:11:31,858
读有权阻止现在没事了这里的 

231
00:11:30,005 --> 00:11:34,103
迭代服务器的 根本缺陷 

232
00:11:32,209 --> 00:11:38,241
而我们之所以有原因 

233
00:11:35,048 --> 00:11:40,597
他们与并发使用写

234
00:11:38,529 --> 00:11:49,100
好了，让我们在我们的回声服务器说 

235
00:11:41,029 --> 00:11:54,046
例如，我们有一个创建一个客户端

236
00:11:49,001 --> 00:11:57,082
连接请求 这是 一个连接 

237
00:11:54,199 --> 00:12:02,120
在服务器接受不写 

238
00:11:57,091 --> 00:12:05,760
服务器回送您知道的一个

239
00:12:02,012 --> 00:12:09,068
字符串，然后在客户端的块再次 

240
00:12:06,579 --> 00:12:15,940
或者不要 做下一个 写或 

241
00:12:09,068 --> 00:12:15,094
关闭连接 的人就 

242
00:12:16,067 --> 00:12:20,123
在用户外出吃午饭，从来没有 

243
00:12:19,043 --> 00:12:25,043
类型将字符串中的这些回波 

244
00:12:21,023 --> 00:12:28,070
客户好了 ，所以在这 一点上服务器 

245
00:12:25,043 --> 00:12:31,096
调用里德，然后 等待块 

246
00:12:28,007 --> 00:12:33,083
此用户在输入一些东西和 

247
00:12:31,096 --> 00:12:36,140
使客户可以将它发送到 

248
00:12:34,046 --> 00:12:38,132
服务器中回荡，但用户已经一去不复返了 

249
00:12:37,004 --> 00:12:44,006
被卡车撞 

250
00:12:39,032 --> 00:12:46,106
反正谁知道所以这 从来没有 这种里德 

251
00:12:44,042 --> 00:12:51,104
然后在不确定量块

252
00:12:47,006 --> 00:12:56,069
时间权，而 其阻断 其 

253
00:12:52,004 --> 00:13:00,062
客户也希望 它 服务 

254
00:12:56,069 --> 00:13:03,074
有那么现在你 在 是阻止好吗 

255
00:13:00,062 --> 00:13:05,144
难以维持的局面，其中一个客户端

256
00:13:04,019 --> 00:13:07,106
那种完全影响了所有的 

257
00:13:06,044 --> 00:13:10,052
在系统中，没有其他客户

258
00:13:08,006 --> 00:13:14,054
其他客户端可以得到 服务，所以如果 

259
00:13:10,052 --> 00:13:18,074
这是一个网络服务器，如果如果一个客户端 

260
00:13:14,054 --> 00:13:20,123
出于某种原因堵塞 没有其他任何 

261
00:13:18,074 --> 00:13:22,079
其他用户将能够 使用该 

262
00:13:21,023 --> 00:13:26,039
在 对 网页的Web服务或看 

263
00:13:23,024 --> 00:13:31,049
一步网站，所以这显然我们不能

264
00:13:26,039 --> 00:13:33,074
有这样的好了，解决的办法是使用 

265
00:13:31,049 --> 00:13:36,056
这 写并发服务器 

266
00:13:33,074 --> 00:13:38,078
而不是迭代服务器里 

267
00:13:36,056 --> 00:13:42,065
我们将有一个独立的并发流 

268
00:13:39,014 --> 00:13:47,051
处理每一个客户的要求， 

269
00:13:43,046 --> 00:13:49,048
与每一个客户那么现在，如果一个互动

270
00:13:47,051 --> 00:13:50,093
客户出于某种原因很慢或

271
00:13:49,066 --> 00:13:52,154
行为不端

272
00:13:50,093 --> 00:13:54,128
或块系统的其他客户端将无法 

273
00:13:53,054 --> 00:13:58,099
受到影响，因为这些客户会 

274
00:13:55,028 --> 00:13:58,099
像通过并发流处理

275
00:14:00,038 --> 00:14:08,039
所以有几种方法 的一些 

276
00:14:03,044 --> 00:14:11,087
方法如果你愿意来创建这些是 

277
00:14:08,039 --> 00:14:16,061
从多个类可能支付 

278
00:14:11,087 --> 00:14:18,089
生活中 有其他时间负PUT和 

279
00:14:16,061 --> 00:14:20,126
还有就 在 让你所有的 

280
00:14:18,089 --> 00:14:23,138
它实际上可能和事实

281
00:14:21,026 --> 00:14:26,030
这是并发的形式 好 ，因此 

282
00:14:24,038 --> 00:14:30,083
问题是，可能是因为可以在 

283
00:14:26,003 --> 00:14:34,058
从从服务器排队的请求 

284
00:14:30,083 --> 00:14:36,101
客户可能，但它会我猜 

285
00:14:34,085 --> 00:14:37,133
实际上那就要排队 它 

286
00:14:37,001 --> 00:14:43,073
会在一定程度不得不接受那些 

287
00:14:38,033 --> 00:14:49,070
连接权，让他们知道， 这样 

288
00:14:43,073 --> 00:14:52,082
不工作，所以在某种程度上你有自 

289
00:14:49,007 --> 00:14:54,071
在因为接听电话都是迭代 

290
00:14:52,082 --> 00:14:58,139
顺序有没有办法得到数据 

291
00:14:55,034 --> 00:15:01,034
不同于其他客户 还可以，但 

292
00:14:59,039 --> 00:15:02,081
但实际上你是在暗示是 

293
00:15:01,034 --> 00:15:06,038
非常类似于一种叫做 

294
00:15:02,081 --> 00:15:07,136
基于事件的 服务器，这将其 

295
00:15:06,038 --> 00:15:10,046
是 的，我们可以创建 一个 方法 

296
00:15:08,036 --> 00:15:14,123
并发流所以有有

297
00:15:11,018 --> 00:15:18,095
有三种方法可以创建这些 

298
00:15:15,023 --> 00:15:20,095
并发流一个是使用 

299
00:15:18,095 --> 00:15:24,095
预言没关系就像我们已经看到的 

300
00:15:20,095 --> 00:15:26,099
好了，所以 在这种情况下 ，内核等 

301
00:15:24,095 --> 00:15:29,120
内核处理所有的调度 

302
00:15:27,035 --> 00:15:33,043
对于美国和它，它的叶子 

303
00:15:30,002 --> 00:15:36,011
交错流程执行 

304
00:15:33,043 --> 00:15:38,066
自动为我们，然后，我们看到 

305
00:15:36,029 --> 00:15:40,046
之前每个流都有自己的私人 

306
00:15:38,066 --> 00:15:42,158
地址空间中，使得 每个流是 

307
00:15:40,046 --> 00:15:47,141
独立的，由内核调度 

308
00:15:43,058 --> 00:15:50,090
还好现在有一个又一个的另一 

309
00:15:48,041 --> 00:15:52,136
基础的方法称为事件，其中 

310
00:15:50,009 --> 00:15:54,017
程序员手动交织

311
00:15:53,036 --> 00:15:57,119
流动的好了，所以不是依靠 

312
00:15:55,007 --> 00:16:00,083
内核交错这些不同

313
00:15:58,019 --> 00:16:04,091
流入该用户编程

314
00:16:01,046 --> 00:16:08,053
创建该手动流动，然后

315
00:16:04,091 --> 00:16:11,102
交错他们没关系 

316
00:16:08,053 --> 00:16:13,109
并且由于它是一个程序的所有 

317
00:16:12,002 --> 00:16:15,047
流共享相同的地址空间 权 

318
00:16:14,009 --> 00:16:20,108
所以他们可以访问所有相同 

319
00:16:15,047 --> 00:16:23,051
全局数据结构和他们他们做 

320
00:16:21,008 --> 00:16:25,079
他们用这种交错

321
00:16:23,051 --> 00:16:27,058
技术称为IO复用你 

322
00:16:25,079 --> 00:16:30,134
知道我会 有关简要 谈 ，但 

323
00:16:27,058 --> 00:16:34,103
这是它在很大程度上解决多 

324
00:16:31,034 --> 00:16:36,059
在 你的书的第三详细

325
00:16:35,003 --> 00:16:40,046
方法这是一种混合的

326
00:16:36,059 --> 00:16:43,064
过程和基于事件线程 

327
00:16:40,046 --> 00:16:46,100
碱所以使用每个各每个这些 

328
00:16:44,009 --> 00:16:52,081
流是用什么实现的

329
00:16:47,000 --> 00:16:57,025
被称为一个线程内核 

330
00:16:52,081 --> 00:16:58,127
像预言一样的内核 

331
00:16:57,025 --> 00:17:02,041
自动交错这些这些 

332
00:16:59,027 --> 00:17:05,048
不同的线程 

333
00:17:02,041 --> 00:17:07,136
但与每个每个线程的过程 

334
00:17:05,048 --> 00:17:10,070
共享相同的地址空间， 所以没关系 

335
00:17:08,036 --> 00:17:14,123
每个线程可以访问所有 全局 

336
00:17:10,007 --> 00:17:16,106
变量的程序，以便在申报

337
00:17:15,023 --> 00:17:19,094
所以它就像基于过程， 而且 

338
00:17:17,069 --> 00:17:21,104
对自动安排内核

339
00:17:19,094 --> 00:17:23,168
对我们来说 ，但它是基于像事件 

340
00:17:22,004 --> 00:17:26,011
每一个流共享的意义

341
00:17:24,068 --> 00:17:28,073
相同的地址空间

342
00:17:26,074 --> 00:17:31,162
好了，我们来看看让我们来看看所有 

343
00:17:28,073 --> 00:17:34,166
三个详细介绍这些方法的 

344
00:17:32,062 --> 00:17:40,093
所以第一种方法是创建 这些 

345
00:17:35,066 --> 00:17:46,115
在这种情况下使用的过程，从而流

346
00:17:40,093 --> 00:17:51,107
这 是我们的回声服务器例子的 

347
00:17:47,015 --> 00:17:55,070
客户端请求连接，然后

348
00:17:52,007 --> 00:17:58,024
调用f得到s 到等待 用户 

349
00:17:55,007 --> 00:18:01,046
在键盘上输入的东西

350
00:17:58,024 --> 00:18:03,116
但用户 不见了 ， 因此 歼 客人˚F 

351
00:18:02,009 --> 00:18:08,090
让我们这个客户端在只有几个街区 

352
00:18:04,016 --> 00:18:12,044
打电话到F获得如此的服务器时，它 

353
00:18:08,009 --> 00:18:13,097
得到它接受连接的请求 

354
00:18:12,044 --> 00:18:16,099
从接受 请求 并返回 

355
00:18:14,078 --> 00:18:16,099
呼叫

356
00:18:17,045 --> 00:18:23,129
并从返回后接受

357
00:18:20,048 --> 00:18:26,102
把它叉儿，然后说 

358
00:18:24,029 --> 00:18:29,081
孩子现在交互子进程 

359
00:18:27,002 --> 00:18:32,060
将负责 与互动 

360
00:18:29,081 --> 00:18:35,138
客户号一个，这样子块 

361
00:18:32,006 --> 00:18:37,081
等待来自客户端的一个数据，其

362
00:18:36,038 --> 00:18:43,040
永远不会因为填补

363
00:18:38,035 --> 00:18:46,082
用户留下 好的，但也没关系 

364
00:18:43,004 --> 00:18:48,083
因为它不会停止服务器

365
00:18:46,082 --> 00:18:52,103
之后服务器叉子云 

366
00:18:49,019 --> 00:18:54,026
右后卫和调用accept和现在 

367
00:18:53,003 --> 00:18:59,024
接受可以接受的连接 

368
00:18:54,089 --> 00:19:01,172
从客户端两叉请求 

369
00:18:59,024 --> 00:19:05,042
掀起又一个不同的孩子 ，可以 

370
00:19:02,072 --> 00:19:07,169
互动与客户端两条SO该

371
00:19:05,042 --> 00:19:09,131
孩子会读的数据等待到 

372
00:19:08,069 --> 00:19:12,154
从客户端显示出来，然后将其 

373
00:19:10,031 --> 00:19:17,039
呼应回来，并在某些时候则

374
00:19:13,054 --> 00:19:18,062
好将关闭此连接，所以你看 

375
00:19:17,039 --> 00:19:22,078
这个行为不端的客户端的头号

376
00:19:19,034 --> 00:19:25,115
现在因为我们有并发流 

377
00:19:22,078 --> 00:19:27,116
与所有的客户端 交互 此 

378
00:19:26,015 --> 00:19:30,047
行为不端的客户端不能不利

379
00:19:28,016 --> 00:19:34,058
影响其他的客户还好所以现在这

380
00:19:30,047 --> 00:19:36,050
这就是这个想法的创造 

381
00:19:34,058 --> 00:19:39,062
并发流，以进行交互 

382
00:19:36,005 --> 00:19:42,038
客户是根本的是有你有 

383
00:19:39,098 --> 00:19:46,130
要做到这一点， 以便有排序 的 

384
00:19:42,083 --> 00:19:47,177
工作服务器实现这样好吗 

385
00:19:47,003 --> 00:19:53,009
我们将如何实际设定此 

386
00:19:48,077 --> 00:19:57,151
基于过程的并行服务器是 

387
00:19:53,009 --> 00:20:02,104
竟然出奇紧凑权 

388
00:19:58,051 --> 00:20:05,074
所以我们要通过在艺术 V WE是 

389
00:20:03,085 --> 00:20:08,146
要在一个端口号来传递我们 

390
00:20:05,074 --> 00:20:10,893
希望此服务器 侦听我们有 

391
00:20:09,046 --> 00:20:15,049
监听描述符和连接 

392
00:20:11,559 --> 00:20:20,520
描述我们已经有了，然后我们有 

393
00:20:15,049 --> 00:20:23,110
的长度和地址地址字段 

394
00:20:20,052 --> 00:20:26,071
而该地址是在声明 

395
00:20:24,001 --> 00:20:29,035
使用这种袜子协议独立方式 

396
00:20:26,071 --> 00:20:30,136
这是保证出或存储类型 

397
00:20:29,044 --> 00:20:32,913
必须足够大 ， 因为你看到的最后 一次 

398
00:20:31,036 --> 00:20:35,101
它的保证 是足够大到 

399
00:20:33,309 --> 00:20:40,395
处理任何类型的解决存在的 IPv4 

400
00:20:36,001 --> 00:20:46,290
或IPv6 好了，所以我们安装一个生病的孩子 

401
00:20:41,169 --> 00:20:49,240
处理程序，然后我们用 开放 

402
00:20:46,299 --> 00:20:51,640
听了FD从您从您的通话 

403
00:20:49,024 --> 00:20:55,027
教科书 建立一个监听 

404
00:20:51,064 --> 00:20:56,071
描述端口，我们通过口 

405
00:20:55,027 --> 00:21:01,086
在作为作为参数来这 

406
00:20:57,034 --> 00:21:09,051
程序，然后服务器进入一个

407
00:21:01,086 --> 00:21:11,154
成一个循环，并在每一次迭代它它 

408
00:21:09,051 --> 00:21:16,062
得到插座或存储的大小

409
00:21:12,054 --> 00:21:22,147
键入并把它放到客户端出借

410
00:21:16,062 --> 00:21:25,069
然后调用 它除了具有 

411
00:21:23,047 --> 00:21:33,006
指针指向到客户端地址

412
00:21:25,069 --> 00:21:34,162
并在客户端使用一个聆听 

413
00:21:33,429 --> 00:21:40,390
这是open返回描述符

414
00:21:35,062 --> 00:21:41,110
听了FD的接受后，呼叫 

415
00:21:40,039 --> 00:21:43,126
得到它返回一个连接请求 

416
00:21:42,001 --> 00:21:48,064
与生产该 客户端 的地址 

417
00:21:44,026 --> 00:21:52,069
的DD，在的另一端 

418
00:21:48,073 --> 00:21:55,075
在真实 与 DP 连接一起 

419
00:21:52,069 --> 00:21:59,152
的那该地址的长度，因此 

420
00:21:55,075 --> 00:22:01,122
的IPv4的情况下， 前四个字节 

421
00:22:00,052 --> 00:22:07,066
然后接受退货， 这 

422
00:22:02,022 --> 00:22:12,861
断开连接的文件描述符的 

423
00:22:07,066 --> 00:22:14,068
那么该孩子，他们 

424
00:22:13,059 --> 00:22:17,890
可以用它来读取和写入和

425
00:22:14,086 --> 00:22:20,158
与 他们的客户端交互，因此产生 

426
00:22:17,089 --> 00:22:22,180
要说它的工作原理孩子，然后 

427
00:22:21,058 --> 00:22:26,074
孩子关闭 它监听的描述符 

428
00:22:23,008 --> 00:22:29,062
然后调用回声例程 

429
00:22:26,074 --> 00:22:33,142
与你交流与互动 

430
00:22:30,034 --> 00:22:36,055
客户端和当回声例程 返回 

431
00:22:34,042 --> 00:22:39,076
客户端关闭连接这 

432
00:22:36,055 --> 00:22:43,090
描述，然后退出，所以这 

433
00:22:39,076 --> 00:22:45,150
关闭不是没有绝对必要 

434
00:22:43,009 --> 00:22:49,072
但我们这样做是为了 要小心好吗 

435
00:22:46,005 --> 00:22:52,054
现在的父母 ，这是很重要 

436
00:22:50,053 --> 00:22:54,055
关闭上述连接描述符，因为 

437
00:22:52,099 --> 00:22:55,147
它不会使用该连接 

438
00:22:54,073 --> 00:22:58,114
仅描述孩子 将使用 

439
00:22:56,047 --> 00:23:00,052
连接描述符所以为了 

440
00:22:59,014 --> 00:23:03,019
避免这种内存泄漏是非常 

441
00:23:00,097 --> 00:23:04,159
重要的是， 孩子要关闭此 

442
00:23:03,019 --> 00:23:07,108
描述没关系，因为记得这 

443
00:23:05,059 --> 00:23:11,092
服务器的无限循环运行 

444
00:23:08,008 --> 00:23:16,084
我 在理论上调解它永远不会是 

445
00:23:11,092 --> 00:23:21,187
永远不会结束好，然后和

446
00:23:16,084 --> 00:23:24,169
那么要避免 做，以避免内存 

447
00:23:22,087 --> 00:23:27,136
漏，我们必须在我们的处理程序，我们有 

448
00:23:25,069 --> 00:23:31,069
有一个生病的孩子处理程序，它会 

449
00:23:28,036 --> 00:23:36,070
将获得所有有孩子的

450
00:23:31,069 --> 00:23:38,110
终止好吧，让我们来看看一点点 

451
00:23:36,007 --> 00:23:42,103
更详细的如何如何 除 

452
00:23:39,001 --> 00:23:45,055
工作让你有一个客户端与客户端 

453
00:23:43,066 --> 00:23:46,108
文件描述符，然后你有一个 

454
00:23:45,064 --> 00:23:49,087
创建一个监听服务器

455
00:23:47,008 --> 00:23:51,049
描述让我们说，就是你知道 

456
00:23:49,087 --> 00:23:53,182
描述由小索引 

457
00:23:51,049 --> 00:23:59,074
整数让我们说， 索引为 

458
00:23:54,082 --> 00:24:01,071
三个描述数量为 三个，从而 

459
00:23:59,074 --> 00:24:04,159
服务器模块可以接受等待

460
00:24:01,809 --> 00:24:06,846
是连接请求客户端发出 

461
00:24:05,059 --> 00:24:08,142
使用连接的连接请求 

462
00:24:07,179 --> 00:24:09,420
呼叫

463
00:24:10,034 --> 00:24:19,058
还好服务器接受连接调用 

464
00:24:13,052 --> 00:24:20,144
然后它创建一个孩子，然后 

465
00:24:19,058 --> 00:24:23,081
孩子使用与客户端的交互

466
00:24:21,044 --> 00:24:25,079
这是连接的文件描述符

467
00:24:23,081 --> 00:24:28,103
从返回的接受，这样会 

468
00:24:25,079 --> 00:24:33,128
保存描述符排名第四的只是 

469
00:24:29,003 --> 00:24:36,005
一些不同的号码好开始

470
00:24:34,028 --> 00:24:38,084
执行模型中 ，我们有 四个这些 

471
00:24:36,023 --> 00:24:41,111
过程的服务器是我们有 

472
00:24:38,084 --> 00:24:43,151
在服务器处理器监听 

473
00:24:42,011 --> 00:24:48,086
连接后，其他请求一个

474
00:24:44,051 --> 00:24:50,114
从客户端 ，然后我们有多个 

475
00:24:48,086 --> 00:24:52,184
客户同时交互 

476
00:24:51,014 --> 00:24:58,088
有多个孩子互动 

477
00:24:53,084 --> 00:25:00,131
同时与多个客户端 没关系 

478
00:24:58,088 --> 00:25:02,117
因为每个这些的这些各 

479
00:25:01,031 --> 00:25:08,042
孩子的过程有没有共享 

480
00:25:03,017 --> 00:25:13,025
他们两家母公司之间 的状态 

481
00:25:08,042 --> 00:25:15,056
孩子继承有他们继承 

482
00:25:13,097 --> 00:25:19,178
描述符表让他们有他们都 

483
00:25:15,056 --> 00:25:21,122
有听FD的副本，并与 

484
00:25:20,078 --> 00:25:25,079
在连接监听描述符

485
00:25:22,022 --> 00:25:28,073
描述好吧，当我们以前看到的 

486
00:25:25,088 --> 00:25:30,152
父母必须关闭 其旗下的副本 

487
00:25:28,073 --> 00:25:32,129
连接文件描述符孩子

488
00:25:31,052 --> 00:25:37,124
应关闭监听描述符 

489
00:25:33,029 --> 00:25:41,048
但它是你知道 刚才是公正 

490
00:25:38,024 --> 00:25:43,031
因为它不需要没事 的时候 

491
00:25:41,048 --> 00:25:45,059
你那么这些实际上是非常简单的

492
00:25:43,031 --> 00:25:47,060
创造有只是一对夫妇 的 

493
00:25:45,059 --> 00:25:51,074
事情你必须要记住 你的时候 

494
00:25:47,006 --> 00:25:54,071
当你建立一个基于流程的服务器，以便 

495
00:25:51,074 --> 00:25:57,172
首先，我们与任何任何 进程 

496
00:25:55,025 --> 00:26:01,052
创建 它有 收获 的孩子 

497
00:25:58,072 --> 00:26:04,109
这些孩子被终止 

498
00:26:01,052 --> 00:26:06,080
避免此内存泄漏的父

499
00:26:05,009 --> 00:26:11,024
过程必须关闭其副本 

500
00:26:06,008 --> 00:26:14,009
连接文件描述符， 有一个 

501
00:26:11,024 --> 00:26:16,061
如果没有几个方面的原因其效果 

502
00:26:14,081 --> 00:26:18,103
它不仅会 创建一个内存泄漏 

503
00:26:16,061 --> 00:26:18,103
但

504
00:26:19,014 --> 00:26:24,039
与之相关的状态

505
00:26:21,066 --> 00:26:25,137
描述实际上将呆在身边

506
00:26:24,039 --> 00:26:30,054
永远，因为内核 不会 

507
00:26:26,037 --> 00:26:33,078
关闭连接，因此，我们看到 

508
00:26:30,054 --> 00:26:35,079
当我们看着在文件I / O现在这 

509
00:26:33,078 --> 00:26:38,477
是刚够本是同种 

510
00:26:35,079 --> 00:26:39,173
文件I / O，我们看着面前的 ，因此 

511
00:26:39,179 --> 00:26:44,760
内核维护每个引用计数

512
00:26:40,073 --> 00:26:46,101
每一个的开放套接字打完 

513
00:26:44,076 --> 00:26:48,084
叉现在有有两家有一个 

514
00:26:47,001 --> 00:26:52,160
父母和 正在访问 的 孩子 

515
00:26:48,084 --> 00:26:54,183
与相关的文件表

516
00:26:52,169 --> 00:26:58,020
连接文件描述符还好使 

517
00:26:55,083 --> 00:26:58,092
和连接不会被关闭，直到 

518
00:26:58,002 --> 00:27:02,051
对于所连接的引用计数 

519
00:26:59,073 --> 00:27:04,146
文件描述是 正确的零，因此 

520
00:27:02,051 --> 00:27:08,145
该文件表项不会被删除

521
00:27:05,046 --> 00:27:10,895
从内核直到直到只剩有

522
00:27:09,045 --> 00:27:15,132
在那里，直到有零个引用 

523
00:27:11,309 --> 00:27:20,540
它好了，所以家长和 孩子 都 

524
00:27:16,032 --> 00:27:22,631
要关闭该描述符 

525
00:27:20,054 --> 00:27:24,087
现在没事了有关过程的好事 

526
00:27:22,919 --> 00:27:26,730
基于服务器的是，他们做的工作

527
00:27:24,087 --> 00:27:29,124
对我们来说，我们 要求他们做对我们 

528
00:27:26,073 --> 00:27:31,101
希望他们来处理与 互动 

529
00:27:30,024 --> 00:27:34,041
多个客户端同时 或有 

530
00:27:32,001 --> 00:27:37,790
这种能力 有一个非常干净的 

531
00:27:34,041 --> 00:27:40,107
共享模式右所以有私人

532
00:27:37,799 --> 00:27:43,790
在 任何所有的 之间的地址空间

533
00:27:41,007 --> 00:27:46,023
孩子们和他们 分享 父 

534
00:27:43,079 --> 00:27:48,098
它们有不同的描述，但他们 

535
00:27:46,023 --> 00:27:51,060
分享他们的单独的副本 

536
00:27:48,809 --> 00:27:56,070
描述符表，但它们共享相同的

537
00:27:51,006 --> 00:27:59,165
打开文件 表好吗 

538
00:27:56,007 --> 00:28:01,085
而且在某种意义上，这是一个这么

539
00:27:59,759 --> 00:28:03,848
最简单的方式来创建 

540
00:28:01,085 --> 00:28:06,014
并发服务器，如果你能得到 

541
00:28:04,649 --> 00:28:08,702
获得如果你能不能分享度日 

542
00:28:06,779 --> 00:28:10,865
任何全局变量或共享地址

543
00:28:09,179 --> 00:28:13,186
空间，那么这是这 是必经之路 

544
00:28:11,639 --> 00:28:13,663
走

545
00:28:14,629 --> 00:28:19,640
缺点是 ，如果有 那 

546
00:28:16,919 --> 00:28:20,990
对于流程的额外开销，甚至 

547
00:28:19,739 --> 00:28:25,742
即使有这样的写入时复制的技巧，

548
00:28:21,629 --> 00:28:27,210
我们看到了分享分享礼服 

549
00:28:26,039 --> 00:28:32,045
家长和孩子之间的空间

550
00:28:27,021 --> 00:28:35,240
还是它仍然是不平凡的 开销 

551
00:28:32,099 --> 00:28:36,176
它是你必须 真正做了很多 

552
00:28:35,429 --> 00:28:38,580
工作的，如果你想共享数据 

553
00:28:36,869 --> 00:28:39,907
流程之间 ，就像我们说你 

554
00:28:38,058 --> 00:28:43,059
希望有某种 共享缓存 

555
00:28:40,249 --> 00:28:48,323
多进程之间你要么

556
00:28:43,059 --> 00:28:50,728
必须使用文件确定 在磁盘上 ， 或者 如果您 

557
00:28:48,989 --> 00:28:53,940
要共享内存，你必须使用 

558
00:28:51,259 --> 00:28:56,940
某种你必须 选择使用一些 

559
00:28:53,094 --> 00:28:58,158
一种内存映射， 或者你必须 

560
00:28:56,094 --> 00:29:01,433
使用什么是这些进程间 

561
00:28:59,058 --> 00:29:03,084
沟通机制，我们

562
00:29:02,279 --> 00:29:06,314
我们不是还没有谈到，但是 

563
00:29:03,084 --> 00:29:07,146
有有办法管可能是 

564
00:29:06,629 --> 00:29:11,717
那些你是 最熟悉 所以 

565
00:29:08,046 --> 00:29:16,715
管允许一个进程来发送数据

566
00:29:12,509 --> 00:29:19,523
到另一个进程 ，并有办法 

567
00:29:17,129 --> 00:29:23,227
过程，但之间共享存储器

568
00:29:19,649 --> 00:29:27,737
他们是他们是累赘，需要我 

569
00:29:24,109 --> 00:29:30,203
必须认真确定现在执行 

570
00:29:28,529 --> 00:29:35,588
第二种方法则是我们所说的 

571
00:29:31,049 --> 00:29:38,081
基于事件的 服务器这样的想法是在这里 

572
00:29:36,119 --> 00:29:44,340
服务器维护一组 

573
00:29:38,369 --> 00:29:46,445
活动的连接，因此它具有一个

574
00:29:44,034 --> 00:29:49,733
从连接文件描述符阵列

575
00:29:47,129 --> 00:29:51,134
不同的客户确定，然后将其 

576
00:29:50,039 --> 00:29:54,110
确定哪些那些 和它的也 

577
00:29:51,629 --> 00:29:57,668
具有听描述符，然后将其 

578
00:29:54,749 --> 00:30:01,766
确定哪个那些描述符的

579
00:29:58,019 --> 00:30:05,042
有挂起的输入，它决定 

580
00:30:01,919 --> 00:30:07,230
这个使用系统调用叫做选择

581
00:30:05,249 --> 00:30:08,880
或者等于有几种方法 

582
00:30:07,023 --> 00:30:12,056
确定此 

583
00:30:08,088 --> 00:30:14,112
但但基本上使用选择或 等于 

584
00:30:12,056 --> 00:30:20,151
你能 确定一组的 

585
00:30:15,012 --> 00:30:24,012
描述符已经挂起的输入，然后 

586
00:30:21,051 --> 00:30:25,137
此这一点，所以输入的到达在 

587
00:30:24,012 --> 00:30:28,050
一个描述符被称为因为某个事件 

588
00:30:26,037 --> 00:30:32,052
它改变了国家 作为一个描述符 

589
00:30:28,005 --> 00:30:34,017
好了，所以事件总是在事件 

590
00:30:32,052 --> 00:30:39,063
一般总是某种 状态 

591
00:30:34,062 --> 00:30:42,120
在这种情况下发生变化，所以当数据到达 

592
00:30:39,063 --> 00:30:47,070
在一个插座，这是一个改变 成 

593
00:30:43,002 --> 00:30:49,041
状态，这样有前无数据 

594
00:30:47,007 --> 00:30:56,016
事件的事件现在有数据 后， 

595
00:30:49,059 --> 00:30:58,086
该服务器可以读取，所以如果当 

596
00:30:56,079 --> 00:30:59,166
听完描述符输入，则 

597
00:30:58,086 --> 00:31:03,171
服务器调用accept接受 

598
00:31:00,066 --> 00:31:05,154
连接并为所有 ， 然后所有 

599
00:31:04,071 --> 00:31:08,118
连接描述符具有挂起 

600
00:31:06,054 --> 00:31:15,111
它输入服务那些从读 

601
00:31:09,018 --> 00:31:17,079
那些以某种顺序 现在没事 了 

602
00:31:16,011 --> 00:31:24,012
对于如何做到 这一点或描述细节

603
00:31:17,079 --> 00:31:24,147
在书中，但基本上我的意思是 

604
00:31:24,012 --> 00:31:29,031
概念上它非常简单，它是

605
00:31:25,047 --> 00:31:30,132
实际上棘手的 实施 ，但 

606
00:31:29,031 --> 00:31:32,112
想法是，有一些集的活跃 

607
00:31:31,032 --> 00:31:34,110
描述正确的有一些集

608
00:31:33,012 --> 00:31:39,018
描述连接描述符 

609
00:31:35,001 --> 00:31:44,064
您正在使用 正在使用权 

610
00:31:39,018 --> 00:31:47,024
现在进行互动与客户有 

611
00:31:44,073 --> 00:31:50,085
一些是无效的，所以如果描述符 

612
00:31:47,078 --> 00:31:53,130
描述被关闭那么它是没有 

613
00:31:50,085 --> 00:31:55,098
再主动权 ，然后有 

614
00:31:54,003 --> 00:31:57,024
其它的描述从未被 

615
00:31:55,098 --> 00:32:01,137
用，所以我们只是有这个数组 

616
00:31:57,051 --> 00:32:05,085
描述， 然后，然后我们记录 

617
00:32:02,037 --> 00:32:10,095
他们 你知道 的描述 

618
00:32:05,085 --> 00:32:13,085
为每个连接 用于 数 

619
00:32:10,095 --> 00:32:12,104
每个这些描述符 

620
00:32:16,056 --> 00:32:20,151
然后使用select或eople或一些 

621
00:32:19,032 --> 00:32:24,036
其他机制我们以某种方式确定 

622
00:32:21,051 --> 00:32:26,127
其中那些活性描述符的有 

623
00:32:24,036 --> 00:32:29,100
输入，然后我们每个服务的那些 

624
00:32:27,027 --> 00:32:33,099
在的情况下， 通过调用听FDE 

625
00:32:30,000 --> 00:32:36,063
除了在这些连接的情况下

626
00:32:33,099 --> 00:32:40,101
实际上描述这些都是本

627
00:32:36,063 --> 00:32:42,066
应CON FD不是客户端为空，但在 

628
00:32:41,019 --> 00:32:49,035
这些连接描述符的情况下

629
00:32:42,066 --> 00:32:51,117
我们我们从他们和读取数据 

630
00:32:49,035 --> 00:32:57,083
当我们，当我们读取每个数据 

631
00:32:52,017 --> 00:32:57,083
每一个描述符，我们做了一些工作好了， 

632
00:32:57,092 --> 00:33:02,097
所以数据到达一个描述符，然后 

633
00:33:01,065 --> 00:33:07,158
我们读到的数据， 然后 我们做了一些 

634
00:33:03,042 --> 00:33:10,136
这种工作也许在 的 情况下 

635
00:33:08,058 --> 00:33:14,154
我们呼应它的右后卫没关系回声服务器

636
00:33:11,036 --> 00:33:19,062
在Web服务器的情况下，我们如果

637
00:33:15,054 --> 00:33:21,099
该数据是HTTP 请求，我们可能会去 

638
00:33:19,062 --> 00:33:26,064
从磁盘这样的文件，并将其返回 

639
00:33:21,099 --> 00:33:28,104
不错，但但在任何情况下，我们，我们注意到 

640
00:33:26,082 --> 00:33:31,098
该描述符有一些数据，我们 

641
00:33:29,049 --> 00:33:35,103
读取数据，然后我们对此作出回应

642
00:33:31,098 --> 00:33:39,143
以某种方式确定，这样，响应者 

643
00:33:36,003 --> 00:33:43,098
多个响应是并发流

644
00:33:40,043 --> 00:33:46,050
没事 的 时候 在 我们正在 与 互动 

645
00:33:43,098 --> 00:33:47,169
该客户端，我们互动，我们是 

646
00:33:47,013 --> 00:33:52,016
创作的时候并发流

647
00:33:48,069 --> 00:33:53,160
每个每个客户端的并发流和

648
00:33:52,043 --> 00:33:56,082
我们服务这些客户端 

649
00:33:54,006 --> 00:33:58,038
同时确定，所以即使它是一个 

650
00:33:56,082 --> 00:34:01,089
我们 不使用 串行 程序的权利 

651
00:33:58,092 --> 00:34:04,167
叉或任何这是一个它只是一个C 

652
00:34:01,089 --> 00:34:06,093
程序简单的C程序 我们 

653
00:34:05,067 --> 00:34:10,576
写这样的方式 ，我们是 

654
00:34:07,029 --> 00:34:10,918
创建自己的并发流 

655
00:34:15,028 --> 00:34:19,064
所以有与任何任何方法

656
00:34:18,041 --> 00:34:21,116
还有的有优势， 

657
00:34:19,064 --> 00:34:23,108
缺点使的一大优势

658
00:34:22,016 --> 00:34:26,111
基于事件的服务器是，它只是 

659
00:34:24,008 --> 00:34:29,057
让相知 是一个过程与 

660
00:34:27,011 --> 00:34:30,083
圣。同一个地址空间的权利，使 

661
00:34:29,057 --> 00:34:33,086
这是很容易的，你可以 使用传统的 

662
00:34:30,083 --> 00:34:35,090
GDB调试器来逐步可以看到 

663
00:34:33,086 --> 00:34:38,090
一切你有机会获得一切 

664
00:34:35,009 --> 00:34:42,068
所以在这个意义上，它们是更简单

665
00:34:38,009 --> 00:34:45,026
调试了解 后再也没有 

666
00:34:43,049 --> 00:34:49,100
进程或线程控制开销等等 

667
00:34:46,007 --> 00:34:52,103
当我们的时候，我们为我们服务的特定 

668
00:34:50,000 --> 00:34:54,077
描述这是非常它的存在是非常 

669
00:34:53,003 --> 00:34:56,075
小的开销正确的，我们只是唯一的 

670
00:34:54,077 --> 00:35:01,090
开销排序确定

671
00:34:56,075 --> 00:35:06,086
该描述符输入可确定 

672
00:35:01,009 --> 00:35:09,038
所以 ，因为这是 高 

673
00:35:06,086 --> 00:35:11,171
性能Web服务器像神没有JS' 

674
00:35:10,019 --> 00:35:15,074
nginx的龙卷风都使用这个事件 

675
00:35:12,071 --> 00:35:18,164
如果你想获得基础的方法的情况下 

676
00:35:15,074 --> 00:35:21,142
每秒超过10,000 10,000请求 

677
00:35:19,064 --> 00:35:24,149
你必须去 像这样 的 东西 

678
00:35:22,042 --> 00:35:28,136
OK缺点是它的更难 

679
00:35:25,049 --> 00:35:34,108
更复杂，比代码了 

680
00:35:29,036 --> 00:35:39,044
其他处理器线程为基础的设计和

681
00:35:35,008 --> 00:35:41,096
它是非常困难这样的一个 

682
00:35:39,044 --> 00:35:43,103
的书面 的最难方面方面 

683
00:35:41,096 --> 00:35:44,159
基于事件的服务器， 你必须 

684
00:35:44,003 --> 00:35:49,076
找出 你多少工作会 

685
00:35:45,059 --> 00:35:51,062
不要在响应 事件 确定，所以让我 

686
00:35:49,076 --> 00:35:55,079
给你让我们说这个服务器是一个网络

687
00:35:51,062 --> 00:35:59,066
服务器和你 输入的它 的一个 

688
00:35:56,006 --> 00:36:01,103
您连接的文件描述符 

689
00:35:59,066 --> 00:36:05,084
简单到最简单的做法 会 

690
00:36:02,003 --> 00:36:10,007
是再假设读取整个 

691
00:36:05,084 --> 00:36:11,146
HTTP请求，而不是 不回 

692
00:36:10,007 --> 00:36:15,083
直到你读完整个请求

693
00:36:12,046 --> 00:36:18,080
好了，所以在这种情况下，该量 

694
00:36:15,083 --> 00:36:20,141
您在响应做事件工作

695
00:36:18,008 --> 00:36:22,043
非常粗粒有很多的 

696
00:36:21,041 --> 00:36:25,049
指令，因为我们马上要读 

697
00:36:23,015 --> 00:36:25,094
每一个每 一个线和 

698
00:36:25,049 --> 00:36:29,051
HD

699
00:36:25,094 --> 00:36:30,493
P请求 头，但它是如此这 

700
00:36:29,069 --> 00:36:35,090
当然，这是当然的例子

701
00:36:31,339 --> 00:36:37,430
屏幕这是 因为每一个 很 简单 

702
00:36:35,009 --> 00:36:38,015
时间你所连接的请求 

703
00:36:37,043 --> 00:36:41,054
描述你刚才读整你 

704
00:36:39,005 --> 00:36:43,048
刚看完整个HTTP请求和 

705
00:36:41,054 --> 00:36:48,113
然后发送一个响应 

706
00:36:43,093 --> 00:36:50,156
好了，有一个在另一方面 它 

707
00:36:49,013 --> 00:36:54,050
脆弱的，因为如果有什么客户端 

708
00:36:51,056 --> 00:36:56,063
行为不端，不发送整个 

709
00:36:54,005 --> 00:36:58,094
HTTP请求什么，如果它发出的一半

710
00:36:56,063 --> 00:37:01,079
这些请求，所以如果你在 做一个 

711
00:36:59,039 --> 00:37:04,040
设计一个基于 事件 的Web服务器，你 

712
00:37:01,079 --> 00:37:06,152
可能不希望这样做的权利 

713
00:37:04,004 --> 00:37:09,005
因为单个 客户 WIII是 

714
00:37:07,052 --> 00:37:11,093
回来的情况我们之前 

715
00:37:09,005 --> 00:37:14,009
在一个单一的行为不端的客户端可以 

716
00:37:11,093 --> 00:37:16,762
排序关闭 整个服务器，以便 

717
00:37:14,054 --> 00:37:21,125
你可能会说好了我要去 我 

718
00:37:17,599 --> 00:37:25,310
去我工作的单位，我在做 

719
00:37:22,025 --> 00:37:27,091
响应于请求将 读取 

720
00:37:25,031 --> 00:37:30,053
从请求单线 

721
00:37:27,091 --> 00:37:33,520
好了，所以我会读一个单一的 线 ，然后 

722
00:37:30,053 --> 00:37:36,342
我会，然后我会 没事 返回 所以每 

723
00:37:34,339 --> 00:37:39,388
所以现在我们在傍晚阅读

724
00:37:36,819 --> 00:37:42,650
单 线条有一次我读过 

725
00:37:39,829 --> 00:37:46,450
整个请求，那么别的话，我会送

726
00:37:42,065 --> 00:37:49,148
响应所以这是更好的权利，使一个 

727
00:37:46,045 --> 00:37:54,424
行为不端的客户端，如果它像发送 

728
00:37:50,048 --> 00:37:56,051
整个整个文本行，在即使 时间 

729
00:37:54,829 --> 00:37:57,858
它中途停止通过 我们仍然会 

730
00:37:56,051 --> 00:38:01,106
能够使 其他服务 的进展 

731
00:37:58,119 --> 00:38:04,270
其他客户端，这样的晶粒更细 

732
00:38:02,006 --> 00:38:07,010
接近它的更好它可能更多

733
00:38:04,027 --> 00:38:09,046
不是等待 整个健壮

734
00:38:07,046 --> 00:38:11,048
整体要求，但它仍然是脆弱的

735
00:38:09,046 --> 00:38:15,131
因为客户端可以 只将 

736
00:38:11,066 --> 00:38:18,128
部分行所以现在我们又回来了所以真的 

737
00:38:16,031 --> 00:38:23,310
写一个强壮的 事件的唯一途径

738
00:38:19,028 --> 00:38:26,033
基于web服务器是能够 处理 

739
00:38:23,589 --> 00:38:28,666
部分线路刚读时，有 

740
00:38:26,078 --> 00:38:30,119
在一个描述符上的可用数据

741
00:38:29,359 --> 00:38:33,680
你刚才读什么数据是可用 

742
00:38:31,019 --> 00:38:35,398
你还记得你读了多少，如果它是 

743
00:38:33,068 --> 00:38:36,727
不是一整行，你无论如何都 必须 

744
00:38:35,569 --> 00:38:37,580
请记住，你必须缓冲它你 

745
00:38:37,339 --> 00:38:39,050
MEM 

746
00:38:37,058 --> 00:38:41,153
布里特 所以现在它变得非常 

747
00:38:39,005 --> 00:38:44,054
复杂的权利，但就是你 

748
00:38:42,053 --> 00:38:46,100
这就是你为此付出的价格 

749
00:38:44,054 --> 00:38:50,060
这种开销排序低的更容易 

750
00:38:47,000 --> 00:38:52,016
调试那种类型的模型，然后的

751
00:38:50,006 --> 00:38:53,087
另一个缺点是，你不能 

752
00:38:52,016 --> 00:38:56,093
因为它是一个真正的顺序程序 

753
00:38:54,041 --> 00:38:59,045
右侧是一个C程序，你不能拿 

754
00:38:56,093 --> 00:39:00,137
利用多内核所以唯一的

755
00:38:59,045 --> 00:39:03,062
的方式来获得某种 更表现出来 

756
00:39:01,037 --> 00:39:06,061
的东西 ，基于事件的服务器 

757
00:39:03,062 --> 00:39:09,068
只是复制该服务器的副本 

758
00:39:06,061 --> 00:39:15,077
但你不能让一个单独的服务器 

759
00:39:09,068 --> 00:39:18,071
走得更快通过使用多核好吗 

760
00:39:15,077 --> 00:39:22,151
第三个方法是使用线程 

761
00:39:18,098 --> 00:39:25,103
创建这些并发流是非常

762
00:39:23,051 --> 00:39:28,133
类似的过程，但有 一些 

763
00:39:26,048 --> 00:39:34,130
重要的分歧，让我们来看看 

764
00:39:29,033 --> 00:39:36,119
首先在我们所说 的一个线程这样 的意思 

765
00:39:35,003 --> 00:39:40,088
让我们回到我打算让我们回去 

766
00:39:37,019 --> 00:39:43,042
在看看的传统观点 

767
00:39:41,015 --> 00:39:46,070
过程因此我们认为的一些过程 的 

768
00:39:43,042 --> 00:39:48,104
上下文的数据结构中

769
00:39:46,007 --> 00:39:51,035
内核OK数据，内核保持 

770
00:39:49,004 --> 00:39:55,010
有关此过程以及本 

771
00:39:51,098 --> 00:39:58,123
其中包含一个私有地址空间

772
00:39:55,001 --> 00:40:02,099
栈的代码和数据，然后将叠层

773
00:39:59,023 --> 00:40:05,120
没关系，然后作为 的，然后 部分 

774
00:40:03,008 --> 00:40:07,076
该进程上下文包括

775
00:40:06,002 --> 00:40:09,089
这与相关的上下文

776
00:40:07,076 --> 00:40:12,143
程序等 的寄存器状态 

777
00:40:10,007 --> 00:40:16,055
代码的程序计数器堆栈指针没关系 

778
00:40:13,043 --> 00:40:18,098
然后它包含内核上下文 

779
00:40:16,055 --> 00:40:21,149
这是 在内核信息 

780
00:40:18,098 --> 00:40:25,106
该内核需要实施 

781
00:40:22,049 --> 00:40:26,132
一个进程的这个想法好了，所有的 

782
00:40:26,006 --> 00:40:31,024
国家实际上是存储在 

783
00:40:27,032 --> 00:40:33,074
内核，但一些数据是是

784
00:40:31,024 --> 00:40:37,067
直接与节目 相关联 并 

785
00:40:33,074 --> 00:40:40,085
其他以外的其他数据的排序 

786
00:40:37,067 --> 00:40:42,118
支持数据内核需要到

787
00:40:40,085 --> 00:40:45,148
实施过程 

788
00:40:43,018 --> 00:40:48,055
好了，所以让我们 只取 这幅画和 

789
00:40:46,048 --> 00:40:54,124
我们只是刚刚搬东西 

790
00:40:48,055 --> 00:40:59,086
周围一 点点所以 我所做的就是 

791
00:40:55,024 --> 00:41:04,071
我已经采取 了堆栈关闭虚拟的 

792
00:40:59,086 --> 00:41:08,164
地址空间和形式的拉出来 

793
00:41:04,071 --> 00:41:11,134
连同 堆栈指针和所述 

794
00:41:09,064 --> 00:41:14,113
这与相关的上下文

795
00:41:12,034 --> 00:41:17,068
程序，以便数据寄存器的 

796
00:41:15,013 --> 00:41:19,018
条件码在堆栈指针 

797
00:41:17,068 --> 00:41:21,154
程序计数器可以的，我只是 

798
00:41:19,063 --> 00:41:24,066
更名为线程上下文 结巴 

799
00:41:22,054 --> 00:41:27,061
程序上下文，但它是相同的 

800
00:41:24,093 --> 00:41:28,171
这是同样的事情，然后我要去 

801
00:41:28,024 --> 00:41:33,025
调用此这件事的 

802
00:41:29,071 --> 00:41:34,105
这些堆叠的和此组合

803
00:41:33,034 --> 00:41:43,045
线程上下文，我会打电话给一个

804
00:41:35,005 --> 00:41:46,006
线程，然后一切遗体 

805
00:41:43,045 --> 00:41:48,091
同样 是我们 有我们还是有 我们的 

806
00:41:46,006 --> 00:41:54,079
代码和数据，我们 有内核 

807
00:41:48,091 --> 00:41:56,098
现在关键的 背景下 ，通过 做这样的 

808
00:41:54,079 --> 00:41:56,158
重构和刚搬东西 

809
00:41:56,098 --> 00:42:00,160
周围 

810
00:41:57,058 --> 00:42:04,060
现在我可以想像所以这个堆栈不 

811
00:42:01,006 --> 00:42:07,033
非常正确的它是如此有一个 

812
00:42:04,078 --> 00:42:08,086
还有的这个有堆栈空间 

813
00:42:07,087 --> 00:42:10,126
然后有数据 的一点点 在这里 

814
00:42:09,058 --> 00:42:13,066
在一些寄存器和一些形式

815
00:42:11,026 --> 00:42:17,104
要存储的东西，但是这是一个相当 

816
00:42:13,066 --> 00:42:22,069
现在 的 数据我到达时， 少量 

817
00:42:18,004 --> 00:42:24,010
像这样的演员现在我能我能 想到 的 

818
00:42:22,069 --> 00:42:27,160
大约有是多线程 

819
00:42:24,001 --> 00:42:31,006
用同样的过程，如果我如果相关

820
00:42:28,006 --> 00:42:33,010
我只是不停组不同的数据线 

821
00:42:31,015 --> 00:42:36,082
上下文为每个线程，然后

822
00:42:34,000 --> 00:42:40,066
所述堆叠的 私人的单独部分 

823
00:42:36,082 --> 00:42:44,107
一个与该线程这样关联

824
00:42:40,066 --> 00:42:48,109
现在每个线程共享相同的代码和 

825
00:42:45,007 --> 00:42:51,070
数据相同的虚拟地址空间具有 

826
00:42:49,009 --> 00:42:54,060
相同的内核方面 还好 相同 

827
00:42:51,007 --> 00:42:53,016
I / O结构 

828
00:42:54,079 --> 00:43:03,092
但现在它有它有自己独立的 

829
00:42:59,006 --> 00:43:05,045
个别堆好了，所以声音地方 

830
00:43:03,092 --> 00:43:07,124
你会存储在变量的东西 

831
00:43:05,099 --> 00:43:10,100
堆栈现在是将私人 

832
00:43:08,024 --> 00:43:13,031
那种独立的，它有自己的 

833
00:43:11,000 --> 00:43:16,052
它自己的程序集抗衡其自身 

834
00:43:13,094 --> 00:43:23,096
堆栈指针自己的寄存器的

835
00:43:16,052 --> 00:43:25,073
和条件码，然后将一个 

836
00:43:24,014 --> 00:43:27,077
现在不同的是，每个线程 

837
00:43:25,073 --> 00:43:29,117
而不是 他们仍有 一个过程 

838
00:43:27,077 --> 00:43:32,096
ID为这个过程的尖端部 

839
00:43:30,017 --> 00:43:35,042
内核上下文，但每个线程的 

840
00:43:32,096 --> 00:43:42,191
现在都有自己的线程ID 作为其一部分 

841
00:43:35,042 --> 00:43:45,065
还好线程上下文所以现在的内核 

842
00:43:43,091 --> 00:43:47,093
可以只是把每一种作为单独的 

843
00:43:45,065 --> 00:43:49,130
流动的权利有一个独立的所以它是 

844
00:43:47,093 --> 00:43:52,130
就像这个过程现在内核 可以 

845
00:43:50,003 --> 00:43:56,006
记得那里的每个线程都有 

846
00:43:53,003 --> 00:43:58,079
自己的程序计数器和 但他们 

847
00:43:56,006 --> 00:44:00,101
运行的代码出同 该涂层 的 

848
00:43:59,006 --> 00:44:03,011
在在相同的代码部分

849
00:44:01,055 --> 00:44:06,080
虚拟地址空间，因此共享 

850
00:44:03,011 --> 00:44:08,099
代码共享数据，但他们有自己的

851
00:44:06,008 --> 00:44:10,091
自己的程序计数器，以便可以在 

852
00:44:08,099 --> 00:44:13,136
内核可提供可创建各 

853
00:44:11,063 --> 00:44:16,067
这些线程作为作为一个单独的流

854
00:44:14,036 --> 00:44:18,119
控制它然后调度就像 

855
00:44:16,067 --> 00:44:21,074
它的过程中或以类似的方式 

856
00:44:19,019 --> 00:44:26,033
它是一个 过程，但不同的 

857
00:44:22,037 --> 00:44:28,070
是什么原因， 对于原因

858
00:44:26,033 --> 00:44:31,040
摆在首位的线程是当 

859
00:44:28,007 --> 00:44:33,059
上校想从触点开关 

860
00:44:31,004 --> 00:44:37,013
一个线程到另一个有没有说 

861
00:44:34,022 --> 00:44:39,110
有要保存太多的信息 

862
00:44:38,003 --> 00:44:42,077
并恢复它的只是少量 

863
00:44:40,001 --> 00:44:45,089
数据，所以内核必须保存这个 

864
00:44:43,004 --> 00:44:48,017
在一些数据数据线程一个上下文 

865
00:44:45,098 --> 00:44:49,184
结构的一些方式， 然后还原 

866
00:44:48,017 --> 00:44:52,073
上下文线索太多，但我们谈论 

867
00:44:50,084 --> 00:44:53,153
约一个非常低的开销样的 

868
00:44:52,073 --> 00:44:56,078
操作，但它并没有乱 

869
00:44:54,053 --> 00:44:59,069
周围的页表的虚拟地址

870
00:44:57,023 --> 00:45:02,029
空间或任何其他的方法的

871
00:44:59,069 --> 00:45:01,075
上下文

872
00:45:05,046 --> 00:45:11,074
所以这样线程是运气有点像 

873
00:45:09,004 --> 00:45:13,033
预言，但他们在是不同的 

874
00:45:11,074 --> 00:45:17,095
某种意义上说它们共享相同的虚拟

875
00:45:13,033 --> 00:45:21,124
地址空间和不同的预言 

876
00:45:17,095 --> 00:45:24,163
其由叉它创建创建

877
00:45:22,024 --> 00:45:28,060
严格的工艺层次线程

878
00:45:25,063 --> 00:45:30,160
只是池，你能想到的线程作为 

879
00:45:28,006 --> 00:45:36,034
访问并发流的池

880
00:45:31,006 --> 00:45:38,014
相同的代码和数据，然后将 

881
00:45:36,088 --> 00:45:39,187
当前的内核负责 

882
00:45:38,068 --> 00:45:42,085
调度 的方式那些流动和 

883
00:45:40,087 --> 00:45:46,168
所以每个流得到得到时间上的

884
00:45:42,085 --> 00:45:50,160
处理器那么像很像 

885
00:45:47,068 --> 00:45:54,154
过程很像并发进程 

886
00:45:51,006 --> 00:45:56,080
我们说两个线程可以并行 ，如果 

887
00:45:55,054 --> 00:45:58,117
它们的流 在时间上 重叠 ，否则 

888
00:45:57,034 --> 00:46:01,063
他们是 连续的，所以这是确切的 

889
00:45:59,017 --> 00:46:03,052
同样的例子，我发现你的时候， 

890
00:46:01,063 --> 00:46:04,162
看着流程，以便在这里你有 

891
00:46:03,052 --> 00:46:07,075
而不是三个过程，我们 有 三个 

892
00:46:05,062 --> 00:46:09,123
线程运行它在同 

893
00:46:07,075 --> 00:46:09,123
处理

894
00:46:10,003 --> 00:46:16,039
一个线程运行一点点， 然后 

895
00:46:13,012 --> 00:46:20,026
内核决定换出来，

896
00:46:16,066 --> 00:46:21,127
和运行线程B这样的话线程B运行

897
00:46:20,026 --> 00:46:24,031
一点点，然后内核 

898
00:46:22,027 --> 00:46:27,070
决定给线程看到一些时间，所以

899
00:46:24,076 --> 00:46:31,105
它可以节省线程这些接触 

900
00:46:27,007 --> 00:46:35,098
恢复线程看到上下文和套 

901
00:46:32,005 --> 00:46:39,094
PC到PC值和线程 

902
00:46:36,061 --> 00:46:41,119
种子上下文等C同时运行，然后将 

903
00:46:39,094 --> 00:46:46,173
内核决定再给予一些时间

904
00:46:42,019 --> 00:46:50,083
所以再运行更多一些 ，是因为 

905
00:46:47,073 --> 00:46:54,073
线程和B在时间上重叠 他们 

906
00:46:50,083 --> 00:46:56,086
同时运行B和 C不 

907
00:46:54,073 --> 00:46:58,150
在时间上重叠，使他们他们现在 

908
00:46:56,086 --> 00:47:03,123
同时运行，但A和C 

909
00:46:59,005 --> 00:47:07,029
同时，因为他们在时间上重叠

910
00:47:04,023 --> 00:47:09,872
所以你可以，你也可以选择

911
00:47:07,074 --> 00:47:11,091
如果有多个多当然 然后 

912
00:47:10,079 --> 00:47:13,680
多重威胁的威胁可以在每次运行

913
00:47:11,091 --> 00:47:16,124
核心，那么你可以 有真正的 

914
00:47:13,068 --> 00:47:16,124
并行好吗 

915
00:47:20,051 --> 00:47:28,107
好了，所以就像我说的线程和

916
00:47:24,051 --> 00:47:31,900
过程是类似的想法，但在 

917
00:47:29,007 --> 00:47:35,025
这个意义上，他们自己每个阶段 

918
00:47:32,359 --> 00:47:38,240
忏悔线程和进程 

919
00:47:35,025 --> 00:47:41,384
对应于某种逻辑流 

920
00:47:38,024 --> 00:47:44,115
他们可以与同时运行 

921
00:47:41,609 --> 00:47:49,230
其它流，并且每个被调度和 

922
00:47:45,015 --> 00:47:50,097
背景内核切换，但 

923
00:47:49,023 --> 00:47:53,082
他们是不同的，因为线程共享 

924
00:47:50,097 --> 00:47:58,104
所有的代码和数据，除了当地

925
00:47:53,082 --> 00:48:00,170
堆栈而事实上那些地方堆 

926
00:47:59,004 --> 00:48:05,573
虽然他们每个线程都有自己的 

927
00:48:01,007 --> 00:48:08,082
它实际上只是 共享同一组 

928
00:48:05,609 --> 00:48:10,658
因此它是真正的同一部分 

929
00:48:09,045 --> 00:48:13,046
虚拟地址空间它只是 

930
00:48:11,099 --> 00:48:16,260
每个每个线程分配其自己 

931
00:48:13,055 --> 00:48:19,354
该堆栈的一部分， 好了，所以即使 

932
00:48:16,026 --> 00:48:21,114
线程有自己单独的栈 

933
00:48:19,849 --> 00:48:24,720
因为它是在同一个虚拟的一部分 

934
00:48:22,014 --> 00:48:27,015
地址空间中的线程可以访问 

935
00:48:24,072 --> 00:48:28,128
堆栈中的任何其他线程的，如果它是和 

936
00:48:27,015 --> 00:48:34,020
这不是做一件好事 ，但它的 

937
00:48:29,028 --> 00:48:36,317
可能好了，所以预言不共享

938
00:48:34,002 --> 00:48:37,080
任何国家的权利，他们做了他们 

939
00:48:36,569 --> 00:48:41,190
拥有自己的私人地址空间 

940
00:48:37,098 --> 00:48:46,131
和线程比更便宜 

941
00:48:41,019 --> 00:48:49,020
预言了它的便宜 创建 

942
00:48:47,031 --> 00:48:50,106
他们的主要理由是 ，有 

943
00:48:49,002 --> 00:48:53,061
与相关短短不到上下文 

944
00:48:51,006 --> 00:48:57,093
线程比有一个过程，因此 

945
00:48:53,079 --> 00:49:00,156
在我们的 系统中 ，当我们衡量了一堆 

946
00:48:57,093 --> 00:49:02,166
我们只是创造和等待一堆 

947
00:49:01,056 --> 00:49:04,835
创作过程中 的wakeboard过程 

948
00:49:03,066 --> 00:49:07,152
一遍又一遍， 然后测量 

949
00:49:05,339 --> 00:49:11,190
时间真可谓是大约 二十 

950
00:49:08,052 --> 00:49:13,121
一千 周期创建和谋取 

951
00:49:11,019 --> 00:49:16,048
过程近万周期

952
00:49:13,589 --> 00:49:20,750
创建并获得一个线程 

953
00:49:16,048 --> 00:49:22,114
这样内核提供线程

954
00:49:20,075 --> 00:49:25,082
我们使用称为 P螺纹 接口 

955
00:49:23,014 --> 00:49:32,060
POSIX线程，所以这是一个相当新的 

956
00:49:26,045 --> 00:49:36,128
标准的，所有所有的Linux UNIX系统

957
00:49:32,006 --> 00:49:45,008
和Windows的Macintosh 所以每次这是一个 

958
00:49:37,028 --> 00:49:47,111
排序为标准的POSIX标准 

959
00:49:45,062 --> 00:49:50,081
操作线程，这样就可以做 

960
00:49:48,011 --> 00:49:52,094
例如 创建和收获线程等等 

961
00:49:50,081 --> 00:49:55,097
有这有点有点像

962
00:49:52,094 --> 00:50:00,100
叉，这是有点像 ，但重量 

963
00:49:55,097 --> 00:50:00,100
不是不太，因为它不会产生 

964
00:50:01,021 --> 00:50:05,120
还有的没有相关的层次

965
00:50:03,074 --> 00:50:09,151
这些，你可以，你可以只喜欢 

966
00:50:06,002 --> 00:50:13,100
取得竞标你可以有一个功能 ，我 

967
00:50:10,051 --> 00:50:15,107
让你的线程ID，你可以杀 

968
00:50:14,018 --> 00:50:19,091
线程使一个线程可以杀死另一 

969
00:50:16,007 --> 00:50:24,011
Thread线程有有一个 

970
00:50:19,091 --> 00:50:25,094
函数退出线程击败的 

971
00:50:24,011 --> 00:50:30,032
正常退出系统调用终止所有 

972
00:50:26,021 --> 00:50:31,067
螺纹和回报是类似与P 

973
00:50:30,032 --> 00:50:33,044
在这个意义上线程退出，只是

974
00:50:31,067 --> 00:50:36,101
终止当前线程的线程

975
00:50:33,044 --> 00:50:39,068
即调用它，然后有办法 

976
00:50:37,001 --> 00:50:42,002
访问 共享同步的访问 

977
00:50:39,068 --> 00:50:44,167
变量我们来看看，其上 

978
00:50:42,002 --> 00:50:45,067
周四更详细 

979
00:50:46,052 --> 00:50:53,141
好了，所以这里的并行线程的hello world 

980
00:50:49,079 --> 00:50:56,177
计划你知道在我们的书 你的 K 至 

981
00:50:54,041 --> 00:50:59,126
参见C参考手册， 非常 

982
00:50:57,077 --> 00:51:00,086
首先第一 件事情是它 

983
00:51:00,026 --> 00:51:04,043
是它表明你如何 写 

984
00:51:01,067 --> 00:51:06,074
可能最简单的C程序调用，所以 

985
00:51:04,043 --> 00:51:08,048
著名的Hello World 程序，使 

986
00:51:06,074 --> 00:51:11,093
追溯到一路像1978年的时候 

987
00:51:08,093 --> 00:51:14,126
K 的我们的图书是首次编写但 

988
00:51:11,093 --> 00:51:17,156
这抓住了上，每当我们 

989
00:51:15,026 --> 00:51:20,069
就像学习一 门新语言或者我们学习 

990
00:51:18,056 --> 00:51:22,115
新的概念，我们总是 写问候 

991
00:51:20,069 --> 00:51:25,072
对于这一概念的世界节目 ，因此 

992
00:51:23,015 --> 00:51:28,082
你好线程世界节目，这是 

993
00:51:25,099 --> 00:51:29,198
这是最简单的线程程序

994
00:51:28,082 --> 00:51:32,168
我能想到的，所以我把它叫做打招呼 

995
00:51:30,098 --> 00:51:39,107
线程使这个世界计划

996
00:51:33,068 --> 00:51:42,155
程序定义了一个函数，以便 由法院 

997
00:51:40,007 --> 00:51:47,030
在POSIX 线程实际 执行 

998
00:51:43,055 --> 00:51:50,081
通过在功能执行代码 

999
00:51:47,003 --> 00:51:55,091
所谓的线程 机制 好和POSIX 

1000
00:51:50,081 --> 00:51:57,104
规定此线程程序需要 

1001
00:51:56,018 --> 00:52:00,071
通用指针作为参数

1002
00:51:58,004 --> 00:52:03,041
可选的通用指针并返回

1003
00:52:00,071 --> 00:52:04,094
通用指针好了， 任何时候你 

1004
00:52:03,041 --> 00:52:08,066
想什么传递给一个线程你 

1005
00:52:04,094 --> 00:52:10,187
不知怎么收拾 所有的 数据 

1006
00:52:08,066 --> 00:52:15,092
成一个对象，那么你可以采取 

1007
00:52:11,087 --> 00:52:18,133
地址了， 但 你 可以看到， 

1008
00:52:15,092 --> 00:52:18,133
这是极其通用 

1009
00:52:20,055 --> 00:52:29,079
所以我们的Hello World 程序创建一个 

1010
00:52:25,017 --> 00:52:31,071
线程通过调用并行线程创建和我们

1011
00:52:29,079 --> 00:52:34,125
说的不是一个孩子，我们称此为 

1012
00:52:31,071 --> 00:52:37,079
纯 线程好，这样有没有 

1013
00:52:35,025 --> 00:52:40,032
亲子关系的任何任何

1014
00:52:37,079 --> 00:52:44,079
线程可以线程可以收获其他

1015
00:52:40,095 --> 00:52:46,095
线程是否他们创建的那些

1016
00:52:44,079 --> 00:52:49,134
螺纹或不行，所以你不必 

1017
00:52:46,095 --> 00:52:55,140
严格的父子层次结构

1018
00:52:50,034 --> 00:52:58,089
皮特创建创建一个线程 

1019
00:52:56,004 --> 00:53:02,079
执行此线程程序

1020
00:52:58,089 --> 00:53:05,103
第三个参数和返回线程

1021
00:53:03,015 --> 00:53:08,040
在地址线的想法， 

1022
00:53:06,003 --> 00:53:15,036
整数指向由第一 

1023
00:53:08,004 --> 00:53:16,089
参数 中的第二个参数被 设置 

1024
00:53:15,036 --> 00:53:20,133
有有办法来设置属性 

1025
00:53:17,025 --> 00:53:23,031
线程， 但超出的范围 

1026
00:53:21,033 --> 00:53:28,110
这门课将永远只是有 

1027
00:53:23,085 --> 00:53:30,156
那些没有然后，这个第四 

1028
00:53:29,001 --> 00:53:32,097
参数是可选的说法， 

1029
00:53:31,056 --> 00:53:35,103
你想传递给你的线程程序

1030
00:53:33,006 --> 00:53:39,012
好了 ，所以在这种情况下，我们说的呼叫 

1031
00:53:36,003 --> 00:53:44,007
就是这样就是所谓的线程程序

1032
00:53:39,012 --> 00:53:46,017
不带任何参数 ，然后我们的线程

1033
00:53:44,043 --> 00:53:49,047
线程程序只是打印出打招呼 

1034
00:53:46,062 --> 00:53:50,154
世界，然后返回 在这种情况下， 

1035
00:53:49,083 --> 00:53:52,182
所以它返回它不返回任何东西 

1036
00:53:51,054 --> 00:53:57,080
空 但如果我们想 回 

1037
00:53:53,082 --> 00:53:59,139
东西向的调用程序 

1038
00:53:57,008 --> 00:54:04,082
我们可以 返回的东西在 

1039
00:54:00,039 --> 00:54:05,054
指针一些通用对象好吗 

1040
00:54:10,039 --> 00:54:13,978
好了，所以线程ID线程 

1041
00:54:12,074 --> 00:54:15,167
属性是空的 线程 

1042
00:54:14,329 --> 00:54:23,060
常规的螺纹参数是无效 

1043
00:54:16,067 --> 00:54:24,128
星T和返回值是无效 

1044
00:54:23,006 --> 00:54:29,048
在指针的指针加倍，这样

1045
00:54:25,028 --> 00:54:30,080
要返回还好没事 

1046
00:54:29,048 --> 00:54:33,127
所以让我们来看看我们什么时候会发生什么 

1047
00:54:30,008 --> 00:54:37,076
执行的hello world 所以主线程 

1048
00:54:34,027 --> 00:54:42,098
运行了一会儿，然后调用 

1049
00:54:38,048 --> 00:54:44,102
并行线程创建它创建了纯 

1050
00:54:42,098 --> 00:54:46,193
螺纹现在是顺流 

1051
00:54:45,002 --> 00:54:51,065
这一度的并行线程运行一次 

1052
00:54:47,093 --> 00:54:52,124
创造收益，然后我们运行两个 

1053
00:54:51,065 --> 00:54:56,014
并发流或运行主

1054
00:54:53,024 --> 00:54:58,653
线程，我们正在 运行的同行 

1055
00:54:56,599 --> 00:54:58,626
线

1056
00:55:01,046 --> 00:55:06,074
所以在这种情况下，我们的Hello World 

1057
00:55:03,029 --> 00:55:11,066
在码头等待的线程都完成 

1058
00:55:06,074 --> 00:55:14,953
通过调用并行线程加入了对等网络 

1059
00:55:11,066 --> 00:55:19,515
调用 它的打印输出后的线程

1060
00:55:15,619 --> 00:55:24,220
返回 知道这会终止线程 

1061
00:55:20,109 --> 00:55:28,510
在这一点上在P螺纹联接返回 

1062
00:55:24,022 --> 00:55:28,051
而主线程继续

1063
00:55:30,006 --> 00:55:37,035
好了，所以用它利用 这些创造这个 

1064
00:55:35,088 --> 00:55:39,134
创建功能，我们会怎么写 

1065
00:55:37,089 --> 00:55:41,097
基于线程的并发回显服务器和 

1066
00:55:40,034 --> 00:55:49,038
再次是非常相似的方式，我们 

1067
00:55:42,069 --> 00:55:51,108
与基于过程的设计，这样做的 

1068
00:55:49,074 --> 00:55:53,097
我们呼吁我们获得了一个监听

1069
00:55:52,008 --> 00:55:58,013
通过拨打我们的哦硕描述符和 

1070
00:55:53,097 --> 00:56:03,099
听FD功能，就像之前 

1071
00:55:58,013 --> 00:56:08,052
那么这个无限循环的服务器里面我们

1072
00:56:03,099 --> 00:56:11,138
我们得到了我们的大小获得大小 

1073
00:56:08,052 --> 00:56:15,111
客户端加法器结构， 以便其是 

1074
00:56:12,038 --> 00:56:20,067
这将是一个足够大 

1075
00:56:16,011 --> 00:56:23,028
适合任何地址，然后我们我们的malloc

1076
00:56:20,067 --> 00:56:25,145
为所连接的文件描述符空间

1077
00:56:23,028 --> 00:56:29,109
所以我们正在做的一个整数大小 

1078
00:56:26,045 --> 00:56:32,097
该动态存储的部分

1079
00:56:30,009 --> 00:56:35,046
将原本连接描述符

1080
00:56:32,097 --> 00:56:37,101
我们要得到 接受回来 

1081
00:56:35,046 --> 00:56:40,047
我们要这其实是真的 

1082
00:56:38,037 --> 00:56:45,039
重要的是避免讨厌的种族 

1083
00:56:40,056 --> 00:56:49,065
条件我会在第二展示你这么

1084
00:56:45,039 --> 00:56:51,048
现在我们所说的我们的听音接受 

1085
00:56:49,065 --> 00:56:53,124
描述和客户端地址和客户端 

1086
00:56:51,048 --> 00:56:57,140
长像以前一样 接受 

1087
00:56:54,024 --> 00:57:01,031
返回连接描述符 和 

1088
00:56:58,004 --> 00:57:05,028
那么我们这个解引用连接 

1089
00:57:01,094 --> 00:57:06,180
描述指针等和商店 

1090
00:57:05,064 --> 00:57:10,155
除了在这返回的值

1091
00:57:07,008 --> 00:57:14,097
这个位置在堆中 ，然后我们 

1092
00:57:11,055 --> 00:57:16,134
叫牛逼线程通过给创建它的 

1093
00:57:15,069 --> 00:57:19,134
我们的线程程序 的名称 ，在这种 

1094
00:57:17,034 --> 00:57:23,115
情况是只是简单的功能 我们 

1095
00:57:20,034 --> 00:57:26,037
在我们的程序中调用线程定义

1096
00:57:24,015 --> 00:57:28,022
指针到所连接的文件 

1097
00:57:26,037 --> 00:57:28,085
描述

1098
00:57:29,021 --> 00:57:32,093
还好 我们的客户，我们的客户 现在 

1099
00:57:31,007 --> 00:57:37,052
其中我们的线程程序，我们将使用 

1100
00:57:32,093 --> 00:57:40,175
与客户 互动 还好使 

1101
00:57:37,052 --> 00:57:42,137
线程程序取消引用参数

1102
00:57:41,075 --> 00:57:45,161
记住 的是一个指针指向一个连接 

1103
00:57:43,037 --> 00:57:49,091
文件描述符所以三维引用 的是 

1104
00:57:46,061 --> 00:57:54,092
指针，以获得获得实际的 

1105
00:57:49,091 --> 00:57:59,108
整数连接描述符，然后将其 

1106
00:57:54,092 --> 00:58:02,153
分离线程 所以默认 

1107
00:58:00,008 --> 00:58:06,044
线程的线程的线程运行 

1108
00:58:03,053 --> 00:58:08,069
独立 于附模式，以便它们可以 

1109
00:58:06,044 --> 00:58:10,052
是你知道他们可以 通过其他被连接 

1110
00:58:08,069 --> 00:58:18,071
线程，它们可以被其他被杀死

1111
00:58:10,052 --> 00:58:19,145
线程但默认 情况下它是类似的，当 

1112
00:58:18,089 --> 00:58:25,157
当线程排序的运行

1113
00:58:20,045 --> 00:58:29,054
独立的模式，你可以或分离 

1114
00:58:26,057 --> 00:58:31,151
模式，则他们时，他们当他们死 

1115
00:58:30,035 --> 00:58:35,074
他们必须通过加入来收获 

1116
00:58:32,051 --> 00:58:40,094
函数来获取这些资源 

1117
00:58:35,074 --> 00:58:42,086
但是，如果我们去除一个线程 话，就不能 

1118
00:58:40,094 --> 00:58:43,100
可它不能被任何线程加入，但 

1119
00:58:42,086 --> 00:58:49,115
当它死的内核

1120
00:58:44,000 --> 00:58:52,025
自动恢复的资源

1121
00:58:50,015 --> 00:58:53,114
与线程，以便在此相关

1122
00:58:52,025 --> 00:58:56,059
情况下，我们将只是这个分离 

1123
00:58:54,014 --> 00:59:00,085
螺纹所以我们不担心 

1124
00:58:56,059 --> 00:59:03,106
收获它，当它完成它什么时候 

1125
00:59:00,085 --> 00:59:05,099
然后我们要 释放此本 

1126
00:59:04,006 --> 00:59:07,040
内存是的malloc 

1127
00:59:05,099 --> 00:59:08,168
所以这是非常重要的，我们必须 释放 

1128
00:59:07,004 --> 00:59:12,005
该内存由 该 为的malloc 

1129
00:59:09,068 --> 00:59:16,163
为了避免存储器主线程

1130
00:59:12,041 --> 00:59:19,055
漏，然后我们，我们调用回声

1131
00:59:17,063 --> 00:59:20,162
功能，所以我们跟 的 互动 

1132
00:59:19,055 --> 00:59:24,056
回声客户，直到客户的回声

1133
00:59:21,062 --> 00:59:27,089
完成，然后我们关闭这个 

1134
00:59:24,056 --> 00:59:30,085
再次描述符避免潜在的 

1135
00:59:27,089 --> 00:59:29,185
致命的内存泄漏 

1136
00:59:34,083 --> 00:59:39,088
所以这种基于线程的执行模型 是 

1137
00:59:37,066 --> 00:59:42,118
非常相似 的执行模型 

1138
00:59:39,088 --> 00:59:45,127
我们与预言看到，所以我们有一个 

1139
00:59:43,018 --> 00:59:48,067
域线程的列表在 听 

1140
00:59:46,027 --> 00:59:51,096
连接请求我们等待

1141
00:59:48,067 --> 00:59:55,075
对于通过接受和连接请求

1142
00:59:51,096 --> 00:59:57,151
然后我们对每一个客户，我们有 一个 

1143
00:59:56,047 --> 01:00:01,069
以该相互作用对螺纹 

1144
00:59:58,051 --> 01:00:03,073
使用所连接的客户机的描述符

1145
01:00:01,069 --> 01:00:08,074
这是在我们创建的经过时 

1146
01:00:03,073 --> 01:00:11,116
线程，然后每个线程都有自己的

1147
01:00:09,019 --> 01:00:14,116
因为它有它自己的堆栈它有它 

1148
01:00:12,016 --> 01:00:18,103
它的 局部变量独立的空间

1149
01:00:15,016 --> 01:00:21,025
这 是真正的强大的东西 

1150
01:00:19,003 --> 01:00:25,090
有关线程现在我们可以用这些 

1151
01:00:21,025 --> 01:00:28,096
的东西，他们通过声明这些地方 

1152
01:00:25,009 --> 01:00:30,031
变量，我们可以，我们可以创建线程

1153
01:00:28,096 --> 01:00:34,098
不会互相影响 和 

1154
01:00:31,012 --> 01:00:35,016
不会，也独立运行是 

1155
01:00:36,097 --> 01:00:40,152
周围的动作 总是想着 

1156
01:00:41,079 --> 01:00:44,175
我想 是的，问题是有没有 

1157
01:00:44,058 --> 01:00:49,095
任何时候你不想跑

1158
01:00:45,075 --> 01:00:51,111
分离，所以当你 运行 哎呀你现金 

1159
01:00:49,095 --> 01:00:54,123
放弃权力杀死其他 

1160
01:00:52,011 --> 01:00:57,033
螺纹，所以我不知道这只是 

1161
01:00:55,023 --> 01:01:00,054
很难很难拿出 

1162
01:00:57,033 --> 01:01:02,115
很好的例子，但 权 ，但如果你想 

1163
01:01:00,054 --> 01:01:05,111
的能力，才能够 终止 

1164
01:01:03,015 --> 01:01:08,043
你也许知道，如果你有其他线程

1165
01:01:06,011 --> 01:01:13,013
也许，如果你，如果你正在运行一个游泳池

1166
01:01:08,043 --> 01:01:12,131
像工作线程，并在某些时候 

1167
01:01:14,057 --> 01:01:20,073
在某些时候，如果我说我想 你 

1168
01:01:18,051 --> 01:01:21,123
可以想象这里假设一个场景 

1169
01:01:20,073 --> 01:01:23,076
您正在运行的工作线程池 

1170
01:01:22,023 --> 01:01:26,028
你给他们的所有作业要做的第一件

1171
01:01:23,076 --> 01:01:27,099
一个 完成你把结果 

1172
01:01:26,028 --> 01:01:29,115
你不需要从结果 

1173
01:01:27,099 --> 01:01:32,198
其他线程，这样就可能你 可能 

1174
01:01:30,015 --> 01:01:36,108
只是想杀死那些线程，但它 

1175
01:01:33,098 --> 01:01:40,100
是的，很难， 很难拿出 

1176
01:01:37,008 --> 01:01:40,100
一个真正令人信服的理由 

1177
01:01:46,022 --> 01:01:49,065
好了，有 思考 的几件事 

1178
01:01:48,003 --> 01:01:51,021
约当你你写的时候 

1179
01:01:49,065 --> 01:01:53,097
基于线程的服务器，所以第一个是 

1180
01:01:51,048 --> 01:01:57,677
那还需要运行分离，以避免 

1181
01:01:53,097 --> 01:01:58,194
潜在的内存泄漏对不起，我

1182
01:01:58,109 --> 01:02:03,000
忘记这个词所以它的相对 

1183
01:01:59,094 --> 01:02:04,095
超然是可连接，因此可连接 

1184
01:02:03,000 --> 01:02:08,058
像一个提线可以收获和 

1185
01:02:04,095 --> 01:02:10,244
其他线程分离线程丧生 

1186
01:02:08,058 --> 01:02:14,082
不能和他们的资源 

1187
01:02:11,099 --> 01:02:17,010
在终止时自动声称这样 

1188
01:02:14,082 --> 01:02:18,168
默认状态可连接，你有 

1189
01:02:17,001 --> 01:02:24,590
使用这种分离的函数调用进行 

1190
01:02:19,068 --> 01:02:26,073
使分离线程最大 

1191
01:02:24,599 --> 01:02:28,440
与 线程 的最大问题 ，所以像 

1192
01:02:26,073 --> 01:02:29,192
有关线程的美丽的东西是 

1193
01:02:28,044 --> 01:02:32,088
您在共享相同的 全局 

1194
01:02:29,849 --> 01:02:34,500
地址空间，所以它很容易分享 

1195
01:02:32,088 --> 01:02:35,097
你知道的数据结构，如果你有 

1196
01:02:34,005 --> 01:02:38,037
多线程，如果你有一个Web服务器 

1197
01:02:36,078 --> 01:02:40,122
这是建并发 Web服务器 

1198
01:02:38,082 --> 01:02:43,098
多线程是很容易 

1199
01:02:41,022 --> 01:02:45,096
实现一个高速缓存，所有的线程 

1200
01:02:43,098 --> 01:02:46,190
可能可以使用，因为他们都 

1201
01:02:45,096 --> 01:02:50,127
共享相同的虚拟地址空间 

1202
01:02:47,009 --> 01:02:53,010
但是，使线程这么好看的东西 

1203
01:02:51,027 --> 01:02:56,076
这缓解难易程度 ，你可以 

1204
01:02:54,000 --> 01:02:58,098
共享资源也是 件事 

1205
01:02:56,076 --> 01:03:00,122
使得他们非常棘手，处理这样 

1206
01:02:58,098 --> 01:03:04,727
只要就像我们有看到了 我们 

1207
01:03:01,022 --> 01:03:06,105
你只要知道壳实验室处理程序

1208
01:03:05,609 --> 01:03:09,630
你只要你有 多个 是 

1209
01:03:07,005 --> 01:03:12,006
流访问共享资源 它可以 

1210
01:03:09,063 --> 01:03:17,042
必须非常小心，它很容易 使 

1211
01:03:12,015 --> 01:03:21,015
错误，这是非常它很容易 

1212
01:03:17,609 --> 01:03:24,632
或者有可能共享资源 

1213
01:03:21,015 --> 01:03:29,204
在非预期的方式意外

1214
01:03:24,839 --> 01:03:32,550
例如，如果如果如果一个线程传递 

1215
01:03:29,339 --> 01:03:34,391
在一个局部变量的地址其

1216
01:03:32,055 --> 01:03:38,055
堆到另一个线程，然后现在

1217
01:03:34,859 --> 01:03:40,380
被叫线程现在可以访问 

1218
01:03:38,055 --> 01:03:44,614
求助者线程并没有什么 

1219
01:03:40,038 --> 01:03:47,106
防止从 调用线程 

1220
01:03:45,109 --> 01:03:50,430
操作上的局部变量

1221
01:03:48,006 --> 01:03:53,007
调用程序堆栈，这将是一个非常 

1222
01:03:50,043 --> 01:03:55,071
坏的事情，但有可能你 

1223
01:03:53,007 --> 01:03:56,094
也许你可能会忘记你知道你 

1224
01:03:55,071 --> 01:03:58,077
也许你可能会忘记的 

1225
01:03:56,094 --> 01:04:07,273
你传递的变量是本地 

1226
01:03:59,031 --> 01:04:12,104
变量不是不是全局 好吗落得 

1227
01:04:08,119 --> 01:04:17,520
非常糟糕的错误在我们我们打招呼 

1228
01:04:13,004 --> 01:04:19,080
在我们的回声服务器的例子，你知道，所以 

1229
01:04:17,052 --> 01:04:26,052
我们现在 非常 小心， 像空间 

1230
01:04:19,008 --> 01:04:29,016
这此连接的文件

1231
01:04:26,052 --> 01:04:31,140
我们传递给同行描述符

1232
01:04:29,088 --> 01:04:34,167
我们正在创建将有螺纹

1233
01:04:32,004 --> 01:04:37,005
容易得多只是 为了打发 

1234
01:04:35,067 --> 01:04:40,143
所连接的文件描述符的地址

1235
01:04:37,005 --> 01:04:43,079
到我们对螺纹容易得多 ，但 

1236
01:04:41,043 --> 01:04:43,124
这也将是错误 

1237
01:04:50,019 --> 01:05:01,107
你可以看到为什么没关系，让我们说对不对 

1238
01:04:59,013 --> 01:05:04,017
在这里，当我们称之为并行线程 ，而不是 创建 

1239
01:05:02,007 --> 01:05:07,080
的指针传递到一个单独 

1240
01:05:04,017 --> 01:05:09,045
热， 而不是分配区域

1241
01:05:07,008 --> 01:05:10,014
这样做，我们刚刚通过 的地址 

1242
01:05:09,045 --> 01:05:18,144
连接的文件描述符同样的事情 

1243
01:05:11,004 --> 01:05:23,102
右好，然后在我们的线程 

1244
01:05:19,044 --> 01:05:27,047
日常我们解引用该指针 

1245
01:05:24,038 --> 01:05:29,079
获得连接文件描述符

1246
01:05:27,047 --> 01:05:32,076
没关系，如果我们 只是 传递 的地址 

1247
01:05:29,079 --> 01:05:42,150
连接的文件描述符，这是真实的

1248
01:05:32,076 --> 01:05:45,084
这是非常糟糕的，你可以看到为什么是它 

1249
01:05:43,005 --> 01:05:49,034
不好吧这是真的，为什么是 

1250
01:05:46,056 --> 01:05:49,079
糟糕， 我的意思只是 

1251
01:05:57,008 --> 01:06:03,096
这是的， 这是正确的那么什么什么 

1252
01:06:02,001 --> 01:06:06,069
这是 假设通过听这 

1253
01:06:04,068 --> 01:06:10,145
测试此连接的地址

1254
01:06:06,069 --> 01:06:13,101
文件描述符，我们推出了一个竞赛 

1255
01:06:11,045 --> 01:06:19,077
还好在比赛中有什么我们假定 

1256
01:06:14,001 --> 01:06:25,056
对端线程就能 

1257
01:06:19,077 --> 01:06:26,163
取消引用前的主要 是指针 

1258
01:06:25,056 --> 01:06:32,073
线程再次进入并获得一个新的 

1259
01:06:27,063 --> 01:06:34,140
连接文件描述符权等什么

1260
01:06:32,073 --> 01:06:36,075
会发生什么情况 的权利，我们不能在 

1261
01:06:35,004 --> 01:06:38,013
并发系统，我们不能做任何

1262
01:06:36,075 --> 01:06:39,117
有关 内核是 如何设想 

1263
01:06:38,049 --> 01:06:43,080
要安排 正确的事情，我们看到 

1264
01:06:40,017 --> 01:06:48,045
有 预言于是同样的事情 是什么 

1265
01:06:43,008 --> 01:06:51,026
如果发生之后并行线程创建主

1266
01:06:48,045 --> 01:06:55,068
线程运行，而不是对线程 

1267
01:06:51,098 --> 01:06:57,129
好了，所以我们通过我们已经通过了 

1268
01:06:55,068 --> 01:07:01,122
所连接的文件描述符的地址

1269
01:06:58,029 --> 01:07:05,088
此客户端 ， 在我们接受 

1270
01:07:02,022 --> 01:07:08,117
从再连接请求 

1271
01:07:05,088 --> 01:07:11,139
在同行线程才能前

1272
01:07:09,017 --> 01:07:18,059
解引用这样的说法，我们得到一个新的 

1273
01:07:12,039 --> 01:07:21,123
连接文件描述符好吗 

1274
01:07:18,059 --> 01:07:25,121
现在孩子跑，它

1275
01:07:22,023 --> 01:07:30,032
解引用该描述符，但 

1276
01:07:26,021 --> 01:07:32,094
它 现在 得到 的是描述符 

1277
01:07:30,032 --> 01:07:35,043
这是一个的对应 

1278
01:07:32,094 --> 01:07:39,099
第二老二不是第一 

1279
01:07:35,043 --> 01:07:41,124
孩子，现在我们有两个线程说话 

1280
01:07:40,044 --> 01:07:44,075
使用相同的同一客户端 

1281
01:07:42,024 --> 01:07:44,075
描述

1282
01:07:49,042 --> 01:07:56,071
所以你看到他们帮助所以很 

1283
01:07:55,000 --> 01:07:59,014
棘手的，这是像一个真正的微妙这 

1284
01:07:56,071 --> 01:08:01,075
是 那种 细微的错误 的一个例子 

1285
01:07:59,014 --> 01:08:08,020
你可以 因为这个介绍 

1286
01:08:01,075 --> 01:08:09,160
意想不到的共享， 它是 导致 

1287
01:08:08,074 --> 01:08:12,148
根本原因是因为你正确地 指出 

1288
01:08:10,006 --> 01:08:20,083
出的是两个共享相同 

1289
01:08:13,048 --> 01:08:22,129
呼叫者内存堆栈 是在这 

1290
01:08:21,037 --> 01:08:24,088
你可以 在那里做 什么 的 情况下， 

1291
01:08:23,029 --> 01:08:27,046
另外还有一件事，你可以 

1292
01:08:24,088 --> 01:08:29,185
你好吗，你可以 只通过 

1293
01:08:27,046 --> 01:08:32,089
干练的描述符本身，所以你可以 

1294
01:08:30,085 --> 01:08:35,158
只投中描述的通用 

1295
01:08:32,089 --> 01:08:36,187
指针和公正的传递和 

1296
01:08:36,058 --> 01:08:41,101
这 只是一种虽然那令人讨厌的 

1297
01:08:37,087 --> 01:08:44,116
这将工作，因为不是 

1298
01:08:42,001 --> 01:08:48,054
解引用它的孩子会会

1299
01:08:45,016 --> 01:08:48,054
只需直接用它

1300
01:08:48,929 --> 01:08:51,997
好那么好，是很好的 

1301
01:09:00,019 --> 01:09:09,020
好了所以所以 真正的 好 

1302
01:09:07,034 --> 01:09:12,037
东西与线程是易于 

1303
01:09:09,029 --> 01:09:15,083
共享但共享还介绍 

1304
01:09:12,064 --> 01:09:18,127
没关系介绍介绍并发症 

1305
01:09:15,083 --> 01:09:23,168
其实死亡，我们要看看 

1306
01:09:19,027 --> 01:09:27,086
方式来排序的控制共享 ，以便 

1307
01:09:24,068 --> 01:09:31,102
这样做了，使我们这样做，我们 

1308
01:09:27,086 --> 01:09:31,102
没有得到意想不到的意外共享 

1309
01:09:35,069 --> 01:09:40,558
好了，总结的方法

1310
01:09:38,067 --> 01:09:43,996
到 我们已经看了 并发 

1311
01:09:41,179 --> 01:09:48,206
我们有一个基于过程并发所以 

1312
01:09:44,599 --> 01:09:50,600
很难共享资源，但它 

1313
01:09:48,449 --> 01:09:52,170
容易避免意外共享，以便在 

1314
01:09:50,699 --> 01:09:55,440
某些方面它更安全，更容易 

1315
01:09:52,017 --> 01:09:58,196
计划基于事件的所以这是它非常 

1316
01:09:55,044 --> 01:10:01,373
低级别非常乏味 ，你必须 

1317
01:09:58,349 --> 01:10:03,630
非常小心你如何 

1318
01:10:01,769 --> 01:10:08,798
你在做 的工作的粒度 

1319
01:10:03,063 --> 01:10:09,159
响应事件，但你必须总 

1320
01:10:09,059 --> 01:10:13,050
在调度控制，所以你可以 

1321
01:10:10,059 --> 01:10:15,548
决定哪个哪个描述符你

1322
01:10:13,005 --> 01:10:17,804
去服务，并在其订购 它 

1323
01:10:16,079 --> 01:10:22,340
这是因为有一个单一的流 

1324
01:10:17,849 --> 01:10:24,851
控制你可以使用调试器进行调试 

1325
01:10:22,034 --> 01:10:26,039
但它并没有 充分利用多核心的这样 

1326
01:10:24,869 --> 01:10:29,963
有取舍了一把有 

1327
01:10:26,084 --> 01:10:33,323
基于线程的系统它很容易 

1328
01:10:30,809 --> 01:10:37,110
资源共享但该共享 

1329
01:10:34,079 --> 01:10:39,095
可以创建自己的问题， 这是 

1330
01:10:37,011 --> 01:10:41,540
相比于两个相当高效

1331
01:10:39,239 --> 01:10:44,130
处理器你没有太多 的控制 

1332
01:10:41,639 --> 01:10:46,170
在调度所以就像我们看到 

1333
01:10:44,013 --> 01:10:48,096
你不是你不能真正控制 

1334
01:10:46,017 --> 01:10:51,716
这与线程得到执行

1335
01:10:48,096 --> 01:10:55,855
该订单并将其可能难以 

1336
01:10:51,869 --> 01:10:59,670
调试，因为有可能是比赛 

1337
01:10:56,719 --> 01:11:03,719
发生极少极少 和 

1338
01:10:59,067 --> 01:11:04,071
所以那种创造的概率 

1339
01:11:03,719 --> 01:11:07,820
这些比赛的条件之一是 

1340
01:11:05,007 --> 01:11:07,082
难

1341
01:11:09,006 --> 01:11:14,062
好了，这就是它 的今天 

1342
01:11:11,082 --> 01:11:16,180
明天我们将看看基于线程 

1343
01:11:14,062 --> 01:11:19,126
更详细和服务器如何写 

1344
01:11:17,008 --> 01:11:21,072
有效的基于线程的系统和 

1345
01:11:20,026 --> 01:11:22,044
正确地

