1
00:00:00,000 --> 00:00:10,349
欢迎很 高兴见到你今天我们 

2
00:00:05,004 --> 00:00:13,059
将开始从如何转变 

3
00:00:10,349 --> 00:00:14,432
我们的 程序 与硬件交互 

4
00:00:13,059 --> 00:00:17,088
如何与软件互动

5
00:00:15,179 --> 00:00:20,550
特别是系统软件 和我们 

6
00:00:17,088 --> 00:00:21,497
要开始通过由调查

7
00:00:20,055 --> 00:00:27,057
研究和学习的过程

8
00:00:22,289 --> 00:00:33,480
所谓联是如何系统 

9
00:00:27,075 --> 00:00:34,146
建立构建你的程序 确定，所以我们 

10
00:00:33,048 --> 00:00:36,137
要学习的 过程 

11
00:00:35,046 --> 00:00:39,395
链接，然后我要告诉 你一个 

12
00:00:37,037 --> 00:00:42,135
很酷的 技术，叫做库 

13
00:00:39,809 --> 00:00:45,450
间的定位，它允许 

14
00:00:43,035 --> 00:00:49,050
您使用链接到实际拦截 

15
00:00:45,045 --> 00:00:51,084
在函数调用在图书馆

16
00:00:49,005 --> 00:00:53,294
像标准C库 ，所以这是一个 

17
00:00:51,084 --> 00:00:57,126
很好很强大有趣的技术

18
00:00:53,789 --> 00:01:02,850
这一切都使通过链接等等 

19
00:00:58,026 --> 00:01:05,079
让我们先从一个简单的程序这个 

20
00:01:02,085 --> 00:01:10,170
程序由名称的两个模块

21
00:01:05,079 --> 00:01:13,128
点c 和一些C点一些C点的需要 

22
00:01:11,007 --> 00:01:16,466
数组作为参数和一个长度为 n 

23
00:01:14,028 --> 00:01:20,100
然后将其总结了这些元件

24
00:01:17,159 --> 00:01:26,180
数组，并返回总和回 

25
00:01:21,000 --> 00:01:28,071
来电者主要点C调用求和函数 

26
00:01:26,018 --> 00:01:33,075
使用，并将它传递一个两个元件阵列 

27
00:01:28,071 --> 00:01:37,104
INT，然后返回，然后 

28
00:01:33,075 --> 00:01:39,014
返回从我们收到的一些值 

29
00:01:38,004 --> 00:01:43,017
那这是一种奇怪的事情 

30
00:01:39,689 --> 00:01:45,000
来回报您的退出状态一样 

31
00:01:43,017 --> 00:01:46,113
那可是我们只是做了它 ，以便 

32
00:01:45,000 --> 00:01:50,007
编译器不会设计的方式，所有的 

33
00:01:47,013 --> 00:01:51,078
我们的代码我知道，让我们看看什么 

34
00:01:50,007 --> 00:01:56,103
如果发生了，当我们想编译那些

35
00:01:51,078 --> 00:02:02,417
这两个模块的每个主点的C 

36
00:01:57,003 --> 00:02:07,020
有的鸭 看到GCC调用系列 

37
00:02:03,119 --> 00:02:10,050
对这些模块的翻译

38
00:02:07,002 --> 00:02:13,004
这些鸭子的C文件首次调用C 

39
00:02:10,005 --> 00:02:13,040
预处理CPP 

40
00:02:13,409 --> 00:02:20,920
然后它调用编译器 

41
00:02:16,003 --> 00:02:23,682
实际的编译器是CC的一个 

42
00:02:20,092 --> 00:02:27,094
编译器生成组件， 其 

43
00:02:23,709 --> 00:02:31,870
然后由汇编AAS翻译 

44
00:02:28,012 --> 00:02:35,014
导致所谓的主点o文件 

45
00:02:31,087 --> 00:02:40,129
Ø点类似的事情发生了第一次

46
00:02:35,014 --> 00:02:43,443
一些 C 点 后打完后 

47
00:02:41,029 --> 00:02:47,648
这三个翻译上的代码工作

48
00:02:43,569 --> 00:02:51,569
我们有 两个目标文件的两个 点O文件 

49
00:02:47,909 --> 00:02:57,430
链接器将这些这些点O文件 

50
00:02:51,569 --> 00:03:00,280
并把一些 它们关联起来有点 

51
00:02:57,043 --> 00:03:05,112
摔破在一起以形成单个 

52
00:03:00,028 --> 00:03:08,050
可执行 所谓的，我们可以再 运行 

53
00:03:06,012 --> 00:03:13,090
那么我们就可以加载并运行 

54
00:03:08,005 --> 00:03:15,954
系统，使主点 C和一些点 

55
00:03:13,009 --> 00:03:20,238
他们被称为源文件，这些点Ø 

56
00:03:16,449 --> 00:03:24,280
文件是我们 是我们的目标文件

57
00:03:21,129 --> 00:03:25,218
单独编译但我们称之为 

58
00:03:24,028 --> 00:03:29,106
重定位的目标文件，因为它们

59
00:03:26,019 --> 00:03:36,024
可以结合在一起以形成 

60
00:03:30,006 --> 00:03:37,545
完全挂钩的可执行目标文件，以便

61
00:03:36,069 --> 00:03:41,500
为什么我们不喜欢 这样 ，你知道为什么 

62
00:03:37,599 --> 00:03:43,720
为什么我们允许所谓的独立 

63
00:03:41,005 --> 00:03:45,954
编译你知道我们为什么不 只是 

64
00:03:43,072 --> 00:03:48,076
有 就像一个巨大的，你知道一个大文件 

65
00:03:46,449 --> 00:03:50,493
这是我们所有的代码，它很好 

66
00:03:49,012 --> 00:03:53,017
有一对夫妇的原因，首先是为 

67
00:03:50,889 --> 00:03:55,908
模块化所以通过允许 您 

68
00:03:53,062 --> 00:03:57,109
打破你的代码 成小块 你 

69
00:03:56,079 --> 00:04:00,135
可以把相关功能集成到单独的 

70
00:03:58,009 --> 00:04:03,106
源文件可以定义库

71
00:04:00,639 --> 00:04:06,120
功能，所以它只是这是一个好的 

72
00:04:04,006 --> 00:04:09,905
技术， 它可以让你 有种 

73
00:04:06,012 --> 00:04:14,026
打破你的代码成 - 尼斯 

74
00:04:09,959 --> 00:04:15,150
模块化件的另一个 原因是 

75
00:04:14,026 --> 00:04:18,063
效率

76
00:04:15,015 --> 00:04:20,082
因此，如果

77
00:04:18,063 --> 00:04:24,162
如果我们如果我们已经打破了我们的计划 

78
00:04:20,082 --> 00:04:27,087
成多块 ，如果我们改变，如果 

79
00:04:25,062 --> 00:04:30,108
我们如果我们只需要改变的一个 

80
00:04:27,087 --> 00:04:31,170
块，我们不必重新编译 

81
00:04:31,008 --> 00:04:34,074
所有其他的所有其它模块 

82
00:04:32,007 --> 00:04:36,075
正确的，我们只需重新编译一个 

83
00:04:34,074 --> 00:04:38,103
模块， 我们改变了，然后链接 

84
00:04:37,038 --> 00:04:42,135
他们一起 再次右键 所以它的 

85
00:04:39,003 --> 00:04:45,006
它的有效 时间它也是 

86
00:04:43,035 --> 00:04:48,042
高效的空间，因为 你可以采取 

87
00:04:45,006 --> 00:04:50,082
所有的说 所有的功能 在 

88
00:04:49,005 --> 00:04:53,079
标准C库，你可以把它们 

89
00:04:50,082 --> 00:04:54,135
所有在一起，但随后的唯一功能 

90
00:04:53,079 --> 00:04:55,173
你实际上得到编译 

91
00:04:55,035 --> 00:04:59,039
链接到你的程序是那些 

92
00:04:56,073 --> 00:05:02,091
你实际调用 好了，你 可以 

93
00:04:59,075 --> 00:05:03,162
你可以节省 空间，你难道你不知道 

94
00:05:02,091 --> 00:05:08,094
通常只使用一小部分 

95
00:05:04,062 --> 00:05:10,098
标准 C函数 等有 

96
00:05:09,021 --> 00:05:12,048
没有有一个 在连接所有的 毫无 意义 

97
00:05:10,098 --> 00:05:14,151
这些功能 集成到你的代码，如果你 

98
00:05:12,048 --> 00:05:18,057
不需要他们没事还等什么 

99
00:05:15,051 --> 00:05:22,134
接头搞好有两个主要有

100
00:05:19,038 --> 00:05:26,124
链接器执行两项主要任务 

101
00:05:23,034 --> 00:05:29,100
首先是所谓的符号解析等等 

102
00:05:27,024 --> 00:05:32,106
程序中定义和参考符号 

103
00:05:30,000 --> 00:05:36,027
没关系什么链接是指 为 

104
00:05:33,006 --> 00:05:40,035
符号，这些都是全局变量 

105
00:05:36,027 --> 00:05:43,083
和功能获得名字和那些 

106
00:05:40,035 --> 00:05:49,134
他们被称为 那些对象 

107
00:05:43,083 --> 00:05:53,091
符号所以在这里我们宣布我们 

108
00:05:50,034 --> 00:05:56,097
这里定义符号称为交换 我们 

109
00:05:54,063 --> 00:05:59,082
当提到我们所说的交换我们 

110
00:05:56,097 --> 00:06:02,190
指的 是符号没关系，这是一个 

111
00:05:59,082 --> 00:06:05,157
参考符号，在这里我们是 

112
00:06:03,009 --> 00:06:10,017
限定的指针被称为一个int 

113
00:06:06,057 --> 00:06:12,129
XP所以我们定义XP和我们 

114
00:06:10,098 --> 00:06:15,140
它初始化为Ⅹ 的地址

115
00:06:13,029 --> 00:06:20,034
我们指的是对X参考

116
00:06:16,004 --> 00:06:23,013
好了，所以符号定义 

117
00:06:20,034 --> 00:06:26,115
由存储的对象文件中

118
00:06:23,049 --> 00:06:29,094
汇编器在其为一个符号表 

119
00:06:27,015 --> 00:06:32,082
结构的数组，其中每个 击中 

120
00:06:29,094 --> 00:06:34,175
包含符号信息

121
00:06:32,082 --> 00:06:41,106
像符号 的名称， 它的大小和 

122
00:06:35,075 --> 00:06:44,127
它现在位于我们所说 

123
00:06:42,006 --> 00:06:48,104
符号解析是， 在 

124
00:06:45,027 --> 00:06:52,089
连接 闪烁 过程中，连接器 

125
00:06:49,004 --> 00:06:56,093
关联与每个符号参照 

126
00:06:52,089 --> 00:07:00,093
正好一个符号定义好吗 

127
00:06:56,093 --> 00:07:01,152
所以这是可能的，你知道多 

128
00:07:00,093 --> 00:07:03,168
为什么这是 一个问题，那么它的可能 

129
00:07:02,052 --> 00:07:07,095
就像在多个模块可能会声明

130
00:07:04,068 --> 00:07:09,075
具有相同 名称 的 全局变量 

131
00:07:07,095 --> 00:07:12,102
连接器必须决定那些哪一个

132
00:07:09,075 --> 00:07:14,084
定义用于所有后续 

133
00:07:13,002 --> 00:07:15,065
引用

134
00:07:15,098 --> 00:07:22,164
现在，一旦一旦接头相关的 

135
00:07:20,024 --> 00:07:26,121
与每个唯一的符号唯一的对象 

136
00:07:23,064 --> 00:07:28,116
然后与每个参考定义它 

137
00:07:27,021 --> 00:07:32,022
确实第二步这是重新定位

138
00:07:29,016 --> 00:07:35,115
拆迁期间， 合并所有 

139
00:07:32,022 --> 00:07:39,060
模块在一起成为单个成 

140
00:07:36,015 --> 00:07:42,033
一个单独的可执行的对象模块，其 

141
00:07:39,006 --> 00:07:45,012
可以直接加载和执行 上 

142
00:07:42,033 --> 00:07:51,048
系统所以当它的时候它时，它 

143
00:07:46,002 --> 00:07:54,021
这是否合并有它有 

144
00:07:51,048 --> 00:07:55,143
弄清楚其中每个的每个符号的每个 

145
00:07:54,039 --> 00:07:58,065
功能和每个变量是要 

146
00:07:56,043 --> 00:08:02,076
存储 没关系，这 被称为 

147
00:07:58,065 --> 00:08:04,334
搬迁因为最初的功能 

148
00:08:02,076 --> 00:08:07,122
只是存储在一些抵消 其 

149
00:08:04,919 --> 00:08:09,360
他们的目标模块，因为中 

150
00:08:08,022 --> 00:08:10,095
链接器不知道那些

151
00:08:09,036 --> 00:08:13,122
功能实际上将 是 

152
00:08:10,095 --> 00:08:17,121
最后一个加载到内存中，因此 

153
00:08:14,022 --> 00:08:20,100
前前搬迁的地址

154
00:08:18,021 --> 00:08:24,230
对象模块中的功能是刚好 

155
00:08:21,000 --> 00:08:27,009
其在模块中的偏移和 

156
00:08:24,419 --> 00:08:31,830
类似地， 对于重定位期间的数据

157
00:08:27,009 --> 00:08:34,037
步骤的链接器决定在哪里

158
00:08:31,083 --> 00:08:37,086
每个符号将是最终 

159
00:08:35,018 --> 00:08:41,061
位于存储器中的一个在 X当 

160
00:08:37,086 --> 00:08:43,170
程序执行，并绑定该说 

161
00:08:41,061 --> 00:08:47,073
那些绝对内存位置的 

162
00:08:44,007 --> 00:08:48,066
到符号，然后，然后 它去 

163
00:08:47,073 --> 00:08:51,120
并期待 在所有引用 那些 

164
00:08:49,029 --> 00:08:53,070
符号，它更新这些引用 

165
00:08:52,002 --> 00:08:54,066
所以他们现在它们指向 

166
00:08:53,007 --> 00:08:56,070
正确的地址 

167
00:08:54,084 --> 00:08:59,172
好了，所以找出 其中的东西 是怎么回事 

168
00:08:57,033 --> 00:09:01,101
去每个定义搞清楚

169
00:09:00,072 --> 00:09:03,099
在那里它会 去为每个 

170
00:09:02,001 --> 00:09:10,032
参照然后更新该参考所以 

171
00:09:03,099 --> 00:09:12,141
它指向正确的位置让我们 

172
00:09:10,032 --> 00:09:15,093
看看这些东西如何将这些 步骤 

173
00:09:13,041 --> 00:09:19,098
在此之前 ，我们需要更详细的工作

174
00:09:15,093 --> 00:09:20,169
到我们需要定义一些东西，所以 

175
00:09:19,098 --> 00:09:24,099
有有3种对象

176
00:09:21,069 --> 00:09:26,136
我已经提到有模块 

177
00:09:24,099 --> 00:09:27,186
点o文件是可重定位目标 

178
00:09:27,036 --> 00:09:32,049
模块这是 的输出 

179
00:09:28,086 --> 00:09:33,129
汇编很好，而且它这不是 它的一个 

180
00:09:32,049 --> 00:09:36,131
二进制文件

181
00:09:34,029 --> 00:09:39,075
但它不是以任何形式，可以是 

182
00:09:37,031 --> 00:09:42,057
直接加载到存储器，它需要

183
00:09:39,075 --> 00:09:44,112
前它由连接器被操纵

184
00:09:42,057 --> 00:09:46,095
可实际使用还有的 

185
00:09:45,012 --> 00:09:50,070
可执行目标文件是 

186
00:09:46,095 --> 00:09:52,188
由连接器产生这些被称为 

187
00:09:50,007 --> 00:09:55,062
一个文档文件有时 做 历史 

188
00:09:53,088 --> 00:09:57,135
最先Linux系统

189
00:09:56,025 --> 00:10:00,123
可执行这种默认名称 

190
00:09:58,035 --> 00:10:03,063
他们用UNIX的开发者

191
00:10:01,023 --> 00:10:06,027
他们的可执行文件的默认名称 

192
00:10:03,063 --> 00:10:08,094
他们点了所以这是这只是 

193
00:10:06,027 --> 00:10:11,028
那种有历史原因的，它的 

194
00:10:08,094 --> 00:10:13,119
这就是所谓的一个点出来，然后有 

195
00:10:11,037 --> 00:10:17,079
另一种类型的对象文件的被称为

196
00:10:14,019 --> 00:10:22,031
共享对象文件或点iso文件 ，其 

197
00:10:17,079 --> 00:10:24,096
是一种现代的现代技术 

198
00:10:22,031 --> 00:10:26,100
创建共享库，我们将 

199
00:10:24,096 --> 00:10:28,173
看看那些我们来看看后来那些

200
00:10:27,000 --> 00:10:33,021
现在的今天 

201
00:10:29,073 --> 00:10:36,114
目标模块来以标准 格式 

202
00:10:33,021 --> 00:10:39,084
所谓的小精灵格式，它是一个统一的 

203
00:10:37,014 --> 00:10:41,022
对于可执行点O文件格式

204
00:10:39,084 --> 00:10:47,148
和点 ISO文件他们都使用 

205
00:10:41,094 --> 00:10:51,170
相同的格式 相同的通用格式，以便 

206
00:10:48,048 --> 00:10:55,056
这一点的同时，这些小精灵，这些二进制文件

207
00:10:52,007 --> 00:10:57,074
他们的二进制他们很有条理 

208
00:10:55,056 --> 00:11:02,064
很好，而且他们分成 部分 

209
00:10:58,037 --> 00:11:06,048
的开头是 一个首标 

210
00:11:02,064 --> 00:11:09,069
定义 喜欢的大小事 

211
00:11:06,048 --> 00:11:12,111
词的字节顺序是否是一个 

212
00:11:09,069 --> 00:11:15,120
点O和点出来或fo，从而它的点 

213
00:11:13,011 --> 00:11:19,022
只是为他们提供某种形式 的一般 

214
00:11:16,002 --> 00:11:21,003
这个关于这个 二进制 信息 

215
00:11:19,022 --> 00:11:25,026
然后有什么所谓 的 

216
00:11:21,003 --> 00:11:27,024
段头表仅是它 

217
00:11:25,026 --> 00:11:30,033
它只是 对 可执行文件 中定义 

218
00:11:27,051 --> 00:11:32,097
目标文件， 它表明，所有 

219
00:11:30,096 --> 00:11:34,119
代码的 不同段 是 

220
00:11:32,097 --> 00:11:37,098
要去在内存中，以便在哪里呢 

221
00:11:35,019 --> 00:11:38,097
你的筹码去 哪里 做你共享 

222
00:11:37,098 --> 00:11:40,179
图书馆去

223
00:11:38,097 --> 00:11:43,152
在哪里呢你对你的初始化， 

224
00:11:41,079 --> 00:11:46,133
未初始化的数据在哪里呢代码 

225
00:11:44,052 --> 00:11:50,094
向右走，因此所有这些所有这些不同 

226
00:11:47,033 --> 00:11:53,049
部分被 该 段中定义 

227
00:11:50,094 --> 00:11:55,143
头表，然后有代码 

228
00:11:53,049 --> 00:11:58,122
本身这就是所谓的点文字 

229
00:11:56,043 --> 00:12:04,076
对于那种神秘历史的部分

230
00:11:59,022 --> 00:12:07,095
原因所以点文字始终码 

231
00:12:04,076 --> 00:12:10,077
那么，再接一个只读数据 

232
00:12:07,095 --> 00:12:14,100
如 在开关跳转表 

233
00:12:10,077 --> 00:12:16,149
语句，使文字和， 只有读 

234
00:12:15,000 --> 00:12:19,038
点文字和RO数据具有这样的性质 

235
00:12:17,049 --> 00:12:22,053
他们是他们只读你 

236
00:12:19,038 --> 00:12:26,084
不写他们那么， 再接 

237
00:12:22,089 --> 00:12:28,164
由数据部分，其是含有 

238
00:12:26,084 --> 00:12:31,113
您的所有初始化的全局空间 

239
00:12:29,064 --> 00:12:37,071
变量，然后有一个部分 

240
00:12:32,013 --> 00:12:43,017
称为VSS 含有 其限定 

241
00:12:38,034 --> 00:12:44,070
现在未初始化的全局变量

242
00:12:43,017 --> 00:12:48,033
这实际上不占用任何空间 

243
00:12:44,007 --> 00:12:49,044
因为他们未初始化率好 

244
00:12:48,033 --> 00:12:54,105
但 他们自己的符号项 

245
00:12:50,007 --> 00:12:56,088
表他们和它在这个时

246
00:12:55,005 --> 00:12:59,028
程序被加载这些变量 

247
00:12:56,088 --> 00:13:00,164
将需要他们居然打算 

248
00:12:59,028 --> 00:13:04,125
必须有空间分配给他们 

249
00:13:01,064 --> 00:13:06,141
DFS 是 那些种类中的 另一 

250
00:13:05,025 --> 00:13:09,084
可以追溯到一路神秘的名字

251
00:13:07,041 --> 00:13:11,055
到20世纪60年代的有一个想法 

252
00:13:09,084 --> 00:13:13,131
指令称区块的开始

253
00:13:11,055 --> 00:13:16,098
符号，我认为更好的方式来记住 

254
00:13:14,031 --> 00:13:18,560
它的意思是更好的安全空间好吗 

255
00:13:16,098 --> 00:13:19,637
所以你可以，如果你有一个单独的 

256
00:13:18,839 --> 00:13:23,010
用于未初始化的变量节

257
00:13:20,519 --> 00:13:25,230
从那时起初始化你不必 

258
00:13:23,001 --> 00:13:33,140
你不必不必消耗 

259
00:13:25,023 --> 00:13:34,116
任何房间 中 的点o文件 确定 

260
00:13:33,149 --> 00:13:38,850
有也为符号节

261
00:13:35,016 --> 00:13:43,029
桌子， 这包含就像我说的 

262
00:13:38,085 --> 00:13:48,138
它的结构对程序的数组

263
00:13:43,029 --> 00:13:53,088
全局变量和定义的东西

264
00:13:49,038 --> 00:13:55,122
与静态属性和每一个 

265
00:13:53,088 --> 00:13:58,787
这些这些符号中的每一个获得 

266
00:13:56,022 --> 00:14:01,068
在符号表中，然后一个条目

267
00:13:59,579 --> 00:14:03,584
有二两部分叫他们 

268
00:14:01,068 --> 00:14:07,071
包含搬迁的信息，所以这是 

269
00:14:04,079 --> 00:14:10,290
票据时，当链接去 

270
00:14:07,098 --> 00:14:11,387
并确定所有引用 

271
00:14:10,029 --> 00:14:13,035
符号它把一个小纸条说我 

272
00:14:12,269 --> 00:14:16,770
要记得 要解决这个问题 

273
00:14:13,089 --> 00:14:20,118
该参考 符号，当我 

274
00:14:16,077 --> 00:14:22,161
当我真正创建可执行 

275
00:14:21,018 --> 00:14:26,037
所以重定位记录就像是一个 

276
00:14:23,061 --> 00:14:27,123
注意链接器或它的一个音符 

277
00:14:26,037 --> 00:14:29,816
该汇编程序的链接

278
00:14:28,023 --> 00:14:32,252
说嘿，你打算 要修复 

279
00:14:30,149 --> 00:14:35,162
了这个这个参考，因为我不 

280
00:14:32,459 --> 00:14:36,600
知道， 我 不知道这个符号是 

281
00:14:35,279 --> 00:14:39,980
实际上将被存储在 内存 中 

282
00:14:36,006 --> 00:14:39,044
当它时，它的加载 

283
00:14:40,088 --> 00:14:47,151
好吧，然后有一个调试节

284
00:14:43,023 --> 00:14:52,035
包含 涉及 信息 

285
00:14:48,051 --> 00:14:54,060
行号在源代码中 以 

286
00:14:52,035 --> 00:14:57,054
在本机代码行数好吗 

287
00:14:55,041 --> 00:14:58,104
所以这就是所谓的调试，这是 

288
00:14:57,054 --> 00:15:01,056
当你与 前围 编译你会得到什么

289
00:14:59,004 --> 00:15:04,055
G和然后有一个头表 

290
00:15:01,074 --> 00:15:08,163
告诉你在哪里所有这些不同的 

291
00:15:04,055 --> 00:15:12,068
部分 现在开始到连接有 

292
00:15:09,063 --> 00:15:15,512
有三种不同类型的 符号 

293
00:15:12,068 --> 00:15:18,156
全局符号在一些定义 

294
00:15:16,079 --> 00:15:21,870
模块m和他们可以和它们可以 是 

295
00:15:19,056 --> 00:15:24,275
使用其他模块 没事 ，所以我 

296
00:15:21,087 --> 00:15:25,616
意思是你有没有注意到，当我们，如果我们有一个 

297
00:15:24,779 --> 00:15:29,010
程序 由多个的 

298
00:15:26,399 --> 00:15:32,700
模块和我们编译那些中的每一个 

299
00:15:29,001 --> 00:15:35,049
模块成点o文件将 是 

300
00:15:32,007 --> 00:15:37,013
调用未定义的函数

301
00:15:35,049 --> 00:15:41,018
由 右 其它模块中定义的 

302
00:15:38,003 --> 00:15:43,077
好了，所以那些，但没有错误 

303
00:15:41,459 --> 00:15:45,660
虽然该编译器不会不 

304
00:15:44,004 --> 00:15:47,097
抛出一个错误，因为它是假设 

305
00:15:45,066 --> 00:15:49,161
这些在 其它 模块中定义

306
00:15:47,097 --> 00:15:52,098
它假定连接器将能够 

307
00:15:50,061 --> 00:15:56,540
找到他们，并确定 

308
00:15:53,007 --> 00:16:01,010
地址，所以其与定义的东西

309
00:15:57,089 --> 00:16:05,310
任何全球任一任全局变量 

310
00:16:01,037 --> 00:16:08,055
或者某个定义的函数名

311
00:16:05,031 --> 00:16:12,129
没有静态属性是一个全球性的 

312
00:16:08,055 --> 00:16:14,093
现在没事了，然后外部符号

313
00:16:13,029 --> 00:16:17,082
各种符号的那种的 另一面 

314
00:16:14,093 --> 00:16:19,167
外部符号是符号 

315
00:16:17,082 --> 00:16:24,087
通过一些模块引用 但在限定 

316
00:16:20,067 --> 00:16:26,139
其他一些模块好了，所以我们在 我们的 

317
00:16:24,087 --> 00:16:29,148
在我们的小运行例如 ，当时 

318
00:16:27,039 --> 00:16:33,548
主要的 C点调用的函数总而言之 

319
00:16:30,048 --> 00:16:35,106
被引用的外部符号好吗 

320
00:16:33,899 --> 00:16:38,670
然后还有有 局部符号 

321
00:16:36,006 --> 00:16:44,007
而这些 中定义的 符号 

322
00:16:38,067 --> 00:16:45,141
和一个模块内引用和好 

323
00:16:44,007 --> 00:16:48,060
你所创建，这是不是这样

324
00:16:46,041 --> 00:16:51,075
从局部变量不同好吗 

325
00:16:48,006 --> 00:16:52,101
链接器要知道当地的 C变量 

326
00:16:51,075 --> 00:16:55,158
是

327
00:16:53,055 --> 00:17:00,060
通过堆栈上的 编译器管理

328
00:16:56,058 --> 00:17:02,627
连接基不具有对当地地方 看到的想法

329
00:17:01,005 --> 00:17:05,037
变量在这 方面 还好 ，当我们 

330
00:17:03,149 --> 00:17:08,760
谈论 一个局部符号就是我们 

331
00:17:05,037 --> 00:17:11,055
讲的是要么是一个全球性的一个 

332
00:17:08,076 --> 00:17:14,765
全局变量或函数 声明 

333
00:17:11,055 --> 00:17:16,077
与静态属性， 其 能 

334
00:17:15,449 --> 00:17:19,100
只能从内引用

335
00:17:16,077 --> 00:17:21,896
模块所以我们 说范围 

336
00:17:19,001 --> 00:17:24,014
在 FUNC功能或全球 范围 

337
00:17:22,589 --> 00:17:26,910
变量定义什么静态 

338
00:17:24,023 --> 00:17:31,029
属性被限定于模块

339
00:17:26,091 --> 00:17:34,137
它被定义好，所以这是用C 

340
00:17:31,029 --> 00:17:37,050
这是我们如何做到抽象与此 

341
00:17:35,037 --> 00:17:40,110
是我们如何能够建立某种私人

342
00:17:37,005 --> 00:17:43,029
其功能和小狗专用功能

343
00:17:41,001 --> 00:17:47,007
不能从外面叫 

344
00:17:43,074 --> 00:17:50,133
该模块好了，例如，如果我们 

345
00:17:47,007 --> 00:17:51,081
想使库 中的函数C 

346
00:17:51,033 --> 00:17:54,087
我们要集合 

347
00:17:52,044 --> 00:17:57,063
功能 的其他程序可以再 

348
00:17:54,087 --> 00:18:00,135
打电话联系到他们的计划和 

349
00:17:57,063 --> 00:18:05,139
调用我们要的功能

350
00:18:01,035 --> 00:18:08,097
可见 于其他程序的定义 

351
00:18:06,039 --> 00:18:10,071
没有静态属性和 

352
00:18:08,097 --> 00:18:13,116
我们希望有私人活动 

353
00:18:10,071 --> 00:18:16,095
而仅仅是内部的，我们宣布了什么 

354
00:18:14,016 --> 00:18:19,022
静态属性， 这样，我们得到 

355
00:18:16,095 --> 00:18:20,954
抽象，我们可以得到隐藏 

356
00:18:19,022 --> 00:18:25,047
信息隐藏和我们是 唯一 

357
00:18:21,809 --> 00:18:30,270
暴露的是我们的数据和功能

358
00:18:25,047 --> 00:18:31,074
希望， 我们要 揭露一切权利，使 

359
00:18:30,027 --> 00:18:35,046
让我们来详细看一下如何 符号 

360
00:18:31,074 --> 00:18:39,763
分辨率步工作我们回顾 

361
00:18:35,046 --> 00:18:40,015
例如我们的 示例程序 

362
00:18:41,019 --> 00:18:49,598
所以在这里我们引用一个全球性的 

363
00:18:43,799 --> 00:18:55,802
多数民众赞成内缅因州定义称为数组

364
00:18:49,769 --> 00:19:04,802
点这里看到，当我们在这里我们定义

365
00:18:56,099 --> 00:19:07,115
缅因州全球名为缅因州 这里我们 

366
00:19:05,099 --> 00:19:13,950
引用全球叫一些这 

367
00:19:07,259 --> 00:19:15,347
在一些C点定义和Val是本地 

368
00:19:13,095 --> 00:19:16,095
栈和接头 上C变量 知道 

369
00:19:16,139 --> 00:19:21,143
任何有关 

370
00:19:16,095 --> 00:19:25,119
现在没事了，也不知道什么 

371
00:19:21,539 --> 00:19:29,570
IRS 这也是现在局部变量 

372
00:19:26,019 --> 00:19:32,128
我们只是让我们确信 我们 

373
00:19:29,849 --> 00:19:34,856
了解当地的区别 

374
00:19:32,299 --> 00:19:40,440
静态C变量与当地的非 

375
00:19:35,549 --> 00:19:43,592
静态C变量所以在这里我们 

376
00:19:40,044 --> 00:19:49,463
定义称为本地静态变量 

377
00:19:43,979 --> 00:19:52,994
这个函数中诠释第 f 因为 

378
00:19:49,859 --> 00:19:57,090
这是当地的范围仅限 于这 

379
00:19:53,129 --> 00:20:00,214
功能，所以这个变量 X只能是 

380
00:19:57,009 --> 00:20:06,188
函数f中引用和 

381
00:20:00,979 --> 00:20:10,590
同样，对于这个定义X和 

382
00:20:06,269 --> 00:20:14,285
函数G只能通过引用

383
00:20:10,059 --> 00:20:15,638
函数G现在有什么，而是因为它是 

384
00:20:14,429 --> 00:20:18,690
与静态属性，它的声明

385
00:20:16,169 --> 00:20:21,206
不存储在堆栈上它实际上 

386
00:20:18,069 --> 00:20:23,073
存储在中就像 一个 点数据 

387
00:20:21,539 --> 00:20:25,595
全球会因此它它就像一个 

388
00:20:24,009 --> 00:20:30,218
全球在 某种意义上说，它实际上是 

389
00:20:26,099 --> 00:20:31,166
存储在 数据而不是堆叠但 

390
00:20:30,299 --> 00:20:34,304
这就像在一个局部C变量 

391
00:20:31,769 --> 00:20:36,806
感觉它的范围 只是 局限于 

392
00:20:34,349 --> 00:20:40,424
它在 这样 定义的函数

393
00:20:37,139 --> 00:20:43,710
什么什么，编译器会做它会

394
00:20:41,099 --> 00:20:46,105
对于X的每个定义分配空间

395
00:20:43,071 --> 00:20:47,157
所以这一点， 它就会给 它一些名字 

396
00:20:46,159 --> 00:20:51,182
它的歧义，所以也许它会调用

397
00:20:48,057 --> 00:20:52,106
这一个X点 1，也许这一个 X 

398
00:20:51,389 --> 00:20:57,050
2点

399
00:20:53,006 --> 00:20:59,009
所以这些符号 在点 分配 

400
00:20:57,005 --> 00:21:00,101
数据，因为，因为他们正在初始化 

401
00:20:59,009 --> 00:21:08,072
而他们得到的符号表项 只 

402
00:21:01,001 --> 00:21:11,096
像就像任何其他符号好 了， 

403
00:21:08,072 --> 00:21:14,078
我说，符号解析的过程中

404
00:21:11,096 --> 00:21:18,097
接头将每个 引用每个 

405
00:21:14,078 --> 00:21:21,155
符号参照正好一个独特 

406
00:21:18,097 --> 00:21:23,120
现在符号定义， 它是如何做 

407
00:21:22,055 --> 00:21:29,057
如果有多个符号 

408
00:21:24,002 --> 00:21:32,057
在所有模块定义，以便于 

409
00:21:29,057 --> 00:21:34,121
了解这样做会会会将就 

410
00:21:32,075 --> 00:21:37,081
定义的符号为是强或

411
00:21:35,021 --> 00:21:42,026
弱如此强大的符号或者是 

412
00:21:38,035 --> 00:21:45,089
过程或函数的函数名或 

413
00:21:42,026 --> 00:21:49,058
初始化的全局变量弱符号 

414
00:21:45,089 --> 00:21:53,174
或者未初始化的全局变量好吗 

415
00:21:49,058 --> 00:21:56,060
所以这里INT foo是一个强有力的象征 

416
00:21:54,074 --> 00:21:58,127
因为它的初始化 我们 

417
00:21:56,006 --> 00:22:04,007
初始化它P1 是由强 

418
00:21:59,027 --> 00:22:08,053
定义foo是处于 P2 C点弱

419
00:22:04,007 --> 00:22:10,088
FOO的这此定义为弱 

420
00:22:08,053 --> 00:22:13,145
因为它的初始化 和 

421
00:22:11,051 --> 00:22:16,139
P2的定义是强没关系，这样 

422
00:22:14,045 --> 00:22:20,129
该velinkar 用途的规则

423
00:22:17,039 --> 00:22:24,068
以下多个强符号不 

424
00:22:21,029 --> 00:22:27,065
允许这样没关系的错误 

425
00:22:24,068 --> 00:22:28,157
因此，这意味着，如果我们如果通过 

426
00:22:27,065 --> 00:22:30,161
多个模块，我们声明函数 

427
00:22:29,057 --> 00:22:34,081
具有相同名称的链接器将将就 

428
00:22:31,061 --> 00:22:34,063
扔了不允许使用的错误

429
00:22:35,053 --> 00:22:40,058
给予强烈的符号和多个弱 

430
00:22:38,024 --> 00:22:45,032
如果链接器总是会选择符号

431
00:22:40,058 --> 00:22:51,083
现在强大的符号记住，如果我们 

432
00:22:46,004 --> 00:22:54,077
初始化一个全局变量， 如果我们 

433
00:22:51,083 --> 00:22:55,142
我们声明了一个初始化的全局变量 

434
00:22:54,077 --> 00:22:57,128
在多个 模块这是 一个错误 

435
00:22:56,042 --> 00:23:00,050
因为这些都是强烈的符号 由好吗 

436
00:22:58,028 --> 00:23:02,111
规则之一，但如果我们有一个强大的 

437
00:23:01,022 --> 00:23:05,036
符号和多个弱符号的所有

438
00:23:03,011 --> 00:23:06,014
用相同的名字， 那么编译器 

439
00:23:05,036 --> 00:23:09,065
将选择

440
00:23:06,041 --> 00:23:11,126
强大的符号没关系，它 会联想 

441
00:23:09,065 --> 00:23:14,120
该符号的所有引用会去 

442
00:23:12,026 --> 00:23:16,067
那强大的象征，如果有 

443
00:23:15,002 --> 00:23:18,089
多个星期在这两个那么它只是 

444
00:23:16,067 --> 00:23:19,142
挑选任意一个，这thisthis 

445
00:23:19,007 --> 00:23:23,021
会看到可能 有问题 

446
00:23:20,042 --> 00:23:26,138
现在你可以用这个 GCC 覆盖它 

447
00:23:23,021 --> 00:23:29,033
如果你，如果你叫旗没有共同的和

448
00:23:27,038 --> 00:23:32,093
与此声明你的功能无 

449
00:23:29,033 --> 00:23:35,033
普遍的说法则多个弱 

450
00:23:32,093 --> 00:23:36,182
符号将扔在一个错误 

451
00:23:35,033 --> 00:23:39,047
连接没事那么为什么我们 关心 

452
00:23:37,082 --> 00:23:40,160
所有这些东西以及事实证明 ，如果 

453
00:23:39,047 --> 00:23:43,088
你不知道的 这个东西，你可以 

454
00:23:41,006 --> 00:23:45,071
你可以运行了一些很严重 

455
00:23:43,088 --> 00:23:48,146
这只是令人困惑的问题， 

456
00:23:46,025 --> 00:23:51,053
混杂权利，使连接器连接器

457
00:23:49,046 --> 00:23:52,139
错误是像他们最坏的一种

458
00:23:51,053 --> 00:23:54,056
在最难的 调试，因为 人们 的 

459
00:23:53,039 --> 00:23:58,058
通常不知道发生了什么事情的 

460
00:23:54,083 --> 00:23:59,149
里面的接头， 通常它是 

461
00:23:58,058 --> 00:24:03,125
只喜欢最好的程序员 

462
00:24:00,049 --> 00:24:05,111
真正了解你懂得这些 

463
00:24:04,025 --> 00:24:08,081
连接器的工作，什么样的错误

464
00:24:06,011 --> 00:24:12,056
他们可以抛出以及如何将它们调试等等 

465
00:24:08,081 --> 00:24:15,134
让我告诉你其中的一些示例 

466
00:24:12,056 --> 00:24:18,113
这些样的错误没事，所以我们 

467
00:24:16,034 --> 00:24:21,043
有我们的工作程序 ，我们有两个 

468
00:24:19,013 --> 00:24:24,044
模块所以每个这些矩形的 

469
00:24:21,043 --> 00:24:28,121
对应于一个模块和我们 

470
00:24:24,044 --> 00:24:33,103
每个模块中定义P1，这样太 

471
00:24:29,021 --> 00:24:33,103
强大的符号这是一个错误没关系 

472
00:24:35,014 --> 00:24:42,082
现在我们在这里被定义 p1 和 p2等等 

473
00:24:40,003 --> 00:24:45,096
我们准备好了，但现在我们已经有了2周 

474
00:24:42,082 --> 00:24:50,089
符号都是整数变量 

475
00:24:45,096 --> 00:24:52,105
所谓X所以，如果这些模块 

476
00:24:51,052 --> 00:24:55,120
引用X连接器将只挑选

477
00:24:53,086 --> 00:25:01,102
它我们就 挑其中的一个服务 

478
00:24:56,002 --> 00:25:05,011
作为定义，但是这是真的 

479
00:25:02,002 --> 00:25:07,021
你现在 要 在这种情况下是什么 

480
00:25:05,029 --> 00:25:09,058
并没有真正伤害任何东西，因为X 

481
00:25:07,021 --> 00:25:12,094
在这两个模块被声明是 int 

482
00:25:09,058 --> 00:25:17,095
没事所以它会只是它会只是 

483
00:25:12,094 --> 00:25:20,143
一些整数的尺寸变量和它 

484
00:25:17,095 --> 00:25:22,147
将是这将是地方和 ，但它 

485
00:25:21,043 --> 00:25:26,077
并不重要， 这其中一个 

486
00:25:23,047 --> 00:25:28,111
链接器选择，但我们开始 得到 

487
00:25:26,077 --> 00:25:33,160
陷入困境，如果我们声明这些 弱 

488
00:25:29,011 --> 00:25:36,082
不同的类型，因此这里的符号

489
00:25:34,006 --> 00:25:42,028
我们已经声明一个模块在一个int X 

490
00:25:36,082 --> 00:25:45,085
而在另一个模块，所以如果双X 

491
00:25:42,082 --> 00:25:48,145
我们写信给X如果链接只是

492
00:25:45,085 --> 00:25:52,087
这个任意选择该符号

493
00:25:49,045 --> 00:26:00,106
定义现在使用的，这是一个符号 

494
00:25:52,087 --> 00:26:02,152
该长度8的尺寸为8，如果我们 

495
00:26:01,006 --> 00:26:05,041
在这个程序的任何地方，如果我们 如果 

496
00:26:03,052 --> 00:26:08,143
链接器选择是，然后在任何地方

497
00:26:05,041 --> 00:26:11,080
编程那些那些引用 

498
00:26:09,043 --> 00:26:17,047
到X引用将是这双 

499
00:26:11,008 --> 00:26:19,102
这个字双字甚至即使在这种

500
00:26:17,083 --> 00:26:24,088
模块如果我们引用X这将是一个8 

501
00:26:20,074 --> 00:26:26,109
字节右所以 它会覆盖Y中 

502
00:26:24,088 --> 00:26:26,109
该 

503
00:26:28,097 --> 00:26:42,151
。为了对不起哦不，它是完全 

504
00:26:41,049 --> 00:26:50,100
它的 系统，它会随便挑一个 

505
00:26:43,051 --> 00:26:50,100
随意而你不知道我是认真的 

506
00:26:52,929 --> 00:26:59,500
好吧这里的现在，这是呃 ，这里的 

507
00:26:56,009 --> 00:27:01,091
问题我们定义了一个强有力的符号X 

508
00:26:59,005 --> 00:27:05,554
因为我们初始化它因此链接

509
00:27:02,072 --> 00:27:09,109
总会将所有关联

510
00:27:06,049 --> 00:27:19,840
这个整数大小 X引用

511
00:27:10,009 --> 00:27:19,084
这个整数大小的符号，所以如果我们 写 

512
00:27:28,041 --> 00:27:37,125
噢权利，使这样的权利X这里

513
00:27:35,057 --> 00:27:40,128
这 将是一个双本模块中，但 

514
00:27:38,025 --> 00:27:43,103
它会在此模块中覆盖ÿ 如此 

515
00:27:41,028 --> 00:27:43,103
这真是可恶 

516
00:27:47,088 --> 00:27:53,143
在这里，我们定义了一个强大的 

517
00:27:51,016 --> 00:27:58,087
符号X所以在以X引用 

518
00:27:54,043 --> 00:28:00,064
第二模块总是会得到它会 

519
00:27:58,087 --> 00:28:03,118
参考此初始化的变量，其 

520
00:28:00,064 --> 00:28:07,090
可能没有那么它可能不是 你 

521
00:28:04,018 --> 00:28:12,025
希望你可以，你可以假设 

522
00:28:07,009 --> 00:28:14,050
它未初始化 代码中的好和 

523
00:28:12,088 --> 00:28:17,125
那么你得到的终极噩梦 

524
00:28:15,031 --> 00:28:19,129
情景假设你知道，因为我们是

525
00:28:18,025 --> 00:28:21,103
按照标准ADI我们可以编译 

526
00:28:20,029 --> 00:28:24,058
我们的代码有多个编译器 和 

527
00:28:22,003 --> 00:28:36,072
这实际上发生在一些哦，是的 

528
00:28:24,058 --> 00:28:38,116
问题噢其实你是对的

529
00:28:36,072 --> 00:28:41,077
它会仍然会采取优先 

530
00:28:39,016 --> 00:28:43,078
你会 通过数量 来写 

531
00:28:41,077 --> 00:28:51,163
这是你想要的， 这样的幻灯片 

532
00:28:43,078 --> 00:28:54,136
不完全正确所以是什么 

533
00:28:52,063 --> 00:28:57,085
这样做 ，专家观点并不是 说 

534
00:28:55,036 --> 00:28:59,101
它总是被 引用只要 

535
00:28:57,085 --> 00:29:02,113
在本地的功能是什么 

536
00:29:00,001 --> 00:29:07,003
声明 回来 的一点 是它 

537
00:29:03,013 --> 00:29:10,044
扭曲 的像 这样没有没有 没有它，如果 

538
00:29:07,021 --> 00:29:14,029
你参考， 如果你 引用AA 

539
00:29:10,044 --> 00:29:18,072
变量这就是你需要这么一个变量

540
00:29:14,029 --> 00:29:18,072
它 在你的模块，然后定义你 

541
00:29:18,084 --> 00:29:28,120
与静态权哦，他们俩都是 

542
00:29:25,054 --> 00:29:32,143
他们都是当地的，所以你如果你这样做 

543
00:29:29,002 --> 00:29:34,009
希望的值时， 如果你想 保留 

544
00:29:33,043 --> 00:29:38,074
如果你想该变量 保留 

545
00:29:34,009 --> 00:29:40,075
从在位置的位置，以便值

546
00:29:38,074 --> 00:29:42,118
假设你它通常是一个糟糕的主意， 因为 

547
00:29:41,056 --> 00:29:45,064
我们会看到，当我们学习，因为线程 

548
00:29:43,018 --> 00:29:49,023
它使你的代码非线程安全的，但

549
00:29:46,036 --> 00:29:52,081
像早期一样随机数生成器

550
00:29:49,068 --> 00:29:54,073
将它会计算 一个伪随机 

551
00:29:52,081 --> 00:29:56,170
号码，然后将其保存 在 

552
00:29:55,018 --> 00:29:59,112
静态变量，然后用其 作为 

553
00:29:57,007 --> 00:30:01,068
在接下来的颈部起始值 

554
00:30:00,012 --> 00:30:04,020
时间你们称为功能，所以 

555
00:30:02,031 --> 00:30:06,075
每当你想值持续 

556
00:30:04,092 --> 00:30:09,092
在函数调用，以减少 

557
00:30:06,075 --> 00:30:09,092
静态是 

558
00:30:25,002 --> 00:30:32,025
顺利拿下它让我让我 得到 这个 

559
00:30:28,053 --> 00:30:35,079
直右2X + T2 实际上会 

560
00:30:32,043 --> 00:30:37,080
对应于存储器看即会 

561
00:30:35,079 --> 00:30:42,176
其实去的内存位置 我 

562
00:30:37,008 --> 00:30:47,097
对不起，我我需要 修改的是这么 写的2倍 

563
00:30:43,076 --> 00:30:50,085
在t2中将会因为 8个字节 

564
00:30:48,069 --> 00:30:53,106
编译器 知道编译器知道 

565
00:30:50,085 --> 00:30:59,094
这是一个双，但它会去 

566
00:30:54,006 --> 00:31:02,085
内存位置，我这只是4 

567
00:30:59,094 --> 00:31:05,130
字节，因为 X因为链接选择 

568
00:31:02,085 --> 00:31:08,093
强大的符号好了，所以这样的 权利 

569
00:31:06,003 --> 00:31:11,066
以X和T 2实际上将覆盖ÿ

570
00:31:08,093 --> 00:31:11,093
好 

571
00:31:12,096 --> 00:31:33,111
对不起，是的问题，这只是 

572
00:31:24,059 --> 00:31:37,830
通常它发生的方式，你 不知道 

573
00:31:34,011 --> 00:31:40,026
没有没有全局变量去在点数据 

574
00:31:37,083 --> 00:31:40,092
他们不进入堆叠，但通常 

575
00:31:40,026 --> 00:31:43,101
如果你定义一个局部变量 

576
00:31:41,073 --> 00:31:44,151
功能就会把他们它将

577
00:31:44,001 --> 00:31:52,046
它们分配一个其他后 

578
00:31:45,051 --> 00:31:51,146
他们在栈上好吗 

579
00:31:53,018 --> 00:31:57,025
没事所以 这一切的讨论 

580
00:31:57,043 --> 00:32:02,078
这些奇怪的强弱符号规则 

581
00:32:00,038 --> 00:32:07,046
链接器有 它的另一个原因 

582
00:32:02,078 --> 00:32:10,163
避免全局 变量，如果你可以的，如果 

583
00:32:08,018 --> 00:32:12,101
你是否需要声明一个全局看 

584
00:32:11,063 --> 00:32:14,147
如果你可以把它声明静态的，因为 

585
00:32:13,001 --> 00:32:17,054
那将限制范围的模块 

586
00:32:15,047 --> 00:32:19,112
， 它的宣告所以这是一个很好的 

587
00:32:17,054 --> 00:32:23,066
主意，如果 你能做到这一点 ，如果你定义 

588
00:32:20,012 --> 00:32:25,073
一个全局变量初始化，使 

589
00:32:23,066 --> 00:32:28,148
你会，你会，你会发现你会 

590
00:32:25,073 --> 00:32:30,116
发现如果您有多个 初始化 

591
00:32:29,048 --> 00:32:35,051
具有相同名称的全局符号 

592
00:32:31,016 --> 00:32:36,068
你的代码，然后，如果你想它是 

593
00:32:35,051 --> 00:32:38,135
总是好的做法，如果你是 

594
00:32:36,068 --> 00:32:40,070
引用外部变量来告诉 

595
00:32:39,035 --> 00:32:47,093
关于它的编译器使用

596
00:32:40,088 --> 00:32:48,176
没事 所以现在 的extern属性 

597
00:32:47,093 --> 00:32:52,130
这一点上，链接器相关 

598
00:32:49,076 --> 00:32:55,145
一些符号每个符号参考

599
00:32:53,003 --> 00:32:58,082
定义现在它必须采取所有这些

600
00:32:56,045 --> 00:33:01,048
对象重定位目标文件和 

601
00:32:59,009 --> 00:33:06,092
斯马什在一起，并创建一个类似

602
00:33:01,048 --> 00:33:10,055
一个大的可执行文件等等假设我们 

603
00:33:06,092 --> 00:33:14,155
例如有点运行实例中，每个 

604
00:33:10,055 --> 00:33:19,130
主要零和一些点Ø包含 一个 

605
00:33:15,055 --> 00:33:21,119
代码并初始化数据的 一些达托 

606
00:33:20,003 --> 00:33:25,061
没有任何初始化 只是 数据 

607
00:33:22,019 --> 00:33:27,026
有代码，然后有自己的系统

608
00:33:25,088 --> 00:33:30,131
实际上之前和之后运行的代码

609
00:33:27,089 --> 00:33:32,114
你的程序故当你的程序 

610
00:33:31,031 --> 00:33:36,104
运行它实际上开始执行 

611
00:33:33,014 --> 00:33:38,105
从会看到一个启动代码 

612
00:33:37,004 --> 00:33:40,070
诸如此类的事情进行初始化，然后 

613
00:33:39,005 --> 00:33:46,019
它确实的最后一件事是 调用 

614
00:33:40,007 --> 00:33:47,012
主要并将其弧RC和RV 好吗 

615
00:33:46,019 --> 00:33:51,110
然后当你当你的程序 

616
00:33:48,002 --> 00:33:54,026
退出 清楚 ，这 是 呼叫，但如果你的 

617
00:33:52,001 --> 00:33:56,093
程序如果你的主函数程序 

618
00:33:54,044 --> 00:33:58,082
做一回则返回 到 

619
00:33:57,002 --> 00:34:03,095
在启动代码， 然后不 

620
00:33:58,082 --> 00:34:05,771
退出好了，所以这只是所以这 

621
00:34:03,095 --> 00:34:09,254
这包括软糖

622
00:34:06,509 --> 00:34:12,480
文本和 数据，以及，所以当我们 

623
00:34:10,109 --> 00:34:18,128
当链接器重定位这些这些 

624
00:34:12,048 --> 00:34:20,327
目标文件需要的所有的 

625
00:34:18,299 --> 00:34:24,302
从各代码中的文本段 

626
00:34:20,759 --> 00:34:28,787
模块和 把它们放在一起 

627
00:34:24,599 --> 00:34:31,618
连续在 点文字 部分 

628
00:34:29,039 --> 00:34:34,064
可执行的目标文件确定，所以它只是 

629
00:34:31,789 --> 00:34:38,940
把它们放在一起以某种 顺序，它 

630
00:34:34,289 --> 00:34:41,312
确定并创建一个合并点 

631
00:34:38,094 --> 00:34:42,713
可执行文本节 

632
00:34:41,519 --> 00:34:45,581
包含了所有的系统代码和

633
00:34:43,559 --> 00:34:47,621
所有在所有定义的代码的的

634
00:34:46,139 --> 00:34:50,192
模块，然后它同样的

635
00:34:48,179 --> 00:34:53,246
与数据 的东西 通吃所有 

636
00:34:50,669 --> 00:34:56,630
来自各个点的数据段

637
00:34:53,849 --> 00:34:59,891
目标文件和把它们放在一起 

638
00:34:56,063 --> 00:35:03,512
在一个组合数据部 

639
00:35:00,269 --> 00:35:06,750
可执行文件，它也将出现 

640
00:35:04,079 --> 00:35:12,131
在调试符号表和

641
00:35:06,075 --> 00:35:16,122
信息以及现在当 它只是 

642
00:35:12,599 --> 00:35:19,673
这类行为，这些搬迁的行为 

643
00:35:17,022 --> 00:35:22,071
这些目标文件， 需要链接 

644
00:35:20,339 --> 00:35:25,382
揣摩出它要 

645
00:35:22,071 --> 00:35:28,400
实际存储这些这些这些 

646
00:35:25,769 --> 00:35:30,824
不同这些不同的符号 时 

647
00:35:29,039 --> 00:35:35,220
这一计划得到当系统变得

648
00:35:31,319 --> 00:35:38,940
加载所以它必须 选择一个地址 

649
00:35:35,022 --> 00:35:41,921
主这项职能将启动 

650
00:35:38,094 --> 00:35:42,099
在一些绝对地址这将 

651
00:35:42,119 --> 00:35:46,140
有 它的 会都来为他们做同样的 

652
00:35:43,044 --> 00:35:48,044
交换所以对于所有的全部数据阵列 

653
00:35:46,014 --> 00:35:48,017
对

654
00:35:50,073 --> 00:35:57,612
而但问题是，当这个 

655
00:35:54,819 --> 00:35:59,868
代码被编译，编译器不 

656
00:35:58,269 --> 00:36:05,274
明确知道哪些地址链接是怎么回事 

657
00:36:00,309 --> 00:36:07,407
挑所以这样编译器创建 

658
00:36:05,769 --> 00:36:10,510
这些这些提醒链接

659
00:36:08,289 --> 00:36:11,680
所谓的重定位项哪家

660
00:36:10,051 --> 00:36:15,150
然后存储在搬迁 

661
00:36:11,068 --> 00:36:17,122
的对象文件的部分和 

662
00:36:15,609 --> 00:36:19,614
这些搬迁这些条目是

663
00:36:18,022 --> 00:36:23,038
到这就是链接程序指令

664
00:36:20,109 --> 00:36:24,177
一些有一个参考 

665
00:36:23,038 --> 00:36:27,067
那将必须符号 

666
00:36:24,789 --> 00:36:32,190
修补了当的代码实际上是 

667
00:36:27,067 --> 00:36:34,123
搬迁并合并到可执行文件 

668
00:36:32,019 --> 00:36:37,938
所以让我们来看看一对夫妇它们的的 

669
00:36:35,023 --> 00:36:39,882
几个 例子，让我们在我们的主 

670
00:36:38,109 --> 00:36:45,660
点C模块中有一个参考 

671
00:36:40,089 --> 00:36:48,132
这对这一 全球性符号 称为数组 

672
00:36:45,066 --> 00:36:50,149
好吧 ，然后也有一个参考 

673
00:36:48,519 --> 00:36:55,527
到这这这全局符号总和 

674
00:36:51,049 --> 00:36:57,348
这是为了让该功能 

675
00:36:55,599 --> 00:37:00,640
编译器创建两个定位项 

676
00:36:57,789 --> 00:37:04,750
第一个为所述参考 

677
00:37:00,064 --> 00:37:07,983
数组所以在这里我们正在记 

678
00:37:04,075 --> 00:37:10,584
EDI是第一个参数所以记住 

679
00:37:08,559 --> 00:37:14,470
我们和功能需要的地址 

680
00:37:11,259 --> 00:37:21,285
的输入数组作为阵列的其 

681
00:37:14,047 --> 00:37:26,074
它的参数 ，所以这招我们正在 

682
00:37:21,519 --> 00:37:28,572
数组的地址转换成EDI用于 

683
00:37:26,074 --> 00:37:29,883
第一个参数，但编译器

684
00:37:29,049 --> 00:37:36,490
不知道该地址是怎么回事 

685
00:37:30,549 --> 00:37:39,220
是它只是是它 只是它 只是它 

686
00:37:36,049 --> 00:37:41,092
只是在它移动 的0 立即值 

687
00:37:39,022 --> 00:37:45,118
到EDI暂时 的权利 ，所以你可以 

688
00:37:41,092 --> 00:37:48,097
看到这一切都是零，但BF是举 

689
00:37:46,018 --> 00:37:52,031
指令，然后有allsey ROS 

690
00:37:48,097 --> 00:37:53,159
在现在

691
00:37:52,031 --> 00:37:57,065
然后它把这个重定位项

692
00:37:54,059 --> 00:38:01,067
在在搬迁部

693
00:37:57,065 --> 00:38:06,071
Maemo操作它，它说，它说的 

694
00:38:01,067 --> 00:38:09,151
在 addre 湖人 以 抵消所以这些都让 

695
00:38:06,071 --> 00:38:14,168
我提醒你，这些是我们的主要 零 

696
00:38:10,051 --> 00:38:17,078
模块只包含一个一个功能，所以 

697
00:38:15,068 --> 00:38:20,120
该功能将启动零偏移 

698
00:38:17,078 --> 00:38:23,159
在在模块的代码部分 

699
00:38:21,002 --> 00:38:25,070
在模块如果点文字部分 

700
00:38:24,059 --> 00:38:27,065
还有其他的功能，在这 

701
00:38:25,088 --> 00:38:30,161
模块他们自己也跟着 

702
00:38:28,019 --> 00:38:34,028
之后 好，它让你可以 

703
00:38:31,061 --> 00:38:35,156
看看编译器是什么，它只是 

704
00:38:34,028 --> 00:38:38,036
所有它，它只是产生的偏移 

705
00:38:36,056 --> 00:38:42,080
从一开始这些指令 

706
00:38:39,008 --> 00:38:45,086
点文字部分，它包括它

707
00:38:42,008 --> 00:38:47,045
这个搬迁进入它说的 

708
00:38:45,086 --> 00:38:53,090
当你在搬迁链接或嘿嘿 

709
00:38:48,017 --> 00:38:59,114
在这点 文字 主要 在零点 偏移 

710
00:38:54,026 --> 00:39:02,078
部分中，您已经有了一个 参考 30 到 

711
00:39:00,014 --> 00:39:08,098
参考阵列中的形式

712
00:39:02,078 --> 00:39:10,112
32位地址 确定，以便所以最终 

713
00:39:08,098 --> 00:39:13,172
链接器将不得不修补

714
00:39:11,012 --> 00:39:16,040
这些，所以这是解决9，这是 

715
00:39:14,072 --> 00:39:18,169
地址这将有修补

716
00:39:16,004 --> 00:39:24,062
四个字节开始地址的 

717
00:39:19,069 --> 00:39:26,125
与符号的绝对地址

718
00:39:24,098 --> 00:39:26,125
排列

719
00:39:28,014 --> 00:39:37,083
然后类似地，参考

720
00:39:32,064 --> 00:39:41,079
参照该参考此

721
00:39:37,083 --> 00:39:44,085
功能等一些编译器不知道 

722
00:39:41,079 --> 00:39:46,080
其中一些实际上将结束它

723
00:39:45,003 --> 00:39:49,020
甚至不知道它在什么模块或 

724
00:39:46,008 --> 00:39:53,094
即使它即使 它是在一个定义 

725
00:39:49,002 --> 00:39:59,055
模块所以在这种情况下，它只是把它做了 

726
00:39:54,066 --> 00:40:01,071
与所有零打电话，然后将 其添加 

727
00:39:59,073 --> 00:40:08,151
3个地点条目的说 

728
00:40:01,071 --> 00:40:13,079
在连接器偏移F你已经有了一个四 

729
00:40:09,051 --> 00:40:20,058
字节PC相对引用的功能 

730
00:40:14,051 --> 00:40:23,052
组装叫一些，然后 这个 

731
00:40:20,058 --> 00:40:25,095
是不大不小的神秘细节这一点，但并 

732
00:40:23,061 --> 00:40:29,073
它包含有一个选项， 包括 

733
00:40:25,095 --> 00:40:32,184
在中偏移和自偏置 

734
00:40:29,073 --> 00:40:35,085
我们使用，因为电话是因为电话

735
00:40:33,084 --> 00:40:38,136
使用 相对 PC 总是解决 

736
00:40:35,085 --> 00:40:42,099
寻址将是值

737
00:40:39,036 --> 00:40:45,072
这里放置在这四个字节表示 

738
00:40:42,099 --> 00:40:47,130
偏移F 将 是 从偏移 

739
00:40:45,072 --> 00:40:50,118
当前RI的p值或 程序员 

740
00:40:48,003 --> 00:40:52,086
计数器值，因为程序

741
00:40:51,018 --> 00:40:57,090
柜台总是指向内斯 猫 

742
00:40:53,013 --> 00:41:00,027
下一个指令，它包括此其 

743
00:40:57,009 --> 00:41:07,062
是四个字节远它包括这个这个 

744
00:41:00,027 --> 00:41:09,093
零下四个偏移所以如果 我 跟 

745
00:41:08,043 --> 00:41:11,109
它在 书，如果你 详细 

746
00:41:09,093 --> 00:41:13,101
真正想知道的是如何工作的，但 

747
00:41:12,009 --> 00:41:16,044
只是这里的关键是，有 

748
00:41:14,073 --> 00:41:19,074
足够的信息， 链接器 

749
00:41:16,044 --> 00:41:21,045
在正确的地址实际上填补如此 

750
00:41:19,074 --> 00:41:22,173
现在，如果我们 看一下搬迁文本 

751
00:41:21,054 --> 00:41:25,095
部分因此，如果我们如果我们编译这段代码 

752
00:41:23,073 --> 00:41:30,128
为可执行文件，然后我们用关闭 

753
00:41:25,095 --> 00:41:30,128
树桩拆开它，然后 

754
00:41:31,065 --> 00:41:36,156
你看这是什么在这里这个参考 

755
00:41:34,071 --> 00:41:40,164
我们移动地址的地址 

756
00:41:37,056 --> 00:41:43,077
的成EDI那些四个字节，其 

757
00:41:41,064 --> 00:41:46,118
最初 的零 到现在已经 

758
00:41:43,077 --> 00:41:50,163
用的实际地址更新 

759
00:41:47,018 --> 00:41:54,018
阵列中的存储器中运行时 好了，所以 

760
00:41:51,063 --> 00:41:56,097
接头决定阵列是

761
00:41:54,018 --> 00:42:00,045
要去的地址 零个六零 

762
00:41:56,097 --> 00:42:01,173
一个零点一八，然后是它的 

763
00:42:00,045 --> 00:42:04,106
实际上修补， 在四个字节 

764
00:42:02,073 --> 00:42:09,129
杯在中移动指令 

765
00:42:05,006 --> 00:42:14,022
与绝对地址和电话 

766
00:42:10,029 --> 00:42:16,053
诗篇是它也 一直 在 更新，但 

767
00:42:14,022 --> 00:42:19,104
这一个有趣 正确的，所以 

768
00:42:16,053 --> 00:42:24,054
它已经更新与地址 

769
00:42:20,004 --> 00:42:30,050
5没关系的PC相对地址，所以当 

770
00:42:24,063 --> 00:42:33,120
该程序 运行这个调用指令 

771
00:42:30,005 --> 00:42:36,006
它会做，当 它时，它 

772
00:42:34,002 --> 00:42:41,076
确定何时它计算绝对

773
00:42:36,051 --> 00:42:43,118
功能的地址一些它会 

774
00:42:41,094 --> 00:42:43,118
采取

775
00:42:49,049 --> 00:42:57,490
将采取的当前值 

776
00:42:55,779 --> 00:43:02,710
程序计数器是下一个 

777
00:42:57,049 --> 00:43:06,115
施工 所以 4 0 0 43和它将增加 

778
00:43:02,071 --> 00:43:09,980
它 无论任何 值在此 

779
00:43:07,015 --> 00:43:12,644
立即字段还好这是牙齿 

780
00:43:10,619 --> 00:43:16,270
今天 comprar 是 牙齿 恭维 

781
00:43:12,779 --> 00:43:19,990
整数因此它可以去它可以是相对的

782
00:43:16,027 --> 00:43:21,091
你可以去- 或者或 加在这种情况下， 

783
00:43:19,099 --> 00:43:26,176
它 说 ， 该函数 ，你 

784
00:43:21,091 --> 00:43:33,300
要调用的是， 它是在 4 0 0 4 E 

785
00:43:27,076 --> 00:43:36,345
3 + 5，它是4 0 0为E 8是 

786
00:43:34,119 --> 00:43:40,000
一些好等等的地址 

787
00:43:37,029 --> 00:43:42,081
链接链接程序编译器

788
00:43:40,000 --> 00:43:45,019
拥有所有 的编译器计算 出的智慧 

789
00:43:42,549 --> 00:43:46,720
搬迁进入的连接仅仅是

790
00:43:45,019 --> 00:43:48,118
通过各那些一味去 

791
00:43:46,072 --> 00:43:51,163
重定位项，只是在做什么 

792
00:43:49,018 --> 00:43:55,024
它告诉确定，但最终结果是， 

793
00:43:52,063 --> 00:43:58,242
现在所有这些这些引用 

794
00:43:55,024 --> 00:44:01,103
被修补了与绝对有效

795
00:43:58,809 --> 00:44:00,860
地址

796
00:44:05,025 --> 00:44:11,103
现在一旦连接创造了一个 

797
00:44:07,092 --> 00:44:14,118
该目标文件目标文件可以 

798
00:44:12,003 --> 00:44:17,052
加载的代码 和数据，并且 对象 

799
00:44:15,018 --> 00:44:21,027
文件可以被直接加载 到存储器 

800
00:44:17,052 --> 00:44:25,065
与没有进一步修改好 

801
00:44:21,027 --> 00:44:31,029
所以，如果你看一下所有的 

802
00:44:25,065 --> 00:44:35,127
只读的可执行部分，从而 

803
00:44:31,047 --> 00:44:37,131
有这样一个IT部分，我们是 

804
00:44:36,027 --> 00:44:40,038
不要担心 所有 的 

805
00:44:38,031 --> 00:44:44,102
代码是在点文字之类的东西 

806
00:44:40,038 --> 00:44:47,115
跳转表或RO数据所有 这 一切 

807
00:44:45,002 --> 00:44:51,009
数据可以直接被加载到存储器 

808
00:44:48,015 --> 00:44:54,724
因为是好了，这些字节可以只是 

809
00:44:51,072 --> 00:44:57,123
直接复制到到存储器中和 

810
00:44:54,859 --> 00:45:05,340
这将形成的所谓的一个只读的 

811
00:44:58,023 --> 00:45:08,025
代码段中的 数据 和点 

812
00:45:05,034 --> 00:45:14,049
数据和BSS 甲板X部 也可以是 

813
00:45:08,025 --> 00:45:16,394
直接复制 到到存储器和在 

814
00:45:14,049 --> 00:45:18,096
所述变量和数据的情况下 

815
00:45:16,619 --> 00:45:25,690
他们会 被初始化 ，这是 一个价值 

816
00:45:18,096 --> 00:45:27,121
存储在符号表中，以便 

817
00:45:25,069 --> 00:45:33,088
我们在这里这提请我们我们的记忆

818
00:45:28,021 --> 00:45:37,830
是，这是在内存地址 

819
00:45:33,088 --> 00:45:41,487
空间每一个Linux程序将看到并 

820
00:45:38,019 --> 00:45:46,390
我们正在绘制从开始的地址

821
00:45:42,279 --> 00:45:51,130
零和往上走 ， 因为 我们 日益 壮大 

822
00:45:46,039 --> 00:46:00,091
起来 ，每个程序都 在此装 

823
00:45:51,013 --> 00:46:03,070
相同的地址0 X 4 0 0 0 0 0 等 

824
00:46:00,091 --> 00:46:05,113
该代码直接来自 

825
00:46:03,007 --> 00:46:07,078
对象文件直接从数据配 

826
00:46:06,013 --> 00:46:12,162
目标文件 ，然后将该，再接 

827
00:46:08,041 --> 00:46:14,041
通过其创建的运行时的热量和 

828
00:46:12,279 --> 00:46:16,390
由malloc的，所以当你需要管理

829
00:46:14,041 --> 00:46:21,450
动态动态需要分配

830
00:46:16,039 --> 00:46:24,043
存储器 等使用malloc该存储器 

831
00:46:21,819 --> 00:46:26,200
出来的这堆哪个开始的

832
00:46:24,043 --> 00:46:30,642
马上数据如下 

833
00:46:26,002 --> 00:46:37,045
段和向上生长 的堆栈 

834
00:46:31,029 --> 00:46:39,900
在可见内存 的最顶端

835
00:46:37,063 --> 00:46:45,145
这是提供给应用程序 

836
00:46:39,009 --> 00:46:48,067
以上是其中存储器被限制 

837
00:46:46,045 --> 00:46:51,124
内核 确定，所以如果 您尝试访问 

838
00:46:49,048 --> 00:46:55,677
这些内存位置，你会得到一个SEG

839
00:46:52,024 --> 00:46:58,039
故障，然后堆栈，因为我们知道 

840
00:46:56,109 --> 00:47:00,180
所以，这是管理下的增长和 

841
00:46:58,039 --> 00:47:02,095
在 运行时创建，然后有这个 

842
00:47:00,819 --> 00:47:05,892
在这个 巨大的缺口区域某处

843
00:47:02,095 --> 00:47:08,098
栈和堆之间有一个 

844
00:47:06,549 --> 00:47:13,150
区域为这样的点Ñ共享库 

845
00:47:08,098 --> 00:47:13,917
所以文件都得到加载到这个这个 

846
00:47:13,015 --> 00:47:19,072
存储器映射区域共享 

847
00:47:14,799 --> 00:47:23,430
图书馆现在该堆的顶部

848
00:47:19,072 --> 00:47:25,089
通过这个 全局变量表示

849
00:47:23,043 --> 00:47:29,652
内核叫破维护

850
00:47:25,089 --> 00:47:32,089
VRK和堆在我们的上方 

851
00:47:30,039 --> 00:47:35,112
知道的是，在前述的维护

852
00:47:32,089 --> 00:47:36,978
通用寄存器RSP现在有一个

853
00:47:35,769 --> 00:47:39,490
的这一点点 一点点 

854
00:47:37,779 --> 00:47:43,350
如果你真的简化 

855
00:47:39,049 --> 00:47:46,063
看看malloc返回的地址 

856
00:47:43,035 --> 00:47:49,039
这事实上是在实际上有两家 

857
00:47:46,063 --> 00:47:51,070
堆有一堆在这里和在 

858
00:47:49,039 --> 00:47:55,063
即向下增长高内存的二手 

859
00:47:52,033 --> 00:47:56,107
对大对象非常大的，你知道，如果 

860
00:47:55,063 --> 00:47:59,101
你现在喜欢一大堆的空间， 

861
00:47:57,007 --> 00:48:04,015
然后就是成长的热量 

862
00:48:00,001 --> 00:48:05,053
保留用于较小的较小的对象，从而 

863
00:48:04,015 --> 00:48:08,052
我真的不知道他们为什么 这样做我 

864
00:48:05,053 --> 00:48:10,090
认为这让他们有独立的 

865
00:48:08,052 --> 00:48:13,077
分配算法对大对象

866
00:48:10,009 --> 00:48:12,096
和小物件 

867
00:48:19,539 --> 00:48:23,617
真正的一个好了，一个 

868
00:48:21,092 --> 00:48:26,701
联优点是，它允许我们 

869
00:48:24,319 --> 00:48:28,640
创造 的东西 图书馆 所以它的 

870
00:48:27,529 --> 00:48:32,450
总有一些事情我们想做的 

871
00:48:28,064 --> 00:48:35,023
程序员我们总是我们总是 希望 

872
00:48:32,045 --> 00:48:38,194
创建抽象然后本 

873
00:48:35,599 --> 00:48:39,622
这些抽象给用户的权利和 

874
00:48:38,599 --> 00:48:55,672
我们通过创建库

875
00:48:39,829 --> 00:49:00,903
定义 API是的，我认为 它只是没有 

876
00:48:56,329 --> 00:49:03,403
不，它实际上是一个很好的问题，我 

877
00:49:01,569 --> 00:49:07,220
我所做过的一切，它 只是增长，直到 

878
00:49:04,069 --> 00:49:09,124
它运行的内存 就在 那里等我 

879
00:49:07,022 --> 00:49:12,038
实际上并不认为 这是一个真正的 

880
00:49:09,619 --> 00:49:14,641
好问题， 我的意思是我所做的那些 

881
00:49:12,038 --> 00:49:23,277
实验和它，它最终到达 

882
00:49:14,839 --> 00:49:32,380
一些限制是啊，我不，我不知道 

883
00:49:23,619 --> 00:49:32,380
这是一个很大的数字，但我这样 

884
00:49:33,006 --> 00:49:37,089
你知道程序员 我们总是希望 

885
00:49:35,013 --> 00:49:41,022
抽象定义API的实现 

886
00:49:37,089 --> 00:49:45,096
打包的 ATIS，让他们 

887
00:49:41,022 --> 00:49:47,111
提供给其他程序员所以如何 

888
00:49:45,096 --> 00:49:49,140
我们实际上可以做到这一点，我们怎样才能使 

889
00:49:48,011 --> 00:49:53,034
提供常用功能

890
00:49:50,004 --> 00:49:55,041
其他程序员还有一两件事给

891
00:49:53,034 --> 00:49:57,105
我们已经学会为止 你可以只 

892
00:49:55,077 --> 00:50:01,086
采取的所有功能，并把他们所有 

893
00:49:58,005 --> 00:50:05,019
在一个大的C文件正确，然后 

894
00:50:02,067 --> 00:50:06,129
程序员只想链接C文件

895
00:50:05,019 --> 00:50:10,038
到他们到他们的计划， 他们 

896
00:50:07,029 --> 00:50:11,124
要使用他们的权利 的另一种选择 

897
00:50:10,038 --> 00:50:13,101
将采取可能 得到一种 

898
00:50:12,024 --> 00:50:16,035
笨拙的，如果它是一个巨大的图书馆权利 

899
00:50:14,001 --> 00:50:19,056
让我们来看看有成百上千的

900
00:50:16,035 --> 00:50:21,048
功能，因此另一种办法是可能 

901
00:50:19,056 --> 00:50:23,103
是只取各 功能把它放在 

902
00:50:21,048 --> 00:50:24,141
一个单独的文件，然后将它们编译 

903
00:50:24,003 --> 00:50:30,068
一起，编译和链接它们 

904
00:50:25,041 --> 00:50:33,066
所有在一起 ，这 是更大的空间， 

905
00:50:30,068 --> 00:50:35,157
时间不是那么我们的第一个有效

906
00:50:33,066 --> 00:50:38,163
选项，但现在看来似乎 会 

907
00:50:36,057 --> 00:50:40,086
繁重的程序员，因为 

908
00:50:39,063 --> 00:50:42,066
程序必须知道所有 

909
00:50:40,086 --> 00:50:44,124
这些函数并把 它们在 

910
00:50:42,093 --> 00:50:45,177
使文件也只是很多你 

911
00:50:45,024 --> 00:50:52,082
知道这一点，你可以结束了一个 

912
00:50:46,077 --> 00:50:52,082
大的离谱命令行GCC

913
00:50:53,003 --> 00:51:01,005
这样的一个解决 这个问题 

914
00:50:58,002 --> 00:51:04,059
它是第一个解决方案是， 

915
00:51:01,032 --> 00:51:07,059
UNIX的开发人员想出了IS 

916
00:51:04,059 --> 00:51:08,154
东西 称之为静态 库，因此 

917
00:51:07,059 --> 00:51:11,067
与 静态库 的想法 是，你 

918
00:51:09,054 --> 00:51:15,096
建立这个档案称为一个点

919
00:51:11,067 --> 00:51:17,133
文件， 该文件是它只是一个 集合 

920
00:51:15,096 --> 00:51:20,109
点O文件，其中每个点o文件

921
00:51:18,033 --> 00:51:22,122
包含一个函数确定 ，所以你把 所有 

922
00:51:21,009 --> 00:51:25,074
在您的图书馆 使用的功能

923
00:51:23,022 --> 00:51:28,065
选择两 到创建一批点邻 

924
00:51:25,074 --> 00:51:30,138
文件，然后使用一个 名为程序 

925
00:51:28,065 --> 00:51:34,137
存档 或A R 采取 这些点ö 

926
00:51:31,038 --> 00:51:37,044
文件把它们放在一起的所有 

927
00:51:35,037 --> 00:51:41,085
一起在一个 大的文件名为存档 

928
00:51:37,098 --> 00:51:42,150
出了与表的内容

929
00:51:41,085 --> 00:51:44,089
告诉 你的偏移量开始

930
00:51:43,005 --> 00:51:47,011
点o文件中的每一个

931
00:51:44,089 --> 00:51:49,161
好了，所以归档就是这

932
00:51:47,056 --> 00:51:55,104
的点O文件级联集合

933
00:51:50,061 --> 00:51:58,135
然后，然后你链接您 传递 

934
00:51:56,004 --> 00:52:02,023
归档到的链接 ，只有它 

935
00:51:59,035 --> 00:52:03,043
采用的是实际上是点O文件

936
00:52:02,023 --> 00:52:05,089
引用和 长度他们进入 

937
00:52:04,015 --> 00:52:09,031
代码右所以它是一个更有效的方法 

938
00:52:05,089 --> 00:52:10,134
你可以有一个巨大的 存档，但像 

939
00:52:09,031 --> 00:52:13,117
让我们来看看，但如果你只调用 printf 

940
00:52:11,034 --> 00:52:19,072
你得到的唯一点Ø文件的printf 

941
00:52:14,017 --> 00:52:27,025
零 还好所以这种工作方式是 

942
00:52:19,072 --> 00:52:30,073
我们采取之前，我们把 所有的功能 

943
00:52:27,025 --> 00:52:32,056
我们希望把我们的图书馆 ，我们运行 

944
00:52:30,082 --> 00:52:35,167
他们通过我们的翻译得到点 

945
00:52:32,056 --> 00:52:39,121
O文件我们通过那些归档到 

946
00:52:36,067 --> 00:52:44,110
获得存档所以在这种情况下，库中

947
00:52:40,021 --> 00:52:48,034
Ç点和具有此 代码 

948
00:52:45,001 --> 00:52:51,055
我们可能要使用 正确 的printf 

949
00:52:48,034 --> 00:52:53,086
所以我们可以，我们可以，我们可以重建 

950
00:52:51,064 --> 00:52:54,139
该归档随时都想要，所以如果一个 

951
00:52:53,086 --> 00:52:57,175
这些 功能 的 改变就好说了 

952
00:52:55,039 --> 00:53:01,039
printf的改变，你只需重新归档 

953
00:52:58,075 --> 00:53:05,089
点重新编译的printf，然后重新归档 

954
00:53:01,039 --> 00:53:08,056
所有的这点O文件所以让我们来看看 

955
00:53:05,089 --> 00:53:12,091
这是关于1500的目标文件，它的 

956
00:53:08,056 --> 00:53:13,150
归档之类 的printf scanf的简单 

957
00:53:13,009 --> 00:53:18,088
整数运算，也有一个数学 

958
00:53:14,005 --> 00:53:21,072
其中有你知道的几个库

959
00:53:18,088 --> 00:53:25,113
对于像百个常用功能

960
00:53:22,017 --> 00:53:30,070
浮点运算的正余弦 正切 

961
00:53:26,013 --> 00:53:32,020
等这些库的惯例是

962
00:53:30,007 --> 00:53:35,095
该图书馆总是有前缀 

963
00:53:32,083 --> 00:53:38,086
库11d中 ，然后再排序 

964
00:53:36,058 --> 00:53:40,125
有什么它的一些迹象是什么

965
00:53:39,013 --> 00:53:41,025
它 

966
00:53:42,066 --> 00:53:46,108
所以现在我们来看看如何使用这些链接

967
00:53:45,001 --> 00:53:51,016
工作的静态库，所以我我有 

968
00:53:47,008 --> 00:53:54,021
在这里创造一个小例子中，我 

969
00:53:51,025 --> 00:53:56,110
创建了一个名为 库矢量库 

970
00:53:54,021 --> 00:53:59,059
它包含函数 

971
00:53:57,001 --> 00:54:01,096
操纵载体，这是一个真正的 

972
00:53:59,059 --> 00:54:04,135
简单的库只是 增加了有一个 

973
00:54:02,005 --> 00:54:10,057
功能添加两个矢量x 和y 

974
00:54:05,035 --> 00:54:12,097
一起和Z轴返回结果和 

975
00:54:10,057 --> 00:54:15,124
然后另一个类似的功能，将

976
00:54:12,097 --> 00:54:21,175
做两成对的乘积

977
00:54:16,024 --> 00:54:25,075
矢量所以XI乘以y I等于ZI和

978
00:54:22,075 --> 00:54:27,097
现在我编译这两个程序 

979
00:54:25,075 --> 00:54:30,079
收拾我想将它们打包成一个 

980
00:54:27,097 --> 00:54:32,104
归档称为铅载体，然后在 

981
00:54:31,015 --> 00:54:36,106
我在我的主要节目， 我会 打电话到 

982
00:54:33,067 --> 00:54:40,080
的advic添加这些功能之一 

983
00:54:37,006 --> 00:54:40,080
这两个矢量x和y一起 

984
00:54:43,043 --> 00:54:49,712
所以现在，当我们编译这个 会发生什么

985
00:54:46,049 --> 00:54:54,095
这个计划我们已经我们已经 

986
00:54:50,099 --> 00:54:57,175
构建归档 现场 博士。从一 

987
00:54:54,509 --> 00:55:01,460
广告零和多 

988
00:54:57,859 --> 00:55:05,876
我们传递 存档链接 

989
00:55:01,046 --> 00:55:10,088
随着我们的主要零重定位 

990
00:55:06,029 --> 00:55:13,076
对象文件，我们也把它传递住 CA 

991
00:55:10,088 --> 00:55:15,767
其具有的定义

992
00:55:13,499 --> 00:55:21,526
包含printf 零和其他任何 

993
00:55:16,559 --> 00:55:25,559
这printf的大号可能会调用所以这三个 

994
00:55:21,769 --> 00:55:28,440
链接器检测到参考 

995
00:55:25,559 --> 00:55:31,562
advic功能添加回去，所以它

996
00:55:28,044 --> 00:55:32,115
只是拉阿德沃卡特Ø 出来，和 

997
00:55:31,859 --> 00:55:35,921
忽略其他

998
00:55:33,015 --> 00:55:39,066
同样，对于printf的点O和然后 

999
00:55:36,479 --> 00:55:41,700
编译所有的主力主攻 0添加 

1000
00:55:39,066 --> 00:55:44,675
矢量和printf点o所有一起

1001
00:55:41,007 --> 00:55:49,376
这个所谓的完全链接的可执行文件 

1002
00:55:45,269 --> 00:55:51,368
PROG 看到的 编译时间，让我们 

1003
00:55:50,069 --> 00:55:55,138
这样做，我们正在做的这个环节我们 

1004
00:55:52,259 --> 00:56:00,311
在编译的时候这样做此链接 

1005
00:55:55,759 --> 00:56:05,430
当我们现在所说的GCC链接什么 

1006
00:56:00,779 --> 00:56:09,848
确实，当它时， 它使用静态的

1007
00:56:05,043 --> 00:56:12,096
库它会扫描所有的点O文件 

1008
00:56:10,469 --> 00:56:16,472
和斑点一个文件，以便在命令

1009
00:56:12,096 --> 00:56:18,395
行，以便你 只是打字GCC然后 

1010
00:56:16,769 --> 00:56:24,660
点O文件列表，并点农委会

1011
00:56:19,259 --> 00:56:27,344
在某些词的文件，以便使在

1012
00:56:24,066 --> 00:56:30,995
扫描它保持当前的列表 

1013
00:56:28,109 --> 00:56:33,206
解析引用正确的，所以如果让我们 

1014
00:56:31,589 --> 00:56:36,610
比如说我们说，它看起来在主要点Ø 

1015
00:56:34,079 --> 00:56:38,940
第一，有给printf参考 

1016
00:56:36,799 --> 00:56:41,801
这是一个悬而未决的参考，因为 

1017
00:56:38,094 --> 00:56:42,683
打印输出不不在主点Ò定义

1018
00:56:41,819 --> 00:56:46,843
使云中的不确定列表 

1019
00:56:43,529 --> 00:56:51,529
在某一点或其他的引用和 

1020
00:56:47,059 --> 00:56:55,110
因为每个新0文件或点文件是 

1021
00:56:51,529 --> 00:56:57,130
遇到链接器会尝试 

1022
00:56:55,569 --> 00:56:58,617
解决其悬而未决的名单 

1023
00:56:57,013 --> 00:57:01,992
是与作为符号的引用

1024
00:56:59,049 --> 00:57:05,770
在该点o文件中定义或点文件 

1025
00:57:02,109 --> 00:57:07,134
然后如果有一个在任何条目 

1026
00:57:05,077 --> 00:57:09,118
名单在 扫描的末尾，则有 

1027
00:57:07,359 --> 00:57:11,740
错误好了，所以，关键是这里 

1028
00:57:10,018 --> 00:57:13,407
链接器将尝试解决 

1029
00:57:11,074 --> 00:57:16,163
从左至右这些引用

1030
00:57:13,569 --> 00:57:19,000
命令行 ，因此这是另一 

1031
00:57:16,829 --> 00:57:20,980
那种重要的事情你就 知道 

1032
00:57:19,000 --> 00:57:23,092
作为程序员，因为为了使 

1033
00:57:20,098 --> 00:57:24,166
你，你穿上你的文件 

1034
00:57:23,092 --> 00:57:27,115
命令行实际上有差别 

1035
00:57:25,066 --> 00:57:30,121
好了，你 可以得到几分怪异 

1036
00:57:28,015 --> 00:57:33,924
莫名其妙的链接错误，如果你，如果你使用

1037
00:57:31,021 --> 00:57:39,870
错误的顺序，以便例如假设 

1038
00:57:34,059 --> 00:57:44,380
我们已经有了一个函数的对象模块

1039
00:57:40,059 --> 00:57:50,290
叫库测试调用一个函数 

1040
00:57:44,038 --> 00:57:54,064
这是一个在和现场 周一 定义 好吗 

1041
00:57:50,029 --> 00:58:00,127
所以这些- L -比格·L时期，即 

1042
00:57:54,064 --> 00:58:03,097
说去找找库 

1043
00:58:01,027 --> 00:58:06,064
在当前目录中这是文件

1044
00:58:03,097 --> 00:58:07,138
什么点看那里， 然后再 

1045
00:58:06,064 --> 00:58:13,153
看在你看正常的地方 

1046
00:58:08,038 --> 00:58:16,102
而在-小写的L，这是一个很 

1047
00:58:14,053 --> 00:58:19,114
喜欢的缩写，我们可以更换 

1048
00:58:17,002 --> 00:58:23,091
这个只用全拼的 VID 

1049
00:58:20,014 --> 00:58:27,453
心是好的 ，但你会看到这本 

1050
00:58:23,109 --> 00:58:29,880
小写L中使用的很多，所以这样库测试

1051
00:58:27,579 --> 00:58:34,626
调用被声明在一个函数 

1052
00:58:29,088 --> 00:58:36,115
住心中有点的因此链接看 

1053
00:58:35,049 --> 00:58:39,126
它看起来在未解决的符号

1054
00:58:37,015 --> 00:58:41,184
库测试点O和它检测到 

1055
00:58:39,819 --> 00:58:44,410
有这个悬而未决的功能，让我们 

1056
00:58:41,319 --> 00:58:49,690
说这叫做foo我知道这是它的 

1057
00:58:44,041 --> 00:58:51,052
所谓盖的乐趣所以，它把它的 

1058
00:58:49,069 --> 00:58:53,958
列出， 然后 继续到 下一个 

1059
00:58:51,052 --> 00:58:57,094
命令行进入，这就是盖线 

1060
00:58:54,579 --> 00:59:01,380
点一，并在那里找到它找到 

1061
00:58:57,094 --> 00:59:03,963
现场的手机，它这个符号 

1062
00:59:01,038 --> 00:59:07,085
解析参照 该 - 盖 

1063
00:59:04,809 --> 00:59:10,760
电话- 实际 地址 

1064
00:59:07,085 --> 00:59:12,152
现在，如果我们切换搬迁地址

1065
00:59:10,076 --> 00:59:16,100
顺序 和我们我们把 LIB 心灵 上 

1066
00:59:13,052 --> 00:59:18,065
第一随后LIB 到 零以及 

1067
00:59:17,000 --> 00:59:20,024
还有的没有分辨的引用 

1068
00:59:18,065 --> 00:59:24,092
在这个库 的权利，它只是一个 

1069
00:59:20,024 --> 00:59:26,090
的函数定义集合，这样它 

1070
00:59:24,092 --> 00:59:27,188
有没有未解决的引用，这样的

1071
00:59:26,009 --> 00:59:30,020
连接着眼于这一切都很好， 

1072
00:59:28,088 --> 00:59:32,135
然后，它着眼于LIB 测试点 哦， 现在 

1073
00:59:31,001 --> 00:59:36,023
有一个未解决的参考，以

1074
00:59:33,035 --> 00:59:38,063
生活乐趣，但我们出门 ，我们的是在 

1075
00:59:36,023 --> 00:59:42,062
在命令 行 的结束 ，这样的的 

1076
00:59:38,063 --> 00:59:46,085
连接犯错，所以你得到这个你得到 这个 

1077
00:59:42,062 --> 00:59:48,065
真正神秘的错误消息，如果您 

1078
00:59:46,085 --> 00:59:52,123
不知道这个排序规则你 

1079
00:59:48,065 --> 00:59:52,123
不会有任何想法如何调试它 

1080
00:59:53,044 --> 00:59:57,098
好了，所以静态库是一种 

1081
00:59:56,057 --> 00:59:59,123
老式 的 解决方案是， 

1082
00:59:57,098 --> 01:00:04,121
现代的解决方案是使用动态 

1083
01:00:00,023 --> 01:00:07,061
库共享的共享库，以便 

1084
01:00:05,021 --> 01:00:09,077
之所以有这种原因

1085
01:00:07,061 --> 01:00:12,062
图书馆的新形式静 

1086
01:00:09,077 --> 01:00:16,163
图书馆有一些一些缺点

1087
01:00:12,062 --> 01:00:19,121
所以每次如果用静态编译 

1088
01:00:17,063 --> 01:00:22,076
库然后每家每户功能

1089
01:00:20,021 --> 01:00:24,044
使用打印出它或每隔的 

1090
01:00:22,076 --> 01:00:27,110
使用 printf的程序有有 

1091
01:00:24,044 --> 01:00:29,123
printf的副本还可以，但几乎每一个 

1092
01:00:28,001 --> 01:00:33,007
每一个程序使用printf的权利，使 

1093
01:00:30,023 --> 01:00:35,027
还有的共享共享库允许 

1094
01:00:33,016 --> 01:00:37,097
提供一种机制， 在那里他们可以只 

1095
01:00:35,027 --> 01:00:43,028
是一个只要有只有一个 

1096
01:00:37,097 --> 01:00:45,119
一个共享库成员的实例像 

1097
01:00:43,028 --> 01:00:47,096
像printf和和每个程序

1098
01:00:46,019 --> 01:00:50,023
在 系统 上 运行 将分享 

1099
01:00:47,096 --> 01:00:49,159
一个副本

1100
01:00:55,031 --> 01:00:59,114
所以这是这是那种大的大 

1101
01:00:58,019 --> 01:01:06,092
这种潜在的缺点

1102
01:01:00,014 --> 01:01:11,017
重复这样的共享库是 

1103
01:01:06,092 --> 01:01:10,117
在这个意义上，它们包含不同

1104
01:01:11,074 --> 01:01:16,118
代码和数据被链接和加载的 

1105
01:01:15,002 --> 01:01:20,054
进入程序 而不是当它不是时 

1106
01:01:17,018 --> 01:01:23,021
它的编译和链接，进入一个 

1107
01:01:20,054 --> 01:01:26,108
可执行目标文件 ，但实际上，当 

1108
01:01:23,048 --> 01:01:30,119
程序被加载 到系统中，以便 

1109
01:01:27,008 --> 01:01:34,019
共享库引用的链接

1110
01:01:31,019 --> 01:01:36,083
对象被推迟， 直到 程序 

1111
01:01:34,019 --> 01:01:38,117
实际上装入到内存中，直到 

1112
01:01:36,083 --> 01:01:40,181
可执行的 目标文件 实际上 是 

1113
01:01:39,017 --> 01:01:44,081
加载到存储器中，这既可以 

1114
01:01:41,081 --> 01:01:45,155
它甚至可能发生它可以发生 

1115
01:01:44,081 --> 01:01:48,097
当程序实际加载到 

1116
01:01:46,055 --> 01:01:51,128
内存，但它也可能发生在运行时 

1117
01:01:48,097 --> 01:01:53,152
随时在运行，所以你可能是你能 

1118
01:01:52,028 --> 01:01:57,076
正在运行 的程序和 程序 

1119
01:01:54,052 --> 01:01:59,120
可以任意 决定加载 

1120
01:01:57,076 --> 01:02:01,115
这是一个在共享声明功能

1121
01:02:00,002 --> 01:02:05,096
库好吧，我会告诉你 ，这是 

1122
01:02:02,015 --> 01:02:07,064
真的很酷，现在这些东西 往往 是 

1123
01:02:06,014 --> 01:02:09,080
叫他们是所谓的共享库 

1124
01:02:07,064 --> 01:02:12,095
他们是所谓的动态链接库 

1125
01:02:09,008 --> 01:02:13,097
如同在Windows中他们是所谓的DLL文件点 

1126
01:02:12,095 --> 01:02:16,120
ISO文件，它们都引用 

1127
01:02:14,069 --> 01:02:16,120
一样

1128
01:02:21,044 --> 01:02:26,049
还好，这样 就跟我 说，你可以 

1129
01:02:24,099 --> 01:02:28,170
动态链接时可出现 

1130
01:02:26,094 --> 01:02:34,013
程序的加载或它的加载后 

1131
01:02:29,007 --> 01:02:35,091
和实际运行 ，并有一个排序 

1132
01:02:34,859 --> 01:02:38,550
大的交易，共享库例程

1133
01:02:36,054 --> 01:02:39,120
可以由多个进程共享和 

1134
01:02:38,055 --> 01:02:41,055
我们来看看这个，这将是有意义

1135
01:02:40,002 --> 01:02:44,061
当我们看到 虚拟记忆，所以 

1136
01:02:41,055 --> 01:02:47,102
不是不担心 ，但现在却 

1137
01:02:44,079 --> 01:02:47,102
这里的过程如何 工作 

1138
01:02:49,076 --> 01:02:55,164
所以我们首先我们要创造，而不是

1139
01:02:53,094 --> 01:03:01,723
创建我们创建一个共享的归档 

1140
01:02:56,064 --> 01:03:07,089
库，所以我们 盖矢量程序 

1141
01:03:02,569 --> 01:03:10,624
而不是创建一个存档 文件，我们 

1142
01:03:07,089 --> 01:03:14,127
创建共享使用一个点iso文件 

1143
01:03:11,119 --> 01:03:17,970
使用共享参数 GCC 所以我们 

1144
01:03:15,027 --> 01:03:21,030
把我们的两个输入功能添加和扎克 

1145
01:03:17,097 --> 01:03:22,140
molbeck 并分享它说，创建和 

1146
01:03:21,003 --> 01:03:26,812
我们告诉GCC创建共享

1147
01:03:23,004 --> 01:03:30,068
库并将其放置在 现场博士。点 FO 

1148
01:03:27,109 --> 01:03:34,410
好吧所以还有还有，该 

1149
01:03:31,004 --> 01:03:36,081
在C中的C语言开发创建的 

1150
01:03:34,041 --> 01:03:39,090
称为库Ç共享库的功能 

1151
01:03:36,081 --> 01:03:43,155
使包含printf和所有与 

1152
01:03:39,009 --> 01:03:46,020
其他的标准库函数，所以我们

1153
01:03:44,055 --> 01:03:49,143
把我们的程序主 -这是一样的 

1154
01:03:47,001 --> 01:03:53,055
程序 调用 adzick和我们编译 

1155
01:03:50,043 --> 01:03:57,069
入主为零， 我们通过主 

1156
01:03:53,055 --> 01:04:02,100
到零，这些点S0文件到 

1157
01:03:57,069 --> 01:04:05,708
连接器提供了链接器不会在这

1158
01:04:03,000 --> 01:04:09,869
点它实际上并没有复制假设 

1159
01:04:06,329 --> 01:04:11,357
我们使用advic或printf的 它不 

1160
01:04:09,869 --> 01:04:14,894
实际上复制这些功能或做

1161
01:04:11,609 --> 01:04:17,400
他们中的任何可执行它 

1162
01:04:15,119 --> 01:04:21,140
只是让音符符号表

1163
01:04:17,004 --> 01:04:22,065
这些功能将需要的 

1164
01:04:21,329 --> 01:04:25,050
这些函数的引用将需要 

1165
01:04:23,001 --> 01:04:27,035
当程序得到解决

1166
01:04:25,005 --> 01:04:29,039
装好了，所以它 

1167
01:04:27,035 --> 01:04:31,123
它把在搬迁进入它说 

1168
01:04:29,039 --> 01:04:35,057
当你加载程序解决此问题的东西

1169
01:04:32,023 --> 01:04:37,112
所以它的部分链接，但它不是 

1170
01:04:35,057 --> 01:04:38,144
完全挂钩，你不能把你

1171
01:04:38,012 --> 01:04:43,043
不能把一个程序 

1172
01:04:39,044 --> 01:04:45,086
你不能把一个可执行 文件 

1173
01:04:43,043 --> 01:04:51,131
被动态链接和加载

1174
01:04:45,086 --> 01:04:53,177
直接你什么，你要做的就是 

1175
01:04:52,031 --> 01:04:56,036
装载机这是XX EE系统调用 

1176
01:04:54,077 --> 01:05:00,085
我们会更多地了解 这一点，但 只是 

1177
01:04:56,081 --> 01:05:03,103
这只是加载载荷一个SIS通话 

1178
01:05:00,085 --> 01:05:07,136
可执行文件到内存中，并运行它们 

1179
01:05:04,003 --> 01:05:14,042
装载机取可执行文件，然后 

1180
01:05:08,036 --> 01:05:15,101
它需要共享数据，使文件 

1181
01:05:14,042 --> 01:05:18,053
这个这个程序需要 

1182
01:05:16,001 --> 01:05:22,027
凯德 也取得了当连接也做了 

1183
01:05:18,053 --> 01:05:21,127
记下哪些数据，这样文件就需要 

1184
01:05:22,003 --> 01:05:28,079
所以加载器调用动态链接 

1185
01:05:26,015 --> 01:05:31,042
这需要那些DESO文件 ，然后 

1186
01:05:29,006 --> 01:05:35,050
实际上解析到的所有引用

1187
01:05:31,042 --> 01:05:39,083
任何未解决的引用 确定故 

1188
01:05:35,005 --> 01:05:43,031
advic附加VAC和printf的地址 

1189
01:05:39,083 --> 01:05:46,109
功能没有被确定直到 

1190
01:05:43,076 --> 01:05:48,101
程序被加载并且由它 

1191
01:05:47,009 --> 01:05:51,101
不是由动态链接程序确定 

1192
01:05:49,001 --> 01:05:53,066
直到程序被 加载， 使得 

1193
01:05:52,001 --> 01:05:55,058
动态链接程序它会经过一个

1194
01:05:53,066 --> 01:05:57,113
类似的过程，静态链接 

1195
01:05:55,058 --> 01:06:01,091
没有那种固定起来引用添加

1196
01:05:58,013 --> 01:06:05,051
回到引用给printf，然后

1197
01:06:01,091 --> 01:06:07,190
在这一点上的二进制二进制是 

1198
01:06:05,051 --> 01:06:11,470
在它是一种 形式的可 被 执行 

1199
01:06:08,009 --> 01:06:15,038
这样直接的问题 

1200
01:06:11,929 --> 01:06:17,012
它可我不 工作 

1201
01:06:15,929 --> 01:06:20,400
是的，你也会认真考虑，如果在底部 

1202
01:06:17,759 --> 01:06:21,824
您希望奇怪的是， 没有看 

1203
01:06:20,004 --> 01:06:29,028
你蓝紫看看你的手指 

1204
01:06:22,409 --> 01:06:31,474
和b0s如果没事的问题 是什么 

1205
01:06:29,064 --> 01:06:33,983
情况如果 包括文件，以便 

1206
01:06:32,059 --> 01:06:37,064
包括被由C处理

1207
01:06:34,559 --> 01:06:39,653
预处理所以他们走了 他们 

1208
01:06:37,109 --> 01:06:42,185
长由时间他们的时候了

1209
01:06:40,499 --> 01:06:44,501
链接得到解决它好了，所以在 

1210
01:06:42,869 --> 01:06:48,877
C预处理器只需要锋利的标志

1211
01:06:44,699 --> 01:06:51,746
限定尖锐符号包括与和

1212
01:06:49,669 --> 01:06:54,757
解释那些，并输出另一种C

1213
01:06:52,169 --> 01:06:58,214
程序，所以如果你，如果你有一个文件

1214
01:06:55,549 --> 01:07:02,606
C预处理器只需要该文件 

1215
01:06:58,619 --> 01:07:04,667
， 只是其扩展和输出 座 

1216
01:07:03,119 --> 01:07:08,134
程序中包含的扩展版本

1217
01:07:05,099 --> 01:07:08,116
所有你 包含的文件 

1218
01:07:11,009 --> 01:07:16,085
现在真正酷的 是，你 可以 

1219
01:07:15,065 --> 01:07:20,096
也做在运行时，这个动态链接

1220
01:07:17,066 --> 01:07:22,915
所以我向您展示我们在做之前 

1221
01:07:20,096 --> 01:07:27,685
它在加载时间，但你也可以 

1222
01:07:23,509 --> 01:07:31,515
擅自决定加载链接， 

1223
01:07:28,549 --> 01:07:35,420
根据从一个共享调用一个函数

1224
01:07:32,109 --> 01:07:38,990
从以点ISO定义的任何功能

1225
01:07:35,042 --> 01:07:42,171
文件，你做的方式是有一个

1226
01:07:38,099 --> 01:07:44,171
有一个名为DL开放的接口 

1227
01:07:42,549 --> 01:07:48,577
这是 在库ç，让你做 

1228
01:07:45,071 --> 01:07:51,116
这一点，让我们说 ，我们希望这是 

1229
01:07:48,829 --> 01:07:53,926
这是我们的主要程序，并就像 

1230
01:07:52,016 --> 01:07:57,092
之前，我们要调用adzick不错，但 

1231
01:07:54,799 --> 01:08:01,160
advic现在它定义在一个点异 

1232
01:07:57,092 --> 01:08:04,166
文件完全相同的点SL文件，我们 

1233
01:08:01,016 --> 01:08:07,094
当我们编译所以 之前生成

1234
01:08:05,066 --> 01:08:12,098
当我们编译我们将调用这个DLLÇ 

1235
01:08:07,094 --> 01:08:13,192
这个程序DLL C点，我们有没有我们

1236
01:08:12,098 --> 01:08:19,187
不知道这是怎么回事 调用 

1237
01:08:14,092 --> 01:08:23,144
从LIB DR功能。 D，使得我们 只 

1238
01:08:20,087 --> 01:08:26,626
编译为那些独立CC 

1239
01:08:24,044 --> 01:08:29,060
这个方案虽然我们计划之内 

1240
01:08:27,409 --> 01:08:31,498
声明指针的函数 指针 

1241
01:08:29,006 --> 01:08:35,995
所谓advic我们给原型 

1242
01:08:32,299 --> 01:08:39,440
这个函数指针， 它 使城市 

1243
01:08:36,589 --> 01:08:42,652
它的两个输入数组输出数组 

1244
01:08:39,044 --> 01:08:45,056
在尺寸，然后第一我们 

1245
01:08:43,219 --> 01:08:48,277
动态加载共享库

1246
01:08:45,056 --> 01:08:53,108
包含我们 希望，所以我们调用 函数 

1247
01:08:48,799 --> 01:08:56,851
DL开放的和我们说加载了这个这个点

1248
01:08:54,008 --> 01:09:01,837
。S L文件到内存中，这样我可以调用 

1249
01:08:57,319 --> 01:09:03,500
功能，但不解决，你知道 

1250
01:09:01,909 --> 01:09:04,963
不用担心不担心 

1251
01:09:03,005 --> 01:09:08,344
解析为函数的引用

1252
01:09:05,449 --> 01:09:13,520
直到我真正告诉你-这就是 

1253
01:09:08,839 --> 01:09:16,843
懒惰的一部分，所以什么什么这个交易

1254
01:09:13,052 --> 01:09:20,311
打开返回的句柄是，那么你 

1255
01:09:17,239 --> 01:09:22,270
在后续调用使用好了，所以如果 我们 

1256
01:09:20,779 --> 01:09:24,796
不，如果把手，因为没有有一些 

1257
01:09:22,549 --> 01:09:27,576
一种错误的喜欢，也许也许这个数据 

1258
01:09:24,949 --> 01:09:27,036
所以文件不存在

1259
01:09:28,006 --> 01:09:34,765
所以一旦我们开放数据，以便文件 

1260
01:09:30,739 --> 01:09:37,831
然后我们用DL厘米 ，手柄等等 

1261
01:09:34,819 --> 01:09:39,907
这一点，那么我们我们给它，因为我们通过 

1262
01:09:38,659 --> 01:09:45,560
字符串函数的名称 

1263
01:09:40,699 --> 01:09:47,755
我们要调用，我们得到了什么，我们得到 

1264
01:09:45,056 --> 01:09:50,965
从 L 回 送作为指针以 

1265
01:09:48,259 --> 01:09:52,324
该功能，然后我们可以，我们可以使用 

1266
01:09:51,469 --> 01:09:54,440
该功能就像任何其他 

1267
01:09:52,909 --> 01:09:56,690
功能，所以我们可以使用该功能 

1268
01:09:54,044 --> 01:09:58,111
指针我们称之为就像 艾拉 

1269
01:09:56,069 --> 01:10:00,167
它是静态定义的函数 

1270
01:09:59,011 --> 01:10:13,034
所以你可以看到这是真的很 

1271
01:10:01,067 --> 01:10:15,346
强大的技术好了，让我们，让我们 

1272
01:10:13,034 --> 01:10:17,126
完成课程 的最后一点 

1273
01:10:15,949 --> 01:10:19,940
我想 向你展示它试图说服 

1274
01:10:18,026 --> 01:10:21,071
您链接实际上是

1275
01:10:19,094 --> 01:10:29,173
有趣的是一种强买强卖的 

1276
01:10:21,071 --> 01:10:30,073
有时是 问题是 

1277
01:10:32,026 --> 01:10:38,102
没有它那怎么现在你只是它的 

1278
01:10:37,159 --> 01:10:42,320
它被声明为函数 指针和 

1279
01:10:39,002 --> 01:10:43,411
你，那么你只是你只是你 只需要使用 

1280
01:10:42,032 --> 01:10:46,103
该 函数 的名称

1281
01:10:43,429 --> 01:10:48,860
你必须取消 对它 的引用 ，或者你 

1282
01:10:47,003 --> 01:10:53,009
你怎么称呼它，你通过调用函数 

1283
01:10:48,086 --> 01:10:56,134
只是使用这项职能

1284
01:10:53,009 --> 01:10:57,034
指针名正确，就像我做

1285
01:11:00,709 --> 01:11:05,773
如果取消引用它，我只是拿回 

1286
01:11:03,017 --> 01:11:11,021
指针值你回来的地址 

1287
01:11:06,349 --> 01:11:15,170
该函数的所有权利，使的它是一种 

1288
01:11:11,057 --> 01:11:16,115
强买强卖 到 到公约 

1289
01:11:15,017 --> 01:11:20,056
联是有趣的，但 我会 

1290
01:11:17,015 --> 01:11:22,082
所以有有 此 尝试 确定 

1291
01:11:20,209 --> 01:11:25,240
叫库强大的技术 

1292
01:11:22,082 --> 01:11:27,751
间的定位和 目标是 

1293
01:11:25,519 --> 01:11:31,600
拦截功能从通话

1294
01:11:28,489 --> 01:11:35,533
图书馆，做一些拦截 

1295
01:11:32,329 --> 01:11:37,670
他们出于某种原因正确所以我们 

1296
01:11:35,929 --> 01:11:41,360
通常希望做的是拦截 

1297
01:11:37,067 --> 01:11:42,128
函数调用可能记录一些一些

1298
01:11:41,036 --> 01:11:46,315
统计或者做一些错误检查 和 

1299
01:11:43,028 --> 01:11:48,937
然后调用真正的功能如预期

1300
01:11:46,639 --> 01:11:55,880
右 所以这样的想法是，我们要 

1301
01:11:49,189 --> 01:11:58,340
创建包装和当程序 

1302
01:11:55,088 --> 01:11:58,537
当程序调用的函数 是什么 

1303
01:11:58,034 --> 01:12:03,133
我们要做的是我们要 

1304
01:11:59,329 --> 01:12:04,360
执行它的包装，而不是 很好，而且 

1305
01:12:03,439 --> 01:12:07,440
我们要做到这一点不改变 

1306
01:12:04,639 --> 01:12:06,720
任何来源的 

1307
01:12:10,024 --> 01:12:14,057
现在有很多 的原因 

1308
01:12:12,077 --> 01:12:17,174
有很多的这种应用 

1309
01:12:14,057 --> 01:12:21,125
是最巧妙的那些，我知道 

1310
01:12:18,074 --> 01:12:23,120
是这些 Facebook的 工程师如此 

1311
01:12:22,025 --> 01:12:26,086
我们正在努力解决这个问题长达一年 

1312
01:12:24,002 --> 01:12:28,067
博客在 Facebook 的 iPhone应用程序和 

1313
01:12:26,086 --> 01:12:31,121
没有人能弄清楚是怎么回事 

1314
01:12:28,085 --> 01:12:33,176
对 他们想通了利用图书馆 

1315
01:12:32,021 --> 01:12:36,086
间的定位 ，他们想通了， 

1316
01:12:34,076 --> 01:12:38,081
有什么东西在网络堆栈 

1317
01:12:36,086 --> 01:12:40,103
写入错误的位置，他们 

1318
01:12:38,081 --> 01:12:43,112
想通了拦截所有 

1319
01:12:41,003 --> 01:12:47,054
从他们的 Facebook应用程序，调用做 

1320
01:12:44,012 --> 01:12:50,054
权利所以像 向右 向右 

1321
01:12:47,054 --> 01:12:51,089
EP权利，使他们只是他们截获 

1322
01:12:50,054 --> 01:12:53,075
所有这些电话， 然后他们能 

1323
01:12:51,089 --> 01:12:54,110
当他们看着的参数和 

1324
01:12:53,075 --> 01:13:00,173
这些功能是如何被称为 

1325
01:12:55,001 --> 01:13:03,068
他们判断错误 ，你也可以 

1326
01:13:01,073 --> 01:13:04,091
用它来监控和分析一样 

1327
01:13:03,077 --> 01:13:06,101
所以，如果你想知道像多少 

1328
01:13:04,091 --> 01:13:09,182
时代不同的功能让你通话 

1329
01:13:07,001 --> 01:13:14,018
你可以可以做你可以设置我们使用 

1330
01:13:10,082 --> 01:13:16,157
它用于产生地址迹线，以便 

1331
01:13:14,018 --> 01:13:19,055
您马拉克当你做你的马利克实验室 

1332
01:13:17,057 --> 01:13:23,105
后来在学期你将成为 

1333
01:13:19,055 --> 01:13:25,118
评估使用的痕迹您马利克 

1334
01:13:24,005 --> 01:13:28,058
我们从实际的程序产生

1335
01:13:26,018 --> 01:13:30,101
使用这种间定位技术 

1336
01:13:28,058 --> 01:13:33,095
好了 ， 所以 我们大家对所有 的 输入后 

1337
01:13:31,001 --> 01:13:38,003
在如Netscape malloc和免费电话

1338
01:13:33,095 --> 01:13:41,147
ID，然后我们就记录什么 

1339
01:13:38,021 --> 01:13:45,047
地址和和尺寸马利克是为

1340
01:13:42,047 --> 01:13:47,063
返回，什么是什么块免费 

1341
01:13:45,047 --> 01:13:51,122
解放了，我们 刚刚创建的跟踪 

1342
01:13:47,063 --> 01:13:55,106
那些和再这么让我告诉你 

1343
01:13:52,022 --> 01:13:57,080
你会怎么做这样的想法，让我们 

1344
01:13:56,006 --> 01:14:00,038
比方说我们有这个主程序和 

1345
01:13:57,008 --> 01:14:01,043
想法是跟踪所有的malloc和free

1346
01:14:00,038 --> 01:14:04,043
调用所以有一个malloc调用和 

1347
01:14:02,015 --> 01:14:06,089
还有一个免费电话，我们希望

1348
01:14:04,088 --> 01:14:09,089
知道这些地址是和我们 

1349
01:14:06,089 --> 01:14:11,090
想知道这些尺寸，所以我们 

1350
01:14:09,098 --> 01:14:14,195
可以做到这一点编译时链接 

1351
01:14:11,099 --> 01:14:18,122
时间或运行时间去做编译 

1352
01:14:15,095 --> 01:14:21,110
一次，我们先写包装函数 

1353
01:14:19,022 --> 01:14:23,046
打电话给我的malloc和我的自由我的地方

1354
01:14:22,001 --> 01:14:25,008
malloc调用

1355
01:14:23,046 --> 01:14:28,128
真正的malloc函数，然后将其 

1356
01:14:25,008 --> 01:14:31,023
打印出的大小，它被称为 

1357
01:14:29,028 --> 01:14:34,092
和地址 malloc返回 

1358
01:14:31,095 --> 01:14:35,133
好了，所以这个时候我们运行它的程序 

1359
01:14:34,092 --> 01:14:36,186
将它打印出这些所有这些

1360
01:14:36,033 --> 01:14:41,100
地址和它做同样的事情 

1361
01:14:37,086 --> 01:14:46,181
自由 ，那么这里的malloc的诀窍 

1362
01:14:42,000 --> 01:14:51,024
我们定义的malloc ^ h我们是我的malloc 

1363
01:14:47,081 --> 01:14:52,110
还好和自由是我的自由，那么我们 

1364
01:14:51,024 --> 01:14:55,062
给原型它，因此 

1365
01:14:53,001 --> 01:14:58,038
编译器不会感到困惑，然后 

1366
01:14:55,062 --> 01:15:02,073
我们编译编译我的mallocÇ成 

1367
01:14:58,047 --> 01:15:07,052
点o文件，然后我们称之为星期，然后我们 

1368
01:15:02,073 --> 01:15:10,119
完成我们调用程序，该程序是 

1369
01:15:07,052 --> 01:15:14,055
我们的 内心主程序INT duxi 

1370
01:15:11,019 --> 01:15:18,033
定位和我们称之为和这里的 

1371
01:15:14,055 --> 01:15:21,057
我们与叫它的伎俩-盖 我 

1372
01:15:18,033 --> 01:15:23,040
争论和我们说一下对于任何包括 

1373
01:15:21,057 --> 01:15:29,123
在当前目录下好了，所以文件

1374
01:15:24,003 --> 01:15:34,098
这是类似于 L - CapTel 

1375
01:15:30,023 --> 01:15:37,032
的说法，但因为我们告诉GCC看

1376
01:15:34,098 --> 01:15:37,167
在当前目录第一所以这 

1377
01:15:37,032 --> 01:15:42,050
排序是其中 内定位 的 

1378
01:15:38,067 --> 01:15:46,122
发生在它，只是因为

1379
01:15:42,005 --> 01:15:48,081
它会它会找到它的 

1380
01:15:47,022 --> 01:15:52,026
要找到一个名为 的malloc ^ h 库 

1381
01:15:49,026 --> 01:15:55,067
我 的意思是 叫的malloc 点H A点.h文件 

1382
01:15:52,062 --> 01:15:57,111
因此所有的malloc调用会 

1383
01:15:55,067 --> 01:16:03,108
通过C预处理程序来翻译我的 

1384
01:15:58,011 --> 01:16:07,103
malloc的，所以当我们运行这个它打印 出 

1385
01:16:04,008 --> 01:16:07,103
该行程malloc和free 跟踪 

1386
01:16:08,007 --> 01:16:13,035
现在我们也可以在链接时这样做，所以 

1387
01:16:11,001 --> 01:16:16,077
我们可以告诉看到，为了 做到这一点，我们 

1388
01:16:13,098 --> 01:16:17,151
曾去访问，我们不得不 

1389
01:16:16,077 --> 01:16:20,142
编译 我们没有 给 程序 

1390
01:16:18,051 --> 01:16:23,057
改变它 ，但我们不得不编译我们 

1391
01:16:21,042 --> 01:16:28,079
可以使用链接时被 定位 

1392
01:16:24,011 --> 01:16:31,062
它避免 该该编译 

1393
01:16:28,079 --> 01:16:32,160
所以这种工作方式我们定义 

1394
01:16:31,062 --> 01:16:35,063
这个特殊的名字包装函数 

1395
01:16:33,006 --> 01:16:37,095
强调下划线包装malloc和 

1396
01:16:35,072 --> 01:16:41,163
这就叫真正的malloc函数和

1397
01:16:38,049 --> 01:16:44,088
然后打印出的信息， 然后 

1398
01:16:42,063 --> 01:16:47,106
在链接时，然后我们做了 间 

1399
01:16:44,088 --> 01:16:48,147
定位通过调用链接器

1400
01:16:48,006 --> 01:16:54,054
这个特殊的 

1401
01:16:49,047 --> 01:17:00,051
- WL参数，所以这是什么 一样的 

1402
01:16:54,054 --> 01:17:02,076
- WL标志GCC说哎采取什么 

1403
01:17:00,051 --> 01:17:05,142
得出如下参数或 

1404
01:17:02,076 --> 01:17:07,122
把所有的用逗号和空格

1405
01:17:06,042 --> 01:17:09,087
然后调用这个链接

1406
01:17:08,022 --> 01:17:12,057
争论好了，所以我们正在做的事情是 

1407
01:17:09,087 --> 01:17:15,179
传递一个连接参数的链接 

1408
01:17:12,057 --> 01:17:21,090
这- - 包装参数的链接 

1409
01:17:16,079 --> 01:17:22,176
它告诉连接器解决所有

1410
01:17:21,009 --> 01:17:25,062
引用的malloc下划线 

1411
01:17:23,076 --> 01:17:29,078
强调包装的malloc和所有

1412
01:17:26,043 --> 01:17:33,120
引用强调真正的malloc - 

1413
01:17:29,096 --> 01:17:34,173
应该被解析为malloc的好了， 

1414
01:17:34,002 --> 01:17:37,065
在我们调用程序的任何地方

1415
01:17:35,073 --> 01:17:39,084
MALLOC 它 会被解析为下划线 

1416
01:17:37,083 --> 01:17:41,085
强调包装的malloc，它会

1417
01:17:39,084 --> 01:17:45,093
调用我们的包装，然后包装 

1418
01:17:42,003 --> 01:17:51,015
调用真正的malloc这其中的原因

1419
01:17:46,074 --> 01:17:54,147
这个标志解析为实际的

1420
01:17:51,015 --> 01:17:57,030
常规的malloc现在在这里你还可以 在 

1421
01:17:55,047 --> 01:17:58,080
真的真的令人惊奇的 是 

1422
01:17:57,003 --> 01:18:01,041
你也可以做到 这间定位 

1423
01:17:58,008 --> 01:18:02,049
其 加载计时器，并且 当 运行 时间 

1424
01:18:01,068 --> 01:18:04,113
程序被 加载 ，所以你甚至不需要 

1425
01:18:03,021 --> 01:18:08,043
接入点O文件，所有你需要 

1426
01:18:05,013 --> 01:18:10,014
是获得可执行的权利和 

1427
01:18:08,043 --> 01:18:12,054
每一个程序 ，我们已经 获得了 

1428
01:18:10,014 --> 01:18:15,057
可执行这样想来，我们可以 

1429
01:18:12,054 --> 01:18:19,059
采取任何程序，我们可以设置在 

1430
01:18:15,057 --> 01:18:21,123
它的库调用在运行时 

1431
01:18:19,059 --> 01:18:25,074
所以我们这样做的方法是我们写的

1432
01:18:22,023 --> 01:18:29,064
包装函数现在 使用DL SIM卡 

1433
01:18:25,074 --> 01:18:31,101
调用我们以前看到我们称之为 

1434
01:18:29,064 --> 01:18:32,079
具有特殊功能的特殊 

1435
01:18:32,001 --> 01:18:37,086
参数来调用

1436
01:18:32,079 --> 01:18:39,093
接下来，我们银， 这是什么

1437
01:18:37,086 --> 01:18:42,090
说是得到真实的地址 

1438
01:18:39,093 --> 01:18:43,161
知识好了，而我们要去 

1439
01:18:43,026 --> 01:18:48,075
到我们要 欺骗连接到 

1440
01:18:44,061 --> 01:18:51,072
首先找我们我们的实现 

1441
01:18:48,075 --> 01:18:52,083
的malloc 但在这里 ， 我们要的是真正 一个 

1442
01:18:51,072 --> 01:18:54,168
所以 我们告诉它 去照照 

1443
01:18:53,055 --> 01:18:59,070
其次它的下一个地方，它 

1444
01:18:55,068 --> 01:19:01,086
一般看起来 与和取 

1445
01:18:59,007 --> 01:19:04,029
的malloc的地址，这样的结果是 

1446
01:19:01,086 --> 01:19:06,108
指针的函数指针叫 的malloc 

1447
01:19:04,092 --> 01:19:10,092
T和那么我们可以只调用 

1448
01:19:07,008 --> 01:19:14,073
函数获取调用 malloc的Lipsy 

1449
01:19:10,092 --> 01:19:17,184
然后打印出来的 数据好了，我们做 

1450
01:19:14,073 --> 01:19:20,141
免费同样的事情说我们用 DF米 

1451
01:19:18,084 --> 01:19:23,156
恰好自由以同样的方式和 

1452
01:19:21,041 --> 01:19:28,086
那么定位间现在会发生 

1453
01:19:24,056 --> 01:19:31,083
当程序被 加载 ，以便我们通知 

1454
01:19:28,086 --> 01:19:34,094
建立了这个我们的主程序现在 我们诠释 

1455
01:19:31,083 --> 01:19:37,134
在定位 运行时 ，我们建立了它 

1456
01:19:34,094 --> 01:19:41,132
很抱歉，我们创建了我们的点SL文件我 

1457
01:19:38,034 --> 01:19:46,083
马拉奇所以使用共享参数，并 

1458
01:19:42,032 --> 01:19:49,077
再然后我们我们编辑了INT INT点 

1459
01:19:46,083 --> 01:19:51,108
ç到这个可执行文件，称为INT R但 

1460
01:19:49,077 --> 01:19:55,152
注意有没有我的malloc提

1461
01:19:52,008 --> 01:19:58,035
点SL的任何地方，现在内 

1462
01:19:56,052 --> 01:20:04,068
定位发生在我们实际运行 

1463
01:19:58,035 --> 01:20:06,090
我们做我们 我们影响 程序 

1464
01:20:04,068 --> 01:20:10,115
内定位通过设置 

1465
01:20:06,009 --> 01:20:15,075
所谓LD预紧环境变量

1466
01:20:11,015 --> 01:20:18,036
我马拉奇某某好，这是一个 

1467
01:20:16,056 --> 01:20:21,093
环境变量来告诉我们 

1468
01:20:18,036 --> 01:20:24,042
动态链接看起来首位 

1469
01:20:21,093 --> 01:20:27,126
看重它首先考虑在LD的价值

1470
01:20:24,096 --> 01:20:29,100
预紧力的位置查找列表

1471
01:20:28,026 --> 01:20:32,115
首先在这些位置时解决

1472
01:20:30,036 --> 01:20:33,043
引用和仅只是后来在看 

1473
01:20:33,015 --> 01:20:36,070
该

1474
01:20:33,043 --> 01:20:38,110
系统正常的地方，这样我们在说 

1475
01:20:36,007 --> 01:20:40,102
看在我马利克点 SO4悬而未决 

1476
01:20:39,001 --> 01:20:43,039
引用，然后再然后我们

1477
01:20:41,065 --> 01:20:44,146
调用所以这不是来砸这是怎么了 

1478
01:20:43,048 --> 01:20:47,050
初始化环境变量

1479
01:20:45,046 --> 01:20:49,111
所以我们这初始化我马利克 

1480
01:20:47,068 --> 01:20:55,069
数据左右，然后我们加载和 

1481
01:20:50,011 --> 01:20:58,099
运行，以便所有的程序等等LD 

1482
01:20:55,069 --> 01:21:01,086
到马利克引用都被转换为 

1483
01:20:58,099 --> 01:21:04,198
引用到说唱功能 

1484
01:21:01,086 --> 01:21:10,141
我们在定义的函数马利克

1485
01:21:05,098 --> 01:21:11,191
我们计划好了，所以这是 一个原来是这样 

1486
01:21:11,041 --> 01:21:14,140
以使得 除定位是一个 

1487
01:21:12,091 --> 01:21:17,103
很酷的技术，它只是它的 

1488
01:21:15,004 --> 01:21:19,027
因为接头的唯一可能使 

1489
01:21:18,003 --> 01:21:22,015
好吧 那么好 

1490
01:21:19,063 --> 01:21:24,126
我们将在看到你在星期四和好 

1491
01:21:22,015 --> 01:21:25,026
祝你生活现金 

