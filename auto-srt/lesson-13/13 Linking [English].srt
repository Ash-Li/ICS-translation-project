1
00:00:00,000 --> 00:00:10,349
welcome good to see you today we're

2
00:00:05,004 --> 00:00:13,059
going to begin transitioning from how

3
00:00:10,349 --> 00:00:14,432
our program interact with hardware to

4
00:00:13,059 --> 00:00:17,088
how they interact with software in

5
00:00:15,179 --> 00:00:20,550
particular system software and we're

6
00:00:17,088 --> 00:00:21,497
going to start that investigation by by

7
00:00:20,055 --> 00:00:27,057
studying and learning about a process

8
00:00:22,289 --> 00:00:33,480
called linking which is how the system

9
00:00:27,075 --> 00:00:34,146
builds builds your program ok so we're

10
00:00:33,048 --> 00:00:36,137
going to study the the process of

11
00:00:35,046 --> 00:00:39,395
linking and then I'm going to show you a

12
00:00:37,037 --> 00:00:42,135
really cool technique called library

13
00:00:39,809 --> 00:00:45,450
inter positioning which it which allows

14
00:00:43,035 --> 00:00:49,050
you to use linking to actually intercept

15
00:00:45,045 --> 00:00:51,084
on function calls in in in libraries

16
00:00:49,005 --> 00:00:53,294
like the standard c library so it's a

17
00:00:51,084 --> 00:00:57,126
very very powerful interesting technique

18
00:00:53,789 --> 00:01:02,850
and it's all enabled by by linking so

19
00:00:58,026 --> 00:01:05,079
let's start with a simple program this

20
00:01:02,085 --> 00:01:10,170
program consists of two modules of name

21
00:01:05,079 --> 00:01:13,128
dot c and some dot c some dot c takes as

22
00:01:11,007 --> 00:01:16,466
an array as an argument and a length n

23
00:01:14,028 --> 00:01:20,100
and then it sums up the elements of that

24
00:01:17,159 --> 00:01:26,180
array and returns the sum back to the

25
00:01:21,000 --> 00:01:28,071
caller main dot c calls the sum function

26
00:01:26,018 --> 00:01:33,075
using and passes it a two element array

27
00:01:28,071 --> 00:01:37,104
of int and then returns that and then

28
00:01:33,075 --> 00:01:39,014
returns the value received from some we

29
00:01:38,004 --> 00:01:43,017
that that's kind of an odd thing to do

30
00:01:39,689 --> 00:01:45,000
to return your your exit status like

31
00:01:43,017 --> 00:01:46,113
that but we just did it so that the

32
00:01:45,000 --> 00:01:50,007
compiler would not devise the way all of

33
00:01:47,013 --> 00:01:51,078
our code i know let's look at what

34
00:01:50,007 --> 00:01:56,103
happens if when we want to compile those

35
00:01:51,078 --> 00:02:02,417
those two modules for each of main dot c

36
00:01:57,003 --> 00:02:07,020
and some duck see the GCC calls a series

37
00:02:03,119 --> 00:02:10,050
of translators on that on those modules

38
00:02:07,002 --> 00:02:13,004
on those ducks c files first calls the c

39
00:02:10,005 --> 00:02:13,040
preprocessor CPP

40
00:02:13,409 --> 00:02:20,920
then it calls the the compiler the

41
00:02:16,003 --> 00:02:23,682
actual compiler does which is CC one the

42
00:02:20,092 --> 00:02:27,094
compiler generates assembly which is

43
00:02:23,709 --> 00:02:31,870
then translated by the assembler AAS and

44
00:02:28,012 --> 00:02:35,014
resulting in a dot o file called main

45
00:02:31,087 --> 00:02:40,129
dot o similar things happens first for

46
00:02:35,014 --> 00:02:43,443
some dot C so after after the after

47
00:02:41,029 --> 00:02:47,648
these three translators work on the code

48
00:02:43,569 --> 00:02:51,569
we have two object files two dot o files

49
00:02:47,909 --> 00:02:57,430
the linker takes those those dot o files

50
00:02:51,569 --> 00:03:00,280
and put some link them together sort of

51
00:02:57,043 --> 00:03:05,112
smashes them together to form a single

52
00:03:00,028 --> 00:03:08,050
executable called that we can then run

53
00:03:06,012 --> 00:03:13,090
then we can then load and run on the

54
00:03:08,005 --> 00:03:15,954
system so the main dot C and some dots

55
00:03:13,009 --> 00:03:20,238
they are called source files these dot o

56
00:03:16,449 --> 00:03:24,280
files are our object files that we are

57
00:03:21,129 --> 00:03:25,218
separately compiled but and we call them

58
00:03:24,028 --> 00:03:29,106
relocatable object files because they

59
00:03:26,019 --> 00:03:36,024
can be combined together to form the

60
00:03:30,006 --> 00:03:37,545
fully linked executable object file so

61
00:03:36,069 --> 00:03:41,500
why do we do it like this you know why

62
00:03:37,599 --> 00:03:43,720
why do we allow the so-called separate

63
00:03:41,005 --> 00:03:45,954
compilation you know why don't we just

64
00:03:43,072 --> 00:03:48,076
have like one big you know one big file

65
00:03:46,449 --> 00:03:50,493
that was all of our code in it well

66
00:03:49,012 --> 00:03:53,017
there's a couple reasons the first is is

67
00:03:50,889 --> 00:03:55,908
modularity so by by allowing you to

68
00:03:53,062 --> 00:03:57,109
break your code into smaller pieces you

69
00:03:56,079 --> 00:04:00,135
can put related functions into separate

70
00:03:58,009 --> 00:04:03,106
source files you can define libraries of

71
00:04:00,639 --> 00:04:06,120
function so it's just it's just good

72
00:04:04,006 --> 00:04:09,905
technique and it allows you to kind of

73
00:04:06,012 --> 00:04:14,026
break your code up into nice - nice

74
00:04:09,959 --> 00:04:15,150
modular pieces the other reason is

75
00:04:14,026 --> 00:04:18,063
efficiency

76
00:04:15,015 --> 00:04:20,082
so if

77
00:04:18,063 --> 00:04:24,162
if we if we've broken up our program

78
00:04:20,082 --> 00:04:27,087
into multiple chunks if we change and if

79
00:04:25,062 --> 00:04:30,108
we if we only need to change one of the

80
00:04:27,087 --> 00:04:31,170
chunks we don't have to recompile the

81
00:04:31,008 --> 00:04:34,074
all the other all the other modules

82
00:04:32,007 --> 00:04:36,075
right we can just recompile the one

83
00:04:34,074 --> 00:04:38,103
module that we changed and then link

84
00:04:37,038 --> 00:04:42,135
them all together again right so it's

85
00:04:39,003 --> 00:04:45,006
it's efficient in time it's also

86
00:04:43,035 --> 00:04:48,042
efficient in space because you can take

87
00:04:45,006 --> 00:04:50,082
all of say all of the functions in the

88
00:04:49,005 --> 00:04:53,079
standard c library you could put them

89
00:04:50,082 --> 00:04:54,135
all together but then the only functions

90
00:04:53,079 --> 00:04:55,173
that you actually get compiled and

91
00:04:55,035 --> 00:04:59,039
linked into your program are the ones

92
00:04:56,073 --> 00:05:02,091
that you actually call okay so you can

93
00:04:59,075 --> 00:05:03,162
you can save space you don't you know

94
00:05:02,091 --> 00:05:08,094
normally you use only a small subset of

95
00:05:04,062 --> 00:05:10,098
the standard C functions and so there's

96
00:05:09,021 --> 00:05:12,048
no there's no point in linking all of

97
00:05:10,098 --> 00:05:14,151
those functions into your code if you

98
00:05:12,048 --> 00:05:18,057
don't need them all right so what are

99
00:05:15,051 --> 00:05:22,134
linkers do well there's two main there's

100
00:05:19,038 --> 00:05:26,124
two main tasks that linker performs the

101
00:05:23,034 --> 00:05:29,100
first is called symbol resolution so

102
00:05:27,024 --> 00:05:32,106
program define and reference symbols

103
00:05:30,000 --> 00:05:36,027
okay what the linker refers to as

104
00:05:33,006 --> 00:05:40,035
symbols and these are global variables

105
00:05:36,027 --> 00:05:43,083
and functions gain the names and those

106
00:05:40,035 --> 00:05:49,134
those objects they're referred to as a

107
00:05:43,083 --> 00:05:53,091
symbol so here we're declaring we're

108
00:05:50,034 --> 00:05:56,097
defining a symbol called swap here we're

109
00:05:54,063 --> 00:05:59,082
referring when we call swap we're

110
00:05:56,097 --> 00:06:02,190
referring to that symbol okay that's a

111
00:05:59,082 --> 00:06:05,157
reference to the symbol and here we're

112
00:06:03,009 --> 00:06:10,017
defining a pointer to an int called

113
00:06:06,057 --> 00:06:12,129
XP so we're defining XP and we're

114
00:06:10,098 --> 00:06:15,140
initializing it to the address of X so

115
00:06:13,029 --> 00:06:20,034
we're referring that's a reference to X

116
00:06:16,004 --> 00:06:23,013
okay so the symbol definitions are

117
00:06:20,034 --> 00:06:26,115
stored in the object file by the

118
00:06:23,049 --> 00:06:29,094
assembler in a symbol table which is an

119
00:06:27,015 --> 00:06:32,082
array of structs where each struck

120
00:06:29,094 --> 00:06:34,175
contains information about the symbol

121
00:06:32,082 --> 00:06:41,106
like the name of the symbol its size and

122
00:06:35,075 --> 00:06:44,127
where it's located now what we mean by

123
00:06:42,006 --> 00:06:48,104
symbol resolution is that during the

124
00:06:45,027 --> 00:06:52,089
linker blinking process the linker

125
00:06:49,004 --> 00:06:56,093
associates each symbol reference with

126
00:06:52,089 --> 00:07:00,093
exactly one symbol definition okay

127
00:06:56,093 --> 00:07:01,152
so it's possible and multiple you know

128
00:07:00,093 --> 00:07:03,168
why is this an issue well it's possible

129
00:07:02,052 --> 00:07:07,095
like in multiple modules you may declare

130
00:07:04,068 --> 00:07:09,075
a global variable with the same name the

131
00:07:07,095 --> 00:07:12,102
linker has to decide which one of those

132
00:07:09,075 --> 00:07:14,084
definitions to use for all subsequent

133
00:07:13,002 --> 00:07:15,065
references

134
00:07:15,098 --> 00:07:22,164
now once once the linker is associated a

135
00:07:20,024 --> 00:07:26,121
unique object with each a unique symbol

136
00:07:23,064 --> 00:07:28,116
definition with each reference then it

137
00:07:27,021 --> 00:07:32,022
does the second step which is relocation

138
00:07:29,016 --> 00:07:35,115
and during relocation it merges all of

139
00:07:32,022 --> 00:07:39,060
the modules together into a single into

140
00:07:36,015 --> 00:07:42,033
a single executable object module that

141
00:07:39,006 --> 00:07:45,012
can be directly loaded and executed on

142
00:07:42,033 --> 00:07:51,048
the system so when it when it when it

143
00:07:46,002 --> 00:07:54,021
does this merging it has to it has to

144
00:07:51,048 --> 00:07:55,143
figure out where each each symbol each

145
00:07:54,039 --> 00:07:58,065
function and each variable is going to

146
00:07:56,043 --> 00:08:02,076
be stored okay and this is called

147
00:07:58,065 --> 00:08:04,334
relocation because initially functions

148
00:08:02,076 --> 00:08:07,122
are just stored at some offset in their

149
00:08:04,919 --> 00:08:09,360
in their object module because the the

150
00:08:08,022 --> 00:08:10,095
linker doesn't know where those

151
00:08:09,036 --> 00:08:13,122
functions are actually going to be

152
00:08:10,095 --> 00:08:17,121
eventually a loaded into memory so

153
00:08:14,022 --> 00:08:20,100
before before relocation the address of

154
00:08:18,021 --> 00:08:24,230
a function in the object module is just

155
00:08:21,000 --> 00:08:27,009
its offset in the in the module and

156
00:08:24,419 --> 00:08:31,830
similarly for data during the relocation

157
00:08:27,009 --> 00:08:34,037
step the the linker decides on where

158
00:08:31,083 --> 00:08:37,086
each symbol is going to be ultimately

159
00:08:35,018 --> 00:08:41,061
located in memory one at X when the

160
00:08:37,086 --> 00:08:43,170
program executes and it binds that that

161
00:08:41,061 --> 00:08:47,073
those absolute memory locations to the

162
00:08:44,007 --> 00:08:48,066
to the symbol and then and then it goes

163
00:08:47,073 --> 00:08:51,120
and looks at all the references to those

164
00:08:49,029 --> 00:08:53,070
symbols and it updates those references

165
00:08:52,002 --> 00:08:54,066
so that they now they point to the

166
00:08:53,007 --> 00:08:56,070
correct address

167
00:08:54,084 --> 00:08:59,172
okay so figure out where stuff is going

168
00:08:57,033 --> 00:09:01,101
to go for each definition figure out

169
00:09:00,072 --> 00:09:03,099
where it's going to go and for each

170
00:09:02,001 --> 00:09:10,032
reference then update that reference so

171
00:09:03,099 --> 00:09:12,141
it now points to the right spot so let's

172
00:09:10,032 --> 00:09:15,093
look at what what these how these steps

173
00:09:13,041 --> 00:09:19,098
work in more detail before that we need

174
00:09:15,093 --> 00:09:20,169
to we need to define a few things so

175
00:09:19,098 --> 00:09:24,099
there's there's three kinds of object

176
00:09:21,069 --> 00:09:26,136
modules that I've alluded to there's the

177
00:09:24,099 --> 00:09:27,186
dot o file which is a relocatable object

178
00:09:27,036 --> 00:09:32,049
module this is the output of the

179
00:09:28,086 --> 00:09:33,129
assembler okay and it's it's not it's a

180
00:09:32,049 --> 00:09:36,131
binary file

181
00:09:34,029 --> 00:09:39,075
but it's not in any form that can be

182
00:09:37,031 --> 00:09:42,057
directly loaded into memory it needs to

183
00:09:39,075 --> 00:09:44,112
be manipulated by the linker before it

184
00:09:42,057 --> 00:09:46,095
can be actually used there's the

185
00:09:45,012 --> 00:09:50,070
executable object file which is

186
00:09:46,095 --> 00:09:52,188
generated by the linker these are called

187
00:09:50,007 --> 00:09:55,062
a doc files sometimes done historically

188
00:09:53,088 --> 00:09:57,135
the very first Linux systems the

189
00:09:56,025 --> 00:10:00,123
executable this sort of the default name

190
00:09:58,035 --> 00:10:03,063
that they the developers of UNIX used

191
00:10:01,023 --> 00:10:06,027
the default name for their executables

192
00:10:03,063 --> 00:10:08,094
as they dot out so that's that's just

193
00:10:06,027 --> 00:10:11,028
sort of a historical reason that it's

194
00:10:08,094 --> 00:10:13,119
it's called a dot out and then there's

195
00:10:11,037 --> 00:10:17,079
another type of object file called the

196
00:10:14,019 --> 00:10:22,031
shared object file or dot iso file which

197
00:10:17,079 --> 00:10:24,096
is a sort of modern a modern technique

198
00:10:22,031 --> 00:10:26,100
for creating shared libraries and we'll

199
00:10:24,096 --> 00:10:28,173
look at those we'll look at those later

200
00:10:27,000 --> 00:10:33,021
today now

201
00:10:29,073 --> 00:10:36,114
object modules come in a standard format

202
00:10:33,021 --> 00:10:39,084
called elf formats and it's a unified

203
00:10:37,014 --> 00:10:41,022
format for dot o files for executables

204
00:10:39,084 --> 00:10:47,148
and for dot iso files they all use the

205
00:10:41,094 --> 00:10:51,170
same format the same general format so

206
00:10:48,048 --> 00:10:55,056
this while these these elf binaries are

207
00:10:52,007 --> 00:10:57,074
their binaries they're very structured

208
00:10:55,056 --> 00:11:02,064
okay and they're broken up into section

209
00:10:58,037 --> 00:11:06,048
the at the beginning is the is a header

210
00:11:02,064 --> 00:11:09,069
that defines things like the size of the

211
00:11:06,048 --> 00:11:12,111
words the byte ordering whether it's a

212
00:11:09,069 --> 00:11:15,120
dot o and a dot out or a dot fo so it

213
00:11:13,011 --> 00:11:19,022
just provides them some sort of general

214
00:11:16,002 --> 00:11:21,003
information about this about this binary

215
00:11:19,022 --> 00:11:25,026
and then there's what's a so called

216
00:11:21,003 --> 00:11:27,024
segment header table which is it only

217
00:11:25,026 --> 00:11:30,033
it's only defined for the executable

218
00:11:27,051 --> 00:11:32,097
object files and it indicates where all

219
00:11:30,096 --> 00:11:34,119
the different segments of the code are

220
00:11:32,097 --> 00:11:37,098
going to go in in memory so where does

221
00:11:35,019 --> 00:11:38,097
your stack go where do your shared

222
00:11:37,098 --> 00:11:40,179
libraries go

223
00:11:38,097 --> 00:11:43,152
where does your your initialized and

224
00:11:41,079 --> 00:11:46,133
uninitialized data where does your code

225
00:11:44,052 --> 00:11:50,094
go right so all these all these various

226
00:11:47,033 --> 00:11:53,049
sections are defined in the segment

227
00:11:50,094 --> 00:11:55,143
header table and then there's the code

228
00:11:53,049 --> 00:11:58,122
itself which is is called the dot text

229
00:11:56,043 --> 00:12:04,076
section for sort of arcane historical

230
00:11:59,022 --> 00:12:07,095
reasons so dot text is always code and

231
00:12:04,076 --> 00:12:10,077
then that's followed by read-only data

232
00:12:07,095 --> 00:12:14,100
such as the jump tables in switch

233
00:12:10,077 --> 00:12:16,149
statements so text and and read only the

234
00:12:15,000 --> 00:12:19,038
dot text and ro data have the property

235
00:12:17,049 --> 00:12:22,053
that they're they're both read-only you

236
00:12:19,038 --> 00:12:26,084
don't write to them then that's followed

237
00:12:22,089 --> 00:12:28,164
by the data section which is contains

238
00:12:26,084 --> 00:12:31,113
space for all of your initialized global

239
00:12:29,064 --> 00:12:37,071
variables and then there's a section

240
00:12:32,013 --> 00:12:43,017
called VSS which contain which defines

241
00:12:38,034 --> 00:12:44,070
the uninitialized global variables now

242
00:12:43,017 --> 00:12:48,033
this doesn't actually take up any space

243
00:12:44,007 --> 00:12:49,044
because they're uninitialized rates okay

244
00:12:48,033 --> 00:12:54,105
but they're their entries in the symbol

245
00:12:50,007 --> 00:12:56,088
table for them and and it's at when this

246
00:12:55,005 --> 00:12:59,028
program gets loaded these variables are

247
00:12:56,088 --> 00:13:00,164
going to need they're actually going to

248
00:12:59,028 --> 00:13:04,125
have to have space allocated for them

249
00:13:01,064 --> 00:13:06,141
DFS is another one of those sort of

250
00:13:05,025 --> 00:13:09,084
arcane names that goes all the way back

251
00:13:07,041 --> 00:13:11,055
to the 60s for there's an idea of

252
00:13:09,084 --> 00:13:13,131
instruction called block started by

253
00:13:11,055 --> 00:13:16,098
symbol I think a better way to remember

254
00:13:14,031 --> 00:13:18,560
what it means is better safe space okay

255
00:13:16,098 --> 00:13:19,637
so you can if you have a separate

256
00:13:18,839 --> 00:13:23,010
section for the uninitialized variable

257
00:13:20,519 --> 00:13:25,230
since then initialized you don't have to

258
00:13:23,001 --> 00:13:33,140
you don't have to not have to consume

259
00:13:25,023 --> 00:13:34,116
any room in the in the dot o file ok

260
00:13:33,149 --> 00:13:38,850
there's also a section for the symbol

261
00:13:35,016 --> 00:13:43,029
table and this contained like I said

262
00:13:38,085 --> 00:13:48,138
it's an array of structs for procedures

263
00:13:43,029 --> 00:13:53,088
global variables and anything defined

264
00:13:49,038 --> 00:13:55,122
with the static attribute and each one

265
00:13:53,088 --> 00:13:58,787
of these each one of these symbols gets

266
00:13:56,022 --> 00:14:01,068
an entry in the symbol table and then

267
00:13:59,579 --> 00:14:03,584
there's two two sections called them

268
00:14:01,068 --> 00:14:07,071
that contain relocation info so this is

269
00:14:04,079 --> 00:14:10,290
the notes when that when the linker went

270
00:14:07,098 --> 00:14:11,387
and identified all the references to

271
00:14:10,029 --> 00:14:13,035
symbols it put a little note to say I'm

272
00:14:12,269 --> 00:14:16,770
going to have to remember to fix this

273
00:14:13,089 --> 00:14:20,118
the reference to the symbol up when I

274
00:14:16,077 --> 00:14:22,161
when I actually create the be executable

275
00:14:21,018 --> 00:14:26,037
so a relocation entry is just like a

276
00:14:23,061 --> 00:14:27,123
note that the linker or that it's a note

277
00:14:26,037 --> 00:14:29,816
that the assembler makes to the linker

278
00:14:28,023 --> 00:14:32,252
to say hey you're going to have to fix

279
00:14:30,149 --> 00:14:35,162
up this this reference because I don't

280
00:14:32,459 --> 00:14:36,600
know I don't know where this symbol is

281
00:14:35,279 --> 00:14:39,980
actually going to be stored in memory

282
00:14:36,006 --> 00:14:39,044
when it's when it's loaded

283
00:14:40,088 --> 00:14:47,151
okay and then there's a debug section

284
00:14:43,023 --> 00:14:52,035
that contains information that relates

285
00:14:48,051 --> 00:14:54,060
line numbers to in the source code to

286
00:14:52,035 --> 00:14:57,054
line numbers in the machine code okay

287
00:14:55,041 --> 00:14:58,104
and so this is called debug and this is

288
00:14:57,054 --> 00:15:01,056
what you get when you compile with dash

289
00:14:59,004 --> 00:15:04,055
G and then there's a header table that

290
00:15:01,074 --> 00:15:08,163
that tells you where all these different

291
00:15:04,055 --> 00:15:12,068
sections start now to a linker there's

292
00:15:09,063 --> 00:15:15,512
there's three different kinds of symbols

293
00:15:12,068 --> 00:15:18,156
global symbols are defined in some

294
00:15:16,079 --> 00:15:21,870
module m and they can and they can be

295
00:15:19,056 --> 00:15:24,275
used by other modules all right so I

296
00:15:21,087 --> 00:15:25,616
mean did you notice when we if we have a

297
00:15:24,779 --> 00:15:29,010
program that consists of multiple

298
00:15:26,399 --> 00:15:32,700
modules and we compile each one of those

299
00:15:29,001 --> 00:15:35,049
modules into a dot o file will be

300
00:15:32,007 --> 00:15:37,013
calling functions that aren't defined

301
00:15:35,049 --> 00:15:41,018
that are defined by other modules right

302
00:15:38,003 --> 00:15:43,077
okay so those but there's no error

303
00:15:41,459 --> 00:15:45,660
though that the compiler doesn't doesn't

304
00:15:44,004 --> 00:15:47,097
throw an error because it's assuming

305
00:15:45,066 --> 00:15:49,161
that those are defined in other modules

306
00:15:47,097 --> 00:15:52,098
and it assumes the linker will be able

307
00:15:50,061 --> 00:15:56,540
to find them in and determine the

308
00:15:53,007 --> 00:16:01,010
address so anything that's defined with

309
00:15:57,089 --> 00:16:05,310
any global either either global variable

310
00:16:01,037 --> 00:16:08,055
or a function name that's defined

311
00:16:05,031 --> 00:16:12,129
without the static attribute is a global

312
00:16:08,055 --> 00:16:14,093
symbol okay now and then external

313
00:16:13,029 --> 00:16:17,082
symbols are kind of a flipside of that

314
00:16:14,093 --> 00:16:19,167
external symbols are symbols that are

315
00:16:17,082 --> 00:16:24,087
referenced by some module but defined in

316
00:16:20,067 --> 00:16:26,139
some other module okay so in our in our

317
00:16:24,087 --> 00:16:29,148
in our little running example when when

318
00:16:27,039 --> 00:16:33,548
main dot C called the function sum it

319
00:16:30,048 --> 00:16:35,106
was referencing an external symbol okay

320
00:16:33,899 --> 00:16:38,670
and then there's there's local symbols

321
00:16:36,006 --> 00:16:44,007
and these are symbols that are defined

322
00:16:38,067 --> 00:16:45,141
and referenced within a module okay and

323
00:16:44,007 --> 00:16:48,060
those you create that this is not this

324
00:16:46,041 --> 00:16:51,075
is different from local variables okay

325
00:16:48,006 --> 00:16:52,101
the linker you know local c variables

326
00:16:51,075 --> 00:16:55,158
are

327
00:16:53,055 --> 00:17:00,060
managed by the compiler on the stack

328
00:16:56,058 --> 00:17:02,627
linker has no idea about local local see

329
00:17:01,005 --> 00:17:05,037
variables okay in this context when we

330
00:17:03,149 --> 00:17:08,760
talk about a local symbol what we're

331
00:17:05,037 --> 00:17:11,055
talking about is is either is a global a

332
00:17:08,076 --> 00:17:14,765
global variable or function declared

333
00:17:11,055 --> 00:17:16,077
with the static attribute whose that can

334
00:17:15,449 --> 00:17:19,100
only be referenced from within that

335
00:17:16,077 --> 00:17:21,896
module so we say that the scope the

336
00:17:19,001 --> 00:17:24,014
scope of the func function or global

337
00:17:22,589 --> 00:17:26,910
variable defines what the static

338
00:17:24,023 --> 00:17:31,029
attribute is limited to the module that

339
00:17:26,091 --> 00:17:34,137
it was defined in okay so this is in C

340
00:17:31,029 --> 00:17:37,050
this is how we do abstraction and this

341
00:17:35,037 --> 00:17:40,110
is how we can create sort of private

342
00:17:37,005 --> 00:17:43,029
functions that and pup private functions

343
00:17:41,001 --> 00:17:47,007
that can't be called from from outside

344
00:17:43,074 --> 00:17:50,133
that module okay so for instance if we

345
00:17:47,007 --> 00:17:51,081
want to make a library in C of functions

346
00:17:51,033 --> 00:17:54,087
we want to make a collection of

347
00:17:52,044 --> 00:17:57,063
functions that other programs can then

348
00:17:54,087 --> 00:18:00,135
call and link into their program and

349
00:17:57,063 --> 00:18:05,139
call the functions that we want to make

350
00:18:01,035 --> 00:18:08,097
visible to to other programs are defined

351
00:18:06,039 --> 00:18:10,071
without the static attribute and the

352
00:18:08,097 --> 00:18:13,116
functions that we want to have private

353
00:18:10,071 --> 00:18:16,095
and just be internal we declare what the

354
00:18:14,016 --> 00:18:19,022
static attribute and that way we get

355
00:18:16,095 --> 00:18:20,954
abstraction and we get hiding

356
00:18:19,022 --> 00:18:25,047
information hiding and we're only

357
00:18:21,809 --> 00:18:30,270
exposing data and functions that that we

358
00:18:25,047 --> 00:18:31,074
want that we want to expose all right so

359
00:18:30,027 --> 00:18:35,046
let's look in detail how the symbol

360
00:18:31,074 --> 00:18:39,763
resolution step works we recall our

361
00:18:35,046 --> 00:18:40,015
example our example program

362
00:18:41,019 --> 00:18:49,598
so here we're referencing a global

363
00:18:43,799 --> 00:18:55,802
called array that's defined within Maine

364
00:18:49,769 --> 00:19:04,802
dot see here when we here we're defining

365
00:18:56,099 --> 00:19:07,115
Maine a global called Maine here we're

366
00:19:05,099 --> 00:19:13,950
referencing a global called some that's

367
00:19:07,259 --> 00:19:15,347
defined in some dot C and Val is a local

368
00:19:13,095 --> 00:19:16,095
C variable on the stack and linker knows

369
00:19:16,139 --> 00:19:21,143
nothing about that

370
00:19:16,095 --> 00:19:25,119
okay now nor does it know anything about

371
00:19:21,539 --> 00:19:29,570
IRS which are also local variables now

372
00:19:26,019 --> 00:19:32,128
let's just let's make sure that we

373
00:19:29,849 --> 00:19:34,856
understand the difference between local

374
00:19:32,299 --> 00:19:40,440
static C variables versus local non

375
00:19:35,549 --> 00:19:43,592
static C variables so here we're

376
00:19:40,044 --> 00:19:49,463
defining a local static variable called

377
00:19:43,979 --> 00:19:52,994
int within this function f now because

378
00:19:49,859 --> 00:19:57,090
it's local its scope is limited to this

379
00:19:53,129 --> 00:20:00,214
function so this variable X can only be

380
00:19:57,009 --> 00:20:06,188
referenced within function f and

381
00:20:00,979 --> 00:20:10,590
similarly for this definition of X and

382
00:20:06,269 --> 00:20:14,285
function G can only be referenced by by

383
00:20:10,059 --> 00:20:15,638
function G now what's but because it's

384
00:20:14,429 --> 00:20:18,690
declared with the static attribute it's

385
00:20:16,169 --> 00:20:21,206
not stored on the stack it's actually

386
00:20:18,069 --> 00:20:23,073
stored in in the in dot data just like a

387
00:20:21,539 --> 00:20:25,595
global would be so it's it's like a

388
00:20:24,009 --> 00:20:30,218
global in a sense that it's actually

389
00:20:26,099 --> 00:20:31,166
stored in data rather than the stack but

390
00:20:30,299 --> 00:20:34,304
it's like a local C variable in the

391
00:20:31,769 --> 00:20:36,806
sense that its scope is limited just to

392
00:20:34,349 --> 00:20:40,424
the function that it's defined in so

393
00:20:37,139 --> 00:20:43,710
what what the compiler will do it will

394
00:20:41,099 --> 00:20:46,105
allocate space for each definition of X

395
00:20:43,071 --> 00:20:47,157
so this and it'll give it some name to

396
00:20:46,159 --> 00:20:51,182
disambiguate it so maybe it will call

397
00:20:48,057 --> 00:20:52,106
this one X dot 1 and maybe this one X

398
00:20:51,389 --> 00:20:57,050
dot 2

399
00:20:53,006 --> 00:20:59,009
so these symbols are allocated in dot

400
00:20:57,005 --> 00:21:00,101
data because because they're initialized

401
00:20:59,009 --> 00:21:08,072
and they get symbol table entries just

402
00:21:01,001 --> 00:21:11,096
like just like any other symbol okay so

403
00:21:08,072 --> 00:21:14,078
I said that during symbol resolution the

404
00:21:11,096 --> 00:21:18,097
linker associates each reference each

405
00:21:14,078 --> 00:21:21,155
symbol reference to exactly one unique

406
00:21:18,097 --> 00:21:23,120
symbol definition now how does it do

407
00:21:22,055 --> 00:21:29,057
that if there's multiple symbol

408
00:21:24,002 --> 00:21:32,057
definitions across all the modules so to

409
00:21:29,057 --> 00:21:34,121
understand this will will will will

410
00:21:32,075 --> 00:21:37,081
define symbols as being either strong or

411
00:21:35,021 --> 00:21:42,026
weak so strong symbols are either

412
00:21:38,035 --> 00:21:45,089
procedures or function function names or

413
00:21:42,026 --> 00:21:49,058
initialize global variables weak symbols

414
00:21:45,089 --> 00:21:53,174
or uninitialized global variables okay

415
00:21:49,058 --> 00:21:56,060
so int foo here is a strong symbol

416
00:21:54,074 --> 00:21:58,127
because it's initialized we're

417
00:21:56,006 --> 00:22:04,007
initializing it p1 is strong by

418
00:21:59,027 --> 00:22:08,053
definition foo is is weak in p2 dot C of

419
00:22:04,007 --> 00:22:10,088
this this definition of foo is weak

420
00:22:08,053 --> 00:22:13,145
because it's uninitialized and the

421
00:22:11,051 --> 00:22:16,139
definition of p2 is strong okay so that

422
00:22:14,045 --> 00:22:20,129
the rules that the velinkar uses are the

423
00:22:17,039 --> 00:22:24,068
following multiple strong symbols not

424
00:22:21,029 --> 00:22:27,065
allowed so that's an error okay

425
00:22:24,068 --> 00:22:28,157
so that means that if we if across

426
00:22:27,065 --> 00:22:30,161
multiple modules we declare a function

427
00:22:29,057 --> 00:22:34,081
with the same name the linker will will

428
00:22:31,061 --> 00:22:34,063
throw an error that's not allowed

429
00:22:35,053 --> 00:22:40,058
given a strong symbol and multiple weak

430
00:22:38,024 --> 00:22:45,032
symbols if the linker will always choose

431
00:22:40,058 --> 00:22:51,083
the strong symbol now remember if we

432
00:22:46,004 --> 00:22:54,077
initialize a global variable and we if

433
00:22:51,083 --> 00:22:55,142
we declare a initialized global variable

434
00:22:54,077 --> 00:22:57,128
across multiple modules that's an error

435
00:22:56,042 --> 00:23:00,050
because those are strong symbols okay by

436
00:22:58,028 --> 00:23:02,111
rule one but if we have one strong

437
00:23:01,022 --> 00:23:05,036
symbol and multiple weak symbols all

438
00:23:03,011 --> 00:23:06,014
with the same name then the compiler

439
00:23:05,036 --> 00:23:09,065
will choose the

440
00:23:06,041 --> 00:23:11,126
strong symbol okay and it will associate

441
00:23:09,065 --> 00:23:14,120
all references to that symbol will go to

442
00:23:12,026 --> 00:23:16,067
that strong symbol and if there's

443
00:23:15,002 --> 00:23:18,089
multiple weeks in both then it just

444
00:23:16,067 --> 00:23:19,142
picks an arbitrary one and this thisthis

445
00:23:19,007 --> 00:23:23,021
will see can be problematic

446
00:23:20,042 --> 00:23:26,138
now you can override it with this GCC

447
00:23:23,021 --> 00:23:29,033
flag called no common and if you if you

448
00:23:27,038 --> 00:23:32,093
declare your function with this no

449
00:23:29,033 --> 00:23:35,033
common argument then multiple weak

450
00:23:32,093 --> 00:23:36,182
symbols will throw an error in the

451
00:23:35,033 --> 00:23:39,047
linker all right so why do we care about

452
00:23:37,082 --> 00:23:40,160
all this stuff well it turns out if

453
00:23:39,047 --> 00:23:43,088
you're not aware of this stuff you can

454
00:23:41,006 --> 00:23:45,071
you can run into some really serious

455
00:23:43,088 --> 00:23:48,146
problems that are just perplexing and

456
00:23:46,025 --> 00:23:51,053
confounding right so linker linker

457
00:23:49,046 --> 00:23:52,139
errors are like the worst kind they're

458
00:23:51,053 --> 00:23:54,056
the hardest kind of debug because people

459
00:23:53,039 --> 00:23:58,058
aren't usually aware of what's going on

460
00:23:54,083 --> 00:23:59,149
inside their linkers and usually it's

461
00:23:58,058 --> 00:24:03,125
only like the very best programmers that

462
00:24:00,049 --> 00:24:05,111
really understand you know how these

463
00:24:04,025 --> 00:24:08,081
linkers work and what kind of errors

464
00:24:06,011 --> 00:24:12,056
they can throw and how to debug them so

465
00:24:08,081 --> 00:24:15,134
let me show you some examples of these

466
00:24:12,056 --> 00:24:18,113
these kind of errors all right so we

467
00:24:16,034 --> 00:24:21,043
have a program we've worked we have two

468
00:24:19,013 --> 00:24:24,044
modules so each of these rectangles

469
00:24:21,043 --> 00:24:28,121
corresponds to a module and we're

470
00:24:24,044 --> 00:24:33,103
defining p1 in each module so that's too

471
00:24:29,021 --> 00:24:33,103
strong symbols that's an error okay

472
00:24:35,014 --> 00:24:42,082
now here we were defining p1 and p2 so

473
00:24:40,003 --> 00:24:45,096
we're okay but now we've got two week

474
00:24:42,082 --> 00:24:50,089
symbols both are integers variables

475
00:24:45,096 --> 00:24:52,105
called X so and if these modules are

476
00:24:51,052 --> 00:24:55,120
referencing X the linker will just pick

477
00:24:53,086 --> 00:25:01,102
it we'll just pick one of these to serve

478
00:24:56,002 --> 00:25:05,011
as the definition but is this really

479
00:25:02,002 --> 00:25:07,021
what you want now in this case it

480
00:25:05,029 --> 00:25:09,058
doesn't really hurt anything because X

481
00:25:07,021 --> 00:25:12,094
is declared in both modules is an int

482
00:25:09,058 --> 00:25:17,095
all right so it'll just be it'll just be

483
00:25:12,094 --> 00:25:20,143
some integer sized variable that and it

484
00:25:17,095 --> 00:25:22,147
will be it'll be somewhere and but it

485
00:25:21,043 --> 00:25:26,077
doesn't really matter which which one

486
00:25:23,047 --> 00:25:28,111
the linker chooses but we start to get

487
00:25:26,077 --> 00:25:33,160
into trouble if we declare these weak

488
00:25:29,011 --> 00:25:36,082
symbols with different types so here

489
00:25:34,006 --> 00:25:42,028
we've declared an int X in one module

490
00:25:36,082 --> 00:25:45,085
and a double X in another module so if

491
00:25:42,082 --> 00:25:48,145
we write to X if the linker just

492
00:25:45,085 --> 00:25:52,087
arbitrarily chooses this this symbol

493
00:25:49,045 --> 00:26:00,106
definition to use now this is a symbol

494
00:25:52,087 --> 00:26:02,152
that of length 8 of size 8 if we

495
00:26:01,006 --> 00:26:05,041
anywhere in this program if we if the

496
00:26:03,052 --> 00:26:08,143
linker chooses that then anywhere in the

497
00:26:05,041 --> 00:26:11,080
program those references to those

498
00:26:09,043 --> 00:26:17,047
references to X will be to this double

499
00:26:11,008 --> 00:26:19,102
word this double word even even in this

500
00:26:17,083 --> 00:26:24,088
module if we reference X it'll be an 8

501
00:26:20,074 --> 00:26:26,109
byte right so it will overwrite Y with

502
00:26:24,088 --> 00:26:26,109
the

503
00:26:28,097 --> 00:26:42,151
hi order excuse me oh no it's completely

504
00:26:41,049 --> 00:26:50,100
its system it'll just pick one

505
00:26:43,051 --> 00:26:50,100
arbitrarily and you don't know I mean it

506
00:26:52,929 --> 00:26:59,500
alright here's now this is uh here's the

507
00:26:56,009 --> 00:27:01,091
problem we've defined a strong symbol X

508
00:26:59,005 --> 00:27:05,554
because we initialize it so the linker

509
00:27:02,072 --> 00:27:09,109
will always will associate all

510
00:27:06,049 --> 00:27:19,840
references to X to this integer size

511
00:27:10,009 --> 00:27:19,084
this integer sized symbol so if we write

512
00:27:28,041 --> 00:27:37,125
oh yeah right so so rights to X here

513
00:27:35,057 --> 00:27:40,128
this will be a double in this module but

514
00:27:38,025 --> 00:27:43,103
it will overwrite Y in this module so

515
00:27:41,028 --> 00:27:43,103
that's really nasty

516
00:27:47,088 --> 00:27:53,143
and here we were defining a strong

517
00:27:51,016 --> 00:27:58,087
symbol X so references to X in the

518
00:27:54,043 --> 00:28:00,064
second module will always get it will

519
00:27:58,087 --> 00:28:03,118
refer to this initialized variable which

520
00:28:00,064 --> 00:28:07,090
might not so it might not be what you

521
00:28:04,018 --> 00:28:12,025
want you may you may be assuming that

522
00:28:07,009 --> 00:28:14,050
it's uninitialized in your code okay and

523
00:28:12,088 --> 00:28:17,125
then you get the the ultimate nightmare

524
00:28:15,031 --> 00:28:19,129
scenario suppose you know because we're

525
00:28:18,025 --> 00:28:21,103
following a standard adi we can compile

526
00:28:20,029 --> 00:28:24,058
our code with multiple compilers and

527
00:28:22,003 --> 00:28:36,072
this actually happens in some oh yes

528
00:28:24,058 --> 00:28:38,116
questions oh yeah actually you're right

529
00:28:36,072 --> 00:28:41,077
it will it will still take preference

530
00:28:39,016 --> 00:28:43,078
and you'd be writing a for by quantity

531
00:28:41,077 --> 00:28:51,163
which is is what you want so that slides

532
00:28:43,078 --> 00:28:54,136
not quite right so yeah what is the

533
00:28:52,063 --> 00:28:57,085
point of doing that expert is not that

534
00:28:55,036 --> 00:28:59,101
it is always being reference just

535
00:28:57,085 --> 00:29:02,113
locally in your function what is the

536
00:29:00,001 --> 00:29:07,003
point of declaring it back is it

537
00:29:03,013 --> 00:29:10,044
distorted in like so no no no it's if

538
00:29:07,021 --> 00:29:14,029
you reference up if you reference a a

539
00:29:10,044 --> 00:29:18,072
variable that's you need so a variable

540
00:29:14,029 --> 00:29:18,072
its defined in your module and then you

541
00:29:18,084 --> 00:29:28,120
with the static right oh they're both

542
00:29:25,054 --> 00:29:32,143
they're both local so you do this if you

543
00:29:29,002 --> 00:29:34,009
want a value to retain from if you want

544
00:29:33,043 --> 00:29:38,074
if you want that variable to retain

545
00:29:34,009 --> 00:29:40,075
value from in locations in location so

546
00:29:38,074 --> 00:29:42,118
suppose you it's usually a bad idea as

547
00:29:41,056 --> 00:29:45,064
we'll see when we study threads because

548
00:29:43,018 --> 00:29:49,023
it makes your code non thread safe but

549
00:29:46,036 --> 00:29:52,081
like early like random number generators

550
00:29:49,068 --> 00:29:54,073
would it would compute a pseudo-random

551
00:29:52,081 --> 00:29:56,170
number and then it would store it in a

552
00:29:55,018 --> 00:29:59,112
static variable and then use that as the

553
00:29:57,007 --> 00:30:01,068
starting value for the next the neck

554
00:30:00,012 --> 00:30:04,020
time you called that function so

555
00:30:02,031 --> 00:30:06,075
whenever you want values to persist

556
00:30:04,092 --> 00:30:09,092
across function invocation to reduce

557
00:30:06,075 --> 00:30:09,092
static yes

558
00:30:25,002 --> 00:30:32,025
well win it let me let me get this

559
00:30:28,053 --> 00:30:35,079
straight right 2x + t2 will actually

560
00:30:32,043 --> 00:30:37,080
correspond to the memory look that will

561
00:30:35,079 --> 00:30:42,176
actually go to the memory location I'm

562
00:30:37,008 --> 00:30:47,097
sorry I I need to amend that so write 2x

563
00:30:43,076 --> 00:30:50,085
in t2 will be 8 bytes because the

564
00:30:48,069 --> 00:30:53,106
compiler you know the compiler knows

565
00:30:50,085 --> 00:30:59,094
that it's a double but it'll go to a

566
00:30:54,006 --> 00:31:02,085
memory location that I that's only 4

567
00:30:59,094 --> 00:31:05,130
bytes because X because the linker chose

568
00:31:02,085 --> 00:31:08,093
the strong symbol okay so so the rights

569
00:31:06,003 --> 00:31:11,066
to X and T 2 will actually overwrite Y

570
00:31:08,093 --> 00:31:11,093
ok

571
00:31:12,096 --> 00:31:33,111
I'm sorry yes question that's just

572
00:31:24,059 --> 00:31:37,830
usually the way it happens you know no

573
00:31:34,011 --> 00:31:40,026
no no global variables go in in dot data

574
00:31:37,083 --> 00:31:40,092
they don't go on the stack but usually

575
00:31:40,026 --> 00:31:43,101
if you define local variables in a

576
00:31:41,073 --> 00:31:44,151
function it will put them it will

577
00:31:44,001 --> 00:31:52,046
allocate them one after the other on

578
00:31:45,051 --> 00:31:51,146
their on the stack okay

579
00:31:53,018 --> 00:31:57,025
all right so all this discussion about

580
00:31:57,043 --> 00:32:02,078
these weird strong weak symbol rules

581
00:32:00,038 --> 00:32:07,046
that the linker have it's another reason

582
00:32:02,078 --> 00:32:10,163
to avoid global variables if you can if

583
00:32:08,018 --> 00:32:12,101
you if you need to declare a global see

584
00:32:11,063 --> 00:32:14,147
if you can declare it static because

585
00:32:13,001 --> 00:32:17,054
that'll limited scope to the the module

586
00:32:15,047 --> 00:32:19,112
that it's declared in so that's a good

587
00:32:17,054 --> 00:32:23,066
idea if you can do it and if you define

588
00:32:20,012 --> 00:32:25,073
a global variable initialize it so that

589
00:32:23,066 --> 00:32:28,148
you'll you'll you'll find you'll

590
00:32:25,073 --> 00:32:30,116
discover if you have multiple initialize

591
00:32:29,048 --> 00:32:35,051
global symbols with the same name in

592
00:32:31,016 --> 00:32:36,068
your code and then if you want to it's

593
00:32:35,051 --> 00:32:38,135
always good practice if you're

594
00:32:36,068 --> 00:32:40,070
referencing an external variable to tell

595
00:32:39,035 --> 00:32:47,093
the compiler about it by using the

596
00:32:40,088 --> 00:32:48,176
extern attribute all right so now at

597
00:32:47,093 --> 00:32:52,130
this point the linker has associated

598
00:32:49,076 --> 00:32:55,145
every symbol reference with some symbol

599
00:32:53,003 --> 00:32:58,082
definition now it has to take all those

600
00:32:56,045 --> 00:33:01,048
object relocatable object files and

601
00:32:59,009 --> 00:33:06,092
smush them together and create like one

602
00:33:01,048 --> 00:33:10,055
one big executable so suppose with our

603
00:33:06,092 --> 00:33:14,155
example a little running example each

604
00:33:10,055 --> 00:33:19,130
main zero and some dot o contain a a

605
00:33:15,055 --> 00:33:21,119
code and initialize data some dato

606
00:33:20,003 --> 00:33:25,061
doesn't have any initialize data just

607
00:33:22,019 --> 00:33:27,026
has code and then there's their system

608
00:33:25,088 --> 00:33:30,131
code that actually runs before and after

609
00:33:27,089 --> 00:33:32,114
your program so when when your program

610
00:33:31,031 --> 00:33:36,104
run it actually starts executing

611
00:33:33,014 --> 00:33:38,105
a startup code from from would see that

612
00:33:37,004 --> 00:33:40,070
that sort of initializes things and then

613
00:33:39,005 --> 00:33:46,019
the last thing that it does is it calls

614
00:33:40,007 --> 00:33:47,012
main and passes it arcs RC and RV okay

615
00:33:46,019 --> 00:33:51,110
and then when your when your program

616
00:33:48,002 --> 00:33:54,026
exits well that this is call but if your

617
00:33:52,001 --> 00:33:56,093
program if your main function routine

618
00:33:54,044 --> 00:33:58,082
does a return then it returns back to

619
00:33:57,002 --> 00:34:03,095
that startup code which then doesn't

620
00:33:58,082 --> 00:34:05,771
exit okay so so this is just and so this

621
00:34:03,095 --> 00:34:09,254
this consists of fudge

622
00:34:06,509 --> 00:34:12,480
texts and data as well and so when we

623
00:34:10,109 --> 00:34:18,128
when the linker relocates these these

624
00:34:12,048 --> 00:34:20,327
object files it takes all of the the

625
00:34:18,299 --> 00:34:24,302
code the text sections from each of the

626
00:34:20,759 --> 00:34:28,787
modules and put them together

627
00:34:24,599 --> 00:34:31,618
contiguously in the dot text section for

628
00:34:29,039 --> 00:34:34,064
the executable object file ok so it just

629
00:34:31,789 --> 00:34:38,940
puts them together in some order that it

630
00:34:34,289 --> 00:34:41,312
determines and it creates a combined dot

631
00:34:38,094 --> 00:34:42,713
text section in the executable that

632
00:34:41,519 --> 00:34:45,581
contains all of the system code and the

633
00:34:43,559 --> 00:34:47,621
all of the all of the code defined in

634
00:34:46,139 --> 00:34:50,192
the modules and then it does the same

635
00:34:48,179 --> 00:34:53,246
thing with the data takes all the all

636
00:34:50,669 --> 00:34:56,630
the dot data sections from the various

637
00:34:53,849 --> 00:34:59,891
object files and puts them together in

638
00:34:56,063 --> 00:35:03,512
one combined data section in the

639
00:35:00,269 --> 00:35:06,750
executable and it also emerges the

640
00:35:04,079 --> 00:35:12,131
symbol tables and in the debug

641
00:35:06,075 --> 00:35:16,122
information as well now when it just the

642
00:35:12,599 --> 00:35:19,673
act the act of sort of relocating these

643
00:35:17,022 --> 00:35:22,071
these object files requires the linker

644
00:35:20,339 --> 00:35:25,382
to figure out where it's going to

645
00:35:22,071 --> 00:35:28,400
actually store these these these

646
00:35:25,769 --> 00:35:30,824
different these different symbols when

647
00:35:29,039 --> 00:35:35,220
the system gets when this program gets

648
00:35:31,319 --> 00:35:38,940
loaded so it it has to pick an address

649
00:35:35,022 --> 00:35:41,921
for main that that function will start

650
00:35:38,094 --> 00:35:42,099
at some absolute address it's going to

651
00:35:42,119 --> 00:35:46,140
have it's gonna have to do the same for

652
00:35:43,044 --> 00:35:48,044
swap so for all the all the data arrays

653
00:35:46,014 --> 00:35:48,017
right

654
00:35:50,073 --> 00:35:57,612
and but the problem is that when this

655
00:35:54,819 --> 00:35:59,868
code is is compiled the compiler doesn't

656
00:35:58,269 --> 00:36:05,274
know what addresses the linker is going

657
00:36:00,309 --> 00:36:07,407
to pick so the so the compiler creates

658
00:36:05,769 --> 00:36:10,510
these these reminders to the linker

659
00:36:08,289 --> 00:36:11,680
called relocation entries which which

660
00:36:10,051 --> 00:36:15,150
are then stored in the relocation

661
00:36:11,068 --> 00:36:17,122
sections of the the object file and

662
00:36:15,609 --> 00:36:19,614
these these relocation entries are

663
00:36:18,022 --> 00:36:23,038
instructions to the linker that's

664
00:36:20,109 --> 00:36:24,177
something that there's a reference to a

665
00:36:23,038 --> 00:36:27,067
symbol that's going to have to be

666
00:36:24,789 --> 00:36:32,190
patched up when the the code is actually

667
00:36:27,067 --> 00:36:34,123
relocated and merged into the executable

668
00:36:32,019 --> 00:36:37,938
so let's look at a couple of these a

669
00:36:35,023 --> 00:36:39,882
couple of examples so in our in our main

670
00:36:38,109 --> 00:36:45,660
dot c module there was a reference to

671
00:36:40,089 --> 00:36:48,132
this to this global symbol called array

672
00:36:45,066 --> 00:36:50,149
okay and then there's also a reference

673
00:36:48,519 --> 00:36:55,527
to this this this global symbol sum

674
00:36:51,049 --> 00:36:57,348
which is the function so the the

675
00:36:55,599 --> 00:37:00,640
compiler creates two relocation entries

676
00:36:57,789 --> 00:37:04,750
the first one for the reference to the

677
00:37:00,064 --> 00:37:07,983
array a so here we're moving remember

678
00:37:04,075 --> 00:37:10,584
EDI is the first argument so remember

679
00:37:08,559 --> 00:37:14,470
our sum function takes the address of

680
00:37:11,259 --> 00:37:21,285
the of array of the input array as its

681
00:37:14,047 --> 00:37:26,074
it's argument so this move we're moving

682
00:37:21,519 --> 00:37:28,572
the address of the array into EDI for

683
00:37:26,074 --> 00:37:29,883
the first argument but the compiler

684
00:37:29,049 --> 00:37:36,490
doesn't know what that address is going

685
00:37:30,549 --> 00:37:39,220
to be it's it just it just it just it

686
00:37:36,049 --> 00:37:41,092
just moves in it an immediate value of 0

687
00:37:39,022 --> 00:37:45,118
into EDI temporarily right so you can

688
00:37:41,092 --> 00:37:48,097
see this is all zeros but bf is the move

689
00:37:46,018 --> 00:37:52,031
instruction and then there's allsey ROS

690
00:37:48,097 --> 00:37:53,159
in for now

691
00:37:52,031 --> 00:37:57,065
and then it places this relocation entry

692
00:37:54,059 --> 00:38:01,067
in the in the relocation section of

693
00:37:57,065 --> 00:38:06,071
Maemo and it it says it says to the

694
00:38:01,067 --> 00:38:09,151
laker at addre at offset a so these let

695
00:38:06,071 --> 00:38:14,168
me remind you these are our main zero

696
00:38:10,051 --> 00:38:17,078
module only contains one one function so

697
00:38:15,068 --> 00:38:20,120
that function starts that offsets zero

698
00:38:17,078 --> 00:38:23,159
in the in the code section of the module

699
00:38:21,002 --> 00:38:25,070
in the dot text section of the module if

700
00:38:24,059 --> 00:38:27,065
there were other functions in this

701
00:38:25,088 --> 00:38:30,161
module they would they would follow

702
00:38:28,019 --> 00:38:34,028
immediately after okay and it so you can

703
00:38:31,061 --> 00:38:35,156
see what what the compiler is it's just

704
00:38:34,028 --> 00:38:38,036
all it it's just generating offsets of

705
00:38:36,056 --> 00:38:42,080
these instructions from the beginning of

706
00:38:39,008 --> 00:38:45,086
the dot text section and it it includes

707
00:38:42,008 --> 00:38:47,045
this relocation entry which says to the

708
00:38:45,086 --> 00:38:53,090
link or hey on when you're relocating

709
00:38:48,017 --> 00:38:59,114
main zero at offset a in this dot text

710
00:38:54,026 --> 00:39:02,078
section you've got a reference a 30 to a

711
00:39:00,014 --> 00:39:08,098
reference to an array in the form of a

712
00:39:02,078 --> 00:39:10,112
32-bit address ok so that so eventually

713
00:39:08,098 --> 00:39:13,172
the linker is going to have to patch up

714
00:39:11,012 --> 00:39:16,040
these so this is address nine this is

715
00:39:14,072 --> 00:39:18,169
address a it's going to have to patch up

716
00:39:16,004 --> 00:39:24,062
the four bytes starting at address a

717
00:39:19,069 --> 00:39:26,125
with the absolute address of the symbol

718
00:39:24,098 --> 00:39:26,125
array

719
00:39:28,014 --> 00:39:37,083
and then similarly the reference to the

720
00:39:32,064 --> 00:39:41,079
reference to this the reference to this

721
00:39:37,083 --> 00:39:44,085
function some the compiler has no idea

722
00:39:41,079 --> 00:39:46,080
where some actually will end up it

723
00:39:45,003 --> 00:39:49,020
doesn't even know what module it's in or

724
00:39:46,008 --> 00:39:53,094
even if it's even it is defined in a

725
00:39:49,002 --> 00:39:59,055
module so in this case it just it does a

726
00:39:54,066 --> 00:40:01,071
call with all zeros and then it adds the

727
00:39:59,073 --> 00:40:08,151
three location entry that says to the

728
00:40:01,071 --> 00:40:13,079
linker at offset F you've got a four

729
00:40:09,051 --> 00:40:20,058
byte PC relative reference to a function

730
00:40:14,051 --> 00:40:23,052
to assemble called some and then it this

731
00:40:20,058 --> 00:40:25,095
is sort of a arcane detail that but and

732
00:40:23,061 --> 00:40:29,073
it includes there's an option to include

733
00:40:25,095 --> 00:40:32,184
a bias in the in the offset and since

734
00:40:29,073 --> 00:40:35,085
we're using since calls are since calls

735
00:40:33,084 --> 00:40:38,136
are always resolved using PC relative

736
00:40:35,085 --> 00:40:42,099
addressing the value that's going to be

737
00:40:39,036 --> 00:40:45,072
placed here at these four bytes that

738
00:40:42,099 --> 00:40:47,130
offset F is going to be an offset from

739
00:40:45,072 --> 00:40:50,118
the current RI p value or programmer

740
00:40:48,003 --> 00:40:52,086
counter value and since the program

741
00:40:51,018 --> 00:40:57,090
counter always points to the Ness cat

742
00:40:53,013 --> 00:41:00,027
next instruction it includes this which

743
00:40:57,009 --> 00:41:07,062
is four bytes away it includes this this

744
00:41:00,027 --> 00:41:09,093
offset of minus four so if it I talked

745
00:41:08,043 --> 00:41:11,109
about it in detail in the book if you

746
00:41:09,093 --> 00:41:13,101
really want to know how this works but

747
00:41:12,009 --> 00:41:16,044
just the point here is that there's

748
00:41:14,073 --> 00:41:19,074
enough information for the linker to

749
00:41:16,044 --> 00:41:21,045
actually fill in the right address so

750
00:41:19,074 --> 00:41:22,173
now if we look at the relocated text

751
00:41:21,054 --> 00:41:25,095
section so if we if we compile this code

752
00:41:23,073 --> 00:41:30,128
into an executable and then we use off

753
00:41:25,095 --> 00:41:30,128
stump to to disassemble it then

754
00:41:31,065 --> 00:41:36,156
what you see is this this reference here

755
00:41:34,071 --> 00:41:40,164
where we move the address of the address

756
00:41:37,056 --> 00:41:43,077
of a into EDI those four bytes which

757
00:41:41,064 --> 00:41:46,118
were originally zero has now been

758
00:41:43,077 --> 00:41:50,163
updated with the the actual address of

759
00:41:47,018 --> 00:41:54,018
array in in memory at runtime okay so

760
00:41:51,063 --> 00:41:56,097
the linkers decided that the array is

761
00:41:54,018 --> 00:42:00,045
going to go at address zero x six zero

762
00:41:56,097 --> 00:42:01,173
one zero one eight and then it's it's

763
00:42:00,045 --> 00:42:04,106
actually patched that the four bytes in

764
00:42:02,073 --> 00:42:09,129
the cup in the in the move instruction

765
00:42:05,006 --> 00:42:14,022
with that absolute address and the call

766
00:42:10,029 --> 00:42:16,053
to Psalm is it's also been updated but

767
00:42:14,022 --> 00:42:19,104
this one's interesting right that so the

768
00:42:16,053 --> 00:42:24,054
the address it's been updated with the

769
00:42:20,004 --> 00:42:30,050
PC relative address of five okay so when

770
00:42:24,063 --> 00:42:33,120
this program run this call instruction

771
00:42:30,005 --> 00:42:36,006
what it will do when it when it

772
00:42:34,002 --> 00:42:41,076
determines when it computes the absolute

773
00:42:36,051 --> 00:42:43,118
address of of the function some it will

774
00:42:41,094 --> 00:42:43,118
take

775
00:42:49,049 --> 00:42:57,490
it will take the current value of the

776
00:42:55,779 --> 00:43:02,710
program counter which is the next

777
00:42:57,049 --> 00:43:06,115
construction so 4 0 0 43 and it will add

778
00:43:02,071 --> 00:43:09,980
to it whatever whatever value is in this

779
00:43:07,015 --> 00:43:12,644
immediate field okay which is a tooth

780
00:43:10,619 --> 00:43:16,270
comprar today's a tooth compliment

781
00:43:12,779 --> 00:43:19,990
integer so it can go it can be relative

782
00:43:16,027 --> 00:43:21,091
you can go - or or plus in this case

783
00:43:19,099 --> 00:43:26,176
it's saying that the function that you

784
00:43:21,091 --> 00:43:33,300
want to call is that it is at 4 0 0 4 e

785
00:43:27,076 --> 00:43:36,345
3 + 5 which is 4 0 0 for e 8 which is

786
00:43:34,119 --> 00:43:40,000
the address of some okay and so the

787
00:43:37,029 --> 00:43:42,081
linker the linker does that the compiler

788
00:43:40,000 --> 00:43:45,019
has all the smarts the compiler computed

789
00:43:42,549 --> 00:43:46,720
the relocation entry the linker is just

790
00:43:45,019 --> 00:43:48,118
blindly going through each of those

791
00:43:46,072 --> 00:43:51,163
relocation entries and just doing what

792
00:43:49,018 --> 00:43:55,024
it's told ok but the net result is that

793
00:43:52,063 --> 00:43:58,242
now all of these these references have

794
00:43:55,024 --> 00:44:01,103
been patched up with with valid absolute

795
00:43:58,809 --> 00:44:00,860
addresses

796
00:44:05,025 --> 00:44:11,103
now once the linker has created a an

797
00:44:07,092 --> 00:44:14,118
object file that object file can be

798
00:44:12,003 --> 00:44:17,052
loaded the code and data and that object

799
00:44:15,018 --> 00:44:21,027
file can be loaded directly into memory

800
00:44:17,052 --> 00:44:25,065
with with no further modification okay

801
00:44:21,027 --> 00:44:31,029
so the if you look at all of the

802
00:44:25,065 --> 00:44:35,127
read-only sections in the executable so

803
00:44:31,047 --> 00:44:37,131
there's this an it section which we're

804
00:44:36,027 --> 00:44:40,038
not to worry about that that all the

805
00:44:38,031 --> 00:44:44,102
code is in the dot text and things like

806
00:44:40,038 --> 00:44:47,115
jump tables or an ro data all of this

807
00:44:45,002 --> 00:44:51,009
data can be loaded directly into memory

808
00:44:48,015 --> 00:44:54,724
as is okay so these bytes can just be

809
00:44:51,072 --> 00:44:57,123
copied directly into into memory and

810
00:44:54,859 --> 00:45:05,340
that that forms is so called a read-only

811
00:44:58,023 --> 00:45:08,025
code segment the the data and the dot

812
00:45:05,034 --> 00:45:14,049
data and BSS deck X section can also be

813
00:45:08,025 --> 00:45:16,394
copied directly into into memory and in

814
00:45:14,049 --> 00:45:18,096
the case of the variables and data

815
00:45:16,619 --> 00:45:25,690
they'll be initialized to a value that's

816
00:45:18,096 --> 00:45:27,121
stored in the symbol table so

817
00:45:25,069 --> 00:45:33,088
we're drawing our our memory here this

818
00:45:28,021 --> 00:45:37,830
is the this is the the memory address

819
00:45:33,088 --> 00:45:41,487
space that every Linux program sees and

820
00:45:38,019 --> 00:45:46,390
we're drawing addresses starting from

821
00:45:42,279 --> 00:45:51,130
zero and going up increasing as we grow

822
00:45:46,039 --> 00:46:00,091
up and every program is loaded at this

823
00:45:51,013 --> 00:46:03,070
the same address 0 X 4 0 0 0 0 0 and so

824
00:46:00,091 --> 00:46:05,113
the the code comes directly from the

825
00:46:03,007 --> 00:46:07,078
object file the data comes directly from

826
00:46:06,013 --> 00:46:12,162
the object file and then that's followed

827
00:46:08,041 --> 00:46:14,041
by a runtime heat which is created and

828
00:46:12,279 --> 00:46:16,390
managed by malloc so when you need

829
00:46:14,041 --> 00:46:21,450
dynamic dynamically need to allocate

830
00:46:16,039 --> 00:46:24,043
memory like using malloc that memory

831
00:46:21,819 --> 00:46:26,200
comes out of this heap which starts

832
00:46:24,043 --> 00:46:30,642
immediately following the the data

833
00:46:26,002 --> 00:46:37,045
segment and grows upwards the stack is

834
00:46:31,029 --> 00:46:39,900
at the very top of the visible memory

835
00:46:37,063 --> 00:46:45,145
that's available to application programs

836
00:46:39,009 --> 00:46:48,067
the memory above that is is restricted

837
00:46:46,045 --> 00:46:51,124
to the kernel ok so if you try to access

838
00:46:49,048 --> 00:46:55,677
those memory locations you'll get a seg

839
00:46:52,024 --> 00:46:58,039
fault and then the stack as we know

840
00:46:56,109 --> 00:47:00,180
grows down so this is managed and

841
00:46:58,039 --> 00:47:02,095
created at runtime and then there's this

842
00:47:00,819 --> 00:47:05,892
region somewhere in this huge gap

843
00:47:02,095 --> 00:47:08,098
between the stack and the heap there's a

844
00:47:06,549 --> 00:47:13,150
region for shared libraries so the dot n

845
00:47:08,098 --> 00:47:13,917
so files all get loaded into this this

846
00:47:13,015 --> 00:47:19,072
memory mapped region for shared

847
00:47:14,799 --> 00:47:23,430
libraries now that the top of the heap

848
00:47:19,072 --> 00:47:25,089
is indicated by this global variable

849
00:47:23,043 --> 00:47:29,652
maintained by the kernel called break

850
00:47:25,089 --> 00:47:32,089
vrk and the the top of the stack as we

851
00:47:30,039 --> 00:47:35,112
know is is maintained by the general

852
00:47:32,089 --> 00:47:36,978
purpose register RSP now there's a

853
00:47:35,769 --> 00:47:39,490
little bit of a this is a little bit of

854
00:47:37,779 --> 00:47:43,350
a simplification if you actually

855
00:47:39,049 --> 00:47:46,063
look at the addresses returned by malloc

856
00:47:43,035 --> 00:47:49,039
there's actually a there's actually two

857
00:47:46,063 --> 00:47:51,070
heaps there's a heap up here and in the

858
00:47:49,039 --> 00:47:55,063
high memory that grows down that's used

859
00:47:52,033 --> 00:47:56,107
for large objects very large you know if

860
00:47:55,063 --> 00:47:59,101
you now like a whole bunch of space and

861
00:47:57,007 --> 00:48:04,015
then the heat that grows up is is

862
00:48:00,001 --> 00:48:05,053
reserved for smaller smaller objects so

863
00:48:04,015 --> 00:48:08,052
I'm not really sure why they do this I

864
00:48:05,053 --> 00:48:10,090
think it allows them to have separate

865
00:48:08,052 --> 00:48:13,077
allocation algorithms for large objects

866
00:48:10,009 --> 00:48:12,096
and small objects

867
00:48:19,539 --> 00:48:23,617
okay so one of the one of the real

868
00:48:21,092 --> 00:48:26,701
advantages of linking is that allows us

869
00:48:24,319 --> 00:48:28,640
to create libraries of things so it's

870
00:48:27,529 --> 00:48:32,450
always something we want to do as

871
00:48:28,064 --> 00:48:35,023
programmers we always we always want to

872
00:48:32,045 --> 00:48:38,194
create abstractions and then present

873
00:48:35,599 --> 00:48:39,622
those abstractions to to users right and

874
00:48:38,599 --> 00:48:55,672
we do that by creating libraries

875
00:48:39,829 --> 00:49:00,903
defining an API yes I think it just no

876
00:48:56,329 --> 00:49:03,403
no it actually that's a good question I

877
00:49:01,569 --> 00:49:07,220
the things I've done it just grows until

878
00:49:04,069 --> 00:49:09,124
it runs out of memory right there so I

879
00:49:07,022 --> 00:49:12,038
don't think actually that's a really

880
00:49:09,619 --> 00:49:14,641
good question I mean I've done those

881
00:49:12,038 --> 00:49:23,277
experiments and it it eventually reaches

882
00:49:14,839 --> 00:49:32,380
some limit yeah I don't I don't know

883
00:49:23,619 --> 00:49:32,380
it's a very large number but I so

884
00:49:33,006 --> 00:49:37,089
you know as programmers we always want

885
00:49:35,013 --> 00:49:41,022
to abstract define api's implement

886
00:49:37,089 --> 00:49:45,096
package up those ATIS and make them

887
00:49:41,022 --> 00:49:47,111
available to to other programmers so how

888
00:49:45,096 --> 00:49:49,140
can we actually do that how can we make

889
00:49:48,011 --> 00:49:53,034
commonly used functions available to

890
00:49:50,004 --> 00:49:55,041
other programmers well one thing given

891
00:49:53,034 --> 00:49:57,105
what we've learned so far you could just

892
00:49:55,077 --> 00:50:01,086
take all the functions and put them all

893
00:49:58,005 --> 00:50:05,019
in a single big C file right and then

894
00:50:02,067 --> 00:50:06,129
programmers would just link that C file

895
00:50:05,019 --> 00:50:10,038
into their into their programs that they

896
00:50:07,029 --> 00:50:11,124
want to use them right another option

897
00:50:10,038 --> 00:50:13,101
would be to take that might get kind of

898
00:50:12,024 --> 00:50:16,035
unwieldy if it's a big library right

899
00:50:14,001 --> 00:50:19,056
let's see has hundreds and hundreds of

900
00:50:16,035 --> 00:50:21,048
functions so another option would might

901
00:50:19,056 --> 00:50:23,103
be to just take each function put it in

902
00:50:21,048 --> 00:50:24,141
a separate file and then compile them

903
00:50:24,003 --> 00:50:30,068
all together and compile and link them

904
00:50:25,041 --> 00:50:33,066
all together so this is more space and

905
00:50:30,068 --> 00:50:35,157
time efficient than then our first

906
00:50:33,066 --> 00:50:38,163
option but it seems like it would be

907
00:50:36,057 --> 00:50:40,086
burdensome on the programmer because the

908
00:50:39,063 --> 00:50:42,066
program would have to know where all

909
00:50:40,086 --> 00:50:44,124
these functions were and put them in

910
00:50:42,093 --> 00:50:45,177
make files would just be a lot of you

911
00:50:45,024 --> 00:50:52,082
know this you could end up with a

912
00:50:46,077 --> 00:50:52,082
ridiculously large command line to GCC

913
00:50:53,003 --> 00:51:01,005
so that the one solution to this problem

914
00:50:58,002 --> 00:51:04,059
it's a the first solution that the

915
00:51:01,032 --> 00:51:07,059
developers of UNIX came up with is

916
00:51:04,059 --> 00:51:08,154
something call it static library so the

917
00:51:07,059 --> 00:51:11,067
idea with a static library is that you

918
00:51:09,054 --> 00:51:15,096
create this archive called the dot a

919
00:51:11,067 --> 00:51:17,133
file which is it's just a collection of

920
00:51:15,096 --> 00:51:20,109
dot o files where each dot o file

921
00:51:18,033 --> 00:51:22,122
contains a function ok so you take all

922
00:51:21,009 --> 00:51:25,074
the functions in your library you use

923
00:51:23,022 --> 00:51:28,065
option two to create a bunch of dot o

924
00:51:25,074 --> 00:51:30,138
files and then you use a program called

925
00:51:28,065 --> 00:51:34,137
an archive or a R to take those dot o

926
00:51:31,038 --> 00:51:37,044
files put them together in a all

927
00:51:35,037 --> 00:51:41,085
together in a big file called an archive

928
00:51:37,098 --> 00:51:42,150
out with a with a table of contents at

929
00:51:41,085 --> 00:51:44,089
the beginning that tells you the offset

930
00:51:43,005 --> 00:51:47,011
of each one of the dot o file

931
00:51:44,089 --> 00:51:49,161
okay so an archive is just this

932
00:51:47,056 --> 00:51:55,104
concatenated collection of dot o files

933
00:51:50,061 --> 00:51:58,135
and then and then you link you pass that

934
00:51:56,004 --> 00:52:02,023
archive to the to the linker and it only

935
00:51:59,035 --> 00:52:03,043
takes the dot o files that are actually

936
00:52:02,023 --> 00:52:05,089
referenced and lengths them into the

937
00:52:04,015 --> 00:52:09,031
code right so it's a more efficient way

938
00:52:05,089 --> 00:52:10,134
you can have a huge archive but like

939
00:52:09,031 --> 00:52:13,117
let's see but if you only call printf

940
00:52:11,034 --> 00:52:19,072
the only dot o file you get is printf

941
00:52:14,017 --> 00:52:27,025
zero okay so the way this works is as

942
00:52:19,072 --> 00:52:30,073
before we take we take all the functions

943
00:52:27,025 --> 00:52:32,056
we want to put in our library we run

944
00:52:30,082 --> 00:52:35,167
them through our translators to get dot

945
00:52:32,056 --> 00:52:39,121
o files we pass those to the archiver to

946
00:52:36,067 --> 00:52:44,110
get a the archive so in this case of Lib

947
00:52:40,021 --> 00:52:48,034
C dot a and which has this code for

948
00:52:45,001 --> 00:52:51,055
printf that we might want to use right

949
00:52:48,034 --> 00:52:53,086
and so we can we can we can recreate

950
00:52:51,064 --> 00:52:54,139
that archive anytime we want so if one

951
00:52:53,086 --> 00:52:57,175
of these functions changes like say

952
00:52:55,039 --> 00:53:01,039
printf changes you just re archive the

953
00:52:58,075 --> 00:53:05,089
dot recompile printf and then re archive

954
00:53:01,039 --> 00:53:08,056
all of it dot o files so in let's see

955
00:53:05,089 --> 00:53:12,091
it's about 1500 object files and it's

956
00:53:08,056 --> 00:53:13,150
archived things like printf scanf simple

957
00:53:13,009 --> 00:53:18,088
integer math and there's also a math

958
00:53:14,005 --> 00:53:21,072
library which has you know several

959
00:53:18,088 --> 00:53:25,113
hundred common functions for things like

960
00:53:22,017 --> 00:53:30,070
floating point math sine cosine tangent

961
00:53:26,013 --> 00:53:32,020
etc these libraries the convention is

962
00:53:30,007 --> 00:53:35,095
that a library always is prefixed with

963
00:53:32,083 --> 00:53:38,086
Lib L ID and then and then sort of

964
00:53:36,058 --> 00:53:40,125
there's some indication of what it what

965
00:53:39,013 --> 00:53:41,025
it does

966
00:53:42,066 --> 00:53:46,108
so now let's see how linking with these

967
00:53:45,001 --> 00:53:51,016
static libraries of work so I I've

968
00:53:47,008 --> 00:53:54,021
created a little example here I've

969
00:53:51,025 --> 00:53:56,110
created a library called Lib vector a

970
00:53:54,021 --> 00:53:59,059
and it consists of functions that

971
00:53:57,001 --> 00:54:01,096
manipulate vectors and this is a real

972
00:53:59,059 --> 00:54:04,135
simple library just adds there's a

973
00:54:02,005 --> 00:54:10,057
function to add two vectors x and y

974
00:54:05,035 --> 00:54:12,097
together and return the result in Z and

975
00:54:10,057 --> 00:54:15,124
then another similar function that will

976
00:54:12,097 --> 00:54:21,175
do pairwise multiplication of two

977
00:54:16,024 --> 00:54:25,075
vectors so X I times y I equals Z I and

978
00:54:22,075 --> 00:54:27,097
now I compile these two programs and

979
00:54:25,075 --> 00:54:30,079
pack I want to package them into an

980
00:54:27,097 --> 00:54:32,104
archive called lead vector a and then in

981
00:54:31,015 --> 00:54:36,106
my in my main program I'm going to call

982
00:54:33,067 --> 00:54:40,080
one of those functions advic to add

983
00:54:37,006 --> 00:54:40,080
these two vectors x and y together

984
00:54:43,043 --> 00:54:49,712
so now what happens when we compile this

985
00:54:46,049 --> 00:54:54,095
this program we've already we've

986
00:54:50,099 --> 00:54:57,175
constructed the archive live dr. a from

987
00:54:54,509 --> 00:55:01,460
ad zero and multi

988
00:54:57,859 --> 00:55:05,876
and we pass that archive to the linker

989
00:55:01,046 --> 00:55:10,088
along with our main to zero relocatable

990
00:55:06,029 --> 00:55:13,076
objects file and we also pass it live CA

991
00:55:10,088 --> 00:55:15,767
which has the definition of which

992
00:55:13,499 --> 00:55:21,526
contains printf zero and anything else

993
00:55:16,559 --> 00:55:25,559
that printf L might call so these three

994
00:55:21,769 --> 00:55:28,440
the linker detects the reference to

995
00:55:25,559 --> 00:55:31,562
advic the function add back and so it

996
00:55:28,044 --> 00:55:32,115
just pulls advocaat o out and and

997
00:55:31,859 --> 00:55:35,921
ignores the rest

998
00:55:33,015 --> 00:55:39,066
similarly for printf dot o and then it

999
00:55:36,479 --> 00:55:41,700
compiles all those main main to 0 add

1000
00:55:39,066 --> 00:55:44,675
vector and printf dot o all together

1001
00:55:41,007 --> 00:55:49,376
into this fully linked executable called

1002
00:55:45,269 --> 00:55:51,368
prog to see for compiled time so we're

1003
00:55:50,069 --> 00:55:55,138
doing this we're doing this link we're

1004
00:55:52,259 --> 00:56:00,311
doing this this linking at compile time

1005
00:55:55,759 --> 00:56:05,430
when we call a GCC now what the linker

1006
00:56:00,779 --> 00:56:09,848
does when it's when it's using static

1007
00:56:05,043 --> 00:56:12,096
libraries it scans all the dot o files

1008
00:56:10,469 --> 00:56:16,472
and dot a files in order on the command

1009
00:56:12,096 --> 00:56:18,395
line so you're just typing GCC and then

1010
00:56:16,769 --> 00:56:24,660
a list of dot o files and dot a CoA

1011
00:56:19,259 --> 00:56:27,344
files in some words so so during the

1012
00:56:24,066 --> 00:56:30,995
scan it keeps a list of the current

1013
00:56:28,109 --> 00:56:33,206
unresolved references right so if let's

1014
00:56:31,589 --> 00:56:36,610
say let's say it looks at main dot o

1015
00:56:34,079 --> 00:56:38,940
first and there's a reference to printf

1016
00:56:36,799 --> 00:56:41,801
that's an unresolved reference because

1017
00:56:38,094 --> 00:56:42,683
printouts not not defined in main dot o

1018
00:56:41,819 --> 00:56:46,843
so that goes in a list of undefined

1019
00:56:43,529 --> 00:56:51,529
references and at some point or another

1020
00:56:47,059 --> 00:56:55,110
as each new 0 file or dot a file is

1021
00:56:51,529 --> 00:56:57,130
encountered the linker tries to

1022
00:56:55,569 --> 00:56:58,617
resolve its list of unresolved

1023
00:56:57,013 --> 00:57:01,992
references with the symbols that are

1024
00:56:59,049 --> 00:57:05,770
defined in that dot o file or dot a file

1025
00:57:02,109 --> 00:57:07,134
and then if there's any entries in the

1026
00:57:05,077 --> 00:57:09,118
list at the end of the scan then there's

1027
00:57:07,359 --> 00:57:11,740
an error okay so that the key here is

1028
00:57:10,018 --> 00:57:13,407
that the linker will try to resolve

1029
00:57:11,074 --> 00:57:16,163
these references from left to right on

1030
00:57:13,569 --> 00:57:19,000
the command line and so this is another

1031
00:57:16,829 --> 00:57:20,980
sort of important thing for you to know

1032
00:57:19,000 --> 00:57:23,092
as programmers because the order that

1033
00:57:20,098 --> 00:57:24,166
you that you put your files on the

1034
00:57:23,092 --> 00:57:27,115
command line actually makes a difference

1035
00:57:25,066 --> 00:57:30,121
okay so you can get sort of weird

1036
00:57:28,015 --> 00:57:33,924
baffling linker errors if you if you use

1037
00:57:31,021 --> 00:57:39,870
the wrong order so for instance suppose

1038
00:57:34,059 --> 00:57:44,380
we've got a function an object module

1039
00:57:40,059 --> 00:57:50,290
called Lib test that calls a function

1040
00:57:44,038 --> 00:57:54,064
that's defined in and live Monday okay

1041
00:57:50,029 --> 00:58:00,127
so these - L - Big L period that that

1042
00:57:54,064 --> 00:58:03,097
says to look for to look for a library

1043
00:58:01,027 --> 00:58:06,064
files in the current directory that's

1044
00:58:03,097 --> 00:58:07,138
what the dot look there first and then

1045
00:58:06,064 --> 00:58:13,153
look in the normal places that you look

1046
00:58:08,038 --> 00:58:16,102
and the the - lowercase L that's a it's

1047
00:58:14,053 --> 00:58:19,114
like an abbreviation we could replace

1048
00:58:17,002 --> 00:58:23,091
this with just the fully spelled out vid

1049
00:58:20,014 --> 00:58:27,453
mind is okay but you'll see this this

1050
00:58:23,109 --> 00:58:29,880
lowercase L used a lot so so Lib test

1051
00:58:27,579 --> 00:58:34,626
calls a function that's declared in in

1052
00:58:29,088 --> 00:58:36,115
live mind dot a so the linker looks at

1053
00:58:35,049 --> 00:58:39,126
it looked at the unresolved symbols in

1054
00:58:37,015 --> 00:58:41,184
Lib test dot o and it detects that

1055
00:58:39,819 --> 00:58:44,410
there's this unresolved function let's

1056
00:58:41,319 --> 00:58:49,690
say it's called foo I know it's it's

1057
00:58:44,041 --> 00:58:51,052
called lid fun so and it puts it on the

1058
00:58:49,069 --> 00:58:53,958
list and then it goes on to the next

1059
00:58:51,052 --> 00:58:57,094
command line entry and that's lid line

1060
00:58:54,579 --> 00:59:01,380
dot a and in there it finds it finds

1061
00:58:57,094 --> 00:59:03,963
this symbol of live phone and it

1062
00:59:01,038 --> 00:59:07,085
resolves the reference to that - lid

1063
00:59:04,809 --> 00:59:10,760
phone - the actual address

1064
00:59:07,085 --> 00:59:12,152
the relocated address now if we switch

1065
00:59:10,076 --> 00:59:16,100
the order and we we put lib mind on a

1066
00:59:13,052 --> 00:59:18,065
first followed by lib to zero well

1067
00:59:17,000 --> 00:59:20,024
there's there's no unresolved references

1068
00:59:18,065 --> 00:59:24,092
in this library right it's just a

1069
00:59:20,024 --> 00:59:26,090
collection of function definitions so it

1070
00:59:24,092 --> 00:59:27,188
there's no unresolved references so the

1071
00:59:26,009 --> 00:59:30,020
linker looks at that that's all good and

1072
00:59:28,088 --> 00:59:32,135
then it looks at lib test dot oh now

1073
00:59:31,001 --> 00:59:36,023
there's an unresolved reference to to

1074
00:59:33,035 --> 00:59:38,063
live fun but we're out of we're at the

1075
00:59:36,023 --> 00:59:42,062
end of the command line so that's the

1076
00:59:38,063 --> 00:59:46,085
linker err so you get this you get this

1077
00:59:42,062 --> 00:59:48,065
really cryptic error message and if you

1078
00:59:46,085 --> 00:59:52,123
didn't know about this ordering rule you

1079
00:59:48,065 --> 00:59:52,123
wouldn't have any idea how to debug it

1080
00:59:53,044 --> 00:59:57,098
okay so the static libraries are kind of

1081
00:59:56,057 --> 00:59:59,123
the old-fashioned solution that the

1082
00:59:57,098 --> 01:00:04,121
modern solution is to use dynamic

1083
01:00:00,023 --> 01:00:07,061
libraries are shared a shared library so

1084
01:00:05,021 --> 01:00:09,077
the reason the reason there's this sort

1085
01:00:07,061 --> 01:00:12,062
of newer form of libraries that static

1086
01:00:09,077 --> 01:00:16,163
libraries have some some disadvantages

1087
01:00:12,062 --> 01:00:19,121
so every if you compile with static

1088
01:00:17,063 --> 01:00:22,076
libraries then every every function that

1089
01:00:20,021 --> 01:00:24,044
uses print out of which it or every

1090
01:00:22,076 --> 01:00:27,110
program that uses printf has to have a

1091
01:00:24,044 --> 01:00:29,123
copy of printf okay but almost every

1092
01:00:28,001 --> 01:00:33,007
every program uses printf right so

1093
01:00:30,023 --> 01:00:35,027
there's shared shared libraries allow

1094
01:00:33,016 --> 01:00:37,097
provide a mechanism where they can just

1095
01:00:35,027 --> 01:00:43,028
be one wherever there's just one

1096
01:00:37,097 --> 01:00:45,119
instance of a shared library member like

1097
01:00:43,028 --> 01:00:47,096
like printf and and every program

1098
01:00:46,019 --> 01:00:50,023
running on the system will share that

1099
01:00:47,096 --> 01:00:49,159
one copy

1100
01:00:55,031 --> 01:00:59,114
so that's the that's sort of the big big

1101
01:00:58,019 --> 01:01:06,092
disadvantage of this potential

1102
01:01:00,014 --> 01:01:11,017
duplication so shared libraries are

1103
01:01:06,092 --> 01:01:10,117
different in the sense that they contain

1104
01:01:11,074 --> 01:01:16,118
code and data that are linked and loaded

1105
01:01:15,002 --> 01:01:20,054
into the program not when it's not when

1106
01:01:17,018 --> 01:01:23,021
it's compiled and linked and into a

1107
01:01:20,054 --> 01:01:26,108
executable object file but actually when

1108
01:01:23,048 --> 01:01:30,119
the program is loaded into the system so

1109
01:01:27,008 --> 01:01:34,019
linking of references to shared library

1110
01:01:31,019 --> 01:01:36,083
objects is deferred until the program is

1111
01:01:34,019 --> 01:01:38,117
actually loaded into into memory until

1112
01:01:36,083 --> 01:01:40,181
the executable object file is actually

1113
01:01:39,017 --> 01:01:44,081
loaded into memory and this can either

1114
01:01:41,081 --> 01:01:45,155
and it can even happen it can happen

1115
01:01:44,081 --> 01:01:48,097
when the program is actually loaded into

1116
01:01:46,055 --> 01:01:51,128
memory but it can also happen at runtime

1117
01:01:48,097 --> 01:01:53,152
anytime at runtime so you can be you can

1118
01:01:52,028 --> 01:01:57,076
be running a program and that program

1119
01:01:54,052 --> 01:01:59,120
can arbitrarily decide to load a

1120
01:01:57,076 --> 01:02:01,115
function that's declared in a shared

1121
01:02:00,002 --> 01:02:05,096
library okay I'll show you that it's

1122
01:02:02,015 --> 01:02:07,064
really cool now these things are often

1123
01:02:06,014 --> 01:02:09,080
called they're called shared libraries

1124
01:02:07,064 --> 01:02:12,095
they're called dynamic link libraries

1125
01:02:09,008 --> 01:02:13,097
like in Windows they're called DLLs dot

1126
01:02:12,095 --> 01:02:16,120
ISO files they're all referenced the

1127
01:02:14,069 --> 01:02:16,120
same thing

1128
01:02:21,044 --> 01:02:26,049
okay so that just like I said you can be

1129
01:02:24,099 --> 01:02:28,170
the dynamic linking can occur when the

1130
01:02:26,094 --> 01:02:34,013
program's loaded or after it's loaded

1131
01:02:29,007 --> 01:02:35,091
and actually running and there's a sort

1132
01:02:34,859 --> 01:02:38,550
of big deal that shared library routines

1133
01:02:36,054 --> 01:02:39,120
can be shared by multiple processes and

1134
01:02:38,055 --> 01:02:41,055
we'll look at this this will make sense

1135
01:02:40,002 --> 01:02:44,061
when we look at virtual memories so

1136
01:02:41,055 --> 01:02:47,102
don't don't worry about that now but but

1137
01:02:44,079 --> 01:02:47,102
here's how the process works

1138
01:02:49,076 --> 01:02:55,164
so we first we have to create instead of

1139
01:02:53,094 --> 01:03:01,723
creating an archive we create a shared

1140
01:02:56,064 --> 01:03:07,089
library so our lid vector routines

1141
01:03:02,569 --> 01:03:10,624
instead of creating an archive a file we

1142
01:03:07,089 --> 01:03:14,127
create a shared a dot iso file using the

1143
01:03:11,119 --> 01:03:17,970
using the shared argument to GCC so we

1144
01:03:15,027 --> 01:03:21,030
take our two input functions add Zac and

1145
01:03:17,097 --> 01:03:22,140
molbeck and share it says to create and

1146
01:03:21,003 --> 01:03:26,812
we're telling GCC to create a shared

1147
01:03:23,004 --> 01:03:30,068
library and place it in live dr. dot fo

1148
01:03:27,109 --> 01:03:34,410
okay and so and there's also that the

1149
01:03:31,004 --> 01:03:36,081
the C the C developers created a

1150
01:03:34,041 --> 01:03:39,090
function of shared library called Lib C

1151
01:03:36,081 --> 01:03:43,155
so that contains printf and all and

1152
01:03:39,009 --> 01:03:46,020
other standard library functions so we

1153
01:03:44,055 --> 01:03:49,143
take our program main - this is the same

1154
01:03:47,001 --> 01:03:53,055
program that calls adzick and we compile

1155
01:03:50,043 --> 01:03:57,069
it into main to zero and we passed main

1156
01:03:53,055 --> 01:04:02,100
to zero and these dot s0 files to the

1157
01:03:57,069 --> 01:04:05,708
linker now the linker doesn't at this

1158
01:04:03,000 --> 01:04:09,869
point it doesn't actually copy let's say

1159
01:04:06,329 --> 01:04:11,357
we're using advic or printf it doesn't

1160
01:04:09,869 --> 01:04:14,894
actually copy those functions or do

1161
01:04:11,609 --> 01:04:17,400
anything with them in the executable it

1162
01:04:15,119 --> 01:04:21,140
just makes a note in the symbol table

1163
01:04:17,004 --> 01:04:22,065
that those functions will need to be the

1164
01:04:21,329 --> 01:04:25,050
references to those functions will need

1165
01:04:23,001 --> 01:04:27,035
to be resolved when the program is

1166
01:04:25,005 --> 01:04:29,039
loaded okay so it

1167
01:04:27,035 --> 01:04:31,123
it puts in a relocation entry it says

1168
01:04:29,039 --> 01:04:35,057
fix this stuff when you load the program

1169
01:04:32,023 --> 01:04:37,112
so it's partially linked but it's not

1170
01:04:35,057 --> 01:04:38,144
fully linked you can't take that you

1171
01:04:38,012 --> 01:04:43,043
can't take a program

1172
01:04:39,044 --> 01:04:45,086
you can't take a executable file that

1173
01:04:43,043 --> 01:04:51,131
was dynamically linked and load it

1174
01:04:45,086 --> 01:04:53,177
directly what you what you do is the

1175
01:04:52,031 --> 01:04:56,036
loader which is the X X ee system call

1176
01:04:54,077 --> 01:05:00,085
and we'll learn more about that but just

1177
01:04:56,081 --> 01:05:03,103
this is just a sis call that loads loads

1178
01:05:00,085 --> 01:05:07,136
executables into memory and runs them

1179
01:05:04,003 --> 01:05:14,042
the loader takes the executable and then

1180
01:05:08,036 --> 01:05:15,101
it takes the shared data so files that

1181
01:05:14,042 --> 01:05:18,053
this this program needs

1182
01:05:16,001 --> 01:05:22,027
cade also made when the linker also made

1183
01:05:18,053 --> 01:05:21,127
a note of which data so files it needs

1184
01:05:22,003 --> 01:05:28,079
so the loader calls the dynamic linker

1185
01:05:26,015 --> 01:05:31,042
which takes those deso files and then

1186
01:05:29,006 --> 01:05:35,050
actually resolves all the references to

1187
01:05:31,042 --> 01:05:39,083
any unresolved reference ok so the

1188
01:05:35,005 --> 01:05:43,031
address of advic the add vac and printf

1189
01:05:39,083 --> 01:05:46,109
functions isn't determined until the

1190
01:05:43,076 --> 01:05:48,101
program is loaded and by that and it

1191
01:05:47,009 --> 01:05:51,101
isn't determined by the dynamic linker

1192
01:05:49,001 --> 01:05:53,066
until the program is loaded so that the

1193
01:05:52,001 --> 01:05:55,058
dynamic linker does it goes through a

1194
01:05:53,066 --> 01:05:57,113
similar process that the static linker

1195
01:05:55,058 --> 01:06:01,091
did sort of fixing up references to add

1196
01:05:58,013 --> 01:06:05,051
back at references to to printf and then

1197
01:06:01,091 --> 01:06:07,190
at that point the binary the binary is

1198
01:06:05,051 --> 01:06:11,470
in it is in a form that can be executed

1199
01:06:08,009 --> 01:06:15,038
directly so question

1200
01:06:11,929 --> 01:06:17,012
that it can I don't work

1201
01:06:15,929 --> 01:06:20,400
yeah well what if you look at the bottom

1202
01:06:17,759 --> 01:06:21,824
where you'd like weird is that no look

1203
01:06:20,004 --> 01:06:29,028
at you blue violet look at your finger

1204
01:06:22,409 --> 01:06:31,474
and b0s if okay the question is what

1205
01:06:29,064 --> 01:06:33,983
happens if you include a file so

1206
01:06:32,059 --> 01:06:37,064
includes are handled by the C

1207
01:06:34,559 --> 01:06:39,653
preprocessor so they're gone they're

1208
01:06:37,109 --> 01:06:42,185
long gone by the time them by the time

1209
01:06:40,499 --> 01:06:44,501
the linker gets around to it okay so the

1210
01:06:42,869 --> 01:06:48,877
C preprocessor just takes sharp sign

1211
01:06:44,699 --> 01:06:51,746
define sharp sign include and and

1212
01:06:49,669 --> 01:06:54,757
interprets those and outputs another C

1213
01:06:52,169 --> 01:06:58,214
program so if you if you include a file

1214
01:06:55,549 --> 01:07:02,606
the C preprocessor just takes that file

1215
01:06:58,619 --> 01:07:04,667
and just expands it and the output seat

1216
01:07:03,119 --> 01:07:08,134
program contains an expanded version of

1217
01:07:05,099 --> 01:07:08,116
all the files that you included

1218
01:07:11,009 --> 01:07:16,085
now what's really cool is that you can

1219
01:07:15,065 --> 01:07:20,096
also do this dynamic linking at runtime

1220
01:07:17,066 --> 01:07:22,915
so what I showed you before we're doing

1221
01:07:20,096 --> 01:07:27,685
it at load time but you can also

1222
01:07:23,509 --> 01:07:31,515
arbitrarily decide to to load link and

1223
01:07:28,549 --> 01:07:35,420
call a function from a shared from a

1224
01:07:32,109 --> 01:07:38,990
from any function defined in a dot iso

1225
01:07:35,042 --> 01:07:42,171
file and the way you do it is there's a

1226
01:07:38,099 --> 01:07:44,171
there's an interface called dl open

1227
01:07:42,549 --> 01:07:48,577
that's in Lib C that allows you to do

1228
01:07:45,071 --> 01:07:51,116
this and so let's say we want to this is

1229
01:07:48,829 --> 01:07:53,926
this is our main program and just like

1230
01:07:52,016 --> 01:07:57,092
before we want to call adzick okay but

1231
01:07:54,799 --> 01:08:01,160
advic now is defined in it in a dot iso

1232
01:07:57,092 --> 01:08:04,166
file the exact same dot SL file that we

1233
01:08:01,016 --> 01:08:07,094
generated before when we compile so

1234
01:08:05,066 --> 01:08:12,098
we'll call this dll C when we compile

1235
01:08:07,094 --> 01:08:13,192
this program DLL dot C we have no we

1236
01:08:12,098 --> 01:08:19,187
have no idea that it's going to call a

1237
01:08:14,092 --> 01:08:23,144
function from from lib dr. D so we just

1238
01:08:20,087 --> 01:08:26,626
compile it as those standalone C C

1239
01:08:24,044 --> 01:08:29,060
program within this program though we

1240
01:08:27,409 --> 01:08:31,498
declare a pointer a function pointer

1241
01:08:29,006 --> 01:08:35,995
called advic and we give the prototype

1242
01:08:32,299 --> 01:08:39,440
for this function its pointers cities so

1243
01:08:36,589 --> 01:08:42,652
it's two input arrays the output array

1244
01:08:39,044 --> 01:08:45,056
on the size and then first we

1245
01:08:43,219 --> 01:08:48,277
dynamically load the shared library that

1246
01:08:45,056 --> 01:08:53,108
contains the function we want so we call

1247
01:08:48,799 --> 01:08:56,851
DL open and we say load up this this dot

1248
01:08:54,008 --> 01:09:01,837
s L file into memory so that I can call

1249
01:08:57,319 --> 01:09:03,500
a function but don't resolve you know

1250
01:09:01,909 --> 01:09:04,963
don't worry don't worry about the

1251
01:09:03,005 --> 01:09:08,344
resolving the references to functions

1252
01:09:05,449 --> 01:09:13,520
until I actually tell you - that's the

1253
01:09:08,839 --> 01:09:16,843
lazy part and so what what this deal

1254
01:09:13,052 --> 01:09:20,311
open returns a handle that that then you

1255
01:09:17,239 --> 01:09:22,270
use in subsequent calls okay so if we

1256
01:09:20,779 --> 01:09:24,796
don't if the handle as no there was some

1257
01:09:22,549 --> 01:09:27,576
kind of error like maybe maybe this data

1258
01:09:24,949 --> 01:09:27,036
so file doesn't exist

1259
01:09:28,006 --> 01:09:34,765
so once we've opened that data so file

1260
01:09:30,739 --> 01:09:37,831
then we use DL cm with the handle so

1261
01:09:34,819 --> 01:09:39,907
this and then we we give it as we passes

1262
01:09:38,659 --> 01:09:45,560
a string the name of the function that

1263
01:09:40,699 --> 01:09:47,755
we want to invoke and we get what we get

1264
01:09:45,056 --> 01:09:50,965
back from the L sent as a pointer to

1265
01:09:48,259 --> 01:09:52,324
that function and then we can we can use

1266
01:09:51,469 --> 01:09:54,440
that function just like any other

1267
01:09:52,909 --> 01:09:56,690
function so we can use that function

1268
01:09:54,044 --> 01:09:58,111
pointer and we call it just as Ella

1269
01:09:56,069 --> 01:10:00,167
where it's statically defined function

1270
01:09:59,011 --> 01:10:13,034
so you can see this is real very

1271
01:10:01,067 --> 01:10:15,346
powerful technique okay so let's let's

1272
01:10:13,034 --> 01:10:17,126
finish the last little bit of the class

1273
01:10:15,949 --> 01:10:19,940
I want to show you it to try to convince

1274
01:10:18,026 --> 01:10:21,071
you that linking is is actually

1275
01:10:19,094 --> 01:10:29,173
interesting which is kind of a hard sell

1276
01:10:21,071 --> 01:10:30,073
sometime yes question yes

1277
01:10:32,026 --> 01:10:38,102
no it's that's how now you just it's

1278
01:10:37,159 --> 01:10:42,320
it's declared as a function pointer and

1279
01:10:39,002 --> 01:10:43,411
you then you just you just you just use

1280
01:10:42,032 --> 01:10:46,103
the name of the function

1281
01:10:43,429 --> 01:10:48,860
you have to dereference it or you just

1282
01:10:47,003 --> 01:10:53,009
you call it you call the function by

1283
01:10:48,086 --> 01:10:56,134
just using that that that function

1284
01:10:53,009 --> 01:10:57,034
pointer name okay just like I did

1285
01:11:00,709 --> 01:11:05,773
if you dereference it I just get back a

1286
01:11:03,017 --> 01:11:11,021
pointer value you get back the address

1287
01:11:06,349 --> 01:11:15,170
of that function all right so it's kind

1288
01:11:11,057 --> 01:11:16,115
of a hard sell to that to convention of

1289
01:11:15,017 --> 01:11:20,056
linking is is interesting but I'm going

1290
01:11:17,015 --> 01:11:22,082
to try ok so there's there's this

1291
01:11:20,209 --> 01:11:25,240
powerful technique called in library

1292
01:11:22,082 --> 01:11:27,751
inter positioning and the goal is to

1293
01:11:25,519 --> 01:11:31,600
intercept function calls from from

1294
01:11:28,489 --> 01:11:35,533
libraries and do something intercept

1295
01:11:32,329 --> 01:11:37,670
them for some reason right so what we

1296
01:11:35,929 --> 01:11:41,360
typically want to do is intercept the

1297
01:11:37,067 --> 01:11:42,128
function call maybe record some to some

1298
01:11:41,036 --> 01:11:46,315
statistics or do some error checking and

1299
01:11:43,028 --> 01:11:48,937
then call the real function as intended

1300
01:11:46,639 --> 01:11:55,880
right so so the idea is we're going to

1301
01:11:49,189 --> 01:11:58,340
create wrappers and when the program

1302
01:11:55,088 --> 01:11:58,537
when a program calls a function what

1303
01:11:58,034 --> 01:12:03,133
we're going to do is we're going to

1304
01:11:59,329 --> 01:12:04,360
execute its wrapper instead okay and

1305
01:12:03,439 --> 01:12:07,440
we're going to do it without changing

1306
01:12:04,639 --> 01:12:06,720
any of the source

1307
01:12:10,024 --> 01:12:14,057
now there there's a lot of reasons

1308
01:12:12,077 --> 01:12:17,174
there's a lot of applications for this

1309
01:12:14,057 --> 01:12:21,125
that the neatest ones that that I know

1310
01:12:18,074 --> 01:12:23,120
is that these facebook engineers so

1311
01:12:22,025 --> 01:12:26,086
we're trying to deal with this year-long

1312
01:12:24,002 --> 01:12:28,067
blog in the Facebook iPhone app and

1313
01:12:26,086 --> 01:12:31,121
nobody could figure out what was going

1314
01:12:28,085 --> 01:12:33,176
on and they figured it out using library

1315
01:12:32,021 --> 01:12:36,086
inter positioning they figured out that

1316
01:12:34,076 --> 01:12:38,081
there was something in the network stack

1317
01:12:36,086 --> 01:12:40,103
writing to the wrong location they

1318
01:12:38,081 --> 01:12:43,112
figured it out by intercepting all the

1319
01:12:41,003 --> 01:12:47,054
calls from their Facebook app that did

1320
01:12:44,012 --> 01:12:50,054
rights so things like right right to the

1321
01:12:47,054 --> 01:12:51,089
EP right so they just they intercepted

1322
01:12:50,054 --> 01:12:53,075
all those calls and then they were able

1323
01:12:51,089 --> 01:12:54,110
to when they looked at the arguments and

1324
01:12:53,075 --> 01:13:00,173
how those functions were being called

1325
01:12:55,001 --> 01:13:03,068
they determine the error you can also

1326
01:13:01,073 --> 01:13:04,091
use it for monitoring and profiling like

1327
01:13:03,077 --> 01:13:06,101
so if you want to know like how many

1328
01:13:04,091 --> 01:13:09,182
times different functions get calls you

1329
01:13:07,001 --> 01:13:14,018
can you can do you can interpose we use

1330
01:13:10,082 --> 01:13:16,157
it for for generating address traces so

1331
01:13:14,018 --> 01:13:19,055
your Malak when you do your malik labs

1332
01:13:17,057 --> 01:13:23,105
later in the semester you're going to be

1333
01:13:19,055 --> 01:13:25,118
evaluating your malik using a traces

1334
01:13:24,005 --> 01:13:28,058
that we generated from real programs

1335
01:13:26,018 --> 01:13:30,101
using this inter positioning technique

1336
01:13:28,058 --> 01:13:33,095
alright so we we enter post on all the

1337
01:13:31,001 --> 01:13:38,003
malloc and free calls in like netscape

1338
01:13:33,095 --> 01:13:41,147
ID and then we just recorded what

1339
01:13:38,021 --> 01:13:45,047
addresses and and sizes Malik was was

1340
01:13:42,047 --> 01:13:47,063
returning and what what blocks free was

1341
01:13:45,047 --> 01:13:51,122
freeing up and we just created a trace

1342
01:13:47,063 --> 01:13:55,106
of those and and then so let me show you

1343
01:13:52,022 --> 01:13:57,080
how you would do this so the idea let's

1344
01:13:56,006 --> 01:14:00,038
say we have this main program and the

1345
01:13:57,008 --> 01:14:01,043
idea is to trace all the malloc and free

1346
01:14:00,038 --> 01:14:04,043
calls so there's one malloc call and

1347
01:14:02,015 --> 01:14:06,089
there's one free call and we want to

1348
01:14:04,088 --> 01:14:09,089
know what these addresses are and we

1349
01:14:06,089 --> 01:14:11,090
want to know what these sizes are so we

1350
01:14:09,098 --> 01:14:14,195
can do this at either compile time link

1351
01:14:11,099 --> 01:14:18,122
time or run time to do it at compile

1352
01:14:15,095 --> 01:14:21,110
time we first write wrapper functions

1353
01:14:19,022 --> 01:14:23,046
called my malloc and my free where my

1354
01:14:22,001 --> 01:14:25,008
malloc call

1355
01:14:23,046 --> 01:14:28,128
the real malloc function and then it

1356
01:14:25,008 --> 01:14:31,023
prints out the size that it was called

1357
01:14:29,028 --> 01:14:34,092
and the address that malloc returned

1358
01:14:31,095 --> 01:14:35,133
okay so this when we run our program it

1359
01:14:34,092 --> 01:14:36,186
will it will print out these all these

1360
01:14:36,033 --> 01:14:41,100
addresses and it does the same thing for

1361
01:14:37,086 --> 01:14:46,181
free and then here's the trick in malloc

1362
01:14:42,000 --> 01:14:51,024
H we we define malloc to be my malloc

1363
01:14:47,081 --> 01:14:52,110
okay and free to be my free and then we

1364
01:14:51,024 --> 01:14:55,062
give the prototype for it so the

1365
01:14:53,001 --> 01:14:58,038
compiler doesn't get confused and then

1366
01:14:55,062 --> 01:15:02,073
we compile compile my malloc C into a

1367
01:14:58,047 --> 01:15:07,052
dot o file and then we call week then we

1368
01:15:02,073 --> 01:15:10,119
complete we call our program which is is

1369
01:15:07,052 --> 01:15:14,055
our main program int duxi for inner

1370
01:15:11,019 --> 01:15:18,033
positioning and we call that and here's

1371
01:15:14,055 --> 01:15:21,057
the trick we call it with the - cap I

1372
01:15:18,033 --> 01:15:23,040
argument and we say look for any include

1373
01:15:21,057 --> 01:15:29,123
files in the current directory okay so

1374
01:15:24,003 --> 01:15:34,098
this was similar to that l - CapTel

1375
01:15:30,023 --> 01:15:37,032
argument but because we tell GCC to look

1376
01:15:34,098 --> 01:15:37,167
in the current directory first so this

1377
01:15:37,032 --> 01:15:42,050
is sort of where the inner positioning

1378
01:15:38,067 --> 01:15:46,122
happens just because when it does that

1379
01:15:42,005 --> 01:15:48,081
it's going to it's going to find a it's

1380
01:15:47,022 --> 01:15:52,026
going to find a library called malloc H

1381
01:15:49,026 --> 01:15:55,067
I mean a dot H file called malloc dot H

1382
01:15:52,062 --> 01:15:57,111
and so all the calls to malloc will be

1383
01:15:55,067 --> 01:16:03,108
translated by the C preprocessor to my

1384
01:15:58,011 --> 01:16:07,103
malloc so when we run this it prints out

1385
01:16:04,008 --> 01:16:07,103
the the trip malloc and free trace

1386
01:16:08,007 --> 01:16:13,035
now we can also do this at link time so

1387
01:16:11,001 --> 01:16:16,077
we can tell see in order to do this we

1388
01:16:13,098 --> 01:16:17,151
had to get access to the we had to

1389
01:16:16,077 --> 01:16:20,142
compile the program we didn't have to

1390
01:16:18,051 --> 01:16:23,057
change it but we had to compile it we

1391
01:16:21,042 --> 01:16:28,079
can use link time that are positioning

1392
01:16:24,011 --> 01:16:31,062
its to avoid that that that compilation

1393
01:16:28,079 --> 01:16:32,160
so the way this works we define our

1394
01:16:31,062 --> 01:16:35,063
wrapper functions with this special name

1395
01:16:33,006 --> 01:16:37,095
underscore underscore wrap malloc and

1396
01:16:35,072 --> 01:16:41,163
this calls the real malloc function and

1397
01:16:38,049 --> 01:16:44,088
then prints out the information and then

1398
01:16:42,063 --> 01:16:47,106
at link time then we do the inter

1399
01:16:44,088 --> 01:16:48,147
positioning by calling the linker with

1400
01:16:48,006 --> 01:16:54,054
this special

1401
01:16:49,047 --> 01:17:00,051
- WL argument and so what this does the

1402
01:16:54,054 --> 01:17:02,076
- WL flag to GCC says hey take what

1403
01:17:00,051 --> 01:17:05,142
follows the argument that follows or

1404
01:17:02,076 --> 01:17:07,122
place all the commas with spaces and

1405
01:17:06,042 --> 01:17:09,087
then invoke the linker with this

1406
01:17:08,022 --> 01:17:12,057
argument okay so what we're doing is

1407
01:17:09,087 --> 01:17:15,179
passing a linker arguments to the linker

1408
01:17:12,057 --> 01:17:21,090
and this - - wrap argument to the linker

1409
01:17:16,079 --> 01:17:22,176
it tells the linker to resolve all

1410
01:17:21,009 --> 01:17:25,062
references to malloc as the underscore

1411
01:17:23,076 --> 01:17:29,078
underscore wrap malloc and all

1412
01:17:26,043 --> 01:17:33,120
references to underscore real malloc -

1413
01:17:29,096 --> 01:17:34,173
should be resolved as malloc okay so

1414
01:17:34,002 --> 01:17:37,065
anywhere in the program where we call

1415
01:17:35,073 --> 01:17:39,084
malloc it will be resolved to underscore

1416
01:17:37,083 --> 01:17:41,085
underscore wrap malloc and it will

1417
01:17:39,084 --> 01:17:45,093
invoke our wrapper and then the wrapper

1418
01:17:42,003 --> 01:17:51,015
calls real malloc which which by because

1419
01:17:46,074 --> 01:17:54,147
of this flag resolves to the actual

1420
01:17:51,015 --> 01:17:57,030
malloc routine now here you can also in

1421
01:17:55,047 --> 01:17:58,080
the really the really amazing thing is

1422
01:17:57,003 --> 01:18:01,041
you can also do this inter positioning

1423
01:17:58,008 --> 01:18:02,049
it load timer and run time when the

1424
01:18:01,068 --> 01:18:04,113
program is loaded so you don't even need

1425
01:18:03,021 --> 01:18:08,043
access to the dot o files all you need

1426
01:18:05,013 --> 01:18:10,014
is access to the executable right and

1427
01:18:08,043 --> 01:18:12,054
for every program we've access to the

1428
01:18:10,014 --> 01:18:15,057
executable so think about that we can

1429
01:18:12,054 --> 01:18:19,059
take any program and we can interpose on

1430
01:18:15,057 --> 01:18:21,123
its library calls at runtime

1431
01:18:19,059 --> 01:18:25,074
so the way we do this is we write the

1432
01:18:22,023 --> 01:18:29,064
wrapper function now uses the DL sim

1433
01:18:25,074 --> 01:18:31,101
call that we saw before and we call it

1434
01:18:29,064 --> 01:18:32,079
with a special function the special

1435
01:18:32,001 --> 01:18:37,086
argument called

1436
01:18:32,079 --> 01:18:39,093
next and we silver and what this is

1437
01:18:37,086 --> 01:18:42,090
saying is get the address of the real

1438
01:18:39,093 --> 01:18:43,161
knowledge okay so and what we're going

1439
01:18:43,026 --> 01:18:48,075
to we're going to trick the linker into

1440
01:18:44,061 --> 01:18:51,072
looking first to our our implementation

1441
01:18:48,075 --> 01:18:52,083
of malloc but here we want the real one

1442
01:18:51,072 --> 01:18:54,168
so we're telling it to get to look in

1443
01:18:53,055 --> 01:18:59,070
the next place its next place that it

1444
01:18:55,068 --> 01:19:01,086
would normally look and and fetch the

1445
01:18:59,007 --> 01:19:04,029
the address of malloc so the result is a

1446
01:19:01,086 --> 01:19:06,108
pointer a function pointer called malloc

1447
01:19:04,092 --> 01:19:10,092
T and then we can just call that

1448
01:19:07,008 --> 01:19:14,073
function to get to call the Lipsy malloc

1449
01:19:10,092 --> 01:19:17,184
and then print out the data okay we do

1450
01:19:14,073 --> 01:19:20,141
the same thing for free say we use DF m

1451
01:19:18,084 --> 01:19:23,156
in exactly the same way for free and

1452
01:19:21,041 --> 01:19:28,086
then the inter positioning now happens

1453
01:19:24,056 --> 01:19:31,083
when the program is loaded so notice we

1454
01:19:28,086 --> 01:19:34,094
built this our main program now int our

1455
01:19:31,083 --> 01:19:37,134
for runtime in a positioning we built it

1456
01:19:34,094 --> 01:19:41,132
I'm sorry we created our dot SL file my

1457
01:19:38,034 --> 01:19:46,083
Malachy so using the shared argument and

1458
01:19:42,032 --> 01:19:49,077
then and then we we compiled int int dot

1459
01:19:46,083 --> 01:19:51,108
C into this executable called int R but

1460
01:19:49,077 --> 01:19:55,152
notice there's no mention of my malloc

1461
01:19:52,008 --> 01:19:58,035
dot SL anywhere and now the inner

1462
01:19:56,052 --> 01:20:04,068
positioning happens when we actually run

1463
01:19:58,035 --> 01:20:06,090
the program and we do we we affect the

1464
01:20:04,068 --> 01:20:10,115
the inner positioning by setting an

1465
01:20:06,009 --> 01:20:15,075
environment variable called LD preload

1466
01:20:11,015 --> 01:20:18,036
to my Malachy so and so well this is a

1467
01:20:16,056 --> 01:20:21,093
environment variable to tell us the

1468
01:20:18,036 --> 01:20:24,042
dynamic linker to look first in the

1469
01:20:21,093 --> 01:20:27,126
value it looked first in the value of LD

1470
01:20:24,096 --> 01:20:29,100
preload is a list of locations look

1471
01:20:28,026 --> 01:20:32,115
first in those locations when to resolve

1472
01:20:30,036 --> 01:20:33,043
references and only only later look in

1473
01:20:33,015 --> 01:20:36,070
the

1474
01:20:33,043 --> 01:20:38,110
the normal system places so we're saying

1475
01:20:36,007 --> 01:20:40,102
to look in my Malik dot so4 unresolved

1476
01:20:39,001 --> 01:20:43,039
references first and then and then we're

1477
01:20:41,065 --> 01:20:44,146
invoking so this isn't bash this is how

1478
01:20:43,048 --> 01:20:47,050
you initialize an environment variable

1479
01:20:45,046 --> 01:20:49,111
so we're initializing it to my Malik

1480
01:20:47,068 --> 01:20:55,069
data so and then we're loading and

1481
01:20:50,011 --> 01:20:58,099
running the program and so the LD so all

1482
01:20:55,069 --> 01:21:01,086
the references to Malik get turned into

1483
01:20:58,099 --> 01:21:04,198
the references to the rapper function

1484
01:21:01,086 --> 01:21:10,141
the Malik function that we defined in in

1485
01:21:05,098 --> 01:21:11,191
our program ok so that's a so that's it

1486
01:21:11,041 --> 01:21:14,140
so that that inter positioning is a

1487
01:21:12,091 --> 01:21:17,103
really cool technique and it's only it's

1488
01:21:15,004 --> 01:21:19,027
only possible because of linkers so

1489
01:21:18,003 --> 01:21:22,015
alright so good

1490
01:21:19,063 --> 01:21:24,126
we'll see you on on Thursday and good

1491
01:21:22,015 --> 01:21:25,026
luck with your cash life

