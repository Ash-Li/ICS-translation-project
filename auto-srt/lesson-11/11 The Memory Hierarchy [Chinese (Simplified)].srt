1
00:00:00,002 --> 00:00:07,091
下午好欢迎大家好 

2
00:00:03,929 --> 00:00:12,750
看到你，希望你 都已经开始了 您 

3
00:00:07,109 --> 00:00:15,900
攻击实验室开始大家是个好

4
00:00:12,075 --> 00:00:17,157
时候开始我想反正我希望 

5
00:00:15,009 --> 00:00:20,025
你喜欢它 ，这是一个这是一个新的 

6
00:00:18,057 --> 00:00:22,856
一个本学期， 我觉得真的 

7
00:00:21,006 --> 00:00:29,082
真的很有趣 ，现代和 

8
00:00:23,369 --> 00:00:30,410
今天当前没关系，我们今天会 

9
00:00:29,082 --> 00:00:32,160
我们要谈 

10
00:00:30,779 --> 00:00:36,680
现在 叫的存储 层次 到目前为止 

11
00:00:33,006 --> 00:00:38,007
在课堂上，我们认为，我们的记忆 

12
00:00:36,068 --> 00:00:39,129
当我们看 我们的组件 

13
00:00:38,007 --> 00:00:42,296
语言课程我们认为的记忆

14
00:00:40,029 --> 00:00:46,080
作为一个字节数组 这是一个大数组 

15
00:00:42,989 --> 00:00:51,023
的字节，我们可以 用一个访问 

16
00:00:46,008 --> 00:00:53,087
指数被称为地址，但实际上

17
00:00:51,329 --> 00:00:57,780
存储系统是一个非常复杂的 

18
00:00:54,059 --> 00:00:59,100
设备的层次结构提供了这种 

19
00:00:57,078 --> 00:01:01,427
的这个这个大的线性抽象

20
00:01:00,000 --> 00:01:05,084
阵列，所以我们今天要去看看 

21
00:01:02,129 --> 00:01:08,570
在存储层次结构如何构建和

22
00:01:05,084 --> 00:01:11,163
为什么他们建立他们的方式和

23
00:01:08,057 --> 00:01:15,536
而我们可以看到的是，那种 

24
00:01:12,063 --> 00:01:18,135
属性的美丽融合

25
00:01:16,049 --> 00:01:22,320
的存储设备和的性质 

26
00:01:19,035 --> 00:01:25,113
程序来共同创造这个 

27
00:01:22,032 --> 00:01:28,691
这这这 美丽的设计被称为 

28
00:01:26,013 --> 00:01:31,462
存储层级，所以我们要 

29
00:01:28,979 --> 00:01:34,590
很快样做的一个高层次的旅游 

30
00:01:31,579 --> 00:01:35,700
存储技术和发展趋势我们 

31
00:01:34,059 --> 00:01:38,115
不打算进入一大堆 

32
00:01:35,007 --> 00:01:41,040
详细点， 看着点

33
00:01:39,015 --> 00:01:43,664
这些这些就是这样 的 

34
00:01:42,003 --> 00:01:45,057
这些技术的特性是 ， 

35
00:01:43,799 --> 00:01:47,070
有一些基本属性 

36
00:01:45,057 --> 00:01:49,059
决定其性能和 

37
00:01:47,007 --> 00:01:52,020
他们的速度和对确定限制 

38
00:01:49,077 --> 00:01:54,156
其性能和速度，所以我 

39
00:01:52,002 --> 00:01:57,060
希望你有你认识的只是一些 

40
00:01:55,056 --> 00:02:00,081
那些什么什么这些 高层次 的 想法 

41
00:01:57,078 --> 00:02:02,100
属性，然后我们将 看看在 

42
00:02:00,081 --> 00:02:04,280
叫的地方节目属性

43
00:02:03,000 --> 00:02:09,009
参考我们将看到如何 

44
00:02:05,009 --> 00:02:11,790
局部性和 存储的 属性 

45
00:02:09,009 --> 00:02:13,086
设备走到一起，表明这 

46
00:02:11,079 --> 00:02:16,158
存储器系统的设计

47
00:02:13,086 --> 00:02:19,095
作为一个层次好了，我们来看看 

48
00:02:17,058 --> 00:02:21,129
回忆第一现在的主力 

49
00:02:19,095 --> 00:02:24,171
内存称为随机存取存储器 

50
00:02:22,029 --> 00:02:27,063
或RAM它的传统打包为 

51
00:02:25,071 --> 00:02:29,103
一个芯片上，然后你把多个芯片 

52
00:02:27,063 --> 00:02:32,136
一起形成，形成你的主 

53
00:02:30,003 --> 00:02:34,095
内存，并有一个基本的存储单元 

54
00:02:33,036 --> 00:02:38,073
叫这其中每个小区的小区

55
00:02:34,095 --> 00:02:40,179
存储一个比特还好现在有有 

56
00:02:38,073 --> 00:02:43,116
公羊有两种类型有一个 

57
00:02:41,079 --> 00:02:45,114
SRAM和DRAM，他们是杰出的 

58
00:02:44,016 --> 00:02:54,114
由这些细胞的方法

59
00:02:46,014 --> 00:02:57,057
在SRAM实现这样要求它的 

60
00:02:55,014 --> 00:03:00,033
不是比DRAM更复杂

61
00:02:57,057 --> 00:03:02,115
像需要四到六个晶体管

62
00:03:00,033 --> 00:03:05,192
每比特而DRAM只需要一个 

63
00:03:03,015 --> 00:03:09,029
晶体管好，所以你会看到， 

64
00:03:05,489 --> 00:03:12,480
SRAM的将是更加昂贵 

65
00:03:09,029 --> 00:03:14,108
许多更 昂贵的，因为它们 是 

66
00:03:12,048 --> 00:03:17,097
更复杂的 每个单元 是更复杂 

67
00:03:15,008 --> 00:03:22,026
但他们也快得多好比十个 

68
00:03:17,097 --> 00:03:22,646
量级比DRAM 更快 

69
00:03:22,026 --> 00:03:26,070
他们有一个有一些其他 

70
00:03:23,519 --> 00:03:29,010
性能太像 SRAM一个不断 

71
00:03:26,007 --> 00:03:32,052
DRAM需要不断被刷新，如果 

72
00:03:29,001 --> 00:03:37,026
你不带一个带打

73
00:03:33,015 --> 00:03:39,114
电压失去电荷，而DRAM

74
00:03:37,026 --> 00:03:41,103
而它需要被堵塞，并且

75
00:03:40,014 --> 00:03:44,075
有一电一充不需要 

76
00:03:42,003 --> 00:03:47,100
要刷新SRAM是 一个很大的 

77
00:03:44,075 --> 00:03:48,126
比DRAM可靠，因此有较少 

78
00:03:48,000 --> 00:03:52,038
需要检错 和 纠错 

79
00:03:49,026 --> 00:03:55,094
还有等等，因为这 

80
00:03:52,038 --> 00:04:01,086
差异右边的SRAM的是昂贵的 

81
00:03:55,094 --> 00:04:03,111
而小于DRAM 我们 更快 找到 

82
00:04:01,086 --> 00:04:07,110
SRAM在这些小快被使用 

83
00:04:04,011 --> 00:04:09,087
片上称为高速缓冲存储器上

84
00:04:08,001 --> 00:04:14,085
回忆我们要学习所有 

85
00:04:09,087 --> 00:04:17,094
那些在星期四，然后是DRAM 

86
00:04:14,094 --> 00:04:18,126
在主存储器使用的主力和 

87
00:04:17,094 --> 00:04:23,165
相关联的帧缓冲器

88
00:04:19,026 --> 00:04:28,085
图形显卡 

89
00:04:24,065 --> 00:04:29,136
现在DRAM和SRAM是易失性 

90
00:04:28,319 --> 00:04:32,550
就是说如果如果他们断电

91
00:04:30,036 --> 00:04:33,111
他们他们失去了所有的信息的权利

92
00:04:32,055 --> 00:04:34,143
所以这就是 为什么当你打开你 

93
00:04:34,011 --> 00:04:37,850
关闭电脑，你必须 你失去 

94
00:04:35,043 --> 00:04:39,932
一切都在你的记忆， 你有 

95
00:04:37,949 --> 00:04:42,032
当你打开它 ， 你 必须 

96
00:04:40,319 --> 00:04:45,320
那种 从 重装所有的东西 你 

97
00:04:42,779 --> 00:04:46,830
盘有一个不同类型的内存 

98
00:04:45,419 --> 00:04:49,680
称为非易失性存储器，其 

99
00:04:46,083 --> 00:04:50,181
保留其信息时，它的 

100
00:04:49,068 --> 00:04:55,577
断电， 还有 的一大堆 

101
00:04:51,081 --> 00:04:57,108
这些东西是所谓的一个只读的 

102
00:04:56,189 --> 00:05:00,248
内存因此， 对这些通用名称 

103
00:04:58,008 --> 00:05:02,013
非易失性存储器是只读

104
00:05:00,779 --> 00:05:04,874
回忆或ROM和有一个整体 

105
00:05:02,058 --> 00:05:06,075
很多不同 类型 的 排序会 

106
00:05:05,729 --> 00:05:09,797
时光倒流 

107
00:05:06,075 --> 00:05:11,133
只有原读取记忆是 

108
00:05:10,409 --> 00:05:14,447
ROM和他们只能做一次程序 

109
00:05:12,033 --> 00:05:16,056
当被制作的芯片，然后 

110
00:05:14,789 --> 00:05:18,930
随着时间的推移逐渐在一段 

111
00:05:16,056 --> 00:05:19,155
像 二三十年有 

112
00:05:18,093 --> 00:05:21,512
在方式罗布的可能改进

113
00:05:20,055 --> 00:05:25,384
在他们如何进行编程和 

114
00:05:22,349 --> 00:05:28,560
删除。 因此，它们可以 被重新编程 

115
00:05:25,879 --> 00:05:30,270
我们今天 的 现代 形式 

116
00:05:28,056 --> 00:05:36,065
的只读存储器被称为闪光

117
00:05:30,027 --> 00:05:39,036
存储器，其提供的能力 

118
00:05:36,065 --> 00:05:43,354
删除您可以删除刚才的块 

119
00:05:39,036 --> 00:05:46,038
闪存称为块，然后将 

120
00:05:43,939 --> 00:05:47,960
不足之处是这些东西 穿 

121
00:05:46,056 --> 00:05:51,065
出来后 约十万 

122
00:05:48,149 --> 00:05:54,197
橡皮擦好了，你可以擦除并 

123
00:05:51,569 --> 00:05:58,622
改编十万次， 

124
00:05:54,629 --> 00:06:01,688
然后，然后它是你的砖砌现在 

125
00:05:59,099 --> 00:06:05,168
这些非易失性存储器的出现

126
00:06:02,219 --> 00:06:08,231
在伍德 所谓固件是 

127
00:06:05,789 --> 00:06:10,793
这是一个的编入软件 

128
00:06:08,339 --> 00:06:12,428
它进入伊朗 ，你看到那些 在 

129
00:06:11,189 --> 00:06:15,242
电脑的BIOS，所以当你开机 

130
00:06:13,229 --> 00:06:17,237
您的计算机中的第一个 

131
00:06:15,719 --> 00:06:18,812
其执行存储在指令

132
00:06:18,029 --> 00:06:21,074
一个在右，如果你想知道像 ROM 

133
00:06:19,649 --> 00:06:23,651
哪里来的这么那些事

134
00:06:21,479 --> 00:06:24,560
他们存储在ROM中，然后有一个 

135
00:06:23,669 --> 00:06:28,550
启动过程，其中渐渐地 

136
00:06:25,289 --> 00:06:31,550
更多的信息和指令 

137
00:06:28,055 --> 00:06:34,724
加载到内存

138
00:06:31,055 --> 00:06:37,104
你知道IO IO设备几乎没有

139
00:06:35,219 --> 00:06:39,390
在他们的计算机被称为控制器 

140
00:06:38,004 --> 00:06:41,013
这些控制器包括

141
00:06:39,039 --> 00:06:43,137
指令和数据 是被 

142
00:06:41,013 --> 00:06:47,022
存储在ROM 和你在一饱眼福 

143
00:06:44,037 --> 00:06:52,113
并且 遍布 在这些坚实的地方 

144
00:06:48,003 --> 00:06:56,022
固态盘是到到到

145
00:06:53,013 --> 00:06:59,079
系统看起来就像一个旋转的磁盘，但 

146
00:06:56,022 --> 00:07:01,026
他们正在建造的快闪记忆体和

147
00:06:59,079 --> 00:07:03,111
这些都是你的拇指 驱动器看到这些

148
00:07:01,062 --> 00:07:04,149
智能手机平板电脑和笔记本电脑和 

149
00:07:04,011 --> 00:07:16,053
他们甚至开始 在 露面 

150
00:07:05,049 --> 00:07:19,131
服务器现在这样的记忆 

151
00:07:16,053 --> 00:07:22,056
连接到使用排序 线的 CPU 

152
00:07:20,031 --> 00:07:25,062
被统称为公交车好吗 

153
00:07:22,056 --> 00:07:31,091
所以数据跨越导线流回和 

154
00:07:25,062 --> 00:07:35,073
提出从我们的CPU芯片和

155
00:07:31,091 --> 00:07:36,177
它由一个寄存器文件这些都是 

156
00:07:35,073 --> 00:07:39,102
通用寄存器是 斧子RDI 

157
00:07:37,077 --> 00:07:42,090
等等，并有一个算术 

158
00:07:40,002 --> 00:07:45,051
逻辑单元，其读取和写入数据 

159
00:07:42,009 --> 00:07:46,056
从寄存器文件，然后

160
00:07:45,051 --> 00:07:49,080
操纵以某种方式通过数据

161
00:07:47,037 --> 00:07:52,059
做某种类型的 算术运算 

162
00:07:49,008 --> 00:07:55,026
或一些逻辑操作，并且如果

163
00:07:52,059 --> 00:07:58,092
说明如果指令需要

164
00:07:55,098 --> 00:08:02,139
存取存储器 所以如果有你做 

165
00:07:58,092 --> 00:08:05,184
此举移动指令读取或 

166
00:08:03,039 --> 00:08:08,126
写入到内存中，然后多数民众赞成通过处理 

167
00:08:06,084 --> 00:08:12,153
被 连接到一个 总线接口 

168
00:08:09,026 --> 00:08:15,108
我们就这么叫系统总线，然后 

169
00:08:13,053 --> 00:08:18,084
其是连接到一个I / O桥与 

170
00:08:16,008 --> 00:08:21,063
这这是芯片 的另一集合 

171
00:08:18,084 --> 00:08:24,084
英特尔称这 是一种我称为 AI / O 

172
00:08:21,063 --> 00:08:26,070
桥他们称该芯片组 还可以，但 

173
00:08:24,084 --> 00:08:29,112
它的芯片集合从分离 

174
00:08:27,033 --> 00:08:31,089
过程中的CPU芯片，然后将

175
00:08:30,012 --> 00:08:33,066
I / O桥被连接 到另一个 总线 

176
00:08:31,089 --> 00:08:35,172
所谓存储器总线其中这 

177
00:08:33,066 --> 00:08:39,005
连接你知道这个 主存储器 

178
00:08:36,072 --> 00:08:40,101
是呵，这 是 一种抽象的我 

179
00:08:39,599 --> 00:08:43,110
不想你把这太 

180
00:08:41,001 --> 00:08:45,033
从字面上但它给你的 想法 

181
00:08:43,011 --> 00:08:48,027
的信息在系统中如何流动 

182
00:08:45,033 --> 00:08:50,055
还好摩登现代的系统使用 

183
00:08:48,027 --> 00:08:53,073
专用总线设计和他们非常

184
00:08:50,055 --> 00:08:54,072
非常神秘 和日益复杂，所以 

185
00:08:53,073 --> 00:08:56,145
我们只是要我们正要 

186
00:08:54,072 --> 00:09:00,131
使用了一个非常简单的抽象 

187
00:08:57,045 --> 00:09:03,141
这些 子这些烟头 架构 

188
00:09:01,031 --> 00:09:07,089
现在现在当假设你做一个负载 

189
00:09:04,041 --> 00:09:11,139
像移动移动操作排队八 

190
00:09:07,089 --> 00:09:13,134
个字节地址到 我们的斧子 好了， 

191
00:09:12,039 --> 00:09:15,048
我们称之为负载，因为我们是我们 

192
00:09:14,034 --> 00:09:18,111
从从视图的点装

193
00:09:16,029 --> 00:09:21,066
在CPU我们将数据装载到了

194
00:09:19,011 --> 00:09:26,015
CPU，但我们正在加载，我们正在加载 

195
00:09:21,066 --> 00:09:28,089
来自存储器的数据到CPU，以便当 

196
00:09:26,015 --> 00:09:31,059
当CPU 执行招 

197
00:09:28,089 --> 00:09:36,146
这样的指令，它第一个地方 

198
00:09:31,059 --> 00:09:39,126
的存储器总线上的地址和 

199
00:09:37,046 --> 00:09:42,099
然后主主存储器感测到 

200
00:09:40,026 --> 00:09:45,120
解决和读出内容的 

201
00:09:42,099 --> 00:09:47,196
在地址的八个字节，因此检索 

202
00:09:46,002 --> 00:09:51,008
从地址字一个八字节的字

203
00:09:48,096 --> 00:09:55,137
并把它回到了巴士 

204
00:09:51,008 --> 00:09:59,064
的那些位行进通过I / O 

205
00:09:56,037 --> 00:10:03,099
桥的总线接口，然后 

206
00:10:00,036 --> 00:10:05,043
CPU读取从字X 

207
00:10:03,099 --> 00:10:07,103
从总线， 然后数据字X 

208
00:10:05,043 --> 00:10:13,044
主管到寄存器的Ras 好了，所以它的 

209
00:10:08,003 --> 00:10:15,075
现在写的 是类似于再 这样 

210
00:10:13,053 --> 00:10:19,062
在这里，我们正在做一个移动指令移动 

211
00:10:15,075 --> 00:10:22,098
从我们的斧头● 在解决 一个主 

212
00:10:19,062 --> 00:10:24,120
内存没关系所以CPU的开端， 

213
00:10:22,098 --> 00:10:27,195
之前通过将地址上

214
00:10:25,002 --> 00:10:30,093
总线主存储器中读取该地址和 

215
00:10:28,095 --> 00:10:32,123
然后等待数据 到达上 

216
00:10:31,011 --> 00:10:36,060
公交所以CPU 然后将 这些 

217
00:10:33,023 --> 00:10:39,041
总线那些对我们的健康X的内容 

218
00:10:36,006 --> 00:10:42,012
内容分布在主内存旅行

219
00:10:39,041 --> 00:10:44,085
然后读取读取字

220
00:10:42,066 --> 00:10:46,149
从总线将它保存在地址 

221
00:10:44,085 --> 00:10:51,093
好了，所以在 这一切的一点是 

222
00:10:47,049 --> 00:10:55,146
该发生的，你知道的操作 

223
00:10:52,065 --> 00:10:57,138
读取和寄存器写入，因为

224
00:10:56,046 --> 00:11:00,111
寄存器文件是非常接近 

225
00:10:58,038 --> 00:11:01,095
ALU这些发生在 一个 数量级上 

226
00:11:01,011 --> 00:11:03,086
几个周期 

227
00:11:01,095 --> 00:11:05,180
还好注册regice 

228
00:11:03,086 --> 00:11:08,755
这是非常接近 的ALU如此 

229
00:11:06,008 --> 00:11:12,787
这些操作都是非常非常事 

230
00:11:09,529 --> 00:11:16,130
快速而回忆 其实这 

231
00:11:13,579 --> 00:11:20,617
是一组很远芯片 

232
00:11:16,013 --> 00:11:22,912
从CT相对来说，你可以

233
00:11:20,959 --> 00:11:25,190
有很多事情在的时候，如果你 

234
00:11:23,029 --> 00:11:27,140
要读取或写入内存有它 

235
00:11:25,019 --> 00:11:29,788
你必须做多操作 

236
00:11:27,014 --> 00:11:31,055
总线数据有旅行繁殖 

237
00:11:29,959 --> 00:11:34,310
跨总线所有这些东西需要 

238
00:11:31,055 --> 00:11:38,057
时间，存储操作和读取 

239
00:11:34,031 --> 00:11:40,105
写通常，你知道，也许50 

240
00:11:38,057 --> 00:11:43,112
纳秒100纳秒，而

241
00:11:41,005 --> 00:11:48,014
寄存器之间发生的操作

242
00:11:44,012 --> 00:11:51,601
在亚纳秒没关系的 顺序，从而 

243
00:11:48,095 --> 00:11:53,141
你在谈论一个1至2个 数量级的 

244
00:11:51,709 --> 00:11:55,714
如果你必须去 幅度差 

245
00:11:54,041 --> 00:11:58,100
关闭芯片2检索来自东西 

246
00:11:56,209 --> 00:12:03,640
内存 好了，所以 这是第一个排序的 

247
00:11:59,000 --> 00:12:06,008
关于内存的系统大外卖项目

248
00:12:03,064 --> 00:12:09,133
现在另一种流行的存储技术

249
00:12:06,008 --> 00:12:10,067
旋转磁盘和我不知道 

250
00:12:09,709 --> 00:12:12,800
你曾经撕开一个除了他们亲切 

251
00:12:11,039 --> 00:12:16,168
有趣的还有一系列 

252
00:12:12,008 --> 00:12:21,037
盘片每个盘片涂覆有 

253
00:12:16,519 --> 00:12:24,230
磁性材料，然后位一和

254
00:12:21,829 --> 00:12:26,570
零进行编码，在这 

255
00:12:24,023 --> 00:12:31,075
磁性材料，然后有这个 

256
00:12:26,057 --> 00:12:34,085
可它就是它的铰链 在 这里手臂

257
00:12:31,075 --> 00:12:36,107
然后它可以在 它 可以 在浮动 

258
00:12:34,085 --> 00:12:38,098
盘片 所以它漂浮在 薄层 

259
00:12:37,007 --> 00:12:41,206
空气在大盘 子 ，有一个 

260
00:12:38,098 --> 00:12:41,192
在最后，可以读/写头 

261
00:12:41,269 --> 00:12:46,670
感应磁场的变化

262
00:12:42,092 --> 00:12:47,821
并且编码 盘 好了，所以这些 

263
00:12:46,067 --> 00:12:50,416
盘片的旋转周围像像 

264
00:12:48,649 --> 00:12:53,570
逆时针这样 ，和本 

265
00:12:51,019 --> 00:12:55,970
手臂可以来回走 所以有 

266
00:12:53,057 --> 00:12:58,936
大量的机械 传动 的 ，所以这是所有 

267
00:12:55,097 --> 00:13:00,161
机械左右的 机械性质 

268
00:12:59,449 --> 00:13:05,000
旋转 盘 需要它的将是 

269
00:13:01,061 --> 00:13:07,064
较慢的右则则D RAM和NS 

270
00:13:05,000 --> 00:13:10,399
公羊还有还有像电子 

271
00:13:07,064 --> 00:13:13,513
它就像一个在固件中的小计算机 

272
00:13:10,399 --> 00:13:16,040
这实际控制的 

273
00:13:14,089 --> 00:13:17,120
此驱动器等的控制的操作

274
00:13:16,004 --> 00:13:20,009
如何

275
00:13:17,012 --> 00:13:23,020
手臂往返和和和 

276
00:13:20,054 --> 00:13:26,057
控制数据是如何读出的 

277
00:13:23,002 --> 00:13:30,013
只是多一点的读/写头， 

278
00:13:26,057 --> 00:13:32,081
我们可以认为 这些磁盘的 细节 

279
00:13:30,031 --> 00:13:34,120
由盘片每个盘片具有 

280
00:13:32,081 --> 00:13:37,088
两个服务的顶部和底部 ， 

281
00:13:35,002 --> 00:13:40,097
然后每个表面由这些 

282
00:13:37,088 --> 00:13:44,183
接送同心圆称为 

283
00:13:41,015 --> 00:13:49,022
跟踪，然后将每个轨道包括 

284
00:13:45,083 --> 00:13:49,091
我们是由含有部门 

285
00:13:49,022 --> 00:13:58,025
数据 

286
00:13:49,091 --> 00:14:01,166
所以通常512 512位或对不起 

287
00:13:58,052 --> 00:14:05,054
字节，然后除这些轨道

288
00:14:02,066 --> 00:14:07,091
通过 山羊该间隙被分开

289
00:14:05,072 --> 00:14:12,161
这些差距好像就在我不 

290
00:14:07,091 --> 00:14:15,104
现在包含现在的数据是盘片 

291
00:14:13,061 --> 00:14:18,125
对 顶部在彼此的顶部对齐

292
00:14:16,004 --> 00:14:22,031
该主轴等的轨道是 

293
00:14:19,025 --> 00:14:25,054
不同 的 表面 ，例如上对齐

294
00:14:22,031 --> 00:14:27,038
因为这里与这条赛道 

295
00:14:25,279 --> 00:14:30,080
这些曲目正式我们的集合

296
00:14:28,001 --> 00:14:33,098
打电话好吗缸，因为它有一个 

297
00:14:30,008 --> 00:14:36,080
现在圆筒形的容量

298
00:14:33,098 --> 00:14:40,139
磁盘是该 比特数 

299
00:14:36,008 --> 00:14:43,103
可以存储和供应商样，他们的 

300
00:14:41,039 --> 00:14:46,061
所有DIS厂商使用他们的报价

301
00:14:44,075 --> 00:14:50,126
在千兆字节的容量，但 其中一个 

302
00:14:46,061 --> 00:14:55,085
千兆字节是10至第九字节右 

303
00:14:51,026 --> 00:14:59,069
而不是2到20 好喜欢喜欢 

304
00:14:55,085 --> 00:15:02,123
你会想到那么什么我不 知道 

305
00:14:59,069 --> 00:15:05,144
他们为什么这样做，但它允许通过 

306
00:15:03,023 --> 00:15:09,119
引用他们的能力和千兆字节 

307
00:15:06,044 --> 00:15:13,112
十到第九个字节它， 它是一个更大的 

308
00:15:10,019 --> 00:15:15,062
数 右所以看起来它看起来越好 

309
00:15:14,012 --> 00:15:18,047
像有更多的信息，这是一个 

310
00:15:15,062 --> 00:15:20,135
小我真的不知道 他们 为什么 这样做 

311
00:15:18,047 --> 00:15:22,666
但我认为 ，这就是为什么它是和它的 

312
00:15:21,035 --> 00:15:24,076
所以它的 那些点点之一

313
00:15:23,089 --> 00:15:28,130
恼人的事情， 我们 只需要 

314
00:15:24,076 --> 00:15:29,165
只知道现在的习惯 

315
00:15:28,013 --> 00:15:35,021
容量由两个确定

316
00:15:30,065 --> 00:15:38,153
独立的技术因素之一是 

317
00:15:35,093 --> 00:15:42,121
记录密度所以这是多少 

318
00:15:39,053 --> 00:15:48,152
位可以装进单个扇区 

319
00:15:43,021 --> 00:15:53,102
或我们或至少 的 一部分 

320
00:15:49,052 --> 00:15:55,067
其它轨道，然后将磁道密度 

321
00:15:54,002 --> 00:15:57,095
这是那种你如何接近可以把 

322
00:15:55,067 --> 00:15:58,154
这些曲目在一起 ，然后将 

323
00:15:57,095 --> 00:16:00,122
这两个产品是所谓 

324
00:15:59,054 --> 00:16:02,120
面密度以及确定 

325
00:16:01,022 --> 00:16:06,086
光盘的 总 容量 ，因此 

326
00:16:03,002 --> 00:16:09,029
更高的面容量的多个比特 

327
00:16:06,086 --> 00:16:14,183
你可以挤在到该上 

328
00:16:09,047 --> 00:16:18,128
现在表面昔日的空中时， 

329
00:16:15,083 --> 00:16:20,126
密度是相当低的每各 

330
00:16:19,028 --> 00:16:23,036
赛道表面上会具有相同的 

331
00:16:21,026 --> 00:16:26,090
扇区数好了，所以出现了 

332
00:16:24,008 --> 00:16:30,011
每个磁道的扇区 ，以便 恒定数 

333
00:16:26,009 --> 00:16:32,042
现在你会发生什么作为你的曲目 

334
00:16:30,038 --> 00:16:35,081
从靠近你知道整个去附近 

335
00:16:33,023 --> 00:16:38,030
由主轴，因为他们去，因为他们移动 

336
00:16:35,081 --> 00:16:40,094
如果你也有同样的权利向外

337
00:16:38,003 --> 00:16:45,011
部门与在相同数量的 

338
00:16:40,094 --> 00:16:47,108
相同的轨道位密度，所述间隙 

339
00:16:45,038 --> 00:16:49,100
部门之间会得到更大

340
00:16:48,008 --> 00:16:51,011
和更大的作为你出去你 

341
00:16:50,000 --> 00:16:55,037
将要浪费更多的 

342
00:16:51,038 --> 00:16:57,043
你的空间，让你在空中时 

343
00:16:55,037 --> 00:16:59,084
密度是相当低的，这是好的 

344
00:16:57,043 --> 00:17:01,109
但 经过一段时间它只是变得不 

345
00:16:59,084 --> 00:17:03,125
好浪费那么多空间，所以什么 

346
00:17:02,009 --> 00:17:06,092
现代系统做的是他们，他们分区 

347
00:17:04,025 --> 00:17:09,104
轨道到这些所谓的 车 

348
00:17:06,092 --> 00:17:11,099
记录区域，其中每个各 

349
00:17:10,004 --> 00:17:14,923
记录区 像这样的就在这里 

350
00:17:12,062 --> 00:17:19,064
每个记录区具有恒定

351
00:17:14,959 --> 00:17:21,350
扇区的数量，以便在每个轨道 

352
00:17:19,064 --> 00:17:23,072
记录区具有相同数量的 

353
00:17:21,035 --> 00:17:26,039
部门，当然，当您移动 

354
00:17:23,072 --> 00:17:28,136
向外如果在向外移动 

355
00:17:26,075 --> 00:17:30,167
记录带你将有 

356
00:17:29,036 --> 00:17:34,037
越做越大的差距，但随后却对 

357
00:17:31,067 --> 00:17:37,148
你开始一个新的记录区即会 

358
00:17:34,037 --> 00:17:39,114
有每磁道 ，然后 更多的扇区 

359
00:17:38,048 --> 00:17:42,051
内 

360
00:17:40,014 --> 00:17:45,053
所以你可以在这个在外在这看

361
00:17:42,051 --> 00:17:47,129
你有外区的越多，你有更多的 

362
00:17:45,179 --> 00:17:50,490
行业比你做这个内区 

363
00:17:48,029 --> 00:17:53,091
好了，这是一个办法来样 交易 

364
00:17:50,049 --> 00:17:55,056
与那种认为这 是成长 

365
00:17:53,091 --> 00:17:58,092
在间隙保持它变得太 

366
00:17:56,019 --> 00:18:02,067
大，是 因为我们 真的不 

367
00:17:59,001 --> 00:18:05,040
有 每磁道 的扇区数 

368
00:18:02,067 --> 00:18:07,104
是不是恒定的，我们将使用一个平均的 

369
00:18:05,004 --> 00:18:10,163
平均每个部门追踪所有 

370
00:18:08,004 --> 00:18:14,010
记录区的时候，我们做排序 的我们 

371
00:18:10,559 --> 00:18:16,470
容量估算 好了，你可以 

372
00:18:14,001 --> 00:18:17,070
想象的公式 计算所述 

373
00:18:16,047 --> 00:18:21,256
磁盘容量是相当简单 

374
00:18:17,079 --> 00:18:23,468
它的每扇区字节数 

375
00:18:21,679 --> 00:18:27,210
平均 每扇区倍

376
00:18:24,179 --> 00:18:29,192
追踪时代 音轨的平均数 

377
00:18:27,021 --> 00:18:31,370
面的每面的次数

378
00:18:29,309 --> 00:18:36,720
盘片的单碟次数

379
00:18:31,559 --> 00:18:40,559
每个磁盘现在没事了，让我们看看 如何只 

380
00:18:36,072 --> 00:18:42,087
工作，所以这些这些表面

381
00:18:40,559 --> 00:18:45,608
以固定旋转速率现在纺丝

382
00:18:42,087 --> 00:18:50,124
一个典型的速率 可以是7200转是一个 

383
00:18:46,049 --> 00:18:56,090
相当普遍的旋转速率，因此 

384
00:18:51,024 --> 00:18:55,109
盘转圈，你可以看到这 

385
00:18:56,036 --> 00:19:00,132
很骄傲的说 

386
00:18:59,021 --> 00:19:05,076
所以它围绕旋转的反 

387
00:19:01,032 --> 00:19:08,114
顺时针然后 臂移动 

388
00:19:05,076 --> 00:19:08,114
径向这里我们去

389
00:19:10,015 --> 00:19:16,109
手臂径向运动，它可以去 

390
00:19:13,001 --> 00:19:23,012
在任何轨道 还好没事 

391
00:19:17,009 --> 00:19:27,478
现在这已经足够好了，当你有 

392
00:19:23,012 --> 00:19:28,085
多个盘片每个这些每一个

393
00:19:27,559 --> 00:19:30,740
其中一个有实际多

394
00:19:28,085 --> 00:19:34,148
武器和有一个 读/写头 

395
00:19:30,074 --> 00:19:39,133
每个表面，所以如果盘片具有 - 

396
00:19:35,048 --> 00:19:42,487
如果对 盘片的 每一侧 被 涂覆 

397
00:19:39,799 --> 00:19:44,450
这种磁性材料 那么你会 

398
00:19:42,919 --> 00:19:46,957
有你对每一个读/写磁头 

399
00:19:44,045 --> 00:19:48,124
侧，然后将这些都 连接 

400
00:19:47,299 --> 00:19:51,830
他们那种一起移动 

401
00:19:48,529 --> 00:19:54,830
现在原来他们这些读/写 

402
00:19:51,083 --> 00:19:55,148
头是他们的权利刚性 

403
00:19:54,083 --> 00:19:58,088
因为密度的磁道密度 

404
00:19:56,048 --> 00:20:00,086
不高，因此他们可能他们

405
00:19:58,088 --> 00:20:02,150
可能只是 有点乐句和即使 

406
00:20:00,086 --> 00:20:05,174
轨道不完美 ，现在 排队 

407
00:20:03,005 --> 00:20:08,069
他们可能只是排序他们的，他们可能 

408
00:20:06,074 --> 00:20:10,127
仍然可以覆盖读 /写 

409
00:20:09,014 --> 00:20:14,413
头仍然可以覆盖轨道 

410
00:20:11,027 --> 00:20:16,906
这些固定这些固定的武器，但

411
00:20:14,539 --> 00:20:20,210
时下的密度 是如此 

412
00:20:17,149 --> 00:20:22,010
高，他们其实控制器 

413
00:20:20,021 --> 00:20:23,590
实际上可以移动的读/写头一个

414
00:20:22,001 --> 00:20:26,027
点点，使其 与相匹配 

415
00:20:23,779 --> 00:20:31,640
所有的轨道上所有的

416
00:20:26,027 --> 00:20:37,102
表面好了，让我们来看看如何 

417
00:20:31,064 --> 00:20:40,112
作品我们如何读取数据，所以我们有我们的 

418
00:20:38,002 --> 00:20:42,086
这是我们的，这是我们的手臂 和尖端 

419
00:20:41,012 --> 00:20:45,681
箭头的是读/写头和 

420
00:20:42,086 --> 00:20:48,149
它的定位和盘片是

421
00:20:45,789 --> 00:20:51,830
逆时针旋转，它的 

422
00:20:49,049 --> 00:20:55,073
定位刚准备读取蓝 

423
00:20:51,083 --> 00:20:58,094
部门因此它为蓝色部门自旋 

424
00:20:55,073 --> 00:20:59,126
该读/写头的下方其感测 

425
00:20:58,094 --> 00:21:00,188
这些比特，并将它们发送到 

426
00:21:00,026 --> 00:21:05,075
控制器，其将它们传递回至

427
00:21:01,088 --> 00:21:07,169
CPU和现在的CPU要求 

428
00:21:05,075 --> 00:21:11,614
磁盘 它要求红 

429
00:21:08,069 --> 00:21:13,528
从红色部门的数据，所以我们必须 

430
00:21:12,289 --> 00:21:17,301
取控制器采取该 

431
00:21:14,149 --> 00:21:19,660
读/写磁头移回 红 

432
00:21:17,409 --> 00:21:23,580
跟踪

433
00:21:19,066 --> 00:21:22,158
然后等待它左右旋转和 

434
00:21:23,088 --> 00:21:32,181
在读/写头，然后 

435
00:21:29,047 --> 00:21:35,122
它读取红色红色 部门 

436
00:21:33,081 --> 00:21:37,114
好了，所以当 我们第一次如此没什么 

437
00:21:36,022 --> 00:21:40,033
三个组件 会在这里 说 

438
00:21:38,014 --> 00:21:44,017
确定需要多长时间来读取一个 

439
00:21:40,033 --> 00:21:44,088
这些部门的当我们移动

440
00:21:44,017 --> 00:21:48,022
头

441
00:21:44,088 --> 00:21:50,143
这就是所谓的寻找，当我们等待 

442
00:21:48,022 --> 00:21:52,030
红色轨道排序的旋转 

443
00:21:51,043 --> 00:21:55,114
围绕这就是所谓的旋转 

444
00:21:53,002 --> 00:22:00,055
延迟，所以但需要多长时间上 

445
00:21:56,014 --> 00:22:03,073
平均它将是一半的一半 

446
00:22:00,055 --> 00:22:06,055
它需要 整个 的 时间 

447
00:22:03,073 --> 00:22:08,110
周围再绕一路

448
00:22:06,055 --> 00:22:10,132
有这类型的数据传输

449
00:22:09,001 --> 00:22:14,010
多长时间需要为为 

450
00:22:11,032 --> 00:22:17,044
跟踪读/写磁头下方通过

451
00:22:15,000 --> 00:22:20,032
现在的原因的原因是很重要的

452
00:22:17,044 --> 00:22:21,070
要知道这是这三个 

453
00:22:20,032 --> 00:22:23,041
组件添加它们放在一起， 

454
00:22:21,007 --> 00:22:26,098
这就是这就是你的平均 时间 

455
00:22:24,022 --> 00:22:30,031
它需要的是时间访问数据 

456
00:22:27,061 --> 00:22:32,086
由寻道时间占据如此寻道时间 

457
00:22:31,012 --> 00:22:34,023
以毫秒为单位被测量对好 

458
00:22:32,086 --> 00:22:36,154
我们正在这头有这 

459
00:22:34,023 --> 00:22:40,078
有有火起来 的伺服 和 

460
00:22:37,054 --> 00:22:43,117
有实际的机械运动和

461
00:22:40,078 --> 00:22:46,174
这需要时间，它是在 

462
00:22:44,017 --> 00:22:50,116
3到9毫秒秩序 

463
00:22:47,074 --> 00:22:52,171
这一直是真正的几十年这样的权利 

464
00:22:51,016 --> 00:22:55,017
这个这个值是不会改变 的权利 

465
00:22:53,071 --> 00:22:59,125
还有的根本只是排序 

466
00:22:55,026 --> 00:23:03,039
机械极限，使得它非常

467
00:23:00,025 --> 00:23:09,040
难以降低这此值 

468
00:23:03,039 --> 00:23:13,072
现在旋转延迟 的时间 

469
00:23:09,004 --> 00:23:16,033
它需要不停地旋转 会我们会打电话给 

470
00:23:13,072 --> 00:23:18,076
的 T平均旋转，然后 将 

471
00:23:16,069 --> 00:23:20,146
花费的时间读这些位将调用 

472
00:23:19,012 --> 00:23:24,018
牛逼平均传输好了，所以我们个人有T 

473
00:23:21,046 --> 00:23:29,074
平均寻道时间是这个 寻道时间 

474
00:23:24,072 --> 00:23:31,144
旋转等待时间和传送时间和 

475
00:23:29,074 --> 00:23:35,083
现在，如果我们只是 把一些 典型的数字 

476
00:23:32,044 --> 00:23:39,100
和插在那些你看到我们寻求

477
00:23:36,064 --> 00:23:41,080
时间是毫秒的量级

478
00:23:40,000 --> 00:23:43,021
旋转速度也量级 

479
00:23:41,008 --> 00:23:44,041
毫秒权利，使有有 

480
00:23:43,021 --> 00:23:49,024
同时机械极限的速度有多快你 

481
00:23:45,013 --> 00:23:51,105
你可以可以旋转这些周围 的访问 

482
00:23:49,024 --> 00:23:54,061
时间和传输的 传输时间 

483
00:23:52,005 --> 00:23:57,016
非常小，所以 它的订单 

484
00:23:54,061 --> 00:23:58,093
幅度要小，因为你就是你 

485
00:23:57,016 --> 00:24:03,073
只 需要读几个比特 

486
00:23:58,093 --> 00:24:04,099
在一个行业好，所以如果你，如果你 

487
00:24:03,073 --> 00:24:07,134
看你能，你可以看到总 

488
00:24:05,053 --> 00:24:11,089
访问时间是寻求和主导 

489
00:24:08,034 --> 00:24:12,109
旋转延迟，所以你知道的好 

490
00:24:11,089 --> 00:24:14,095
只是有点经验法则 

491
00:24:13,009 --> 00:24:16,096
估计需要多长时间阅读 

492
00:24:14,095 --> 00:24:17,173
从谋求盘只取两次 

493
00:24:16,096 --> 00:24:22,096
寻道时间，你会你会 

494
00:24:18,073 --> 00:24:26,107
相当接近，基本上转移 

495
00:24:22,096 --> 00:24:27,169
时间就是你得到的是免费的，现在这里的 

496
00:24:27,007 --> 00:24:33,025
在这里要知道 最重要的事情 

497
00:24:28,069 --> 00:24:35,142
有关磁盘我们在SRAM约访问时间 

498
00:24:33,025 --> 00:24:42,027
4纳秒得到 一个双字 

499
00:24:36,042 --> 00:24:44,077
DRAM是大约60纳秒所以DRAM是 

500
00:24:42,027 --> 00:24:49,054
约一个数量级慢 

501
00:24:44,077 --> 00:24:51,172
SRAM但盘 慢40000次 

502
00:24:49,054 --> 00:24:55,081
比SRAM所以这是4000个订单 

503
00:24:52,072 --> 00:24:59,110
幅度差 这是巨大的和 

504
00:24:55,081 --> 00:25:04,153
这是它的幅度的 250倍订单 

505
00:25:00,001 --> 00:25:07,042
且T公羊慢，因此在有一个 

506
00:25:05,053 --> 00:25:11,119
DRAM和SRAM之间差距较大

507
00:25:07,051 --> 00:25:15,123
有盘之间更大的差距 

508
00:25:12,019 --> 00:25:19,057
和等其它存储器类型

509
00:25:16,023 --> 00:25:25,024
现在现代磁盘呈现更简单 

510
00:25:19,057 --> 00:25:29,062
鉴于比，所以我们那么这这条赛道 

511
00:25:25,033 --> 00:25:32,064
缸部门几何，所以现代 

512
00:25:30,007 --> 00:25:35,035
现代磁盘控制器实际存在

513
00:25:32,064 --> 00:25:37,108
到 CPU它们呈现该盘是 

514
00:25:35,035 --> 00:25:40,051
逻辑块的序列，其中每个 

515
00:25:38,008 --> 00:25:42,022
块是是扇区 侧 的倍数

516
00:25:40,051 --> 00:25:44,062
因此这在最简单的情况下，块

517
00:25:42,022 --> 00:25:46,048
只是觉得一个逻辑块是一个 

518
00:25:44,062 --> 00:25:47,146
扇区，然后块 

519
00:25:46,048 --> 00:25:51,066
从零开始， 他们只是全力以赴 

520
00:25:48,046 --> 00:25:55,063
向上一些一些 大量 方式 

521
00:25:51,066 --> 00:25:56,149
然后将磁盘控制器保持 

522
00:25:55,063 --> 00:25:58,144
映射保持映射

523
00:25:57,049 --> 00:26:04,063
逻辑块与实际之间

524
00:25:59,044 --> 00:26:06,273
物理扇区，从而为老

525
00:26:04,063 --> 00:26:07,072
说的是你知道最有趣最

526
00:26:06,669 --> 00:26:10,690
在 计算机科学的想法是涉及 

527
00:26:08,053 --> 00:26:13,066
某种形式的间接的，所以这是一个 

528
00:26:10,069 --> 00:26:14,688
间接的水平，为您提供 

529
00:26:13,066 --> 00:26:17,074
知道的逻辑块之间的这种映射

530
00:26:15,309 --> 00:26:19,750
和物理块因此它允许磁盘 

531
00:26:17,074 --> 00:26:21,513
控制器采取一些汽缸和 

532
00:26:19,075 --> 00:26:23,116
保留他们作为备用气瓶 那 

533
00:26:22,179 --> 00:26:27,460
在电子逻辑块没有被映射和 

534
00:26:24,016 --> 00:26:30,052
那么，如果有如果的部门之一 

535
00:26:27,046 --> 00:26:34,078
在气缸磁盘变坏

536
00:26:30,052 --> 00:26:36,109
控制器可以只复制 复制 

537
00:26:34,078 --> 00:26:38,125
到备用筒，然后数据

538
00:26:37,009 --> 00:26:41,478
只是不停权利，使这一点，所以 

539
00:26:39,025 --> 00:26:43,027
这就是为什么你的 4MATIC 容量是 

540
00:26:41,559 --> 00:26:44,646
不到排序的，如果你知道，如果你 

541
00:26:43,027 --> 00:26:45,121
算实际的气缸 数 

542
00:26:45,429 --> 00:26:48,340
在磁盘上

543
00:26:46,021 --> 00:26:50,029
所述4MATIC 容量小于 

544
00:26:48,034 --> 00:26:52,090
最大容量，因为一些人的 

545
00:26:50,029 --> 00:27:00,076
汽缸被保留以供 

546
00:26:52,009 --> 00:27:02,077
故障现在如磁盘设备 

547
00:27:00,076 --> 00:27:07,111
连接到所述CPU和所述

548
00:27:03,058 --> 00:27:12,061
经由I / O桥的另一个存储器 

549
00:27:08,011 --> 00:27:14,074
一种总线称为I / O总线这是什么 

550
00:27:12,088 --> 00:27:17,137
我显示你有什么我 展示你现在 

551
00:27:14,074 --> 00:27:19,165
是实际上是不具有代表性的 

552
00:27:18,037 --> 00:27:22,099
现代系统是典型的 

553
00:27:20,065 --> 00:27:27,070
什么是所谓的PCI总线大约五 

554
00:27:22,099 --> 00:27:29,101
年前，现代客车现在的PCI 

555
00:27:27,007 --> 00:27:33,048
总线是广播总线意味着它只是 

556
00:27:30,001 --> 00:27:37,036
单组导线，所以如果任何设备 

557
00:27:34,011 --> 00:27:39,070
改变这些导线中的值每 

558
00:27:37,036 --> 00:27:42,094
该总线上的设备可以看到这些值 

559
00:27:39,007 --> 00:27:44,041
还好这就是所谓 的广播总线和 

560
00:27:42,094 --> 00:27:48,175
这是一个最简单的一种方式挂钩 

561
00:27:45,004 --> 00:27:52,009
事堂现代生产系统采用总线 

562
00:27:49,075 --> 00:27:53,152
结构称为PCI Express的这

563
00:27:52,054 --> 00:27:55,060
虽然它有 字PCI和 它的 

564
00:27:54,052 --> 00:27:58,063
完全不同的是点至点 

565
00:27:56,014 --> 00:28:00,019
这样的设备是由一组连接

566
00:27:58,063 --> 00:28:03,064
点对点连接

567
00:28:00,019 --> 00:28:06,022
通过呃仲裁通过 某种形式 的 

568
00:28:03,064 --> 00:28:08,113
切换，我们不会进入 它 它的 

569
00:28:06,049 --> 00:28:13,060
同样的 想法这是一个更有效 

570
00:28:09,013 --> 00:28:15,031
设计它的速度更快，但它 

571
00:28:13,006 --> 00:28:17,011
主要提供同样的功能它 

572
00:28:15,031 --> 00:28:20,127
只是接了它可以让 你连接 

573
00:28:18,001 --> 00:28:24,007
所有设备你 到你的 CPU 

574
00:28:21,027 --> 00:28:26,089
所以才觉得这个总线作为这种 

575
00:28:24,016 --> 00:28:30,064
单组导线，其中每个导线 

576
00:28:26,089 --> 00:28:31,177
携带位和连接的每一个设备 

577
00:28:30,064 --> 00:28:36,103
它可以看到所有的所有的值 

578
00:28:32,077 --> 00:28:38,086
电线，所以它 有一些设备 

579
00:28:37,003 --> 00:28:40,051
这只是建造它直接进入 

580
00:28:38,086 --> 00:28:41,095
主板和 他们连接到总线 

581
00:28:40,051 --> 00:28:46,093
像你知道磁盘只是直接插入 

582
00:28:42,076 --> 00:28:48,175
进入主板，您对插座

583
00:28:46,093 --> 00:28:51,106
知道你的图形适配器和USB 

584
00:28:49,075 --> 00:28:52,171
控制器，然后系统呈现

585
00:28:52,006 --> 00:28:56,037
一个界面， 您可以插入 鼠标 

586
00:28:53,071 --> 00:29:00,085
之类的老鼠的鼠标和键盘 

587
00:28:56,037 --> 00:29:03,039
插入USB控制器 ，然后 有 

588
00:29:00,085 --> 00:29:05,110
扩展槽允许您 

589
00:29:03,039 --> 00:29:07,074
连接到导线，并在总线 

590
00:29:06,001 --> 00:29:09,094
允许您添加其他设备，如 

591
00:29:07,074 --> 00:29:13,138
也许联网哦，如果你想要把一个 

592
00:29:10,003 --> 00:29:15,082
在有网络适配器现在该怎么办

593
00:29:14,038 --> 00:29:18,046
发生在我们想要读取磁盘 

594
00:29:15,082 --> 00:29:21,085
部门以及CPU的启动这个读 

595
00:29:19,018 --> 00:29:23,071
通过写一个三重所以编写三种

596
00:29:22,012 --> 00:29:27,025
不同的值写入一个命令 

597
00:29:23,071 --> 00:29:28,162
好比说读取写入逻辑块 

598
00:29:27,025 --> 00:29:31,120
数，所以我想读逻辑块

599
00:29:29,062 --> 00:29:33,109
号码，我希望把内容

600
00:29:32,002 --> 00:29:37,077
在一定的那个逻辑块的

601
00:29:34,009 --> 00:29:41,026
在内存中处理好所以它是一个命令 

602
00:29:37,095 --> 00:29:45,166
逻辑块号和一个存储器

603
00:29:41,026 --> 00:29:48,073
解决磁盘控制器读取 

604
00:29:46,066 --> 00:29:50,163
任何部门对应于 

605
00:29:48,073 --> 00:29:53,101
逻辑块所以我们假设 

606
00:29:51,063 --> 00:29:56,140
逻辑块是由一个的 

607
00:29:54,001 --> 00:29:59,095
扇区，然后它这个有趣 

608
00:29:57,004 --> 00:30:02,050
事情 它复制它需要的控制 

609
00:29:59,095 --> 00:30:04,114
公交车，并将其复制的数据是这样的 

610
00:30:02,086 --> 00:30:06,097
磁盘控制器现在复制数据 

611
00:30:05,014 --> 00:30:08,080
横跨通过I I / O总线/ O 

612
00:30:06,097 --> 00:30:11,164
桥梁和直接到主存 

613
00:30:08,008 --> 00:30:12,016
而不会通知的CPU，因此 

614
00:30:12,064 --> 00:30:18,070
CPU完成

615
00:30:13,006 --> 00:30:22,060
在 无视事实，这 

616
00:30:18,007 --> 00:30:24,010
转移是怎么回事 ，然后一旦它 

617
00:30:23,014 --> 00:30:27,933
一旦它传输的数据是一个 

618
00:30:24,073 --> 00:30:29,140
主存储器然后它通知CPU 

619
00:30:28,059 --> 00:30:33,820
使用这种机制称为中断 

620
00:30:30,004 --> 00:30:37,023
因此它实际上声称在该引脚

621
00:30:33,082 --> 00:30:40,071
实际的CPU芯片本身，以便它改变了 

622
00:30:37,419 --> 00:30:43,480
该引脚的值从0到1， 并且 

623
00:30:40,809 --> 00:30:46,815
扳机是一个中断，并且

624
00:30:43,048 --> 00:30:50,050
通知CPU认为这是该

625
00:30:47,409 --> 00:30:53,470
部门已 确定 复制 这样则 

626
00:30:50,005 --> 00:30:54,091
CPU，如果有一些程序某处 

627
00:30:53,047 --> 00:30:57,996
等待数据读入 

628
00:30:55,036 --> 00:31:00,082
内存 所以现在现在的CPU 可以可以 

629
00:30:58,419 --> 00:31:03,495
执行该程序并处理该 

630
00:31:00,082 --> 00:31:06,163
内存中，因此这是什么这是什么 机制 

631
00:31:04,179 --> 00:31:10,150
允许他们这样做的原因是

632
00:31:07,063 --> 00:31:15,070
因为 这里面只是 这么神可怕的 

633
00:31:10,015 --> 00:31:18,019
减缓在10毫秒内 的系统 

634
00:31:16,033 --> 00:31:19,114
可以执行数以百万计

635
00:31:18,019 --> 00:31:21,258
指令的CPU 可 

636
00:31:20,014 --> 00:31:23,553
执行百万千万的 

637
00:31:21,429 --> 00:31:25,467
说明这将是一个可怕的 浪费 

638
00:31:23,679 --> 00:31:29,220
该CPU等待该数据来 

639
00:31:25,809 --> 00:31:32,320
脱落的磁盘，这样它的作用是它 

640
00:31:29,022 --> 00:31:34,611
它发出这个请求磁盘 

641
00:31:32,032 --> 00:31:36,109
控制器 ，然后而清楚 

642
00:31:34,809 --> 00:31:40,090
真的很慢艰苦的过程是怎么回事 

643
00:31:37,009 --> 00:31:41,044
在CPU上可以执行的其他

644
00:31:40,009 --> 00:31:47,065
指令和在其他有用 

645
00:31:41,044 --> 00:31:48,112
工作，所以这真的是必不可少的 排序 

646
00:31:47,065 --> 00:31:50,071
的越来越合理的性能 和 

647
00:31:49,012 --> 00:31:54,012
从保持这种很慢的磁盘 

648
00:31:51,025 --> 00:31:59,119
从系统拖慢系统

649
00:31:54,012 --> 00:32:01,096
现在有另一个有趣的 炒作 

650
00:32:00,019 --> 00:32:04,023
光盘类型称为 固态硬盘 

651
00:32:01,096 --> 00:32:07,105
这是一种中途 之间 

652
00:32:04,059 --> 00:32:11,127
旋转旋转盘 和 DRAM 

653
00:32:08,086 --> 00:32:14,086
回忆和固态硬盘到

654
00:32:12,027 --> 00:32:16,069
到 CPU，它看起来酷似 

655
00:32:14,086 --> 00:32:19,174
旋转盘具有相同的插座 

656
00:32:16,069 --> 00:32:22,084
插上它具有相同的物理接口 

657
00:32:20,074 --> 00:32:25,102
具有相同的包装还行 吧 

658
00:32:22,084 --> 00:32:26,092
看起来像一个旋转的圆盘，而是 

659
00:32:26,002 --> 00:32:29,088
具有 所有这些机械 的 

660
00:32:27,064 --> 00:32:34,129
它实际上完全是建出来的 

661
00:32:29,088 --> 00:32:37,123
闪存和 固件 作为 

662
00:32:35,029 --> 00:32:40,126
所述控制器，以便 的 内部 

663
00:32:38,023 --> 00:32:43,092
固态硬盘有一个固件 

664
00:32:41,026 --> 00:32:45,049
固件的一套名为闪光 

665
00:32:43,299 --> 00:32:47,500
其用于所述转换层

666
00:32:45,049 --> 00:32:54,070
目的， 同一目的的 磁盘 

667
00:32:47,005 --> 00:32:58,012
控制器确实 在旋转 盘的 

668
00:32:54,007 --> 00:33:00,100
然后存储器本身读出的数据 

669
00:32:58,057 --> 00:33:03,786
可以读取读取 和写入 

670
00:33:01,063 --> 00:33:06,121
闪存以页为单位，其 

671
00:33:04,299 --> 00:33:12,387
取决于技术可为512 

672
00:33:07,021 --> 00:33:16,054
KB 到4千个字节，然后一个序列 

673
00:33:13,179 --> 00:33:18,940
页面现在这些这些形式的块 

674
00:33:16,054 --> 00:33:21,063
这些块是从不同的 

675
00:33:18,094 --> 00:33:24,102
逻辑块的CPU 这样做是 

676
00:33:21,549 --> 00:33:32,260
这类条款的不幸重叠 

677
00:33:25,074 --> 00:33:33,127
但关键是还是我猜 

678
00:33:32,026 --> 00:33:37,072
限制是，数据被写入

679
00:33:34,027 --> 00:33:39,124
页为单位，但一个页面只能是 

680
00:33:37,072 --> 00:33:44,134
写入 整个块被 后 

681
00:33:40,024 --> 00:33:46,069
抹去好了，就是 这样似乎有点 

682
00:33:45,034 --> 00:33:48,100
奇怪，但就是 这样的工作方式 

683
00:33:46,069 --> 00:33:54,112
所以这是什么意思是，如果你想 

684
00:33:49,000 --> 00:33:56,059
写，如果你想给 你写信页面 

685
00:33:55,012 --> 00:33:59,101
必须找到一个 地方 块 这 

686
00:33:56,059 --> 00:34:01,123
被擦除你必须复制所有的 

687
00:34:00,001 --> 00:34:04,060
在您的其他网页 在您的目标块 

688
00:34:02,023 --> 00:34:07,722
到新的块，然后你可以 

689
00:34:04,006 --> 00:34:10,815
做正确的好，所以你可以 看到， 

690
00:34:07,929 --> 00:34:13,934
写入现在变得相当复杂 

691
00:34:11,409 --> 00:34:19,090
操作读你可以读什么和 

692
00:34:14,429 --> 00:34:20,440
然后像所有的Flash 一所以它的类型的 

693
00:34:19,009 --> 00:34:23,107
高效正确的，因为你写

694
00:34:20,044 --> 00:34:25,075
一个页面，但 要做到这一点 ， 你必须 排序 

695
00:34:24,007 --> 00:34:28,116
的拷贝在所有其他网页

696
00:34:25,075 --> 00:34:29,083
块，你必须是比赛中的 整体 

697
00:34:28,179 --> 00:34:32,226
然后当你完成，那么你删除 

698
00:34:30,055 --> 00:34:34,087
这个块，因此它可以被用于为

699
00:34:32,649 --> 00:34:36,910
其他写入 是 

700
00:34:34,087 --> 00:34:39,091
所以最终十万后 

701
00:34:36,091 --> 00:34:41,134
重复 这些 权利 现在穿出来 

702
00:34:40,027 --> 00:34:44,095
闪存转换层寻 

703
00:34:42,034 --> 00:34:48,049
现代系统做各种花式的 

704
00:34:44,095 --> 00:34:50,116
专有算法排序的延伸 

705
00:34:48,049 --> 00:34:52,147
生活他们使用兑现和和 

706
00:34:51,016 --> 00:34:55,111
各种技巧来延长寿命

707
00:34:53,047 --> 00:34:57,118
这些SSD所以在实践中这不是真的 

708
00:34:56,011 --> 00:35:00,088
一个问题，我会告诉你的 

709
00:34:58,018 --> 00:35:04,099
第二个这样的表现

710
00:35:00,088 --> 00:35:06,094
固态硬盘的特性，现在你可以 

711
00:35:04,099 --> 00:35:09,148
认为一个典型的 硬盘驱动器 ， 你可能 

712
00:35:07,048 --> 00:35:11,119
能够让你知道 我的意思是，如果什么 

713
00:35:10,048 --> 00:35:14,059
当我衡量他们，当我测量

714
00:35:12,019 --> 00:35:16,035
驱动器，其可以是每40 50兆字节 

715
00:35:14,059 --> 00:35:20,077
第二，这将是一个 典型的速率 

716
00:35:16,035 --> 00:35:20,113
还好这些SSD 比快10倍 

717
00:35:20,077 --> 00:35:22,150
那 

718
00:35:21,013 --> 00:35:27,037
因此对于连续读取，你可以得到 

719
00:35:23,005 --> 00:35:31,051
约500 50兆字节顺序写入

720
00:35:27,037 --> 00:35:33,061
是有点慢随机访问 

721
00:35:31,096 --> 00:35:34,105
不管你是在读或写是 

722
00:35:33,061 --> 00:35:38,086
有点不是 顺序访问 的速度慢 

723
00:35:35,086 --> 00:35:40,135
当我们将看到这是，这是 

724
00:35:38,086 --> 00:35:42,091
如果它在 内存系统中相当普遍 

725
00:35:41,035 --> 00:35:47,079
它几乎总是最好做的事情 

726
00:35:42,091 --> 00:35:49,156
顺序，而不是 跳跃和 

727
00:35:47,079 --> 00:35:52,126
擦除随机写入速度较慢，因为 

728
00:35:50,056 --> 00:35:55,075
删除删除大约需要一毫秒 

729
00:35:53,026 --> 00:35:58,072
右所以现在我们 备份到该 

730
00:35:55,075 --> 00:36:00,157
哪个 是哪个毫秒范围 是慢 

731
00:35:58,072 --> 00:36:04,099
和我 没有提到，如果你修改一个 

732
00:36:01,057 --> 00:36:07,116
所有其他网页后一个一个页面

733
00:36:04,099 --> 00:36:10,126
在该块必须现在复制 

734
00:36:08,016 --> 00:36:16,099
早期的SSD 之间产生了巨大差距

735
00:36:11,026 --> 00:36:20,110
随机写入和和和顺序

736
00:36:16,099 --> 00:36:21,127
线索，但他们因为某种的 

737
00:36:21,001 --> 00:36:25,042
在闪存转换改进

738
00:36:22,027 --> 00:36:26,095
层中的这些是不是真的那么说 

739
00:36:25,051 --> 00:36:29,086
差异正确阅读 和写作 

740
00:36:26,095 --> 00:36:31,099
它的书写速度较慢，但他们正在 做 

741
00:36:29,086 --> 00:36:33,171
各种有趣的令人惊奇的事情

742
00:36:31,099 --> 00:36:37,102
得到这些数字相当接近 

743
00:36:34,071 --> 00:36:39,127
确定这样的艺术，当我们有固态硬盘的型号 

744
00:36:38,002 --> 00:36:43,089
我们并不需要区分 

745
00:36:40,027 --> 00:36:43,089
再那之间的读取和写入 

746
00:36:44,038 --> 00:36:49,497
好了，所以固态硬盘，因为他们没有动

747
00:36:47,041 --> 00:36:51,990
部分有更快他们采取少 

748
00:36:49,839 --> 00:36:53,906
功率他们更坚固 ，你知道哪些 

749
00:36:52,359 --> 00:36:57,450
就是为什么他们是很好的拇指驱动器和

750
00:36:54,509 --> 00:37:00,900
你知道iPod播放器之类的东西 

751
00:36:58,269 --> 00:37:04,660
但他们有这个潜力，穿出来 

752
00:37:00,009 --> 00:37:05,928
这可能是一个问题 ，但在实践中 

753
00:37:04,066 --> 00:37:09,215
它不是例如英特尔担保 

754
00:37:06,819 --> 00:37:14,170
你可以做 的写入128个千兆兆字节 

755
00:37:09,809 --> 00:37:15,910
在你的SSD不再那么好 

756
00:37:14,017 --> 00:37:17,396
这是一个很大的数据写我 的意思 

757
00:37:15,091 --> 00:37:22,710
想想怎么会多年走 

758
00:37:17,549 --> 00:37:26,410
写那么多数据，并作为20 

759
00:37:23,529 --> 00:37:27,627
2015年截至目前还有很多更 

760
00:37:26,041 --> 00:37:31,680
比旋转圆盘 昂贵 每字节 

761
00:37:28,509 --> 00:37:34,690
所以旋转磁盘是更大的，但

762
00:37:32,049 --> 00:37:41,148
他们是慢的固态硬盘体积较小 ， 

763
00:37:34,069 --> 00:37:42,888
现在他们更快，如果你需要，如果你 

764
00:37:42,039 --> 00:37:46,180
看性能特点 

765
00:37:43,509 --> 00:37:49,509
这些不同的存储设备的 

766
00:37:46,018 --> 00:37:54,087
相对于CPU随着时间的推移，你得到这个

767
00:37:49,509 --> 00:37:59,510
非常有趣的图表现在这本 

768
00:37:54,249 --> 00:38:03,252
曲线图示出了在 y轴上的存取时间 

769
00:37:59,609 --> 00:38:07,620
纳秒数 比例 好了，所以每个 

770
00:38:03,549 --> 00:38:10,960
这些在单元中的每个改变每一个 

771
00:38:07,719 --> 00:38:13,751
从1000到10000表示顺序

772
00:38:10,096 --> 00:38:18,139
在 访问时间 幅度差的 

773
00:38:14,039 --> 00:38:26,066
在x轴上 画出我的时间去 

774
00:38:19,039 --> 00:38:29,688
2085至15 年，然后我绘制的30 

775
00:38:26,309 --> 00:38:33,190
访问时间或的周期时间

776
00:38:30,039 --> 00:38:36,960
在这些设备的磁盘访问时间

777
00:38:33,019 --> 00:38:39,043
SSD DRAM和SRAM和周期时间

778
00:38:36,096 --> 00:38:41,115
处理器，以便让我们来看看在 

779
00:38:39,043 --> 00:38:45,462
底部我们的周期时间 

780
00:38:42,015 --> 00:38:47,454
随着时间的推移处理器和你看到的是什么 

781
00:38:45,849 --> 00:38:51,900
它的下降在sort 

782
00:38:47,589 --> 00:38:54,430
指数率1985年 至2003 年 

783
00:38:51,009 --> 00:38:55,047
有有基本上翻倍

784
00:38:54,043 --> 00:38:58,125
每18个月到两年 

785
00:38:56,028 --> 00:39:03,105
并且在时钟频率和 

786
00:38:59,025 --> 00:39:08,046
的循环时间得到的具有过 

787
00:39:04,005 --> 00:39:12,069
这18个月的2 至 2年的时间 使这 

788
00:39:08,046 --> 00:39:16,050
还等什么做了什么，直到厂家

789
00:39:12,069 --> 00:39:16,164
2003 让自己的处理器更快了 

790
00:39:16,005 --> 00:39:19,086
他们将他们只会加倍 

791
00:39:17,064 --> 00:39:21,159
时钟频率它们 降低 了 

792
00:39:20,031 --> 00:39:25,065
他们 是芯片的特征尺寸

793
00:39:22,059 --> 00:39:27,114
做这将让他们 把 

794
00:39:25,065 --> 00:39:31,149
事情靠得更近 ，然后有 

795
00:39:28,014 --> 00:39:36,093
这一点，再增加 时钟 

796
00:39:32,049 --> 00:39:39,105
由 成比例的量的频率现在 

797
00:39:36,093 --> 00:39:43,772
这一切都结束了2003年是一个有趣的 

798
00:39:40,005 --> 00:39:46,089
今年由于 这 台计算机的历史 

799
00:39:44,609 --> 00:39:48,830
有一种不幸财产 

800
00:39:46,089 --> 00:39:50,118
那你消耗的功率为 

801
00:39:48,083 --> 00:39:52,164
正比于你的频率 好吧， 

802
00:39:51,018 --> 00:39:56,049
更多的权力我的意思是 越高 

803
00:39:53,064 --> 00:39:59,079
频率您可以通过消耗更多的功率 

804
00:39:56,049 --> 00:40:01,143
2003 英特尔是处理器 

805
00:39:59,079 --> 00:40:06,090
准备 船将要 烧 

806
00:40:02,043 --> 00:40:10,952
约800瓦的功率想想800 

807
00:40:06,009 --> 00:40:13,011
你的笔记本电脑内瓦的灯泡和 

808
00:40:11,339 --> 00:40:18,980
我居然看到一个的 早期原型 

809
00:40:13,092 --> 00:40:21,177
这些设备和散热 片到的

810
00:40:18,098 --> 00:40:23,190
吸收功率从芯片约 

811
00:40:22,077 --> 00:40:26,118
这个大它是 关于4平方英寸 

812
00:40:24,009 --> 00:40:31,014
这是一个巨大的 东西只是坐在 

813
00:40:27,018 --> 00:40:34,056
主板所以这就是我们什么我们 

814
00:40:31,095 --> 00:40:36,122
说的是 ，处理器设计打 

815
00:40:34,056 --> 00:40:39,081
2003年电墙，他们再也 

816
00:40:37,022 --> 00:40:44,073
只是继续增加时钟 

817
00:40:39,081 --> 00:40:46,086
频率以获得更快的使 

818
00:40:44,073 --> 00:40:49,101
速度更快的计算机，什么使他们

819
00:40:47,031 --> 00:40:52,044
有2003，而不是后做

820
00:40:50,001 --> 00:40:55,016
增加时钟频率，并尝试 

821
00:40:52,044 --> 00:40:58,092
代替时钟倍频 

822
00:40:55,016 --> 00:41:02,064
他们把更多的处理器内核到 

823
00:40:58,092 --> 00:41:04,140
芯片所以现在他们再一个CPU芯片 

824
00:41:02,064 --> 00:41:08,067
成单独的处理器核心每一个 

825
00:41:05,004 --> 00:41:12,383
可以执行自己的指令 

826
00:41:08,094 --> 00:41:14,121
然后所以与通过 并行 运行 

827
00:41:12,779 --> 00:41:18,000
你可以做更有效的工作，所以 

828
00:41:15,021 --> 00:41:18,410
有效的循环时间可以继续 

829
00:41:18,000 --> 00:41:20,279
下去

830
00:41:18,599 --> 00:41:21,692
所以我什么， 我在 这里 绘制 在 

831
00:41:20,279 --> 00:41:24,377
底部是有效的循环时间，以便 

832
00:41:22,529 --> 00:41:28,538
基本循环时间除以 

833
00:41:25,259 --> 00:41:31,410
核心数量因此在这里2005 

834
00:41:28,619 --> 00:41:32,684
第一个系统，因此现在使用双核 

835
00:41:31,041 --> 00:41:35,960
你可以运行两个独立的线程或 

836
00:41:33,269 --> 00:41:37,277
两个独立的程序，目前 

837
00:41:36,329 --> 00:41:40,670
它是关于四核服务器类 

838
00:41:38,069 --> 00:41:44,700
系统就可以得到8个核心， 

839
00:41:40,067 --> 00:41:45,072
甚至还有大约 十二核 芯片使 

840
00:41:44,007 --> 00:41:47,606
在未来发生了什么事情发生的是 

841
00:41:46,017 --> 00:41:51,024
时钟频率会 

842
00:41:48,299 --> 00:41:55,170
保持相当恒定的，所以你可以看到 

843
00:41:51,024 --> 00:41:56,363
现场可以看到周期时间，先生，他们 

844
00:41:55,017 --> 00:41:59,025
这里实际上增加了一点点， 

845
00:41:56,579 --> 00:42:03,210
然后他们慢慢地下降，但它 

846
00:41:59,025 --> 00:42:04,814
一般 平整 ，所以唯一的办法 

847
00:42:03,021 --> 00:42:06,042
真正得到更多的表现 会 

848
00:42:05,039 --> 00:42:11,138
前锋是增加的数量 

849
00:42:06,042 --> 00:42:15,221
独立内核，这只是这

850
00:42:12,029 --> 00:42:17,400
只是方式它有现在是 在 这里 

851
00:42:15,599 --> 00:42:19,710
所述黑色圆圈的第二行我

852
00:42:17,004 --> 00:42:22,086
绘制的访问时间在SRAM 

853
00:42:19,071 --> 00:42:25,880
时间，你可以看到，SRAM是 

854
00:42:23,022 --> 00:42:29,141
跟踪CPU非常好 ，有 

855
00:42:26,519 --> 00:42:33,660
这是一个数量级的速度较慢，但 

856
00:42:29,339 --> 00:42:33,416
这是非常跟踪CPU性能

857
00:42:33,066 --> 00:42:36,665
好

858
00:42:34,109 --> 00:42:39,113
DRAM 可以看到有一个巨大的缺口 

859
00:42:37,259 --> 00:42:42,260
在CPU 和 DRAM 之间 的几个 

860
00:42:39,509 --> 00:42:43,470
在过去的 几年级和订单

861
00:42:42,269 --> 00:42:46,170
几年出轨已经变得有点

862
00:42:43,047 --> 00:42:53,876
更好，但他们已经证明了出奇 

863
00:42:46,017 --> 00:42:56,046
很难做出更快的固态硬盘

864
00:42:54,299 --> 00:42:59,400
那种在磁盘和DRAM之间 

865
00:42:56,046 --> 00:43:01,145
那么在这里的磁盘，你可以在看 

866
00:42:59,004 --> 00:43:02,963
亿纳秒就是这样的一个

867
00:43:01,559 --> 00:43:07,562
毫秒，所以你可以看到 磁盘 

868
00:43:03,359 --> 00:43:11,363
那种在此在这种 

869
00:43:07,859 --> 00:43:12,950
毫秒范围内的存取时间和

870
00:43:11,759 --> 00:43:16,811
那些他们已经走了下来那些

871
00:43:13,769 --> 00:43:18,960
点点，但没有真正太多这样 

872
00:43:17,279 --> 00:43:21,690
我要 说明 一点 的是，有 

873
00:43:18,096 --> 00:43:25,005
DRAM之间的巨大差距 

874
00:43:21,069 --> 00:43:27,073
SSD硬盘和 CPU，并在某些情况下， 

875
00:43:25,869 --> 00:43:32,980
这甚至 变得更糟随着时间的推移 

876
00:43:27,073 --> 00:43:34,932
通过所以 这是一个 正确的 问题 我们怎么样 

877
00:43:32,098 --> 00:43:38,125
程序都需要数据我们的数据是 

878
00:43:35,589 --> 00:43:42,160
存储在内存和磁盘 ，所以如果我们如果 

879
00:43:39,025 --> 00:43:45,049
我们的电脑正变得越来越快，我们的

880
00:43:42,016 --> 00:43:48,094
存储设备是住相对 

881
00:43:45,049 --> 00:43:50,628
相同或相对较慢那么我们已经 

882
00:43:48,094 --> 00:43:52,713
有一个问题，就在增加我们的 

883
00:43:51,069 --> 00:43:55,690
在计算机性能不会 它会 

884
00:43:53,559 --> 00:43:57,880
努力使我们的程序运行得更快 

885
00:43:55,069 --> 00:44:00,121
因为我们在时间限制之 

886
00:43:57,088 --> 00:44:01,147
对需要访问数据 好了， 

887
00:44:01,021 --> 00:44:03,930
这是这是排序 的 

888
00:44:02,047 --> 00:44:07,166
我们必须面对的根本问题

889
00:44:04,119 --> 00:44:10,540
用和原来 的关键 

890
00:44:07,589 --> 00:44:14,685
此桥接在CPU之间的这种间隙 

891
00:44:10,054 --> 00:44:16,150
和 内存，这是这个非常基本的 

892
00:44:15,549 --> 00:44:21,490
所谓的程序基本属性 

893
00:44:17,005 --> 00:44:23,083
当地确定，所以这是一个 重要的 

894
00:44:21,049 --> 00:44:26,070
排序的基本持久性

895
00:44:24,028 --> 00:44:26,070
程式

896
00:44:31,000 --> 00:44:37,042
所以我们说，这样做的节目有 

897
00:44:34,018 --> 00:44:41,059
这个属性被称为本地和什么 

898
00:44:37,042 --> 00:44:42,139
这意味着 ，我很 抱歉，我 只是我 

899
00:44:41,059 --> 00:44:44,155
要读它致力于它真的 

900
00:44:43,039 --> 00:44:49,042
准确的定义，以便方案往往 

901
00:44:45,055 --> 00:44:51,091
使用数据和指令，其

902
00:44:49,042 --> 00:44:55,042
地址是接近或等于那些

903
00:44:51,091 --> 00:44:57,148
他们使用了最近 好了，所以如果 

904
00:44:55,042 --> 00:45:01,051
程序访问的数据项的 

905
00:44:58,048 --> 00:45:04,063
机会是非常高的，它的要 

906
00:45:01,051 --> 00:45:07,125
访问该数据项或附近的数据 

907
00:45:04,063 --> 00:45:10,087
在不久的将来项目好吗 

908
00:45:08,025 --> 00:45:12,031
该可能性，该方案是

909
00:45:10,087 --> 00:45:15,123
要访问该数据项或 

910
00:45:12,085 --> 00:45:20,113
附近 在不久的将来 的某个数据项 

911
00:45:16,023 --> 00:45:23,047
这个属性被称为本地这么好 

912
00:45:21,013 --> 00:45:25,066
这一点，我们通常区分 二两 

913
00:45:23,047 --> 00:45:28,141
不同地区的时间 

914
00:45:25,066 --> 00:45:30,133
局部性的财产，最近 

915
00:45:29,041 --> 00:45:33,088
引用的项目很可能是

916
00:45:31,033 --> 00:45:36,055
在不久的将来再次引用ksdc 

917
00:45:33,088 --> 00:45:37,119
所以如果你读一个变量 机会 

918
00:45:36,055 --> 00:45:40,123
你会再次读取该变量 

919
00:45:38,019 --> 00:45:42,118
例如，假设你正在总结 成 

920
00:45:41,023 --> 00:45:44,028
一个循环的每个循环 内的可变

921
00:45:43,018 --> 00:45:50,020
迭代你要访问 

922
00:45:44,073 --> 00:45:53,089
该变量没关系空间局部性 

923
00:45:50,002 --> 00:45:57,040
对于与附近项目的倾向

924
00:45:53,089 --> 00:45:58,183
解决了的项目，如果我们如果访问 

925
00:45:57,058 --> 00:46:03,153
我们访问一个项目几率很高

926
00:45:59,083 --> 00:46:03,090
我们要进入附近的好项目 

927
00:46:04,086 --> 00:46:10,117
所以让我们来看看这个小片段

928
00:46:09,007 --> 00:46:13,068
代码，看看我们是否能够识别所有 的 

929
00:46:11,017 --> 00:46:15,082
不同 地区的这一代码 

930
00:46:13,068 --> 00:46:17,071
所以，我们有两种不同的 

931
00:46:15,082 --> 00:46:19,135
引用有数据引用和

932
00:46:17,098 --> 00:46:20,191
再有就是正确的指令所以我们 

933
00:46:20,035 --> 00:46:23,109
读出指令的内存和 

934
00:46:21,091 --> 00:46:27,133
这些指令引用数据 

935
00:46:24,009 --> 00:46:30,088
好了，第一 ，我们是 所有的通知 

936
00:46:28,033 --> 00:46:33,109
我们引用的元素 

937
00:46:30,088 --> 00:46:35,176
阵列陆续 所以我们增加 

938
00:46:34,009 --> 00:46:38,071
AI通过 一个每次 ，然后 我们是如此 

939
00:46:36,076 --> 00:46:40,125
我们递增我每次每次迭代

940
00:46:38,071 --> 00:46:42,135
通过循环，我们正在阅读AI 

941
00:46:41,025 --> 00:46:44,034
可以，然后呢 

942
00:46:43,035 --> 00:46:47,073
被称为步幅一个参考图形

943
00:46:45,015 --> 00:46:50,100
步幅是多少，我们是 

944
00:46:47,073 --> 00:46:52,092
增加此此指数所以我们

945
00:46:51,000 --> 00:46:55,056
因为我们通过一个我们增加它

946
00:46:52,092 --> 00:46:58,109
调用一个箭步一个模式等什么 

947
00:46:55,056 --> 00:47:03,138
一种什么样的地方 的 是 

948
00:46:59,009 --> 00:47:08,064
到AI空间重复的引用或 

949
00:47:04,038 --> 00:47:11,136
时间空间的权利，因为我们是

950
00:47:08,064 --> 00:47:14,073
没关系什么访问有关附近的项目 

951
00:47:12,036 --> 00:47:19,062
在此引用这个变量的一些 

952
00:47:14,073 --> 00:47:22,101
环路， 现在是什么时间内

953
00:47:19,062 --> 00:47:23,148
有关说明，以便我们我们

954
00:47:23,001 --> 00:47:26,052
参考其中每个循环迭代 

955
00:47:24,048 --> 00:47:28,125
我们参考，我们正在执行 

956
00:47:26,052 --> 00:47:34,053
指令序列那么什么样的 

957
00:47:29,025 --> 00:47:35,081
局部性的是， 每个环内

958
00:47:34,062 --> 00:47:37,089
迭代 

959
00:47:35,081 --> 00:47:38,085
没有这空间的权利，因为我们是

960
00:47:37,089 --> 00:47:41,180
刚刚执行的序列 

961
00:47:39,021 --> 00:47:44,028
每次循环迭代内的指令 

962
00:47:42,008 --> 00:47:48,105
但 后来我们 通过循环 周期 

963
00:47:44,091 --> 00:47:50,142
反复所以我们的机会所以每次循环 

964
00:47:49,077 --> 00:47:53,079
迭代我们要 访问 的每一个 

965
00:47:51,042 --> 00:47:55,125
那些我们 访问的说明

966
00:47:53,097 --> 00:47:57,099
以前的循环迭代确保我们走

967
00:47:56,025 --> 00:47:59,118
我们最多只是不断在我们正要 

968
00:47:57,099 --> 00:48:00,195
继续执行同一程序集 

969
00:48:00,018 --> 00:48:04,059
实现语言指令 

970
00:48:01,095 --> 00:48:04,158
现在这个循环体，在这个简单 

971
00:48:04,059 --> 00:48:07,095
例如，它可能只是一个 

972
00:48:05,058 --> 00:48:11,102
指令，但在一般的循环能 

973
00:48:07,095 --> 00:48:11,102
有多个指令

974
00:48:12,008 --> 00:48:17,099
现在，当我要求你 ，我 的 一个 

975
00:48:16,043 --> 00:48:22,046
主要种类的这个点中的一个

976
00:48:18,071 --> 00:48:24,134
只是这整个过程是，作为一个

977
00:48:22,073 --> 00:48:27,116
专业的程序员它是一个 

978
00:48:25,034 --> 00:48:30,035
那你能够基本技能 

979
00:48:28,016 --> 00:48:33,023
看代码，并 因此得到了质 

980
00:48:30,044 --> 00:48:33,068
它的地方的意义，因为正如我们将 

981
00:48:33,023 --> 00:48:35,087
看到

982
00:48:33,068 --> 00:48:37,133
好的地方变成好

983
00:48:35,087 --> 00:48:40,148
性能是系统的方式

984
00:48:38,033 --> 00:48:43,064
建这些天，以便作为一个程序员 是 

985
00:48:41,048 --> 00:48:44,144
非常重要的，你 要能够 对 

986
00:48:43,064 --> 00:48:47,129
那种看代码，并得到一些 

987
00:48:45,044 --> 00:48:50,057
定性的感觉一样，这就是漂亮 

988
00:48:48,029 --> 00:48:52,097
好的地方太可怕了局部性 

989
00:48:50,057 --> 00:48:54,121
正确的是， 你想要做的是 什么 

990
00:48:52,097 --> 00:48:57,139
避免 在您的代码可怕的地方 

991
00:48:55,021 --> 00:49:01,076
让我们 来看一个简单的例子 在这里 

992
00:48:58,039 --> 00:49:04,088
看看我的意思，所以我什么 

993
00:49:01,076 --> 00:49:07,115
做的是我正在 一个数组 

994
00:49:04,088 --> 00:49:12,116
二维阵列的与 行MM 

995
00:49:08,015 --> 00:49:17,069
和n列 和内的双重嵌套 

996
00:49:13,016 --> 00:49:18,094
迭代循环对我和J，我总结 

997
00:49:17,069 --> 00:49:21,083
该阵列的元件

998
00:49:18,094 --> 00:49:28,136
看来 这是一个非常简单的操作 

999
00:49:21,083 --> 00:49:30,122
什么可能出问题的权利，使其变为 

1000
00:49:29,036 --> 00:49:34,109
如果你写的代码出有

1001
00:49:31,022 --> 00:49:39,026
加地方它会运行秩序 

1002
00:49:35,009 --> 00:49:41,030
幅度较慢所以单看这一点，如果 

1003
00:49:39,026 --> 00:49:44,033
你看看这个，你认为这有 

1004
00:49:41,003 --> 00:49:48,026
好的地方或坏的地方 ，现在让我们 

1005
00:49:44,033 --> 00:49:50,095
看看关于访问 

1006
00:49:48,053 --> 00:49:50,095
的 

1007
00:49:53,016 --> 00:50:06,093
好坏以及因此如何是怎么一个悠闲 

1008
00:50:03,021 --> 00:50:10,086
出内存右它的行权行 

1009
00:50:06,093 --> 00:50:12,108
所以看到使用用途，勾画出 一个 连续上调 

1010
00:50:10,086 --> 00:50:14,115
谎言所以首先的要素 

1011
00:50:13,008 --> 00:50:17,043
第一行之后的所有 

1012
00:50:15,015 --> 00:50:20,109
第二行的元素， 随后 

1013
00:50:17,043 --> 00:50:22,137
第三行中的所有元素 好吗 

1014
00:50:21,009 --> 00:50:27,063
那么我们如何访问这个数组 的样子 

1015
00:50:23,037 --> 00:50:30,111
在我们访问IJ 和我们 

1016
00:50:27,063 --> 00:50:33,111
改变j中最快的，所以我们保持 眼睛 

1017
00:50:31,011 --> 00:50:36,090
恒定，然后我们变化J和然后我们 

1018
00:50:34,011 --> 00:50:40,038
接入都让我们保持眼睛常数 

1019
00:50:36,009 --> 00:50:43,107
一行访问我，然后我们改变J确定

1020
00:50:40,038 --> 00:50:47,073
访问该 行还行 中的所有列 

1021
00:50:44,088 --> 00:50:51,159
所以每个每个击球手，然后 我们增加 

1022
00:50:47,073 --> 00:50:56,091
然后我们回去，并增加 我这样 

1023
00:50:52,059 --> 00:50:59,118
现在我们所访问的下一行好了， 

1024
00:50:56,091 --> 00:51:02,127
如果我们看的地址 

1025
00:51:00,018 --> 00:51:06,030
IJ 是地址 序列 

1026
00:51:03,027 --> 00:51:07,116
被读取那些将对应于 

1027
00:51:06,003 --> 00:51:10,010
迈进一个访问，所以我们会很

1028
00:51:08,016 --> 00:51:14,028
访问所有 的元素的那些的 

1029
00:51:11,000 --> 00:51:17,004
顺序为了 好了，这就是 

1030
00:51:14,028 --> 00:51:18,065
真正好的空间 局部性权 

1031
00:51:17,004 --> 00:51:22,080
这就是你能做的最好的 

1032
00:51:18,065 --> 00:51:24,108
现在怎么样怎么样，然后我们 

1033
00:51:22,008 --> 00:51:26,100
有时间局部性一些，这样的

1034
00:51:25,008 --> 00:51:32,034
良好的权利，使这个一切 

1035
00:51:27,072 --> 00:51:33,168
相当不错的，所以这 是 一个很好的 案例，现在 

1036
00:51:32,034 --> 00:51:37,047
这个东西我做了什么我已经 

1037
00:51:34,068 --> 00:51:41,145
采取了同样的计划，我刚刚 

1038
00:51:37,047 --> 00:51:46,050
倒置循环，所以我环J上第一 

1039
00:51:42,045 --> 00:51:48,137
然后在我，然后我只是有 

1040
00:51:46,005 --> 00:51:48,092
相同的内循环体

1041
00:51:52,015 --> 00:51:55,024
现在是什么做这做什么 

1042
00:51:53,047 --> 00:52:00,106
该做的空间局部性 我们 

1043
00:51:56,005 --> 00:52:04,057
访问还好 耶可怕的 ，因为它是 

1044
00:52:01,006 --> 00:52:08,041
外出时，你应该被冒犯，当 你 

1045
00:52:04,057 --> 00:52:11,143
看这是不可怕，但它是 可怕的 

1046
00:52:08,041 --> 00:52:13,089
正确的，因为看 所以我们现在是我们 

1047
00:52:12,043 --> 00:52:16,108
控股周杰伦 

1048
00:52:13,089 --> 00:52:18,118
我们拿着周杰伦不变，然后 

1049
00:52:17,008 --> 00:52:23,085
我们通过第j个元素迭代

1050
00:52:19,018 --> 00:52:26,086
各行，以便的精选跳绳我们有N 

1051
00:52:23,085 --> 00:52:28,167
我们有N 每一行 中的元素 ，所以我们是 

1052
00:52:26,086 --> 00:52:32,155
通过 做 存储 一个箭步 -N接入 

1053
00:52:29,067 --> 00:52:34,111
所以我们要像这样，然后我们 

1054
00:52:33,055 --> 00:52:36,109
然后递增，我们正在寻找，然后 

1055
00:52:35,011 --> 00:52:38,046
我们通过一个递增列 

1056
00:52:37,009 --> 00:52:41,020
那么我们就这样了 

1057
00:52:38,046 --> 00:52:42,112
所以这是可怕的空间局部性这

1058
00:52:41,002 --> 00:52:48,091
是最糟糕的空间位置，我们可以

1059
00:52:43,012 --> 00:52:52,090
现在得到让我们来看看三 

1060
00:52:49,009 --> 00:52:56,056
维数组，让我问 你 

1061
00:52:52,009 --> 00:52:57,037
让我张贴以下问题 可 

1062
00:52:56,056 --> 00:53:00,109
您根据这种定性 

1063
00:52:58,018 --> 00:53:02,055
想法，这种想法，你想你 

1064
00:53:01,009 --> 00:53:06,028
想尝试得到 一个箭步一个 

1065
00:53:02,055 --> 00:53:10,063
参考模式好，所以你会怎样 

1066
00:53:06,028 --> 00:53:13,075
置换这些所予给这 间 

1067
00:53:10,063 --> 00:53:15,082
身体KIJ 

1068
00:53:13,075 --> 00:53:17,143
你将如何推动这些置换 

1069
00:53:15,082 --> 00:53:23,164
这些循环指标 给一个箭步一个 

1070
00:53:18,043 --> 00:53:27,091
参考模式好没错 き 

1071
00:53:24,064 --> 00:53:28,159
J的是正确的 ，所以我们 希望 在一般什么 

1072
00:53:27,091 --> 00:53:32,116
做的是我们要去 右去 

1073
00:53:29,059 --> 00:53:36,085
向左我们希望，我们希望这些指数来 

1074
00:53:33,016 --> 00:53:38,071
要改变最快的，所以我们希望我们Ĵ 

1075
00:53:36,085 --> 00:53:40,147
想K和我将保持恒定和 

1076
00:53:38,071 --> 00:53:44,077
然后我们想 改变J，则我们要 

1077
00:53:41,047 --> 00:53:47,068
增加我，然后为值 

1078
00:53:44,077 --> 00:53:49,120
K和 我 的那些价值 ，我们希望要 

1079
00:53:47,068 --> 00:53:53,094
至 J 的所有值的序列 

1080
00:53:50,002 --> 00:53:53,076
再次好吗 

1081
00:53:56,259 --> 00:54:02,380
好了，我们已经看了的性质 

1082
00:53:59,599 --> 00:54:04,690
存储技术和 工艺 

1083
00:54:02,038 --> 00:54:06,091
我们和有这种基本 

1084
00:54:04,069 --> 00:54:11,072
排序的基本原则 

1085
00:54:06,091 --> 00:54:16,480
更便宜的存储 更大的存储 

1086
00:54:11,072 --> 00:54:19,088
更高容量的存储是 更 便宜 

1087
00:54:17,299 --> 00:54:21,200
昂贵的存储是 因为我们 小 

1088
00:54:19,088 --> 00:54:27,007
只是没有 我们可以不花 

1089
00:54:21,002 --> 00:54:30,301
足够的钱， 还有的这种差距 有 

1090
00:54:27,799 --> 00:54:34,670
我们的存储设备和之间的差距

1091
00:54:30,499 --> 00:54:38,660
的CPU， 其 至少在的情况下 

1092
00:54:34,067 --> 00:54:42,124
磁盘正在变得更大，我们有 

1093
00:54:38,066 --> 00:54:45,675
显示出本地 确定 ，所以计划

1094
00:54:43,024 --> 00:54:49,153
这三样东西的这些属性 

1095
00:54:46,269 --> 00:54:52,130
存储技术和性能 

1096
00:54:49,369 --> 00:54:55,730
我们的计划相互补充 

1097
00:54:52,013 --> 00:54:58,016
这个美丽的 方式 提出 ，并通知 

1098
00:54:55,073 --> 00:55:00,112
我们的存储系统的设计和 

1099
00:54:58,016 --> 00:55:04,855
这种设计被称为东西 

1100
00:55:00,769 --> 00:55:09,775
存储层次 确定这里是一个想法 

1101
00:55:04,999 --> 00:55:13,027
存储层次您层代替 

1102
00:55:10,369 --> 00:55:15,170
你现在在创建平面内存系统 

1103
00:55:13,279 --> 00:55:19,460
您的存储系统的层次结构 

1104
00:55:15,017 --> 00:55:22,216
在的顶部的顶部的装置和

1105
00:55:19,046 --> 00:55:24,122
这个层次的你有你的小 

1106
00:55:22,369 --> 00:55:27,650
更快，更昂贵的存储 

1107
00:55:25,022 --> 00:55:30,871
设备，以便在 最高层必须 

1108
00:55:27,065 --> 00:55:33,994
寄存器其是其可以是 

1109
00:55:31,069 --> 00:55:37,640
访问和一个周期内正确的 

1110
00:55:34,579 --> 00:55:38,674
指令，而该指令是 

1111
00:55:37,064 --> 00:55:39,119
执行可以访问读取和写入

1112
00:55:39,529 --> 00:55:42,553
寄存器 

1113
00:55:40,019 --> 00:55:45,020
好了，所以寄存器是在的顶部 

1114
00:55:42,769 --> 00:55:46,880
层次，但因为这些都是在 

1115
00:55:45,002 --> 00:55:49,004
定制硅他们是非常昂贵的 

1116
00:55:46,088 --> 00:55:51,116
右边的制造工厂，使

1117
00:55:49,004 --> 00:55:53,062
处理器耗资数十亿美元OK 

1118
00:55:52,016 --> 00:55:55,094
所以这是最昂贵的， 

1119
00:55:53,098 --> 00:55:57,146
因为它也是最小的

1120
00:55:55,094 --> 00:56:01,123
我们只在顶部有16个寄存器 

1121
00:55:58,046 --> 00:56:05,605
现在下面 我们把层次

1122
00:56:02,023 --> 00:56:07,070
一个或多个SRAM存储器SRAM记忆 

1123
00:56:06,019 --> 00:56:10,140
是比较快的

1124
00:56:07,007 --> 00:56:11,102
这是最快的一种记忆，所以我们

1125
00:56:10,014 --> 00:56:15,089
把一个或 多个 所谓的 

1126
00:56:12,065 --> 00:56:22,161
内置缓存SRAM 进行高速缓存存储器 

1127
00:56:15,089 --> 00:56:25,092
在处理器芯片本身，然后 

1128
00:56:23,061 --> 00:56:27,128
这些高速缓存，因为它们是由 

1129
00:56:25,092 --> 00:56:30,144
从SRAM他们的顺序 

1130
00:56:28,028 --> 00:56:32,034
在大小兆 还好他们多 

1131
00:56:31,044 --> 00:56:37,077
比寄存器大，但他们 

1132
00:56:32,088 --> 00:56:39,156
他们兆 好它，如果我们看 

1133
00:56:37,077 --> 00:56:41,148
然后那 下面 就是我们的主内存 

1134
00:56:40,056 --> 00:56:45,060
它内置了DRAM和那些能 

1135
00:56:42,048 --> 00:56:48,054
是千兆字节数十GB的上 

1136
00:56:45,096 --> 00:56:50,133
现代系统，然后在下面是 

1137
00:56:48,054 --> 00:56:53,121
我们的本地 磁盘，我们甚至可以有 

1138
00:56:51,033 --> 00:56:56,037
下层像web服务器是 

1139
00:56:54,021 --> 00:56:58,092
存储你知道上存储的东西

1140
00:56:56,037 --> 00:57:02,082
谷歌，你能想到的 ，如 

1141
00:56:58,092 --> 00:57:03,135
只是 我们 体系 中的 一部分 ，现在这里的 

1142
00:57:02,082 --> 00:57:07,143
在这里有更高的核心理念 

1143
00:57:04,035 --> 00:57:11,079
入口的存储器层次结构中每个级别 

1144
00:57:08,043 --> 00:57:14,075
在这个层次结构保存数据这

1145
00:57:11,079 --> 00:57:17,157
从下一级中检索

1146
00:57:14,075 --> 00:57:21,108
好了，所以缓存保持寄存器保存数据

1147
00:57:18,057 --> 00:57:25,083
这是一个的存储在 L1缓存的 

1148
00:57:22,008 --> 00:57:28,077
L1缓存认为，检索出的数据

1149
00:57:25,083 --> 00:57:30,174
从L2缓存 L3缓存持有 

1150
00:57:28,077 --> 00:57:32,142
多数民众赞成恢复的数据是这 

1151
00:57:31,074 --> 00:57:35,085
从主存储器的主存储器中检索

1152
00:57:33,042 --> 00:57:39,078
认为这是一个从检索到的数据

1153
00:57:35,085 --> 00:57:41,160
二级盘等，现在 

1154
00:57:39,078 --> 00:57:44,139
正如我们即将看到的，之所以记忆 

1155
00:57:42,006 --> 00:57:49,013
系统的设计就像 这是 

1156
00:57:45,039 --> 00:57:49,067
他们当你有这种 系统 

1157
00:57:50,063 --> 00:57:56,962
这个你可以在一般的访问可以 

1158
00:57:53,096 --> 00:57:59,185
在的速度访问您的 数据 

1159
00:57:57,529 --> 00:58:02,650
在 顶部 的 一天，最快的项目

1160
00:58:00,049 --> 00:58:07,051
层次的所以这是最快的 

1161
00:58:02,065 --> 00:58:10,073
但随着存储的成本

1162
00:58:07,069 --> 00:58:14,000
层次结构的下部好了，所以这 

1163
00:58:11,045 --> 00:58:20,099
这个工程全称为一个想法，因为 

1164
00:58:14,000 --> 00:58:23,869
缓存，以便在计算2高速缓存把它 

1165
00:58:20,099 --> 00:58:26,099
一个计算机科学家是它的一个 

1166
00:58:23,869 --> 00:58:30,740
作用较小的较快的存储设备 

1167
00:58:26,099 --> 00:58:32,108
作为在该数据的分段区域 

1168
00:58:30,074 --> 00:58:34,663
较大较慢的设备所以就像像

1169
00:58:33,089 --> 00:58:37,124
在这里你可以认为 你的主内存 

1170
00:58:35,329 --> 00:58:39,406
是上存储的数据高速缓存

1171
00:58:38,024 --> 00:58:42,373
磁盘 对你 从磁盘 读入内存 ， 

1172
00:58:40,099 --> 00:58:43,970
那么你将其存储在 确定可以 对存储 

1173
00:58:42,589 --> 00:58:47,608
认为主要的内存作为一个临时的

1174
00:58:43,097 --> 00:58:48,104
区域，这样一旦你 从数据 

1175
00:58:47,779 --> 00:58:51,410
磁盘你不要 再 访问它 的 

1176
00:58:49,067 --> 00:58:53,416
磁盘访问是多少内存 

1177
00:58:51,041 --> 00:59:00,098
快好了，所以这个想法的所有传播 

1178
00:58:54,019 --> 00:59:04,048
一路上扬的层次确定，所以我们为您 

1179
00:59:00,098 --> 00:59:07,193
可以想到的一种方式想缓存

1180
00:59:04,309 --> 00:59:09,950
缓存是想像你的背包时， 

1181
00:59:08,093 --> 00:59:11,782
你准备到学校来 

1182
00:59:09,095 --> 00:59:13,118
早晨所以你 在你的 

1183
00:59:12,619 --> 00:59:17,644
公寓这是一种 从 远处 

1184
00:59:14,018 --> 00:59:19,957
学校，所以 你进入学校 之前 

1185
00:59:17,869 --> 00:59:22,490
你把物品从你的房子 和 

1186
00:59:20,119 --> 00:59:25,400
你把它们放在你的背包 ，因为 

1187
00:59:22,049 --> 00:59:26,428
然后再当，然后你走 

1188
00:59:25,004 --> 00:59:29,113
那么你来上学，如果你需要 

1189
00:59:26,869 --> 00:59:30,910
那些 他们 的项目 在您的背包你 

1190
00:59:29,509 --> 00:59:32,690
知道，如果你没有这样做，每次 

1191
00:59:31,279 --> 00:59:35,240
你需要的东西，你必须走 

1192
00:59:32,069 --> 00:59:35,072
回家， 并把它往回走，到 

1193
00:59:35,024 --> 00:59:38,803
学校

1194
00:59:35,072 --> 00:59:39,871
它 使高速缓存的想法是挺你 

1195
00:59:39,019 --> 00:59:42,073
知道这是一个非常熟悉的一种简单 

1196
00:59:40,519 --> 00:59:44,577
概念，但事实证明是 相当 

1197
00:59:42,559 --> 00:59:51,580
功能强大，它 的 所有部分显示出来 

1198
00:59:45,099 --> 00:59:53,140
没关系 的计算机系统 ， 所以我们 

1199
00:59:51,769 --> 00:59:56,480
说的是，在每个等级k 

1200
00:59:53,509 --> 00:59:59,509
层次结构中的更快更小的设备

1201
00:59:56,048 --> 01:00:02,057
级别K个用作用于缓存 

1202
00:59:59,509 --> 01:00:06,420
在等级k 加1较大较慢的装置

1203
01:00:02,057 --> 01:00:08,606
记得我们从水平这么大号零走

1204
01:00:06,042 --> 01:00:11,055
这是最高的最小最低 

1205
01:00:09,119 --> 01:00:13,260
实际上水平最高的是

1206
01:00:11,055 --> 01:00:14,102
在营地进一步东西

1207
01:00:13,026 --> 01:00:21,033
层次结构，并为我们提高水平 

1208
01:00:15,002 --> 01:00:23,100
我们 现在为什么 要去到整个组织 

1209
01:00:21,033 --> 01:00:26,061
做他们的工作，所以这 是这 是一个非常 

1210
01:00:24,000 --> 01:00:31,083
他们因为工作基本理念

1211
01:00:26,061 --> 01:00:33,069
地点是因为本地程序 

1212
01:00:31,083 --> 01:00:36,177
往往访问一个储存的数据

1213
01:00:33,069 --> 01:00:41,070
k级往往比他们访问数据

1214
01:00:37,077 --> 01:00:44,130
在等级k 加1好了，所以，如果我们访问 

1215
01:00:41,079 --> 01:00:47,097
在级别k 加1， 我们可以将它的项目

1216
01:00:45,003 --> 01:00:49,094
高达等级k 机会是因为 

1217
01:00:47,097 --> 01:00:52,149
局部性我们将再次访问 

1218
01:00:50,021 --> 01:00:57,680
好了，现在我们要访问的数据 

1219
01:00:53,049 --> 01:01:00,054
在等级k多次在 

1220
01:00:57,869 --> 01:01:03,590
率级 K 的速度 不是在 

1221
01:01:00,099 --> 01:01:05,172
k级速度加 一 好 了，这就是 

1222
01:01:03,059 --> 01:01:08,124
这就是乐趣胃底根本 

1223
01:01:06,072 --> 01:01:11,076
想法和因为 因为我们不 

1224
01:01:09,024 --> 01:01:14,057
在等级k访问数据 加1作为 

1225
01:01:11,076 --> 01:01:18,081
通常我们可以，我们能够 用 得起 慢 

1226
01:01:14,057 --> 01:01:22,071
存储装置，其是便宜好 

1227
01:01:18,081 --> 01:01:26,390
在此，因此，我们可以使他们做大 

1228
01:01:22,071 --> 01:01:28,122
便宜预测所以这样做是什么 

1229
01:01:27,119 --> 01:01:31,890
层次创造了一个大水池

1230
01:01:29,022 --> 01:01:35,025
存储这大致占规模 

1231
01:01:31,089 --> 01:01:37,184
可 在 被 访问 的最低水平。 

1232
01:01:35,025 --> 01:01:38,084
速度 最高 级别 

1233
01:01:40,089 --> 01:01:45,184
没事看看让我们来看看如何缓存 

1234
01:01:44,023 --> 01:01:50,023
工作在一般的方式，然后我们会 

1235
01:01:46,084 --> 01:01:51,097
看到周四如何将这些硬件缓存 

1236
01:01:50,023 --> 01:01:54,028
回忆的工作不错，但就像我说的 

1237
01:01:51,097 --> 01:01:55,189
缓存是一个非常普遍的想法，可以 

1238
01:01:54,073 --> 01:02:00,076
在各级中的应用

1239
01:01:56,089 --> 01:02:03,115
层次所以在这里我们有一个缓存，因此

1240
01:02:01,003 --> 01:02:07,069
在各种最高速缓存的有一些

1241
01:02:04,015 --> 01:02:10,114
一种转印单元从一个去 

1242
01:02:07,069 --> 01:02:15,073
到下一级所以在这里我们在 

1243
01:02:11,014 --> 01:02:17,020
这在这个级别上，我们有什么

1244
01:02:16,009 --> 01:02:22,024
我们会打电话， 可保持 高速缓存 

1245
01:02:17,074 --> 01:02:24,082
块，这样我们的我们的记忆中，然后在 

1246
01:02:22,024 --> 01:02:26,113
较低的水平，我们有记忆，这

1247
01:02:24,082 --> 01:02:29,095
存储器被划分为块 

1248
01:02:27,013 --> 01:02:33,079
一些固定的大小这是这是这样的 

1249
01:02:29,095 --> 01:02:37,156
路高速靠近 靠近上 

1250
01:02:33,079 --> 01:02:39,156
在目前的层级工作的一部分

1251
01:02:38,056 --> 01:02:44,128
下级一样，如果你正在访问 

1252
01:02:40,056 --> 01:02:47,062
数据从Web服务器然后将 数据说

1253
01:02:45,028 --> 01:02:49,054
被分成文件通常好吗 

1254
01:02:47,062 --> 01:02:50,110
但在其他级别 的数据 

1255
01:02:49,054 --> 01:02:54,073
分块所以只是假设 

1256
01:02:51,001 --> 01:02:56,086
这是主存储器中，然后上面 

1257
01:02:54,073 --> 01:02:59,145
我们有一个 由一堆的 

1258
01:02:56,095 --> 01:03:03,124
这些块，所以我们只取记忆 

1259
01:03:00,045 --> 01:03:06,087
和分区INS块，其中每个 

1260
01:03:04,024 --> 01:03:09,031
块是相同的字节数 ，并 

1261
01:03:06,087 --> 01:03:10,168
然后将数据之间传送 

1262
01:03:09,031 --> 01:03:13,117
存储器和 在块大小 的高速缓存 

1263
01:03:11,068 --> 01:03:15,160
转让单位好，所以如果你需要数据 

1264
01:03:14,017 --> 01:03:18,034
从内存，如果缓存中 的数据 需要 

1265
01:03:16,006 --> 01:03:21,088
从存储器中它会抓住一个整块 

1266
01:03:18,034 --> 01:03:25,048
然后在时间的缓存中的任何点 

1267
01:03:22,042 --> 01:03:29,047
保持在主块的子集

1268
01:03:25,048 --> 01:03:34,050
内存好了，所以这个这个缓存是多少 

1269
01:03:29,092 --> 01:03:33,168
速度更快，但 它也慢得多 

1270
01:03:35,058 --> 01:03:40,077
并且因为这和它的多 

1271
01:03:37,083 --> 01:03:42,099
小对不起它的速度 更快，但 

1272
01:03:40,077 --> 01:03:44,142
这是它的更昂贵，因为 

1273
01:03:42,099 --> 01:03:45,180
它的速度更快也更贵， 

1274
01:03:45,042 --> 01:03:56,100
因为它更昂贵的 是小 

1275
01:03:46,008 --> 01:03:58,083
现在 假设假设 现金 一旦 

1276
01:03:57,000 --> 01:04:05,007
参考说，CPU请求数据

1277
01:03:59,055 --> 01:04:07,086
该中都包含的块中有四个因此它 

1278
01:04:05,007 --> 01:04:09,093
看起来它查看数据是否 在 

1279
01:04:07,086 --> 01:04:12,129
缓存它不是那么缓存 问 

1280
01:04:09,093 --> 01:04:15,147
内存给它块中的四个，这样 

1281
01:04:13,029 --> 01:04:18,105
块是从存储器拷贝到 

1282
01:04:16,047 --> 01:04:20,100
缓存覆盖的一 

1283
01:04:19,005 --> 01:04:24,021
现有在这种情况下阻止个IT 

1284
01:04:21,000 --> 01:04:29,085
将覆盖封锁所以现在现在块 

1285
01:04:24,021 --> 01:04:32,085
四是在我们现在的缓存现在假设现在 

1286
01:04:29,085 --> 01:04:36,120
假设CPU■ 对于一些数据，是 

1287
01:04:32,085 --> 01:04:40,110
在块 了 十个 被复制并和 

1288
01:04:37,002 --> 01:04:42,087
我们会覆盖该块现在

1289
01:04:41,001 --> 01:04:44,034
存储在缓存中 的整体思路 是 

1290
01:04:43,005 --> 01:04:47,013
那我们希望寻求 

1291
01:04:44,043 --> 01:04:48,096
这就是CPU上执行的程序将

1292
01:04:47,013 --> 01:04:50,097
重用，我们刚刚度过的那些块的一个

1293
01:04:48,096 --> 01:04:53,130
所有的时间我们去一切麻烦 

1294
01:04:50,097 --> 01:04:57,150
把它从 内存 复制 到这个缓存 

1295
01:04:54,003 --> 01:05:04,095
我们知道这是缓慢，现在假设 

1296
01:04:58,005 --> 01:05:08,088
该CPU需要 在方框B的一些数据 

1297
01:05:05,022 --> 01:05:11,037
在这种情况下，14好了，所以它需要 

1298
01:05:09,033 --> 01:05:13,068
它需要更多的 内存词是 

1299
01:05:11,037 --> 01:05:17,136
存储最初存储在 

1300
01:05:13,068 --> 01:05:21,069
内存在方框14现在好了 

1301
01:05:18,036 --> 01:05:23,121
该缓存可以只返回那是什么 

1302
01:05:21,069 --> 01:05:26,094
我们所说的一击右 所以块，我们 

1303
01:05:24,021 --> 01:05:29,028
访问是在缓存中，这样的好 

1304
01:05:26,094 --> 01:05:33,183
点击率是不错的，因为现在我们可以 返回 

1305
01:05:29,091 --> 01:05:36,099
该块 直接CTU，这此 

1306
01:05:34,083 --> 01:05:38,109
内存比，如果我们不得不快得多 

1307
01:05:36,099 --> 01:05:41,115
一路到主 存储器到 

1308
01:05:39,009 --> 01:05:44,073
DRAM 好所以SRAM 比快得多 

1309
01:05:42,015 --> 01:05:47,022
在DRAM 让他们看到你获取 

1310
01:05:44,073 --> 01:05:48,105
块14比它快得多 

1311
01:05:47,022 --> 01:05:54,090
有，如果它只是走了一路 

1312
01:05:49,005 --> 01:05:58,011
内存好这些类的 其他 的 

1313
01:05:54,009 --> 01:06:00,090
命中的对面是一个 小姐所以假设 

1314
01:05:58,011 --> 01:06:03,078
该CPU S 表示块12的高速缓存 

1315
01:06:01,071 --> 01:06:06,144
查找该块不能找到它 

1316
01:06:03,078 --> 01:06:08,175
这是一个小姐，因此 缓存必须 

1317
01:06:07,044 --> 01:06:12,045
问DRAM的主 存储器 

1318
01:06:09,075 --> 01:06:15,138
块12 在那里它被复制到 

1319
01:06:12,045 --> 01:06:17,142
缓存中，然后它可以返回 该如此 

1320
01:06:16,038 --> 01:06:20,046
这需要更长的时间正确的，因此 CT 有 

1321
01:06:18,042 --> 01:06:23,070
等待的块为 X是 

1322
01:06:21,018 --> 01:06:25,047
从内存搜索等未命中 

1323
01:06:23,007 --> 01:06:27,018
缓慢，点击率是不错的，因为他们是 

1324
01:06:25,047 --> 01:06:31,080
快速的失误是不好的，因为 他们是 

1325
01:06:27,081 --> 01:06:34,119
他们现在慢，我们通常

1326
01:06:31,008 --> 01:06:37,008
几种 不同的区分

1327
01:06:35,019 --> 01:06:40,067
两种缓存所以第一种 

1328
01:06:37,008 --> 01:06:42,081
思念是一种冷小姐或强制 缺失 

1329
01:06:40,067 --> 01:06:43,158
这导致，因为有刚 

1330
01:06:43,053 --> 01:06:45,135
没有在缓存中 

1331
01:06:44,058 --> 01:06:49,074
最初缓存他们是空的，他们有 

1332
01:06:46,035 --> 01:06:50,130
无块，因为我们取为我们取 

1333
01:06:49,074 --> 01:06:52,113
从较低的水平块

1334
01:06:51,003 --> 01:06:55,098
接下来的一个新的水平，并把它们放在 

1335
01:06:53,013 --> 01:06:58,035
缓存缓存会慢慢填满 

1336
01:06:56,025 --> 01:07:00,048
块，我们会尽快和 意志 

1337
01:06:58,035 --> 01:07:01,047
增加希布斯的可能性，但 

1338
01:07:00,048 --> 01:07:02,142
当缓存为空

1339
01:07:01,047 --> 01:07:04,128
我们要每次都错过这样的权利 

1340
01:07:03,042 --> 01:07:07,080
这里面还有没有办法来避免 冷 

1341
01:07:05,028 --> 01:07:09,054
想念你的权利得到了所以这个被称为 

1342
01:07:07,008 --> 01:07:11,055
热身缓存以便加载

1343
01:07:09,054 --> 01:07:13,125
数据项到缓存中最初它是 

1344
01:07:12,027 --> 01:07:15,075
冷，当您添加 更多的项目 你 

1345
01:07:14,025 --> 01:07:20,114
热身它意味着你 

1346
01:07:15,075 --> 01:07:25,119
现在增加一击的可能性 

1347
01:07:21,014 --> 01:07:28,032
有一个有另一种形式的 

1348
01:07:26,019 --> 01:07:30,084
对称一种神话被称为 

1349
01:07:28,032 --> 01:07:33,066
在容量 缺失而这些失误是 

1350
01:07:30,084 --> 01:07:35,091
由于高速缓存仅仅是一个 

1351
01:07:33,066 --> 01:07:36,165
一定规模的权利，你只是 不能在 

1352
01:07:35,091 --> 01:07:41,115
比如我们看，我们只有有四个

1353
01:07:37,065 --> 01:07:45,116
块，这样如果我们如果我们想，如果 

1354
01:07:42,015 --> 01:07:49,026
我们如果我们的，如果我们的时间局部性

1355
01:07:46,016 --> 01:07:51,050
涉及八个街区，你知道说这是 

1356
01:07:49,026 --> 01:07:55,089
一个循环，我们要访问的是 

1357
01:07:51,005 --> 01:07:57,012
访问元素的数组 那 

1358
01:07:55,089 --> 01:07:58,128
由八个块有刚

1359
01:07:57,057 --> 01:08:00,066
没有足够的空间来存储 八个街区 

1360
01:07:59,028 --> 01:08:01,100
因此阻止缓存所以我们要

1361
01:08:01,047 --> 01:08:04,092
要得到 

1362
01:08:02,000 --> 01:08:06,809
正确的，我们需要一个更大的 高速缓存可 

1363
01:08:04,092 --> 01:08:08,165
能够 满足和存储这 八个 

1364
01:08:06,809 --> 01:08:11,910
块，如果我们有一个足够大的缓存 

1365
01:08:09,065 --> 01:08:14,139
那么，我们得到很好的命中率的权利，如果我们

1366
01:08:11,091 --> 01:08:17,480
可能所有的块存储在我们的缓存 

1367
01:08:15,039 --> 01:08:19,131
然后我们再那么缓存可以采取

1368
01:08:18,299 --> 01:08:23,351
利用的空间的和 

1369
01:08:20,031 --> 01:08:25,044
在该 程序 中时间局部性所以 

1370
01:08:23,819 --> 01:08:26,888
一般我们称这组

1371
01:08:25,044 --> 01:08:29,783
在任何点块时间当 

1372
01:08:27,509 --> 01:08:32,310
程序运行我们所说的一套 

1373
01:08:30,179 --> 01:08:34,460
这是那种被 访问的块

1374
01:08:32,031 --> 01:08:37,050
一遍又一遍的工作集和 

1375
01:08:34,046 --> 01:08:38,100
所以你的工作组和工作组

1376
01:08:37,005 --> 01:08:42,063
将改变你知道当你从循环去

1377
01:08:39,000 --> 01:08:45,014
循环从函数的功能，但在 

1378
01:08:43,008 --> 01:08:47,052
在时间 程序 中 的一个点时， 

1379
01:08:45,014 --> 01:08:49,023
你有这种想法的一个工作组 

1380
01:08:47,052 --> 01:08:52,831
这是种块的， 你 

1381
01:08:49,023 --> 01:08:55,382
需要有存储在 缓存好吗 

1382
01:08:53,299 --> 01:08:58,020
所以当你的工作集大小 

1383
01:08:55,589 --> 01:09:00,870
超出你的缓存大小，那么你得到 

1384
01:08:58,002 --> 01:09:03,077
容量缺失有这样其他种类 

1385
01:09:00,087 --> 01:09:06,096
奇怪的小姐 叫冲突未 

1386
01:09:03,077 --> 01:09:09,776
其中有与方式 ，缓存做

1387
01:09:06,096 --> 01:09:12,135
经常执行这样的想法是

1388
01:09:10,469 --> 01:09:15,060
大部分现金尤其是 硬件 

1389
01:09:13,035 --> 01:09:20,040
高速缓存，因为他们是他们 必须要 

1390
01:09:15,006 --> 01:09:24,092
简单 他们拥有 限制，其中一个 

1391
01:09:20,085 --> 01:09:26,554
块可以被放置到一些小的一组 

1392
01:09:24,092 --> 01:09:30,161
高速缓存中的位置

1393
01:09:27,319 --> 01:09:35,363
所以像最简单的模型之一是 

1394
01:09:30,989 --> 01:09:40,016
只取块我只能放置在 

1395
01:09:35,759 --> 01:09:42,150
块I MOD缓存大小所以在 我们的 

1396
01:09:40,259 --> 01:09:46,770
这是小的缓存，我们看到了 

1397
01:09:42,015 --> 01:09:48,063
四大块，我们会采取我们将采取 

1398
01:09:46,077 --> 01:09:50,082
从内存块我， 我们会坚持 

1399
01:09:48,063 --> 01:09:54,632
它在块I MOD 4故块 零 会 

1400
01:09:51,027 --> 01:09:59,082
在去块0 在我们的高速缓存和会 

1401
01:09:55,199 --> 01:10:03,050
方框4 和作为将阻塞8块9 

1402
01:09:59,082 --> 01:10:05,105
将进入块1的高速缓存和 

1403
01:10:03,005 --> 01:10:06,005
那是

1404
01:10:06,034 --> 01:10:14,075
当出现这种情况假设，假设我们使用

1405
01:10:12,002 --> 01:10:17,003
这种模式 ，所以我们要采取块 

1406
01:10:14,075 --> 01:10:21,079
我和我们打算把它放在我们只能 

1407
01:10:17,012 --> 01:10:25,013
将其放置在高速缓存中块I MOD FOR 

1408
01:10:21,079 --> 01:10:27,164
现在假设我们假设我们的参考 

1409
01:10:25,013 --> 01:10:31,064
图案从存储器块零涉及 

1410
01:10:28,064 --> 01:10:33,853
块中的四个并阻止个IT只是 

1411
01:10:31,064 --> 01:10:36,152
三个街区，所以我们 有我们有足够的 

1412
01:10:34,429 --> 01:10:39,890
房间的缓存来存储这三个 

1413
01:10:37,052 --> 01:10:41,108
的，因为我们的路块，但

1414
01:10:39,089 --> 01:10:45,098
决定将块，每个块将 

1415
01:10:42,008 --> 01:10:48,103
是 将驱逐当我们访问块中有 四个 

1416
01:10:45,098 --> 01:10:51,101
它会进入 零 块 在高速缓存中 

1417
01:10:49,003 --> 01:10:55,019
当我们在访问缓存块

1418
01:10:52,001 --> 01:10:57,052
它会覆盖该块，它会去

1419
01:10:55,019 --> 01:11:00,107
到在高速缓存中，因此块零 

1420
01:10:57,052 --> 01:11:02,129
因为这一点 ， 是真正的 访问 

1421
01:11:01,007 --> 01:11:04,906
图案以阴谋的所述 

1422
01:11:03,029 --> 01:11:07,091
我们使用用于放置该算法

1423
01:11:04,969 --> 01:11:10,040
块行不行，是因为这一点，我们有 

1424
01:11:07,091 --> 01:11:12,100
充足的空间在缓存中，但由于 

1425
01:11:10,004 --> 01:11:15,005
这种访问模式的 

1426
01:11:13,000 --> 01:11:19,076
与放置算法阴谋 

1427
01:11:15,014 --> 01:11:21,023
我们得到错过每一次，我们将看到如何 

1428
01:11:19,076 --> 01:11:23,114
我们将看到冲突护士是如何工作的

1429
01:11:22,004 --> 01:11:30,010
详细当我们研究你的缓存 

1430
01:11:24,014 --> 01:11:29,110
所以明天

1431
01:11:31,005 --> 01:11:39,006
所以这是无处不在这些高速缓存 

1432
01:11:34,059 --> 01:11:40,151
在存储层次结构 和看到所有的 

1433
01:11:39,051 --> 01:11:43,083
它们是这种或那种形式的高速缓冲存储器 

1434
01:11:41,051 --> 01:11:44,142
正确 ，因此您能想到的寄存器 

1435
01:11:43,083 --> 01:11:47,147
作为一种类型的高速缓存的

1436
01:11:45,042 --> 01:11:51,057
它们是什么缓存八个字节的字 

1437
01:11:48,047 --> 01:11:54,069
还好这里的IT缓存它的缓存 

1438
01:11:51,057 --> 01:11:57,075
右边的CPU 本身有什么上

1439
01:11:54,069 --> 01:12:00,084
等待时间是瞬间发生的内 

1440
01:11:57,075 --> 01:12:00,126
一个指令，然后谁管理 

1441
01:12:00,084 --> 01:12:02,085
高速缓存

1442
01:12:01,026 --> 01:12:04,122
总得有人当管理缓存

1443
01:12:02,085 --> 01:12:06,089
当有加载一个项目的请求 

1444
01:12:05,022 --> 01:12:09,045
从层次结构 中 的 下级 

1445
01:12:07,025 --> 01:12:11,031
有些事情决定做什么用 

1446
01:12:09,045 --> 01:12:13,056
但 如把 它放在 这 就是 高速缓存 

1447
01:12:11,031 --> 01:12:16,092
所谓在此管理高速缓存以及 

1448
01:12:13,056 --> 01:12:18,117
情况下，编译管理缓存时 

1449
01:12:16,092 --> 01:12:20,190
当您编译C代码 

1450
01:12:19,017 --> 01:12:23,046
编译器的数字哪个寄存器中的数据

1451
01:12:21,009 --> 01:12:29,031
从内存中的项目将会进入

1452
01:12:23,046 --> 01:12:32,048
好了，好TLB这是后话这个 

1453
01:12:30,012 --> 01:12:34,095
是在虚拟内存使用的高速缓存 

1454
01:12:32,066 --> 01:12:38,130
再有就是这些硬件缓存 

1455
01:12:34,095 --> 01:12:41,186
所谓的L1和L2缓存，使他们储存64 

1456
01:12:39,003 --> 01:12:46,014
现代Intel系统字节块和 

1457
01:12:42,086 --> 01:12:48,108
他们缓存的CPU芯片本身在 

1458
01:12:46,041 --> 01:12:52,092
在被内置 到 S斜坡 

1459
01:12:49,008 --> 01:12:56,091
CPU芯片和根据 是否L1 

1460
01:12:52,092 --> 01:12:59,133
缓存到核心i7s有一个延迟 

1461
01:12:56,091 --> 01:13:02,172
4个周期 和L2具有10的等待时间 

1462
01:13:00,033 --> 01:13:06,090
循环，并且这两种由管理 

1463
01:13:03,072 --> 01:13:08,109
五金 所以当你在CPU 

1464
01:13:06,009 --> 01:13:11,082
从L1 高速缓存 获取项目 

1465
01:13:09,009 --> 01:13:14,076
硬件菲格发现它，如果有一个 

1466
01:13:12,063 --> 01:13:16,071
未命中和一个块 从L2加载 

1467
01:13:14,076 --> 01:13:17,085
硬件 L1缓存计算出 

1468
01:13:16,071 --> 01:13:23,093
把它放在哪里好了，所以这一切完成 

1469
01:13:18,066 --> 01:13:26,127
而无需硬件的任何干预

1470
01:13:23,093 --> 01:13:28,185
磁盘包含缓冲操作系统 

1471
01:13:27,027 --> 01:13:33,042
保持缓冲区高速缓存所以在这种情况下， 

1472
01:13:29,085 --> 01:13:35,168
什么是缓存 文件的 部分 好吗 

1473
01:13:33,042 --> 01:13:39,141
他们正在缓存在主内存和 

1474
01:13:36,068 --> 01:13:42,070
延迟到2个主要的存储器是大约一个 

1475
01:13:40,041 --> 01:13:44,086
百次左右 

1476
01:13:42,088 --> 01:13:46,129
而这些由 经营管理

1477
01:13:44,086 --> 01:13:48,825
系统，使操作系统储备 

1478
01:13:47,029 --> 01:13:52,338
的存储器，用于存储文件的部分 

1479
01:13:49,599 --> 01:13:54,790
你已经加载，以便使操作 

1480
01:13:52,599 --> 01:13:59,603
系统利用地方，如果你，如果你 

1481
01:13:54,079 --> 01:14:00,178
读取一个文件，然后开始阅读 

1482
01:13:59,639 --> 01:14:04,300
从该文件中它会引用字节

1483
01:14:01,078 --> 01:14:08,187
实际上从文件缓存中 

1484
01:14:04,003 --> 01:14:13,015
并且它不会出去磁盘网络 

1485
01:14:08,889 --> 01:14:16,800
通过网络之类的东西保持高速缓存 

1486
01:14:13,042 --> 01:14:18,127
NFS 和SS保持在磁盘上的本地缓存 

1487
01:14:16,008 --> 01:14:22,105
您的浏览器有 一个缓存，因此当它 

1488
01:14:19,027 --> 01:14:25,626
从服务器获取文件，它 

1489
01:14:23,077 --> 01:14:26,676
在本地磁盘上保存这些文件，所以如果 

1490
01:14:25,869 --> 01:14:29,871
再次引用这些网页 

1491
01:14:27,369 --> 01:14:31,210
他们是从服务可以是本地磁盘 

1492
01:14:29,889 --> 01:14:34,958
而不是 在 将所有的方式 

1493
01:14:31,021 --> 01:14:38,059
网络确定这样的一点是，这些 

1494
01:14:35,579 --> 01:14:40,540
缓存处处存在于内存 

1495
01:14:38,059 --> 01:14:41,128
层次和他们都基于 

1496
01:14:40,054 --> 01:14:47,062
他们只是执行相同的原则 

1497
01:14:42,028 --> 01:14:49,407
以不同的方式 确定，所以刚 

1498
01:14:48,034 --> 01:14:52,893
总结一下我们已经 我们做了什么 

1499
01:14:49,659 --> 01:14:54,940
今天我们已经看到，有有一个 

1500
01:14:53,199 --> 01:14:57,300
CPU 与 我们的 存储 之间的差距

1501
01:14:54,094 --> 01:14:59,113
是继续增加设备

1502
01:14:57,003 --> 01:15:03,076
我们已经看到， 精心编写的程序 

1503
01:15:00,013 --> 01:15:07,542
具有这种性质称为本地 和 

1504
01:15:04,003 --> 01:15:09,010
我们通过采取看出缓存 

1505
01:15:07,659 --> 01:15:11,320
使用高速缓存我们可以建立一个内存 

1506
01:15:09,073 --> 01:15:13,129
层次， 它利用优势 

1507
01:15:11,032 --> 01:15:16,048
局部性和程序， 并允许 我们 

1508
01:15:14,029 --> 01:15:18,588
构建存储系统在这里我们可以 

1509
01:15:16,048 --> 01:15:21,121
在 最快 的速度访问数据 

1510
01:15:18,849 --> 01:15:24,884
设备，但在成本和容量 

1511
01:15:22,021 --> 01:15:28,800
在最低 级别 的 设备 

1512
01:15:25,199 --> 01:15:31,266
确定，所以周四我们要 看看在 

1513
01:15:28,989 --> 01:15:35,006
层次结构的非常具体的部分 

1514
01:15:31,869 --> 01:15:34,898
所谓的高速缓存存储器

