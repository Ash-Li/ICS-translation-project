1
00:00:00,000 --> 00:00:07,014
all right good afternoon everybody

2
00:00:02,078 --> 00:00:11,094
welcome good to see you so today we're

3
00:00:07,014 --> 00:00:14,633
going to look at an idea called

4
00:00:11,094 --> 00:00:17,683
exceptional control flow that's a very

5
00:00:14,759 --> 00:00:20,852
important part of making modern systems

6
00:00:18,529 --> 00:00:23,580
and it exists at all levels of the

7
00:00:21,689 --> 00:00:30,731
system from the lowest level Hardware

8
00:00:23,058 --> 00:00:33,144
all the way up to software so the idea

9
00:00:31,109 --> 00:00:37,500
is when when you turn on a computer from

10
00:00:34,044 --> 00:00:40,050
the very from the very first time you

11
00:00:37,005 --> 00:00:42,012
turn it on it just does execute one

12
00:00:40,005 --> 00:00:45,042
instruction after another until that you

13
00:00:42,057 --> 00:00:46,134
turn it off okay and if each core if you

14
00:00:45,087 --> 00:00:48,120
have multiple cores then each of those

15
00:00:47,034 --> 00:00:50,323
cores are executing instructions one

16
00:00:49,002 --> 00:00:54,066
after the other

17
00:00:50,629 --> 00:00:58,170
now the the sequence of instructions is

18
00:00:54,084 --> 00:00:59,393
called the control flow okay and the the

19
00:00:58,017 --> 00:01:02,019
actual sequence of instructions that the

20
00:01:00,149 --> 00:01:06,232
hardware is executing is called the

21
00:01:02,037 --> 00:01:10,826
physical control flow now normally

22
00:01:06,979 --> 00:01:13,650
normally this control flow that executes

23
00:01:11,159 --> 00:01:17,220
just one instruction after another just

24
00:01:13,065 --> 00:01:19,068
sequentially in memory and we've so far

25
00:01:17,022 --> 00:01:21,108
we've seen two two mechanisms for

26
00:01:19,095 --> 00:01:23,834
altering the control flow so that it's

27
00:01:22,008 --> 00:01:27,015
not so that we're not executing just the

28
00:01:24,689 --> 00:01:31,711
next instruction so that's branches and

29
00:01:27,015 --> 00:01:36,054
jumps and procedure call and return okay

30
00:01:31,909 --> 00:01:38,951
now now jumps and call it branches jumps

31
00:01:36,054 --> 00:01:41,813
call and return those are reacting to

32
00:01:39,329 --> 00:01:45,240
changes in program State so when you do

33
00:01:42,299 --> 00:01:48,630
a branch you check to control condition

34
00:01:45,024 --> 00:01:50,025
codes and then based on some the results

35
00:01:48,063 --> 00:01:54,072
of that comparison then you then you do

36
00:01:50,025 --> 00:01:56,064
the branch okay put it real system needs

37
00:01:54,072 --> 00:02:00,071
to be able to adapt to changes in the

38
00:01:56,064 --> 00:02:05,127
system State okay so for example data

39
00:02:00,719 --> 00:02:10,796
arrives from a disk yep or some are on

40
00:02:06,027 --> 00:02:12,093
network user types control C okay the

41
00:02:11,489 --> 00:02:15,840
program executes s-- an illegal

42
00:02:12,093 --> 00:02:17,166
instruction okay all of these represent

43
00:02:15,084 --> 00:02:21,233
some change some kind of change in the

44
00:02:18,066 --> 00:02:26,142
in the system state and we need some way

45
00:02:21,989 --> 00:02:29,400
to react to that so this so what we need

46
00:02:27,042 --> 00:02:31,050
is we call this exceptional control flow

47
00:02:29,004 --> 00:02:32,100
because it's sort of outside of the

48
00:02:31,005 --> 00:02:34,774
normal control flow that we we see in

49
00:02:33,036 --> 00:02:38,075
our programs

50
00:02:35,269 --> 00:02:42,750
now exceptional control flow or ECF

51
00:02:38,075 --> 00:02:43,094
exists at all levels in the system from

52
00:02:42,075 --> 00:02:48,174
the very lowest level

53
00:02:43,094 --> 00:02:51,156
hardware at the very lowest level we

54
00:02:49,074 --> 00:02:53,148
have we're called exception and these

55
00:02:52,056 --> 00:02:57,131
are changes in the control flow in

56
00:02:54,048 --> 00:03:02,106
response to some low level system event

57
00:02:58,031 --> 00:03:05,118
so this is a or and bi event we mean a

58
00:03:03,006 --> 00:03:07,098
change in the state now exceptions are

59
00:03:06,018 --> 00:03:10,029
implemented using a combination of

60
00:03:07,098 --> 00:03:12,117
hardware and os software which we'll see

61
00:03:10,029 --> 00:03:15,060
in it in a minute but these these

62
00:03:13,017 --> 00:03:20,064
exceptional control flows this at higher

63
00:03:15,006 --> 00:03:21,078
levels to so in the process context

64
00:03:20,064 --> 00:03:24,138
switch is an example of exceptional

65
00:03:22,032 --> 00:03:27,087
control flow that also it's implemented

66
00:03:25,038 --> 00:03:31,044
by hardware and the operating system

67
00:03:27,087 --> 00:03:31,173
kernel and it so if process context

68
00:03:31,044 --> 00:03:36,048
switches we'll see later

69
00:03:32,073 --> 00:03:38,160
later today you're executing your

70
00:03:36,084 --> 00:03:42,233
executing your code in the current in

71
00:03:39,006 --> 00:03:46,035
your current process and then all of a

72
00:03:42,989 --> 00:03:49,110
sudden the system is executing code from

73
00:03:46,089 --> 00:03:52,098
another process right so your process

74
00:03:49,011 --> 00:03:55,029
gets like suspended and so there's a so

75
00:03:53,079 --> 00:03:58,115
that's a form of exceptional control

76
00:03:55,029 --> 00:04:01,065
flow where you're executing statements

77
00:03:59,015 --> 00:04:03,062
instructions within one one process and

78
00:04:01,065 --> 00:04:05,088
then all of a sudden you're executing

79
00:04:03,062 --> 00:04:09,521
statements instructions in another

80
00:04:05,088 --> 00:04:12,197
process um at a higher level totally in

81
00:04:10,079 --> 00:04:15,810
software we have the idea of a signal

82
00:04:12,989 --> 00:04:17,130
and this is implemented by operating

83
00:04:15,081 --> 00:04:20,100
system software we'll learn all about

84
00:04:17,013 --> 00:04:23,046
signals next lecture and then even

85
00:04:21,000 --> 00:04:26,001
higher at an even higher level you have

86
00:04:23,046 --> 00:04:28,080
non-local jumps in C which are just

87
00:04:26,001 --> 00:04:31,005
implemented by the C runtime library so

88
00:04:28,008 --> 00:04:31,104
this allows you non-local jumps allow

89
00:04:31,005 --> 00:04:35,058
you to break the normal call and return

90
00:04:32,076 --> 00:04:37,077
patterns so from one from within a

91
00:04:35,058 --> 00:04:40,127
function normally you can only return to

92
00:04:37,077 --> 00:04:43,286
the function that calls that called you

93
00:04:41,027 --> 00:04:46,032
non-local jumps allow you to within a

94
00:04:43,979 --> 00:04:49,320
function break that and return to some

95
00:04:46,077 --> 00:04:50,175
other some other function or some other

96
00:04:49,032 --> 00:04:53,118
part of the code so we'll look at

97
00:04:51,075 --> 00:04:55,131
signals and non-local jumps next lecture

98
00:04:54,018 --> 00:04:56,111
today we're going to look at exceptions

99
00:04:56,031 --> 00:05:02,950
and

100
00:04:57,011 --> 00:05:07,027
disease so an exception is a transfer of

101
00:05:03,229 --> 00:05:09,322
control to the operating systems kernel

102
00:05:07,027 --> 00:05:13,028
where the kernel is the memory resident

103
00:05:10,159 --> 00:05:14,930
part of the operating system you know so

104
00:05:13,037 --> 00:05:19,426
an operating system provides all kinds

105
00:05:14,093 --> 00:05:22,094
of programs like to list files to change

106
00:05:19,759 --> 00:05:26,150
directories to list the current

107
00:05:23,003 --> 00:05:27,077
processes so all of that stuff

108
00:05:26,015 --> 00:05:29,314
constitutes the operating system the

109
00:05:27,077 --> 00:05:33,103
kernel is the part of the operating

110
00:05:29,449 --> 00:05:37,930
system that's always resident in memory

111
00:05:34,003 --> 00:05:40,192
so an exception is this really low-level

112
00:05:37,093 --> 00:05:41,099
transfer of control to the operating

113
00:05:40,219 --> 00:05:44,295
system because something happened in the

114
00:05:41,099 --> 00:05:48,148
system so you're executing your code

115
00:05:44,979 --> 00:05:51,022
user code and then something happens

116
00:05:49,039 --> 00:05:54,460
some event so by event we need there's

117
00:05:51,409 --> 00:05:57,860
some change in the system State in

118
00:05:54,046 --> 00:06:00,068
response to that there's the exception

119
00:05:57,086 --> 00:06:04,088
transfers control from from your user

120
00:06:00,068 --> 00:06:06,146
code to code in the kernel which is

121
00:06:05,006 --> 00:06:10,015
called an exception Handler and then the

122
00:06:07,046 --> 00:06:13,315
kernel responds to that change in some

123
00:06:10,069 --> 00:06:17,330
way this is called the exception

124
00:06:13,729 --> 00:06:18,800
processing and then there's three

125
00:06:17,033 --> 00:06:21,077
there's three things that can happen

126
00:06:18,008 --> 00:06:24,011
after the kernel handles the exception

127
00:06:21,077 --> 00:06:27,140
it can return and re execute that the

128
00:06:24,083 --> 00:06:29,662
current instruction okay and we'll see

129
00:06:28,004 --> 00:06:32,383
this is this is useful for things like

130
00:06:30,409 --> 00:06:36,740
page faults allows us to implement

131
00:06:32,779 --> 00:06:40,815
virtual memory it could return to the

132
00:06:36,074 --> 00:06:44,074
next instruction which I've shown here

133
00:06:41,139 --> 00:06:44,740
or it could abort

134
00:06:45,085 --> 00:06:50,142
now exceptions are implemented by

135
00:06:48,037 --> 00:06:54,130
hardware and software so the the actual

136
00:06:51,042 --> 00:06:58,093
transfer of control you know the change

137
00:06:55,003 --> 00:07:01,069
in the program counter or IP is is is

138
00:06:58,093 --> 00:07:05,155
done by the hardware but the code that

139
00:07:01,096 --> 00:07:07,129
executes as a result of that exception

140
00:07:06,055 --> 00:07:11,134
is set up and determined by the

141
00:07:08,029 --> 00:07:14,080
operating system kernel so every every

142
00:07:12,034 --> 00:07:17,038
type of event has a unique exception

143
00:07:14,008 --> 00:07:18,099
number which serves as an index into a

144
00:07:17,038 --> 00:07:24,039
jump table called an exception table

145
00:07:19,071 --> 00:07:27,169
okay and so when when event K happens

146
00:07:24,048 --> 00:07:30,139
then the hardware looks uses K as an

147
00:07:28,069 --> 00:07:32,161
index into this table and gets the

148
00:07:31,039 --> 00:07:37,050
address of the exception handler for

149
00:07:33,061 --> 00:07:40,108
that for that for that exception and so

150
00:07:37,005 --> 00:07:45,060
every time that event K happens that

151
00:07:41,008 --> 00:07:48,097
handler handler case is invoked now

152
00:07:46,005 --> 00:07:50,104
there's a different kinds of exceptions

153
00:07:48,097 --> 00:07:53,103
we distinguish them as being

154
00:07:51,004 --> 00:07:57,085
asynchronous or synchronous asynchronous

155
00:07:54,003 --> 00:08:00,099
exceptions happen as a result of changes

156
00:07:57,085 --> 00:08:04,141
in state that are occurred outside the

157
00:08:00,099 --> 00:08:07,099
outside of the processor so these are

158
00:08:05,041 --> 00:08:11,125
called interrupts and those changes in

159
00:08:07,099 --> 00:08:13,174
state are the processor is notified

160
00:08:12,025 --> 00:08:16,108
about those changes in state by setting

161
00:08:14,074 --> 00:08:20,131
a pin on the on the processor an

162
00:08:17,008 --> 00:08:24,016
external pin called the interrupt pin so

163
00:08:21,031 --> 00:08:27,046
this is the kind of when say a disk

164
00:08:24,016 --> 00:08:30,040
controller finishes doing a direct

165
00:08:27,046 --> 00:08:32,505
memory access and copying data from the

166
00:08:30,004 --> 00:08:35,095
disk into memory it notifies the

167
00:08:32,919 --> 00:08:41,370
processor that it's finished that copy

168
00:08:36,031 --> 00:08:46,053
by setting the interrupt in hi okay

169
00:08:41,037 --> 00:08:47,115
and so after an interrupt happens the

170
00:08:46,053 --> 00:08:51,102
handler returns to the next instruction

171
00:08:48,015 --> 00:08:53,064
so an interrupt typically it's as though

172
00:08:52,002 --> 00:08:54,009
you're running your program you're

173
00:08:53,064 --> 00:08:57,066
running your program and then there's

174
00:08:54,072 --> 00:08:58,149
like this little there's like this

175
00:08:57,066 --> 00:09:00,066
little pause while the interrupt handler

176
00:08:59,049 --> 00:09:02,088
runs and then your program just

177
00:09:00,066 --> 00:09:04,122
continues to run okay so it's it's

178
00:09:02,088 --> 00:09:08,177
usually sort of done behind the scenes

179
00:09:05,022 --> 00:09:12,066
and doesn't doesn't affect your

180
00:09:09,077 --> 00:09:16,173
execution of your program now the most

181
00:09:12,066 --> 00:09:20,070
common a common example of a interrupt

182
00:09:17,073 --> 00:09:22,170
is the timer interrupt so you're all

183
00:09:20,007 --> 00:09:26,013
systems have a built-in timer that goes

184
00:09:23,007 --> 00:09:27,096
off every few milliseconds and when it

185
00:09:26,076 --> 00:09:30,117
when the timer goes off it sets the

186
00:09:28,059 --> 00:09:32,145
interrupts in high and there's a special

187
00:09:31,017 --> 00:09:36,066
exception number four for timer

188
00:09:33,045 --> 00:09:38,127
interrupts and this is we need this in

189
00:09:36,066 --> 00:09:41,154
order for the this allows we need this

190
00:09:39,027 --> 00:09:44,031
to allow the kernel to get control of

191
00:09:42,054 --> 00:09:46,059
the system again otherwise a user

192
00:09:44,031 --> 00:09:49,053
program could just run forever in an

193
00:09:46,059 --> 00:09:51,093
infinite loop and no one would be no way

194
00:09:49,053 --> 00:09:53,115
for the operating system to get to get

195
00:09:51,093 --> 00:09:57,099
control so every few milliseconds this

196
00:09:54,015 --> 00:10:00,036
timer goes off that causes a transient

197
00:09:57,099 --> 00:10:03,102
exception into the into the kernel and

198
00:10:00,036 --> 00:10:04,122
then the kernel can as we see the kernel

199
00:10:04,002 --> 00:10:07,071
can decide what to do

200
00:10:05,022 --> 00:10:13,029
maybe maybe schedule a new process or

201
00:10:07,071 --> 00:10:14,082
let the correct process run and then and

202
00:10:13,029 --> 00:10:16,104
then this an i/o ended up from an

203
00:10:14,082 --> 00:10:18,168
external devices is also a common

204
00:10:17,004 --> 00:10:21,096
example now the other classic exceptions

205
00:10:19,068 --> 00:10:26,076
are synchronous exceptions and there are

206
00:10:21,096 --> 00:10:29,147
three classes of those one is the one

207
00:10:26,076 --> 00:10:32,103
class is called the trap a trap is a

208
00:10:30,047 --> 00:10:34,086
intentional exception so this is an

209
00:10:33,003 --> 00:10:37,074
exception that's caused intentionally by

210
00:10:34,086 --> 00:10:40,095
the program and the most the most common

211
00:10:37,074 --> 00:10:42,138
form of a trap is a system call so you

212
00:10:41,076 --> 00:10:45,078
know the operating system kernel

213
00:10:43,038 --> 00:10:47,073
provides all kinds of services to to a

214
00:10:45,096 --> 00:10:49,179
program but your program doesn't have

215
00:10:47,073 --> 00:10:51,150
direct access your program can't call

216
00:10:50,079 --> 00:10:53,167
functions in the kernel it can't access

217
00:10:52,005 --> 00:10:55,092
data directly in the kernel

218
00:10:54,067 --> 00:10:59,110
because that memory is protected and

219
00:10:56,037 --> 00:11:02,121
unavailable to user programs so what the

220
00:11:00,001 --> 00:11:06,007
kernel does is it provides a an

221
00:11:03,021 --> 00:11:09,025
interface that allows programs to to

222
00:11:06,016 --> 00:11:11,020
make request to effectively call

223
00:11:09,025 --> 00:11:13,054
functions within the kernel and to make

224
00:11:11,002 --> 00:11:16,014
requests for various services and this

225
00:11:13,054 --> 00:11:18,106
this interface is called a system call

226
00:11:16,032 --> 00:11:24,076
okay so a program makes a system call

227
00:11:19,006 --> 00:11:26,011
and and and requests various functions

228
00:11:24,076 --> 00:11:29,140
from the kernel the kernel provides

229
00:11:26,056 --> 00:11:31,095
those sort of reacts to that request and

230
00:11:30,004 --> 00:11:34,090
then returns control back to the

231
00:11:31,095 --> 00:11:36,181
function there the calling program so

232
00:11:35,026 --> 00:11:41,029
you can think of a system call as kind

233
00:11:37,081 --> 00:11:42,112
of it's a it looks like a function call

234
00:11:41,056 --> 00:11:47,119
but it's really transferring control

235
00:11:43,012 --> 00:11:51,024
into the kernel okay then there's some

236
00:11:48,019 --> 00:11:53,086
so traps are intentional faults are

237
00:11:51,024 --> 00:12:00,060
unintentional but but may be recoverable

238
00:11:53,086 --> 00:12:02,149
okay so things like page faults which

239
00:12:00,006 --> 00:12:04,102
when we will learn more about these when

240
00:12:03,049 --> 00:12:07,111
we study virtual memory but something

241
00:12:05,056 --> 00:12:09,079
like a page fault it's actually

242
00:12:08,011 --> 00:12:13,012
recoverable it just that the kernel has

243
00:12:09,079 --> 00:12:13,171
dirt it means that the data the portion

244
00:12:13,012 --> 00:12:17,101
of the address space that your program

245
00:12:14,071 --> 00:12:19,150
referenced isn't actually in memory it

246
00:12:18,001 --> 00:12:22,072
needs to be copied from disk where it's

247
00:12:20,005 --> 00:12:24,058
stored into memory and then the

248
00:12:22,072 --> 00:12:26,125
instruction that that caused a fault

249
00:12:25,003 --> 00:12:30,010
needs just restarted and then it works

250
00:12:27,025 --> 00:12:34,033
that the the memory is is there and then

251
00:12:30,073 --> 00:12:36,151
the instruction works properly but other

252
00:12:34,033 --> 00:12:39,034
faults are unintentional unrecoverable

253
00:12:37,051 --> 00:12:42,073
like protection fault so if you try to

254
00:12:39,034 --> 00:12:46,045
access a portion of memory that's that's

255
00:12:42,073 --> 00:12:48,109
not allocated or floating-point

256
00:12:46,045 --> 00:12:53,119
exceptions often times those those can

257
00:12:49,009 --> 00:12:56,011
be recoverable so eat in either case

258
00:12:54,019 --> 00:12:57,028
when there's a fault it either reacts

259
00:12:56,029 --> 00:13:01,075
Acutes the current instruction or to

260
00:12:58,009 --> 00:13:03,018
boat or or the boards and then there's

261
00:13:01,075 --> 00:13:05,122
unintentional and unrecoverable

262
00:13:03,099 --> 00:13:07,135
exceptions which are called the board's

263
00:13:06,022 --> 00:13:10,054
and those those always the board's

264
00:13:08,035 --> 00:13:12,061
so if you execute an illegal instruction

265
00:13:10,054 --> 00:13:15,061
if there's a problem with your memory

266
00:13:12,061 --> 00:13:18,067
memory and it's corrupted or if there's

267
00:13:16,024 --> 00:13:22,093
some problem with the machine those

268
00:13:18,067 --> 00:13:24,148
creative warts that that always that are

269
00:13:22,093 --> 00:13:28,144
unrecoverable and never return back to

270
00:13:25,048 --> 00:13:32,131
the to the program now system calls

271
00:13:29,044 --> 00:13:34,060
there's many different kinds of system

272
00:13:33,031 --> 00:13:39,037
calls and they all have their own unique

273
00:13:34,006 --> 00:13:44,017
number which is assigned by by Linux so

274
00:13:39,091 --> 00:13:45,157
in a for example to read a file there's

275
00:13:44,071 --> 00:13:49,162
a system call called read which is

276
00:13:46,057 --> 00:13:59,083
number 0 opening a file is just an call

277
00:13:50,062 --> 00:14:03,075
number 2 and so on and there's a there's

278
00:13:59,083 --> 00:14:06,118
an instruction called Cisco which

279
00:14:03,075 --> 00:14:08,152
actually performs the system call now

280
00:14:07,018 --> 00:14:10,096
you usually don't use the system call

281
00:14:09,052 --> 00:14:13,117
and start desist call instruction

282
00:14:10,096 --> 00:14:15,151
directly in your program D Linux wraps

283
00:14:14,017 --> 00:14:20,044
those in system level functions which

284
00:14:16,051 --> 00:14:21,112
actually call it for you but it it's

285
00:14:20,044 --> 00:14:24,133
interesting to see how it actually works

286
00:14:22,012 --> 00:14:26,020
so exactly you want to open a file you

287
00:14:25,033 --> 00:14:29,119
call the system level function called

288
00:14:26,092 --> 00:14:35,176
open with a file name and some options

289
00:14:30,019 --> 00:14:40,027
say read only write only and so in the

290
00:14:36,076 --> 00:14:43,168
cisco instruction takes the first assist

291
00:14:40,099 --> 00:14:47,191
call number is in our ax and then other

292
00:14:44,068 --> 00:14:51,100
other arguments are in our dir si RDX

293
00:14:48,091 --> 00:14:53,146
our 10 r8 and r9 so you can see if we

294
00:14:52,000 --> 00:14:55,081
look in the the open function calls the

295
00:14:54,046 --> 00:14:58,054
underscore underscore open function

296
00:14:55,081 --> 00:14:59,170
which actually invokes the syscall so if

297
00:14:59,026 --> 00:15:02,119
you look at that code you see it moves

298
00:15:00,007 --> 00:15:06,022
the two which is the sis call number for

299
00:15:03,019 --> 00:15:11,056
read into into a ax and then it does the

300
00:15:06,085 --> 00:15:15,178
SIS call and then the the sis call

301
00:15:11,056 --> 00:15:17,128
returns its status in our ax if it's a

302
00:15:16,078 --> 00:15:19,095
negative number then that means

303
00:15:18,028 --> 00:15:23,207
something some error occurred

304
00:15:19,095 --> 00:15:24,484
if it's a positive number then that

305
00:15:23,459 --> 00:15:27,521
means something that no error occurred

306
00:15:25,339 --> 00:15:29,432
so in this case and I in at the open

307
00:15:28,079 --> 00:15:31,740
it's returning as a file descriptor a

308
00:15:30,269 --> 00:15:34,490
small integer called the file descriptor

309
00:15:31,074 --> 00:15:37,223
which then you you can use in subsequent

310
00:15:34,049 --> 00:15:38,768
calls to read and write and then you can

311
00:15:37,889 --> 00:15:41,790
see the code is checking for this

312
00:15:39,209 --> 00:15:50,430
negative return value too and there's a

313
00:15:41,079 --> 00:15:52,748
whole series of these compares so let's

314
00:15:50,043 --> 00:15:55,202
look at an example of a fault

315
00:15:53,459 --> 00:15:59,516
so here's suppose we have this program

316
00:15:55,589 --> 00:16:02,190
that we're writing into a valid region

317
00:16:00,029 --> 00:16:04,103
of memory but it's not actually stored

318
00:16:02,019 --> 00:16:07,032
on it's not actually in the memory it

319
00:16:04,769 --> 00:16:11,600
needs to be loaded from disk into into

320
00:16:07,032 --> 00:16:14,087
memory so this is a so-called page fault

321
00:16:11,006 --> 00:16:17,022
so this this instruction this move L

322
00:16:14,087 --> 00:16:21,176
because this because the memory at this

323
00:16:17,076 --> 00:16:25,149
address isn't isn't available triggers a

324
00:16:21,959 --> 00:16:28,560
page fault so that that creates an

325
00:16:26,049 --> 00:16:30,081
exception a transfer of control into the

326
00:16:28,056 --> 00:16:33,063
the page fault handler in the kernel

327
00:16:30,081 --> 00:16:37,125
which copies that page from disk to

328
00:16:33,063 --> 00:16:39,111
memory and then it returns and when it

329
00:16:38,025 --> 00:16:42,104
returns it re-execute the move L

330
00:16:40,011 --> 00:16:45,980
instruction so that's kind of cool so

331
00:16:42,329 --> 00:16:48,720
now the memory is available and now that

332
00:16:46,079 --> 00:16:52,880
the move L this move L instruction when

333
00:16:48,072 --> 00:16:55,137
it's reacts acute 'add completes and

334
00:16:52,088 --> 00:16:58,092
then we continue now another type of

335
00:16:56,037 --> 00:17:00,129
fault is an invalid memory reference so

336
00:16:58,092 --> 00:17:03,174
here we have a we're accessing an

337
00:17:01,029 --> 00:17:06,072
element of a which doesn't exist and

338
00:17:04,074 --> 00:17:10,273
it's an illegal it's an invalid

339
00:17:06,072 --> 00:17:13,137
reference so in this case the move L

340
00:17:10,939 --> 00:17:17,880
instruction it looks like a it looks

341
00:17:14,037 --> 00:17:19,256
like a page fault but the kernel detects

342
00:17:17,088 --> 00:17:20,136
that it's an invalid address that there

343
00:17:19,589 --> 00:17:24,150
isn't anything that can be loaded from

344
00:17:21,036 --> 00:17:28,050
disk this is an invalid region of the

345
00:17:24,015 --> 00:17:32,088
virtual address space so it it sends a

346
00:17:28,005 --> 00:17:33,030
signal to the to the process and then

347
00:17:32,088 --> 00:17:36,162
never never

348
00:17:33,075 --> 00:17:39,174
turns it so the signal ascent is the

349
00:17:37,062 --> 00:17:44,139
infamous segmentation the signal that

350
00:17:40,074 --> 00:17:47,160
causes the infamous segmentation fault

351
00:17:45,039 --> 00:17:50,040
message to print out and we'll see next

352
00:17:48,006 --> 00:17:56,007
lecture we'll see we'll see how these

353
00:17:50,049 --> 00:17:58,140
signals actually actually work okay so I

354
00:17:56,061 --> 00:17:59,117
said we've seen exceptions or very

355
00:17:59,004 --> 00:18:02,049
low-level

356
00:18:00,017 --> 00:18:04,038
transfers of control that are

357
00:18:02,085 --> 00:18:07,089
implemented by both hardware and the

358
00:18:04,038 --> 00:18:11,046
operating system software in kudzu at

359
00:18:08,025 --> 00:18:14,049
the higher level is another form of

360
00:18:11,046 --> 00:18:16,085
exceptional control flow called and we

361
00:18:14,049 --> 00:18:21,066
see it in the in the context of a

362
00:18:16,085 --> 00:18:24,164
process context switch so let's look at

363
00:18:21,066 --> 00:18:27,138
and let's look at what what a process is

364
00:18:25,064 --> 00:18:29,115
so a process the idea of a process is

365
00:18:28,038 --> 00:18:32,099
one of the most fundamental and

366
00:18:30,015 --> 00:18:36,036
important ideas in computer science and

367
00:18:32,099 --> 00:18:37,164
this classical definition of is that a

368
00:18:36,036 --> 00:18:42,054
process is an instance of a running

369
00:18:38,064 --> 00:18:45,090
program okay it's different from a

370
00:18:42,054 --> 00:18:47,055
program a program exists can exist in

371
00:18:45,009 --> 00:18:50,025
many different places right a program

372
00:18:47,055 --> 00:18:54,152
exists in yourseif as text in a C file

373
00:18:51,006 --> 00:19:00,045
it can exist as the dot text section of

374
00:18:55,052 --> 00:19:02,115
a binary it can exist as bytes that have

375
00:19:00,045 --> 00:19:04,110
been loaded into memory a process is an

376
00:19:03,015 --> 00:19:12,092
instance of a program that's that's

377
00:19:05,001 --> 00:19:16,079
running that's in execution and a

378
00:19:12,092 --> 00:19:19,179
process provides two key abstractions

379
00:19:16,088 --> 00:19:22,164
okay it's the first abstraction is that

380
00:19:20,079 --> 00:19:27,108
it gives it gives you the illusion that

381
00:19:23,064 --> 00:19:30,090
you had exclusive access to the CPU and

382
00:19:28,008 --> 00:19:32,013
the and the registers okay so when

383
00:19:30,009 --> 00:19:34,044
you're running when you're running your

384
00:19:32,058 --> 00:19:37,059
program in a process you never have to

385
00:19:35,025 --> 00:19:40,038
worry about any other any other programs

386
00:19:37,059 --> 00:19:42,147
modifying your registers and and you

387
00:19:40,038 --> 00:19:45,096
can't even tell that there's even other

388
00:19:43,047 --> 00:19:46,070
processes running on the system right it

389
00:19:45,096 --> 00:19:48,098
looks

390
00:19:46,007 --> 00:19:50,018
except for occasional delays like an

391
00:19:48,098 --> 00:19:53,147
instruction that just takes a little

392
00:19:50,081 --> 00:19:56,099
longer to run except for that it looks

393
00:19:54,047 --> 00:19:59,126
like you have unique exclusive exclusive

394
00:19:56,099 --> 00:20:02,153
use of the of the processor and it's in

395
00:20:00,026 --> 00:20:04,034
its registers the the other abstraction

396
00:20:03,053 --> 00:20:08,090
that it provides is the illusion that

397
00:20:05,006 --> 00:20:11,060
you have your own address space okay so

398
00:20:08,009 --> 00:20:14,020
you have and this is provided by a

399
00:20:11,006 --> 00:20:17,015
mechanism called virtual memory so each

400
00:20:15,001 --> 00:20:22,049
each running program has its own code

401
00:20:18,005 --> 00:20:25,043
data heap stack and you never see that

402
00:20:22,049 --> 00:20:27,055
the code and you never see the memory

403
00:20:25,088 --> 00:20:30,122
that's being used by other processes

404
00:20:27,055 --> 00:20:32,147
okay so it looks for all intents and

405
00:20:31,022 --> 00:20:35,090
purposes process gives you this illusion

406
00:20:33,047 --> 00:20:38,102
that you have access to the exclusive

407
00:20:35,009 --> 00:20:43,043
access to all the the memory and the and

408
00:20:39,002 --> 00:20:48,016
the processor now the the system runs

409
00:20:44,024 --> 00:20:52,040
many of these processes simultaneously

410
00:20:48,016 --> 00:20:55,028
even even on a system with a single core

411
00:20:52,004 --> 00:20:57,016
many of these multiple processes are

412
00:20:55,028 --> 00:20:59,099
actually running at the same time

413
00:20:57,052 --> 00:21:03,068
concurrently and you can see this if you

414
00:20:59,099 --> 00:21:07,175
look at this here I ran top on on my Mac

415
00:21:03,068 --> 00:21:10,082
and you can see it's running 123 123

416
00:21:08,075 --> 00:21:14,093
total processes five of which are

417
00:21:10,082 --> 00:21:17,120
actually running and each one of these

418
00:21:14,093 --> 00:21:20,116
processes has its own unique process ID

419
00:21:18,002 --> 00:21:20,098
this is an integer

420
00:21:23,013 --> 00:21:27,082
now the way so it looks it looks like

421
00:21:25,929 --> 00:21:32,140
you have unique access or exclusive

422
00:21:27,082 --> 00:21:34,135
access to the to the system but in

423
00:21:32,014 --> 00:21:38,403
reality on a suppose we have a single

424
00:21:35,035 --> 00:21:40,069
core on a you're actually sharing the

425
00:21:38,529 --> 00:21:42,700
system and the operating the operating

426
00:21:40,069 --> 00:21:48,918
system is is sort of managing that

427
00:21:42,007 --> 00:21:52,596
sharing so what it does is that we have

428
00:21:49,539 --> 00:21:58,960
a process that's running and it has its

429
00:21:53,289 --> 00:22:01,377
own it has its own address space and and

430
00:21:58,096 --> 00:22:05,158
it has its and it has its own registers

431
00:22:02,169 --> 00:22:08,241
and now at some point either because it

432
00:22:06,058 --> 00:22:11,074
cut at some point an exception occurs

433
00:22:08,889 --> 00:22:14,931
either because of the timer interrupt or

434
00:22:11,074 --> 00:22:16,263
a fault of some kind or a trap at some

435
00:22:15,309 --> 00:22:20,355
point the the operating system gets

436
00:22:16,929 --> 00:22:21,966
control of the system and and in this

437
00:22:20,769 --> 00:22:27,000
case let's say it decides that it wants

438
00:22:22,299 --> 00:22:28,386
to run another process so it copies the

439
00:22:27,000 --> 00:22:31,051
registers the current the current

440
00:22:29,169 --> 00:22:35,500
register values into memory and saves

441
00:22:31,051 --> 00:22:39,560
them and then it schedules the next

442
00:22:35,005 --> 00:22:43,042
process for execution and it loads the

443
00:22:40,019 --> 00:22:45,108
the registers that were saved from the

444
00:22:43,087 --> 00:22:47,106
last time that process was was running

445
00:22:45,909 --> 00:22:50,110
it loads those into the CPU registers

446
00:22:47,889 --> 00:22:53,830
and then it switches the address space

447
00:22:50,011 --> 00:22:58,012
to the address space for for this

448
00:22:53,083 --> 00:23:00,032
process so this the address space and

449
00:22:58,012 --> 00:23:05,017
the register values are the context and

450
00:23:00,779 --> 00:23:08,320
so the context switch is is what is the

451
00:23:05,062 --> 00:23:11,134
change in the in the address space and

452
00:23:08,032 --> 00:23:16,063
the registers ok so then as a point the

453
00:23:12,034 --> 00:23:19,973
that process is running now in reality

454
00:23:16,063 --> 00:23:22,232
on modern systems with multiple cores

455
00:23:20,279 --> 00:23:25,332
the operating system will schedule

456
00:23:22,799 --> 00:23:27,822
processes on those multiple cores and

457
00:23:25,809 --> 00:23:29,980
then if there's no if there's not enough

458
00:23:28,029 --> 00:23:32,082
course to handle the processes then it

459
00:23:29,098 --> 00:23:34,161
will do the context switching just like

460
00:23:32,559 --> 00:23:35,610
we showed before

461
00:23:36,079 --> 00:23:42,116
now each process represents a what we

462
00:23:40,034 --> 00:23:44,069
call logical control flow so if you were

463
00:23:43,016 --> 00:23:46,091
to you know there's a physical control

464
00:23:44,069 --> 00:23:51,077
flow which if we just looked at all the

465
00:23:46,091 --> 00:23:53,093
TC values we'd be executing instructions

466
00:23:52,049 --> 00:23:55,100
from one process and then all of a

467
00:23:54,011 --> 00:23:58,070
sudden we'd be executing from another

468
00:23:56,000 --> 00:24:00,047
process but within a single process

469
00:23:58,007 --> 00:24:01,093
there's a logical control flow which are

470
00:24:00,047 --> 00:24:05,126
all the instructions for that process

471
00:24:02,056 --> 00:24:08,093
now we say that two processes run

472
00:24:06,026 --> 00:24:11,048
concurrently if their flows overlap in

473
00:24:08,093 --> 00:24:13,130
time otherwise they're sequential so

474
00:24:11,048 --> 00:24:16,082
let's look at let's look an example we

475
00:24:14,003 --> 00:24:20,012
have three processes process a runs for

476
00:24:16,082 --> 00:24:22,097
a while and then it's it's interrupted

477
00:24:20,039 --> 00:24:24,131
by process B and process C and then

478
00:24:22,097 --> 00:24:28,142
eventually it continues running and then

479
00:24:25,031 --> 00:24:31,034
it terminates process B interrupts

480
00:24:29,042 --> 00:24:35,048
process a and then it runs for a while

481
00:24:31,034 --> 00:24:37,133
and then it terminates process C once

482
00:24:36,002 --> 00:24:41,060
when process B finishes then process C

483
00:24:38,033 --> 00:24:43,058
gets to run for a while then process a

484
00:24:41,006 --> 00:24:45,068
runs for a while and then process C

485
00:24:43,058 --> 00:24:52,079
terminates okay so given given this

486
00:24:46,022 --> 00:24:55,120
definition of concurrency which which of

487
00:24:52,079 --> 00:24:55,120
these processes are running concurrently

488
00:24:57,063 --> 00:25:10,122
what about a a and B yes so so a and

489
00:25:07,098 --> 00:25:22,116
these flows B these flow overlaps with

490
00:25:11,022 --> 00:25:27,117
aids flow right so B B finishes starts

491
00:25:23,016 --> 00:25:31,113
and finished some portion this portion

492
00:25:28,017 --> 00:25:33,096
of B's flow overlaps with A's flow like

493
00:25:32,013 --> 00:25:36,039
because b is still running hasn't

494
00:25:33,096 --> 00:25:38,193
finished okay so so a and B are

495
00:25:36,039 --> 00:25:43,104
concurrent as and similarly C and a

496
00:25:39,093 --> 00:25:45,162
overlap so they're concurrent but B and

497
00:25:44,004 --> 00:25:54,018
C are not concurrent right these

498
00:25:46,062 --> 00:25:57,108
finishes before C starts now this idea

499
00:25:54,018 --> 00:25:59,084
of concurrency it doesn't this this

500
00:25:58,008 --> 00:26:02,067
definition of concurrency holds

501
00:25:59,084 --> 00:26:03,165
regardless of the number of cores right

502
00:26:02,067 --> 00:26:06,114
if even if you have one core this

503
00:26:04,065 --> 00:26:08,133
example that I showed you was on one

504
00:26:07,014 --> 00:26:11,075
core but even if you have multiple cores

505
00:26:09,033 --> 00:26:15,081
as long as the flows overlap in time

506
00:26:11,075 --> 00:26:17,157
they're concurrent but we can think of

507
00:26:15,081 --> 00:26:19,083
these no matter what we can we can think

508
00:26:18,057 --> 00:26:20,148
of these as running in parallel with

509
00:26:20,001 --> 00:26:25,046
each other at least from the point of

510
00:26:21,048 --> 00:26:24,146
view of these individual processes

511
00:26:29,096 --> 00:26:37,110
now this this notion of a context switch

512
00:26:33,065 --> 00:26:40,071
is it's managed by its managed by the

513
00:26:38,001 --> 00:26:42,003
kernel okay and it's important to

514
00:26:40,071 --> 00:26:43,086
realize that the kernels not like a

515
00:26:42,003 --> 00:26:45,012
separate process that's running it

516
00:26:43,086 --> 00:26:49,149
always runs in the context of some

517
00:26:45,039 --> 00:26:52,092
existing process and it's it's it's it's

518
00:26:50,049 --> 00:26:55,068
just code that's in the upper portion of

519
00:26:52,092 --> 00:26:58,170
the address space that gets executed as

520
00:26:55,068 --> 00:27:00,075
a result of an exception so what what

521
00:26:59,007 --> 00:27:03,033
happens the way to think about this is

522
00:27:01,038 --> 00:27:05,085
that you have this process a that runs

523
00:27:03,096 --> 00:27:06,191
and then an exception occurs which

524
00:27:05,085 --> 00:27:10,128
transfers control to the kernel the

525
00:27:07,091 --> 00:27:12,144
kernel invokes its scheduler which

526
00:27:11,028 --> 00:27:16,074
decides whether to let a continue to run

527
00:27:13,044 --> 00:27:19,071
or to to do a context switch and run a

528
00:27:16,074 --> 00:27:23,142
new process another process so in this

529
00:27:19,071 --> 00:27:27,128
example the schedulers decided to to run

530
00:27:24,042 --> 00:27:31,071
process B so it executes code and then

531
00:27:28,028 --> 00:27:34,035
sort of changes sort of once it repoint

532
00:27:31,071 --> 00:27:37,071
s' the address space then it's running

533
00:27:34,098 --> 00:27:40,170
in the context of process B and it

534
00:27:37,071 --> 00:27:43,071
finishes loading the registers for for

535
00:27:41,007 --> 00:27:45,102
process B general-purpose registers and

536
00:27:43,071 --> 00:27:51,072
then transfers control to B and feed

537
00:27:46,065 --> 00:27:53,078
takes up where it left off okay and then

538
00:27:51,072 --> 00:27:56,103
at some point another exception occurs

539
00:27:53,078 --> 00:27:58,119
and in the kernel decides to transfer

540
00:27:57,003 --> 00:28:00,068
control back to process a which picks up

541
00:27:59,019 --> 00:28:03,072
where it left off right here

542
00:28:00,068 --> 00:28:06,105
so whatever instruction it finishes

543
00:28:03,072 --> 00:28:07,155
executing whatever instructs instruction

544
00:28:07,005 --> 00:28:10,056
was executing at the time of the

545
00:28:08,055 --> 00:28:12,131
exception execute the next instruction

546
00:28:10,056 --> 00:28:12,131
here

547
00:28:16,549 --> 00:28:21,632
now Linux provides a number of functions

548
00:28:20,009 --> 00:28:24,107
that you can you can call from a user

549
00:28:22,379 --> 00:28:26,438
program to manipulate processes and this

550
00:28:24,989 --> 00:28:29,015
this this process this act of

551
00:28:26,969 --> 00:28:32,060
manipulating processes we refer to as

552
00:28:29,249 --> 00:28:35,294
process control now all of these

553
00:28:32,879 --> 00:28:37,930
functions most are I should say most of

554
00:28:35,699 --> 00:28:40,796
these functions called invokes systems

555
00:28:38,389 --> 00:28:43,463
make system calls but they're there

556
00:28:41,669 --> 00:28:45,713
they're wrapped in higher levels what we

557
00:28:44,129 --> 00:28:47,177
call system level functions that that

558
00:28:46,109 --> 00:28:52,181
are the things you actually call from

559
00:28:47,609 --> 00:28:54,647
your user program now system level in

560
00:28:52,829 --> 00:28:56,834
Linux system level functions that will

561
00:28:54,989 --> 00:28:58,085
typically return a minus one if there's

562
00:28:56,879 --> 00:29:00,956
an error and then they'll set a global

563
00:28:58,949 --> 00:29:04,970
variable called error no to indicate the

564
00:29:01,649 --> 00:29:07,747
reason so there's a hard and fast rule

565
00:29:05,159 --> 00:29:12,194
when you're doing when you're invoking

566
00:29:08,629 --> 00:29:14,671
system level functions you must check

567
00:29:12,509 --> 00:29:17,606
the return values from those functions

568
00:29:15,049 --> 00:29:21,068
you should and this you never you'll get

569
00:29:18,479 --> 00:29:22,523
it you'll get into huge trouble if you

570
00:29:21,239 --> 00:29:25,283
if you neglect to check the return

571
00:29:22,919 --> 00:29:28,925
values okay so you should never make a

572
00:29:25,679 --> 00:29:31,703
system a system level function call

573
00:29:28,979 --> 00:29:33,005
without checking the return value the

574
00:29:31,919 --> 00:29:37,922
and the only exception there's some

575
00:29:33,239 --> 00:29:43,241
functions that return void such as a

576
00:29:38,219 --> 00:29:44,276
exit or free don't return anything so

577
00:29:43,259 --> 00:29:47,261
the way the typical way you would do

578
00:29:44,789 --> 00:29:50,190
this is like the fork call which we use

579
00:29:47,459 --> 00:29:52,511
to create processes returns the process

580
00:29:50,019 --> 00:29:55,388
idea of the of the the process that are

581
00:29:52,979 --> 00:29:57,044
created which is always positive if

582
00:29:55,559 --> 00:29:59,576
there's an error returns minus 1 so we

583
00:29:57,629 --> 00:30:02,675
check for the return value to be less

584
00:29:59,729 --> 00:30:06,767
than 0 and then we we deal with that

585
00:30:03,089 --> 00:30:10,163
error somehow ok in this case we're just

586
00:30:07,109 --> 00:30:12,206
printing a message and exiting now this

587
00:30:10,829 --> 00:30:17,855
gets although it's essential to do this

588
00:30:13,079 --> 00:30:19,118
it gets sort of forked from from my

589
00:30:18,089 --> 00:30:21,098
point of view we're trying to present

590
00:30:19,469 --> 00:30:23,477
code to you

591
00:30:21,179 --> 00:30:26,278
it gets really messy it takes up a lot

592
00:30:24,269 --> 00:30:26,278
of space yes

593
00:30:30,032 --> 00:30:35,048
I'm checking that it's less than zero oh

594
00:30:36,038 --> 00:30:41,064
yeah that probably that should be

595
00:30:39,041 --> 00:30:45,057
normally the convention is to return

596
00:30:41,064 --> 00:30:46,107
nonzero so you're right that it's not a

597
00:30:45,057 --> 00:30:48,105
hard and fast rule but that's that's

598
00:30:47,007 --> 00:30:54,069
typically the convention so I guess it

599
00:30:49,005 --> 00:30:57,036
should be exit one so what we'll do to

600
00:30:54,069 --> 00:30:58,101
simplify this in the code that we

601
00:30:57,036 --> 00:30:59,043
present to you and in the code that we

602
00:30:59,001 --> 00:31:02,067
present you in the book

603
00:31:00,006 --> 00:31:07,017
well we'll define error reporting

604
00:31:02,067 --> 00:31:08,073
functions so unix-style errors we the

605
00:31:07,017 --> 00:31:14,082
function returns -1 and then sets there

606
00:31:09,027 --> 00:31:17,073
are no will if we get that kind of if we

607
00:31:14,082 --> 00:31:19,083
get that kind of air will will print

608
00:31:17,073 --> 00:31:21,138
thee will print a message and we'll

609
00:31:19,083 --> 00:31:24,117
report what that error was before we

610
00:31:22,038 --> 00:31:28,044
exit and so then in the code we can

611
00:31:25,017 --> 00:31:31,044
replace that that body of that if

612
00:31:28,044 --> 00:31:32,127
statement with just a single line okay

613
00:31:31,044 --> 00:31:35,109
so that that makes the code a little

614
00:31:33,027 --> 00:31:38,031
tighter but we'll go even further than

615
00:31:36,009 --> 00:31:41,064
that and we'll define these wrappers

616
00:31:38,031 --> 00:31:44,055
which were pioneered by a great

617
00:31:41,064 --> 00:31:48,081
technical writer w richards of stevens

618
00:31:44,055 --> 00:31:50,063
and what we do here is we we replace

619
00:31:48,081 --> 00:31:55,092
each function with an error at a wrapper

620
00:31:51,035 --> 00:31:58,035
that has the identical interface as the

621
00:31:55,092 --> 00:32:00,108
function the original function and it

622
00:31:58,035 --> 00:32:03,099
has the first the first letter uppercase

623
00:32:01,008 --> 00:32:06,107
and then what this wrapper does is it

624
00:32:03,099 --> 00:32:09,105
calls it calls the original function

625
00:32:07,007 --> 00:32:12,048
checks for the errors and then and then

626
00:32:10,005 --> 00:32:15,036
if there's no error returns what the

627
00:32:12,048 --> 00:32:16,140
original function would have returned so

628
00:32:15,036 --> 00:32:20,043
the behavior of this wrapper is

629
00:32:17,004 --> 00:32:22,086
identical to the wrapped function if

630
00:32:21,006 --> 00:32:25,011
there's not an error okay and if there

631
00:32:23,022 --> 00:32:27,087
is an error then it deals with it

632
00:32:25,056 --> 00:32:30,099
somehow and prints a message and so then

633
00:32:27,087 --> 00:32:32,169
this allows us to make our code really

634
00:32:30,099 --> 00:32:34,131
compact without violating this hard and

635
00:32:33,069 --> 00:32:37,094
fast rule that we have to we have to

636
00:32:35,031 --> 00:32:37,094
check for errors

637
00:32:39,047 --> 00:32:44,996
okay the simplest function process

638
00:32:43,169 --> 00:32:47,100
control functions are functions that

639
00:32:45,419 --> 00:32:49,980
allow you to get the pid' for the

640
00:32:47,001 --> 00:32:52,050
current process which is getpid or the

641
00:32:49,098 --> 00:32:54,407
the processor idea of the parent process

642
00:32:52,059 --> 00:32:56,148
that created the current process okay so

643
00:32:55,289 --> 00:32:59,360
this these take no arguments and they

644
00:32:57,048 --> 00:33:01,136
return an integer which is a process

645
00:32:59,999 --> 00:33:02,360
again

646
00:33:04,019 --> 00:33:10,958
now Linux provides ways to create and

647
00:33:07,739 --> 00:33:12,767
terminate processes and from a

648
00:33:11,129 --> 00:33:14,183
programmers perspective we can think of

649
00:33:13,019 --> 00:33:18,071
a process as being in one of three

650
00:33:14,669 --> 00:33:20,714
states running so in this case the

651
00:33:18,539 --> 00:33:25,590
process is actually running and execute

652
00:33:21,119 --> 00:33:27,134
instructions or its it can be scheduled

653
00:33:25,059 --> 00:33:27,878
maybe it's not running but it can be

654
00:33:27,269 --> 00:33:32,270
scheduled at a later time

655
00:33:28,409 --> 00:33:36,494
thanks and it's waiting is waiting to be

656
00:33:32,369 --> 00:33:40,448
scheduled it can be stopped which means

657
00:33:37,259 --> 00:33:42,323
that execution is suspended and won't be

658
00:33:41,159 --> 00:33:44,850
scheduled until further notice so we'll

659
00:33:42,899 --> 00:33:46,590
see how this works and we study signals

660
00:33:44,085 --> 00:33:48,514
in the next lecture but usually a

661
00:33:46,059 --> 00:33:51,878
process is stopped because it receives a

662
00:33:49,279 --> 00:33:54,314
certain kind of signal and then that the

663
00:33:52,409 --> 00:33:58,430
process becomes stopped in ways it won't

664
00:33:54,629 --> 00:34:01,691
be executed it won't be scheduled until

665
00:33:58,619 --> 00:34:04,622
you explicitly tell it to be scheduled

666
00:34:02,249 --> 00:34:06,311
oyel process can be terminated which

667
00:34:04,649 --> 00:34:10,520
means it stopped permanently okay so

668
00:34:06,869 --> 00:34:12,944
it'll never be scheduled again it's done

669
00:34:10,052 --> 00:34:15,147
now a process can be terminated for one

670
00:34:13,619 --> 00:34:18,662
of three reasons so one it receives a

671
00:34:16,047 --> 00:34:22,098
signal whose default action is to

672
00:34:19,049 --> 00:34:25,061
terminate it or your your program

673
00:34:22,098 --> 00:34:26,717
returns from the main routine so you

674
00:34:25,169 --> 00:34:30,242
know you can if you know the definition

675
00:34:27,599 --> 00:34:33,510
for main is int see main routines always

676
00:34:30,899 --> 00:34:36,270
return an int so you can return from

677
00:34:33,051 --> 00:34:37,910
main and that will terminate your event

678
00:34:36,027 --> 00:34:42,146
it will terminate the process or you can

679
00:34:38,369 --> 00:34:46,740
explicitly call the exit function the

680
00:34:42,389 --> 00:34:49,436
exit function exits the program with an

681
00:34:46,074 --> 00:34:51,233
exit status of the of its argument so

682
00:34:49,859 --> 00:34:54,863
as as you pointed out that the

683
00:34:51,899 --> 00:34:56,921
convention is that for normal return is

684
00:34:54,899 --> 00:34:59,996
to return zero and then non zero on

685
00:34:57,119 --> 00:35:03,134
error or you can another way to do this

686
00:35:00,869 --> 00:35:04,910
is just return an integer value from the

687
00:35:03,269 --> 00:35:08,303
main routine and that will that will set

688
00:35:05,279 --> 00:35:10,950
the exit status now exit is kind of

689
00:35:08,609 --> 00:35:13,710
unusual and you'll see this is typical

690
00:35:10,095 --> 00:35:15,164
of all these process control functions

691
00:35:13,071 --> 00:35:18,920
that they normally functions you call

692
00:35:16,019 --> 00:35:21,101
them once and then they return one ok

693
00:35:19,559 --> 00:35:25,652
the exit you call one and then it never

694
00:35:21,839 --> 00:35:30,450
returns okay so that's so that's a

695
00:35:26,489 --> 00:35:32,546
little unusual now a parent process can

696
00:35:30,045 --> 00:35:40,204
create a child process by calling the

697
00:35:33,059 --> 00:35:45,155
fork function so fork takes no arguments

698
00:35:40,609 --> 00:35:50,730
and it returns an integer it creates a

699
00:35:46,019 --> 00:35:55,070
new child process and then it returns in

700
00:35:50,073 --> 00:35:56,192
both the parent and the child so this is

701
00:35:55,529 --> 00:35:57,630
a little hard to wrap your head around

702
00:35:56,849 --> 00:36:01,850
at first

703
00:35:57,063 --> 00:36:04,095
it's called once by the parent but it's

704
00:36:01,859 --> 00:36:06,960
then it returns in both it creates a new

705
00:36:04,095 --> 00:36:09,914
process and then it returns in both the

706
00:36:06,096 --> 00:36:13,122
parent and the child and to the child it

707
00:36:10,769 --> 00:36:16,792
returns zero to the parent it returned

708
00:36:14,022 --> 00:36:19,801
it returned to the child's process ID

709
00:36:16,999 --> 00:36:19,999
okay

710
00:36:20,829 --> 00:36:26,830
the child gets an identical copy of the

711
00:36:23,929 --> 00:36:29,022
parents virtual address space but

712
00:36:26,929 --> 00:36:33,025
separate right there they're distinct

713
00:36:29,859 --> 00:36:35,923
but immediately after the fork returns

714
00:36:33,889 --> 00:36:37,945
the addresses the address space is

715
00:36:36,499 --> 00:36:40,582
identical so that means that all the

716
00:36:38,449 --> 00:36:44,485
variables all the global variables the

717
00:36:41,329 --> 00:36:45,400
stack the code everything is identical

718
00:36:44,809 --> 00:36:48,844
and the child

719
00:36:46,039 --> 00:36:53,071
it has exact same values as it as it

720
00:36:49,159 --> 00:36:55,186
does in the parent the the child gets

721
00:36:53,359 --> 00:36:59,377
identical copies of the parents open

722
00:36:55,429 --> 00:37:01,462
open file descriptors so the child has

723
00:36:59,539 --> 00:37:02,617
access to any open files including like

724
00:37:01,759 --> 00:37:05,845
standard in and standard out that the

725
00:37:03,319 --> 00:37:07,402
parent had and the only difference is

726
00:37:06,619 --> 00:37:11,668
that the child gets a different process

727
00:37:08,149 --> 00:37:16,150
ID than the parent so fork is really

728
00:37:12,109 --> 00:37:17,200
strange because it's called once that

729
00:37:16,159 --> 00:37:22,159
returns twice once in the parent and

730
00:37:18,019 --> 00:37:27,025
once in the child so here's an example

731
00:37:22,159 --> 00:37:31,180
of this here's the this is an example

732
00:37:27,079 --> 00:37:33,091
program that has a it has a local

733
00:37:31,369 --> 00:37:37,390
variable called X on the stack

734
00:37:33,199 --> 00:37:42,238
initialized to 1 and then it calls fork

735
00:37:37,579 --> 00:37:46,651
and fork creates the child and returns

736
00:37:42,589 --> 00:37:50,653
the it returns a value to that both the

737
00:37:47,299 --> 00:37:52,351
parent and the child we the only way we

738
00:37:51,229 --> 00:37:54,274
can distinguish whether we're executing

739
00:37:52,819 --> 00:37:56,914
in the parent or the child is to check

740
00:37:54,679 --> 00:37:59,776
that return value okay so here if the

741
00:37:57,769 --> 00:38:02,797
process ID is pit as 0 then we're

742
00:38:00,649 --> 00:38:05,737
executing in the child and remember the

743
00:38:03,049 --> 00:38:13,096
child got exactly the same has exactly

744
00:38:06,529 --> 00:38:18,571
the same memory and and code as the

745
00:38:13,519 --> 00:38:20,584
parent so X in the child is is 1 so when

746
00:38:18,949 --> 00:38:23,977
we print we print this message from the

747
00:38:21,169 --> 00:38:28,174
child we increment X and then print this

748
00:38:24,229 --> 00:38:32,840
this message so the child will print 1+1

749
00:38:28,669 --> 00:38:35,270
2 and then exit

750
00:38:32,084 --> 00:38:36,128
in the parent when we check that this

751
00:38:35,027 --> 00:38:39,029
process ID it's going to be non zero

752
00:38:37,028 --> 00:38:43,031
because it's the process idea that of a

753
00:38:39,029 --> 00:38:45,062
child so in this case so so the parent

754
00:38:43,031 --> 00:38:47,039
won't execute this the body of this

755
00:38:45,062 --> 00:38:50,090
conditional so the parent will will

756
00:38:48,011 --> 00:38:53,057
execute this printf and in the parent we

757
00:38:50,009 --> 00:38:56,104
decrement X before we print it so the

758
00:38:53,057 --> 00:39:01,088
parent prints out one minus one is zero

759
00:38:57,085 --> 00:39:03,098
now there's no guarantee we have no

760
00:39:01,088 --> 00:39:06,092
guarantee whether the childhood parent

761
00:39:03,098 --> 00:39:09,113
executes first it could happen when the

762
00:39:06,092 --> 00:39:10,190
fork when the fork returns the the

763
00:39:10,013 --> 00:39:15,017
kernel may decide to schedule the child

764
00:39:11,009 --> 00:39:16,094
first okay in which in which case this

765
00:39:15,017 --> 00:39:20,042
code in the body of the conditional

766
00:39:17,075 --> 00:39:23,075
would run or it may it may decide to run

767
00:39:20,042 --> 00:39:25,133
the parent first okay and and there's no

768
00:39:23,075 --> 00:39:28,091
way to predict and it is wrong it's an

769
00:39:26,033 --> 00:39:29,129
error to make any assumption like that

770
00:39:28,091 --> 00:39:32,165
about what's going to run first the

771
00:39:30,029 --> 00:39:35,083
parent of the child and you can see that

772
00:39:33,065 --> 00:39:38,081
they share the same open files because

773
00:39:35,083 --> 00:39:40,112
both the parent and the child print to

774
00:39:38,081 --> 00:39:46,130
standard out and it prints on the

775
00:39:41,012 --> 00:39:48,080
terminal okay yes what if the question

776
00:39:47,003 --> 00:39:52,037
is what if you call fork multiple times

777
00:39:48,008 --> 00:39:53,093
I'll show you some examples of those it

778
00:39:52,064 --> 00:39:55,163
gets a little hairy we'll have a will

779
00:39:54,065 --> 00:40:00,151
use a model called a process graph to

780
00:39:56,063 --> 00:40:00,151
sort sort of understand what happens

781
00:40:03,061 --> 00:40:09,134
okay so like just like you said forks

782
00:40:06,002 --> 00:40:12,017
forks or kind of can be kind of complex

783
00:40:10,034 --> 00:40:14,038
and to understand especially if they're

784
00:40:12,017 --> 00:40:16,064
nested or you call them multiple times

785
00:40:14,038 --> 00:40:21,080
so we use the tool called the process

786
00:40:16,064 --> 00:40:24,080
graph to to capture sort of what what

787
00:40:21,008 --> 00:40:25,016
could happen when we call Forks right we

788
00:40:24,008 --> 00:40:27,059
can we can't we can't make any

789
00:40:26,006 --> 00:40:30,101
assumption about the ordering of of

790
00:40:28,031 --> 00:40:33,044
different processes but we can capture

791
00:40:31,055 --> 00:40:36,074
the partial ordering of events using

792
00:40:33,044 --> 00:40:37,118
this this tool called a process graph so

793
00:40:36,074 --> 00:40:39,152
what we'll do is we'll let each vertex

794
00:40:38,018 --> 00:40:42,092
correspond to the execution of the

795
00:40:40,052 --> 00:40:45,098
statement and then an edge it's that

796
00:40:42,092 --> 00:40:47,177
happens before relation so a happens

797
00:40:45,098 --> 00:40:50,132
for B we will label edges with current

798
00:40:48,077 --> 00:40:53,129
values of variables if we have a

799
00:40:51,032 --> 00:40:55,121
printout vertices a printout a vertex

800
00:40:54,029 --> 00:40:58,097
that corresponds to a printf we can

801
00:40:56,021 --> 00:41:00,119
label that with the output and then

802
00:40:58,097 --> 00:41:03,131
every graph starts with a vertex with

803
00:41:01,019 --> 00:41:06,038
knowing in edges so given this graph

804
00:41:04,031 --> 00:41:09,098
then any topological sort of the graph

805
00:41:06,038 --> 00:41:13,040
represents some feasible some feasible

806
00:41:09,098 --> 00:41:14,165
total ordering of events and by

807
00:41:13,004 --> 00:41:17,042
topological sort we mean a total

808
00:41:15,065 --> 00:41:21,152
ordering of the vertices where all the

809
00:41:17,078 --> 00:41:22,169
edges go from left to right ok so let's

810
00:41:22,052 --> 00:41:28,129
look at how this would work for our

811
00:41:23,069 --> 00:41:32,075
example program here we have the parent

812
00:41:29,029 --> 00:41:36,035
initially X is equal to 1 then the

813
00:41:32,075 --> 00:41:40,079
parent calls fork the fork returns in

814
00:41:36,089 --> 00:41:42,182
both the parent and the child the child

815
00:41:41,015 --> 00:41:47,084
prints and both the parent and the child

816
00:41:43,082 --> 00:41:49,130
print the value of x after incrementing

817
00:41:47,084 --> 00:41:53,093
or decrementing and then they both exit

818
00:41:50,003 --> 00:41:56,087
okay so you can think of these as it's

819
00:41:54,074 --> 00:41:57,943
happening so these happen concurrently

820
00:41:57,014 --> 00:42:02,018
right which means they can be

821
00:41:58,609 --> 00:42:04,580
interleaved and in in any way so the the

822
00:42:02,054 --> 00:42:09,071
topological sort of this graph will tell

823
00:42:04,058 --> 00:42:15,077
us a feasible what's a feasible what are

824
00:42:09,071 --> 00:42:17,102
feasible interleavings ok so we can so

825
00:42:15,077 --> 00:42:19,124
if we if we real able the graph just to

826
00:42:18,002 --> 00:42:26,099
keep it simple so if we real able these

827
00:42:20,024 --> 00:42:31,031
edges with just single letters then this

828
00:42:26,099 --> 00:42:32,108
total ordering a dec FD represented

829
00:42:31,031 --> 00:42:36,074
represents it's a topological sort and

830
00:42:33,089 --> 00:42:41,068
thus a feasible total ordering so here

831
00:42:36,074 --> 00:42:44,090
we have a executing then D then e

832
00:42:41,869 --> 00:42:50,710
executes sin the child and then at this

833
00:42:44,009 --> 00:42:53,048
point the the kernel decides to swap out

834
00:42:50,071 --> 00:42:56,156
swap out e swap out the child and now

835
00:42:54,029 --> 00:42:59,041
let the parent run so the parent picks

836
00:42:57,056 --> 00:43:02,150
up and executes see

837
00:42:59,041 --> 00:43:04,115
and then and then it gets rescheduled to

838
00:43:03,005 --> 00:43:07,016
chat then the child gets scheduled and

839
00:43:05,015 --> 00:43:10,022
executes f and then the parent the

840
00:43:07,061 --> 00:43:11,153
parent runs and finally finishes right

841
00:43:10,022 --> 00:43:14,096
so this is this is very unlikely that it

842
00:43:12,053 --> 00:43:18,056
you'd only ask you one instruction and

843
00:43:14,096 --> 00:43:20,099
then and then B and then have a context

844
00:43:18,056 --> 00:43:23,093
switch but it's it's feasible right

845
00:43:20,099 --> 00:43:25,190
because it represents because the the

846
00:43:23,093 --> 00:43:32,096
total ordering is it is a topological

847
00:43:26,009 --> 00:43:35,093
ordering on the other hand this is this

848
00:43:32,096 --> 00:43:37,103
is infeasible because F here in this

849
00:43:36,074 --> 00:43:41,078
total ordering we're executing F before

850
00:43:38,066 --> 00:43:44,114
E and you can see that this that just

851
00:43:41,078 --> 00:43:46,106
can't happen right so the the edges on

852
00:43:45,014 --> 00:43:49,037
these the logical flow represented by

853
00:43:47,006 --> 00:43:52,103
this child have to occur in this order

854
00:43:49,037 --> 00:43:57,110
first E and then F right by that just

855
00:43:53,003 --> 00:44:03,095
because F follows eating the code right

856
00:43:58,001 --> 00:44:06,007
that the compilers not going to it's not

857
00:44:03,095 --> 00:44:07,099
going to alter those

858
00:44:06,007 --> 00:44:13,024
okay so what happens if now if we have

859
00:44:08,035 --> 00:44:16,069
two consecutive Forks well let's draw

860
00:44:13,087 --> 00:44:16,153
that the process graph will help us

861
00:44:16,069 --> 00:44:21,112
understand this

862
00:44:17,053 --> 00:44:25,108
so in the parent we print L 0 and then

863
00:44:22,012 --> 00:44:29,038
fork and that creates a child and both

864
00:44:26,008 --> 00:44:31,009
and so the fork returns to this printf

865
00:44:29,038 --> 00:44:34,062
in both the parent and the child so they

866
00:44:31,009 --> 00:44:38,020
both the parent and the child print L 1

867
00:44:34,062 --> 00:44:41,133
and then both parents and child's

868
00:44:38,002 --> 00:44:44,008
executes a fork so that creates that

869
00:44:42,033 --> 00:44:48,061
creates another child that creates two

870
00:44:44,008 --> 00:44:52,015
more now two two children okay and then

871
00:44:48,061 --> 00:44:55,132
and so that returns to the printf which

872
00:44:52,087 --> 00:44:57,136
says by so the result of this of calling

873
00:44:56,032 --> 00:45:02,089
Fork twice like this is that creates

874
00:44:58,036 --> 00:45:04,048
four processor okay and you can and if

875
00:45:02,089 --> 00:45:05,125
it's confusing you can always work it

876
00:45:04,048 --> 00:45:09,049
out with the process graph like this

877
00:45:06,025 --> 00:45:12,052
okay so we can weaken us we can see

878
00:45:09,058 --> 00:45:13,150
feasible and infeasible orderings so

879
00:45:12,052 --> 00:45:17,056
this one's feasible take my word for it

880
00:45:14,005 --> 00:45:17,014
this one is then feasible and let's see

881
00:45:17,092 --> 00:45:23,113
why

882
00:45:18,004 --> 00:45:28,012
so it's L 0 and there's no way to to

883
00:45:24,013 --> 00:45:30,019
print by before the first fork all right

884
00:45:28,048 --> 00:45:31,117
so that's infeasible if we if we drew

885
00:45:30,073 --> 00:45:35,148
out this process graph we'd have a

886
00:45:32,017 --> 00:45:36,048
backward a backward edge

887
00:45:37,071 --> 00:45:41,148
okay now what happens if we nest Forex

888
00:45:40,074 --> 00:45:43,163
in the parent okay I'm not sure why

889
00:45:42,048 --> 00:45:50,627
you'd want to do this except maybe to

890
00:45:43,829 --> 00:45:52,530
torture to 13 students but so we can

891
00:45:51,059 --> 00:45:55,800
just work this out by drawing the

892
00:45:52,053 --> 00:45:58,089
process graph so here we have the parent

893
00:45:55,008 --> 00:46:06,057
it prints L 0 and then it does a fork so

894
00:45:58,089 --> 00:46:10,116
that creates a a child so the child if

895
00:46:07,029 --> 00:46:12,117
fork is not equal to 0 then we're in the

896
00:46:11,016 --> 00:46:17,094
parent right so this code executes sin

897
00:46:13,017 --> 00:46:19,092
the parent if fork is 0 then we're

898
00:46:17,094 --> 00:46:22,176
executing the child and the child just

899
00:46:19,092 --> 00:46:25,125
prints by and then and then terminate it

900
00:46:23,076 --> 00:46:30,093
eventually terminates I didn't show it

901
00:46:26,025 --> 00:46:33,093
here if it calls exit think the function

902
00:46:30,093 --> 00:46:37,145
that called this function calls exit so

903
00:46:33,093 --> 00:46:41,462
the parent so fork not equal to 0

904
00:46:38,045 --> 00:46:44,654
indicates that this is the parent so the

905
00:46:42,299 --> 00:46:50,270
parent prints l1 and then it does

906
00:46:45,059 --> 00:46:50,270
another fork that fork creates a child

907
00:46:50,096 --> 00:46:57,141
so if if if fork is not equal to 0 then

908
00:46:55,044 --> 00:47:00,138
we're in the parent so the parent prints

909
00:46:58,041 --> 00:47:06,120
l2 and then exits this conditional and

910
00:47:01,038 --> 00:47:08,717
prints by if if fork returns 0 then that

911
00:47:07,002 --> 00:47:11,046
means we're executing the child so we

912
00:47:09,059 --> 00:47:14,460
don't execute this code we jump out of

913
00:47:11,064 --> 00:47:23,127
this conditional and then the child just

914
00:47:14,046 --> 00:47:25,143
prints by ok and we can dub so this this

915
00:47:24,027 --> 00:47:28,816
represents an infeasible output from

916
00:47:26,043 --> 00:47:28,672
this program

917
00:47:29,089 --> 00:47:38,430
l0 Fork week so L 0 followed by by

918
00:47:34,074 --> 00:47:40,453
that's feasible and then followed by L 1

919
00:47:38,043 --> 00:47:40,732
that's okay

920
00:47:42,000 --> 00:47:48,078
and then the next buy is okay but it

921
00:47:44,064 --> 00:47:53,157
simply we can't have this we can't have

922
00:47:48,078 --> 00:47:56,109
this by preceding this l2 because l2

923
00:47:54,057 --> 00:48:01,095
will this printf will execute before

924
00:47:57,009 --> 00:48:09,038
this printf okay and I'll let you work

925
00:48:01,095 --> 00:48:10,140
out this one up as a as an exercise all

926
00:48:09,119 --> 00:48:14,168
right now when a when a process

927
00:48:11,004 --> 00:48:16,005
terminates for whatever reason the

928
00:48:14,609 --> 00:48:20,640
system actually keeps it around for

929
00:48:16,005 --> 00:48:23,007
until it's reaped and the reason until

930
00:48:20,064 --> 00:48:25,107
it's reaped by its parent and the reason

931
00:48:23,052 --> 00:48:27,054
it does this is that the parent may want

932
00:48:26,007 --> 00:48:30,009
to know about the exit status of the

933
00:48:27,072 --> 00:48:32,471
child so but if a parent creates a child

934
00:48:30,027 --> 00:48:36,072
it may want to wait for that child to

935
00:48:33,119 --> 00:48:38,940
finish and and check its exit status so

936
00:48:36,072 --> 00:48:40,128
when when any process terminates the

937
00:48:38,094 --> 00:48:42,503
system leaves that it doesn't it doesn't

938
00:48:41,028 --> 00:48:45,042
remove it entirely from the system it

939
00:48:43,349 --> 00:48:47,760
keeps it or a little bit of state

940
00:48:45,042 --> 00:48:51,461
associated with that child in the form

941
00:48:47,076 --> 00:48:54,114
of the exit status of the child and the

942
00:48:51,839 --> 00:48:57,660
and some other tables some other OS

943
00:48:55,014 --> 00:49:00,096
tables so because this child is

944
00:48:57,066 --> 00:49:01,149
terminated but it's not gone it they're

945
00:49:00,096 --> 00:49:08,157
called zombies so there's sort of half

946
00:49:02,049 --> 00:49:12,668
half-living half-dead and so a process a

947
00:49:09,057 --> 00:49:15,144
zombie remains of zombie until it's it's

948
00:49:13,109 --> 00:49:18,560
it's reaped by its parent using a

949
00:49:16,044 --> 00:49:21,072
function called weight or weighted and

950
00:49:18,056 --> 00:49:23,058
as a result of as a result of doing

951
00:49:21,072 --> 00:49:24,153
weight or weight that the parent has

952
00:49:23,058 --> 00:49:27,120
given the exit status information and

953
00:49:25,053 --> 00:49:32,094
then the kernel deletes the zombie

954
00:49:28,002 --> 00:49:34,098
process now what if the parent doesn't

955
00:49:32,094 --> 00:49:40,253
doesn't read this one of its child

956
00:49:35,016 --> 00:49:43,715
zombies so it's if any parent if the

957
00:49:41,099 --> 00:49:46,260
parent terminates then the system

958
00:49:43,859 --> 00:49:48,510
arranges for the very first process that

959
00:49:46,026 --> 00:49:50,885
existed in the system called the init

960
00:49:48,051 --> 00:49:52,056
process which has a process ID of one it

961
00:49:51,119 --> 00:49:56,150
arranges for the anit process to read

962
00:49:53,001 --> 00:49:56,015
that that child

963
00:49:56,018 --> 00:50:03,087
so there's so orphaned orphaned children

964
00:49:59,057 --> 00:50:05,121
will always be reaped by by the anit

965
00:50:03,087 --> 00:50:11,109
process so we only really have to worry

966
00:50:06,021 --> 00:50:13,083
about about reaping zombies in in the

967
00:50:12,009 --> 00:50:17,016
case where we have long-running parents

968
00:50:13,083 --> 00:50:19,158
like shells or servers because in that

969
00:50:17,079 --> 00:50:22,173
case a server may create millions of

970
00:50:20,058 --> 00:50:26,112
child processes each one of those each

971
00:50:23,073 --> 00:50:28,077
one of those does each one of those

972
00:50:27,012 --> 00:50:30,021
child processes when they terminate

973
00:50:28,077 --> 00:50:33,141
become zombies and they they have state

974
00:50:31,002 --> 00:50:36,075
which takes up room in the kernel so you

975
00:50:34,041 --> 00:50:39,045
can get this it's a form of memory leak

976
00:50:36,075 --> 00:50:40,119
if you don't if you don't reap these

977
00:50:39,045 --> 00:50:44,108
zombie children that can eventually fill

978
00:50:41,019 --> 00:50:44,108
up the memory space and crash the kernel

979
00:50:47,081 --> 00:50:52,125
so for for cases where you have

980
00:50:51,003 --> 00:50:55,068
long-running programs then we have to we

981
00:50:53,025 --> 00:50:58,092
have to use wait or wait could to read

982
00:50:55,068 --> 00:51:03,153
the children so let's look at an example

983
00:50:58,092 --> 00:51:06,110
first let's look an example of this

984
00:51:04,053 --> 00:51:09,141
zombie phenomenon so here we have a

985
00:51:07,001 --> 00:51:14,013
function we call fork and then within

986
00:51:10,041 --> 00:51:15,099
the child we print a message of the

987
00:51:14,022 --> 00:51:19,095
process idea of that child and then we

988
00:51:15,099 --> 00:51:20,106
exit the child within the parent we

989
00:51:19,095 --> 00:51:22,188
print a message and then we go into an

990
00:51:21,069 --> 00:51:26,154
infinite loop okay so this is a parent

991
00:51:23,088 --> 00:51:29,163
that's that never never reach the child

992
00:51:27,054 --> 00:51:36,057
that it created so if we run this

993
00:51:30,063 --> 00:51:39,069
program called Forks you can see it

994
00:51:36,084 --> 00:51:41,148
prints these two messages the parent

995
00:51:40,023 --> 00:51:46,122
prints a message and the child prints a

996
00:51:42,048 --> 00:51:48,117
message and then and we're running it in

997
00:51:47,022 --> 00:51:50,094
the background with this ampersand okay

998
00:51:49,017 --> 00:51:53,058
because we're going to otherwise it

999
00:51:50,094 --> 00:51:56,121
would it would it's it's still running

1000
00:51:53,058 --> 00:51:58,074
and we wouldn't be able to inspect it so

1001
00:51:57,021 --> 00:52:01,026
after we run this program in the

1002
00:51:58,074 --> 00:52:02,157
background then we use PS to print the

1003
00:52:01,026 --> 00:52:05,073
current processes and we can see that

1004
00:52:03,057 --> 00:52:08,059
there's two we can see here at the

1005
00:52:05,073 --> 00:52:10,962
parent which is process ID 663

1006
00:52:08,077 --> 00:52:15,088
and then the child which is six six four

1007
00:52:11,619 --> 00:52:21,970
zero and that the defunct indicates that

1008
00:52:15,088 --> 00:52:24,047
it's a zombie okay now if we kill six

1009
00:52:21,097 --> 00:52:27,115
six three nine that's the parent and

1010
00:52:24,839 --> 00:52:30,010
then to another PS you see that the

1011
00:52:28,015 --> 00:52:31,944
zombies gone that the child is gone

1012
00:52:30,001 --> 00:52:37,039
because it's been reached by the emit

1013
00:52:32,079 --> 00:52:39,040
process one now what happens if the

1014
00:52:37,039 --> 00:52:42,067
child doesn't terminate you might wonder

1015
00:52:39,004 --> 00:52:48,033
like if if a parent creates a child and

1016
00:52:42,067 --> 00:52:51,142
then the parents and then the chat and

1017
00:52:48,069 --> 00:52:53,800
the child never terminates and the

1018
00:52:52,042 --> 00:52:57,043
parent terminates then what would happen

1019
00:52:53,008 --> 00:53:00,072
much so let's just let's look at an

1020
00:52:57,052 --> 00:53:03,381
example of those and see so here we're

1021
00:53:01,044 --> 00:53:06,933
we're calling fork we're creating a

1022
00:53:03,849 --> 00:53:09,760
child within the child we print a

1023
00:53:07,329 --> 00:53:14,230
message and then the child goes into an

1024
00:53:09,076 --> 00:53:16,635
infinite loop and the parent prints a

1025
00:53:14,023 --> 00:53:21,028
message and then exits so if we run this

1026
00:53:17,319 --> 00:53:25,347
program you can see that the two

1027
00:53:21,073 --> 00:53:27,088
messages from parents and child and then

1028
00:53:25,599 --> 00:53:30,624
if we look at the if we look at the

1029
00:53:27,088 --> 00:53:33,090
prophecies we can see we can see that

1030
00:53:30,849 --> 00:53:33,900
the child is still running

1031
00:53:38,589 --> 00:53:42,592
okay so the channel process is still

1032
00:53:40,094 --> 00:53:45,169
running even though the parents's has

1033
00:53:42,619 --> 00:53:55,400
terminated and now if we kill this child

1034
00:53:46,069 --> 00:53:56,120
six six seven six and then if we kill it

1035
00:53:55,004 --> 00:54:00,073
then we can see that it's gone it's no

1036
00:53:57,002 --> 00:54:01,046
longer in the system okay so that child

1037
00:54:00,469 --> 00:54:04,400
when we when we killed it that

1038
00:54:01,064 --> 00:54:07,723
terminated it it had no parents so the

1039
00:54:04,004 --> 00:54:14,027
anit process reads it and it it's no

1040
00:54:08,299 --> 00:54:18,140
longer a zombie so the the function that

1041
00:54:14,063 --> 00:54:21,065
we use to to synchronize with children

1042
00:54:18,014 --> 00:54:26,173
and read them the simplest one is called

1043
00:54:21,065 --> 00:54:29,404
wait and wait it takes an optional

1044
00:54:26,299 --> 00:54:31,393
status where you can get the exit status

1045
00:54:29,989 --> 00:54:36,890
of the inspect the exit status of the

1046
00:54:32,239 --> 00:54:39,243
child basically wait suspends the

1047
00:54:36,089 --> 00:54:40,678
execution of the process that calls it

1048
00:54:39,279 --> 00:54:43,351
until one or one of its children

1049
00:54:41,479 --> 00:54:46,400
terminates and it doesn't specify which

1050
00:54:43,999 --> 00:54:49,056
one it just waits until one of the

1051
00:54:46,004 --> 00:54:54,005
children that it created terminates and

1052
00:54:49,569 --> 00:54:56,630
then if this child status is not no than

1053
00:54:54,041 --> 00:54:57,850
the integer that it returns are the

1054
00:54:56,063 --> 00:55:00,065
integer that it points to this is a

1055
00:54:58,219 --> 00:55:02,630
pointer the integer that it points to

1056
00:55:00,065 --> 00:55:03,904
will be set to some value that indicated

1057
00:55:02,063 --> 00:55:06,292
the reason the child terminated and its

1058
00:55:04,489 --> 00:55:10,501
exit status and you can you can check

1059
00:55:06,859 --> 00:55:11,953
that using these macros which your your

1060
00:55:10,609 --> 00:55:16,708
textbook describes in more detail and

1061
00:55:12,799 --> 00:55:20,630
let you uh so let's look at how how this

1062
00:55:17,599 --> 00:55:23,671
works in a simple example so here we're

1063
00:55:20,063 --> 00:55:27,262
calling Fork and creating a child which

1064
00:55:24,319 --> 00:55:30,394
prints a message and then exits the

1065
00:55:27,829 --> 00:55:32,880
parent prints a message and then it

1066
00:55:31,069 --> 00:55:36,145
waits for the child to terminate and

1067
00:55:33,339 --> 00:55:39,346
when the child terminates it prints a

1068
00:55:36,829 --> 00:55:41,896
message and indicating that the child

1069
00:55:40,039 --> 00:55:44,131
terminated and then prints by so if we

1070
00:55:42,499 --> 00:55:46,585
were to look at the the process graph of

1071
00:55:44,959 --> 00:55:49,024
this you would see that we would have of

1072
00:55:47,359 --> 00:55:52,190
the fork creates the parent and

1073
00:55:49,609 --> 00:55:55,657
the child both the parent and the child

1074
00:55:52,019 --> 00:56:01,078
through their their printf and then the

1075
00:55:56,089 --> 00:56:03,094
parent waits it suspends until that the

1076
00:56:01,249 --> 00:56:08,690
child terminates in this case by calling

1077
00:56:03,589 --> 00:56:13,591
exit okay so what that means is it's

1078
00:56:08,069 --> 00:56:15,145
it's infeasible so you can say hello

1079
00:56:13,609 --> 00:56:16,450
from the parent

1080
00:56:17,078 --> 00:56:24,086
it's infeasible though for this this

1081
00:56:20,093 --> 00:56:29,188
child terminated message CT to occur

1082
00:56:24,086 --> 00:56:30,088
before the bye because

1083
00:56:34,016 --> 00:56:40,049
because the the child hasn't yet

1084
00:56:36,026 --> 00:56:42,119
terminated so it these two these two

1085
00:56:40,049 --> 00:56:47,144
messages will never be printed until the

1086
00:56:43,019 --> 00:56:56,117
child is terminated by calling exit so

1087
00:56:48,044 --> 00:57:09,082
is that clear yes so the question is can

1088
00:56:57,017 --> 00:57:15,104
you have an output HP HP HC CT by yes

1089
00:57:09,082 --> 00:57:18,089
yes because the parent ex-prince HP is a

1090
00:57:16,004 --> 00:57:22,022
context which the child prints HC and

1091
00:57:18,089 --> 00:57:24,182
then exits and now the parent will the

1092
00:57:22,022 --> 00:57:36,047
wait will return and then it prints CT

1093
00:57:25,082 --> 00:57:39,131
by okay here's this is a and this is a

1094
00:57:36,047 --> 00:57:42,080
little more go a little more involved

1095
00:57:40,031 --> 00:57:43,130
example so here what we want to do we're

1096
00:57:42,008 --> 00:57:45,086
going to create a bunch of children and

1097
00:57:44,003 --> 00:57:48,080
then we're going to wait for them all to

1098
00:57:46,058 --> 00:57:50,120
terminate and we're going to wait but we

1099
00:57:49,007 --> 00:57:51,080
won't be able to wait in any specific

1100
00:57:51,002 --> 00:57:57,151
order

1101
00:57:51,008 --> 00:58:00,104
we just so here we have a loop 0 through

1102
00:57:57,349 --> 00:58:05,180
n and in each loop body we're going to

1103
00:58:01,076 --> 00:58:06,101
we're going to fork a child and exit

1104
00:58:05,018 --> 00:58:11,114
with a return status that that's going

1105
00:58:07,001 --> 00:58:15,089
to tell us which child it was in the

1106
00:58:12,014 --> 00:58:21,014
parent so we do this we do this a end

1107
00:58:15,089 --> 00:58:24,128
time and then and then afterwards the

1108
00:58:21,014 --> 00:58:28,993
parent inside inside a similar loop 0 to

1109
00:58:25,028 --> 00:58:30,080
add waits for a child to terminate so

1110
00:58:29,119 --> 00:58:38,030
it'll it'll work it will wait for end

1111
00:58:30,008 --> 00:58:41,069
children to terminate wait returns a way

1112
00:58:38,003 --> 00:58:44,098
return to the the process ID and then a

1113
00:58:42,041 --> 00:58:44,098
status

1114
00:58:45,029 --> 00:58:53,033
which is in in this child status

1115
00:58:50,054 --> 00:58:55,109
variable and so we take that variable

1116
00:58:53,033 --> 00:58:57,131
now and we can use this WF exited macro

1117
00:58:56,009 --> 00:59:01,012
to determine if it terminated normally

1118
00:58:58,031 --> 00:59:03,113
with an exit by calling exit and if so

1119
00:59:01,039 --> 00:59:07,124
then we can check its exit status using

1120
00:59:04,013 --> 00:59:12,020
the W exit status macro otherwise if it

1121
00:59:08,024 --> 00:59:14,087
is WF exit it is false then that means

1122
00:59:12,002 --> 00:59:16,037
some something the child terminated for

1123
00:59:14,087 --> 00:59:23,156
some other reason not not because it

1124
00:59:16,055 --> 00:59:27,083
called exits okay there's a we can we

1125
00:59:24,056 --> 00:59:29,072
can actually use wait kid which is

1126
00:59:27,083 --> 00:59:31,169
similar to wait but it allows us to wait

1127
00:59:29,072 --> 00:59:34,160
for a specific process a specific child

1128
00:59:32,069 --> 00:59:37,070
a specific process a specific child with

1129
00:59:35,006 --> 00:59:42,020
a specific process ID to terminate and

1130
00:59:37,007 --> 00:59:45,029
I'll I'll let you you can wait that it's

1131
00:59:42,074 --> 00:59:47,156
really involved and it's described in

1132
00:59:45,092 --> 00:59:49,106
detail in your textbook and so you'll

1133
00:59:48,056 --> 00:59:54,110
need to look you'll need to look there

1134
00:59:50,006 --> 00:59:57,011
for the details on how that works now

1135
00:59:55,001 --> 01:00:02,033
another important so we've learned how

1136
00:59:57,011 --> 01:00:04,049
to create new prophecy the but we

1137
01:00:02,042 --> 01:00:05,138
haven't learned how to when we when we

1138
01:00:04,049 --> 01:00:08,147
call for it we just create an exact copy

1139
01:00:06,038 --> 01:00:11,096
of the the child is just an exact copy

1140
01:00:09,047 --> 01:00:15,092
of the parents running the same code

1141
01:00:11,096 --> 01:00:16,178
same program same variables okay to run

1142
01:00:15,092 --> 01:00:20,173
a different program inside of a process

1143
01:00:17,078 --> 01:00:27,167
we use a function called exec de and

1144
01:00:21,073 --> 01:00:30,140
eggs ik loads and runs within the

1145
01:00:28,067 --> 01:00:33,074
current process it loads and runs the

1146
01:00:31,004 --> 01:00:36,035
executable file name which is its first

1147
01:00:33,074 --> 01:00:40,157
argument and file name can be either a

1148
01:00:36,071 --> 01:00:43,142
binary executable binary okay or it can

1149
01:00:41,057 --> 01:00:48,113
be a script it can be a text file a

1150
01:00:44,042 --> 01:00:52,054
so-called script file that starts whose

1151
01:00:49,013 --> 01:00:52,054
first line starts with a

1152
01:00:52,055 --> 01:00:56,132
pounds bang and then and then there's a

1153
01:00:54,092 --> 01:00:58,097
path of some interpreter so for example

1154
01:00:57,032 --> 01:01:01,831
if you if you want to write a shell

1155
01:00:58,097 --> 01:01:05,144
script you the first line of your shell

1156
01:01:02,119 --> 01:01:09,050
script is is pound bang and then the the

1157
01:01:06,044 --> 01:01:11,090
path name of the bash shell and then

1158
01:01:09,005 --> 01:01:14,093
that will that will execute - and then

1159
01:01:11,009 --> 01:01:17,012
bash will will read in the lines

1160
01:01:14,093 --> 01:01:19,097
following and interpret them just as

1161
01:01:18,002 --> 01:01:23,099
though you type them in it's a at the

1162
01:01:20,033 --> 01:01:25,115
command line so in either case it

1163
01:01:24,017 --> 01:01:29,066
executes either an interpreter or it

1164
01:01:26,015 --> 01:01:33,047
executes the binary with who's argued

1165
01:01:29,066 --> 01:01:37,151
with the argument list are V and a list

1166
01:01:33,047 --> 01:01:40,141
of environment variables in Eng P okay

1167
01:01:38,051 --> 01:01:43,139
now by default argue the first argument

1168
01:01:41,041 --> 01:01:46,124
in our V is the name of the file that

1169
01:01:44,039 --> 01:01:51,047
that's being executed so it's it's this

1170
01:01:47,024 --> 01:01:54,098
file name so what that allows you to do

1171
01:01:52,019 --> 01:01:56,036
is in your code you can check our v-0 if

1172
01:01:54,098 --> 01:01:56,180
you want to print out the name of the

1173
01:01:56,036 --> 01:02:02,044
file the name of the program that's

1174
01:01:57,008 --> 01:02:01,072
executing you just print out our d0

1175
01:02:04,094 --> 01:02:12,101
okay now at exits all of the code and

1176
01:02:09,093 --> 01:02:15,120
the data and the stack it overwrites the

1177
01:02:13,064 --> 01:02:18,773
completely overrides the virtual address

1178
01:02:16,002 --> 01:02:23,351
space so once you call eggs egg within a

1179
01:02:19,349 --> 01:02:26,150
within a process it blows away the

1180
01:02:23,549 --> 01:02:28,595
current program that's it okay

1181
01:02:26,015 --> 01:02:30,066
however it retains that it's still the

1182
01:02:29,009 --> 01:02:35,970
same process it's just running now a

1183
01:02:30,066 --> 01:02:38,094
different program and so it retains the

1184
01:02:35,097 --> 01:02:43,188
process ID and any open files that you

1185
01:02:38,094 --> 01:02:46,423
have so eggs like is really is really

1186
01:02:44,088 --> 01:02:53,088
mind-blowing because it's called once

1187
01:02:47,269 --> 01:02:55,367
but it never returns except if there's

1188
01:02:53,088 --> 01:02:56,987
an error so if this file doesn't exist

1189
01:02:56,249 --> 01:03:00,308
for example then then eggs egg will

1190
01:02:57,779 --> 01:03:06,180
return on -1 but otherwise in normal

1191
01:03:00,839 --> 01:03:06,908
operation it never returns all right so

1192
01:03:06,018 --> 01:03:10,117
let's look at the structure of the stack

1193
01:03:07,529 --> 01:03:13,580
when this new program starts so after

1194
01:03:10,279 --> 01:03:17,430
after after X after the eggs egg ve

1195
01:03:14,039 --> 01:03:22,920
finishes its work it creates a new stack

1196
01:03:17,043 --> 01:03:27,112
is loads in new code and data creates a

1197
01:03:22,092 --> 01:03:30,041
new empty heath ok everything's new and

1198
01:03:27,499 --> 01:03:34,499
the stack that it creates has the

1199
01:03:30,869 --> 01:03:36,180
following form ok at the bottom here's

1200
01:03:34,499 --> 01:03:40,583
the bottom of the stack and our stack is

1201
01:03:36,018 --> 01:03:44,927
growing this way so the first function

1202
01:03:41,339 --> 01:03:47,342
that executes is is a function called

1203
01:03:45,089 --> 01:03:51,184
Lib C underscore start underscore main

1204
01:03:47,369 --> 01:03:51,436
so that has it that has a stack frame

1205
01:03:53,011 --> 01:03:56,110
so let's look this is what I'm showing

1206
01:03:54,085 --> 01:04:00,090
here is the situation right before the

1207
01:03:57,001 --> 01:04:04,048
startup code calls main so there's

1208
01:04:01,035 --> 01:04:06,126
there's the future stack frame for main

1209
01:04:04,057 --> 01:04:10,150
will be here at the top of this

1210
01:04:07,026 --> 01:04:14,092
following the top of the stack there's

1211
01:04:11,005 --> 01:04:19,048
some padding and then the argument list

1212
01:04:14,092 --> 01:04:21,174
in RV is contained on the on the stack

1213
01:04:19,093 --> 01:04:25,093
so that the RV is a list of pointers

1214
01:04:22,074 --> 01:04:27,127
terminated by the null pointer and each

1215
01:04:25,093 --> 01:04:30,096
one of these pointers points up into a

1216
01:04:28,027 --> 01:04:35,080
string that corresponds to an argument

1217
01:04:31,023 --> 01:04:38,067
okay so when you run a program you

1218
01:04:35,008 --> 01:04:37,095
specify the

