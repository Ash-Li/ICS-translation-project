1
00:00:00,000 --> 00:00:07,014
没事，大家下午好 

2
00:00:02,078 --> 00:00:11,094
欢迎好所以今天 我们 看到你 

3
00:00:07,014 --> 00:00:14,633
去看看称作思想 

4
00:00:11,094 --> 00:00:17,683
异常控制流，这是一个非常 

5
00:00:14,759 --> 00:00:20,852
现代制造系统的重要组成部分

6
00:00:18,529 --> 00:00:23,580
它存在于的各级 

7
00:00:21,689 --> 00:00:30,731
从最低级的 硬件 系统 

8
00:00:23,058 --> 00:00:33,144
一路攀升到软件这样的想法 

9
00:00:31,109 --> 00:00:37,500
就是当你把从 计算机上

10
00:00:34,044 --> 00:00:40,050
很从你第一次 

11
00:00:37,005 --> 00:00:42,012
打开它，它只是 一个执行 

12
00:00:40,005 --> 00:00:45,042
接连直到你的指令

13
00:00:42,057 --> 00:00:46,134
关掉它好，如果每个核心，如果你 

14
00:00:45,087 --> 00:00:48,120
具有多个核那么每个那些的

15
00:00:47,034 --> 00:00:50,323
芯被执行指令的一个

16
00:00:49,002 --> 00:00:54,066
后其他

17
00:00:50,629 --> 00:00:58,170
现在的指令序列是 

18
00:00:54,084 --> 00:00:59,393
所谓控制流很好，而且在 该 

19
00:00:58,017 --> 00:01:02,019
指令实际序列 

20
00:01:00,149 --> 00:01:06,232
硬件正在执行被称为 

21
00:01:02,037 --> 00:01:10,826
物理控制流程现在通常 

22
00:01:06,979 --> 00:01:13,650
通常，执行该控制流程 

23
00:01:11,159 --> 00:01:17,220
接连才刚刚一个指令

24
00:01:13,065 --> 00:01:19,068
依次在内存中，我们到目前为止已经 

25
00:01:17,022 --> 00:01:21,108
我们已经看到了二两个机制 

26
00:01:19,095 --> 00:01:23,834
改变控制流，以便它的 

27
00:01:22,008 --> 00:01:27,015
并非如此，我们不是 仅仅 执行 了 

28
00:01:24,689 --> 00:01:31,711
下一条指令，这样的分支机构和 

29
00:01:27,015 --> 00:01:36,054
跳跃和过程调用和返回好吗 

30
00:01:31,909 --> 00:01:38,951
立刻跳转，并调用它的分支跳转

31
00:01:36,054 --> 00:01:41,813
调用和返回那些反应 

32
00:01:39,329 --> 00:01:45,240
改变程序的 状态，所以当你做 

33
00:01:42,299 --> 00:01:48,630
一个分支您检查控制病情 

34
00:01:45,024 --> 00:01:50,025
代码，然后根据一些结果 

35
00:01:48,063 --> 00:01:54,072
在比较时，然后你再 这样做 

36
00:01:50,025 --> 00:01:56,064
分支没关系把它真正的系统需求 

37
00:01:54,072 --> 00:02:00,071
要 能够 适应变化 

38
00:01:56,064 --> 00:02:05,127
系统状态好了， 例如 数据 

39
00:02:00,719 --> 00:02:10,796
从磁盘没错到达或一些上 

40
00:02:06,027 --> 00:02:12,093
网络用户类型对照 C 的行 

41
00:02:11,489 --> 00:02:15,840
程序执行S-- 非法 

42
00:02:12,093 --> 00:02:17,166
指令还行所有 这些代表 

43
00:02:15,084 --> 00:02:21,233
一些改变某种变化的 

44
00:02:18,066 --> 00:02:26,142
在系统的状态，我们需要一些方法 

45
00:02:21,989 --> 00:02:29,400
反应到所以这使我们需要的 

46
00:02:27,042 --> 00:02:31,050
被我们称这种特殊的 控制流 

47
00:02:29,004 --> 00:02:32,100
因为它是某种外部的 

48
00:02:31,005 --> 00:02:34,774
我们看到我们在正常的控制流

49
00:02:33,036 --> 00:02:38,075
我们的节目

50
00:02:35,269 --> 00:02:42,750
现在异常控制流或ECF 

51
00:02:38,075 --> 00:02:43,094
存在于从系统 中 的 所有级别 

52
00:02:42,075 --> 00:02:48,174
最底层 

53
00:02:43,094 --> 00:02:51,156
硬件在非常低 的水平，我们 

54
00:02:49,074 --> 00:02:53,148
有我们所谓的例外 ，这些 

55
00:02:52,056 --> 00:02:57,131
是在控制流量的变化 

56
00:02:54,048 --> 00:03:02,106
针对一些低级别的系统事件 

57
00:02:58,031 --> 00:03:05,118
所以这是一个还是和 双向情况下，我们指的是 

58
00:03:03,006 --> 00:03:07,098
在现在的状态改变的例外是 

59
00:03:06,018 --> 00:03:10,029
使用的组合来实现

60
00:03:07,098 --> 00:03:12,117
硬件和OS 软件，我们会看到 

61
00:03:10,029 --> 00:03:15,060
它在一分钟内，但这些这些 

62
00:03:13,017 --> 00:03:20,064
异常控制在较高的流动这

63
00:03:15,006 --> 00:03:21,078
各级 所以在进程上下文 

64
00:03:20,064 --> 00:03:24,138
开关 是一个异常的例子 

65
00:03:22,032 --> 00:03:27,087
也它实现的控制流

66
00:03:25,038 --> 00:03:31,044
通过硬件和操作系统

67
00:03:27,087 --> 00:03:31,173
核心。它因此 ，如果进程 上下文 

68
00:03:31,044 --> 00:03:36,048
开关以后我们会看到 

69
00:03:32,073 --> 00:03:38,160
今天晚些时候你执行你的 

70
00:03:36,084 --> 00:03:42,233
执行 在当前代码 

71
00:03:39,006 --> 00:03:46,035
您当前的进程，然后所有的 

72
00:03:42,989 --> 00:03:49,110
突然系统从执行代码 

73
00:03:46,089 --> 00:03:52,098
另一个进程权利，使您的过程 

74
00:03:49,011 --> 00:03:55,029
得到像暂停，所以有这样 

75
00:03:53,079 --> 00:03:58,115
这是特殊的控制的一种形式

76
00:03:55,029 --> 00:04:01,065
流在那里你执行语句 

77
00:03:59,015 --> 00:04:03,062
一个一个进程内的指令和 

78
00:04:01,065 --> 00:04:05,088
然后 突然 你执行 

79
00:04:03,062 --> 00:04:09,521
在另一个报表说明 

80
00:04:05,088 --> 00:04:12,197
过程庵在较高的水平 完全在 

81
00:04:10,079 --> 00:04:15,810
软件，我们有 一个信号的 想法 

82
00:04:12,989 --> 00:04:17,130
这是 由操作系统 执行 

83
00:04:15,081 --> 00:04:20,100
系统软件，我们将了解 

84
00:04:17,013 --> 00:04:23,046
信号下节课再连 

85
00:04:21,000 --> 00:04:26,001
你 有一个更高的水平更高

86
00:04:23,046 --> 00:04:28,080
用C非本地跳转这只是 

87
00:04:26,001 --> 00:04:31,005
C运行时库中实现这样 

88
00:04:28,008 --> 00:04:31,104
这可以让你的非本地跳转允许

89
00:04:31,005 --> 00:04:35,058
你打破了正常的调用和返回 

90
00:04:32,076 --> 00:04:37,077
图案，从而从一个从内 

91
00:04:35,058 --> 00:04:40,127
功能通常你只能回 

92
00:04:37,077 --> 00:04:43,286
调用该 叫 你的函数

93
00:04:41,027 --> 00:04:46,032
非本地的跳跃让你内 

94
00:04:43,979 --> 00:04:49,320
功能打破，并返回到一些 

95
00:04:46,077 --> 00:04:50,175
其他的一些其他功能或其他一些 

96
00:04:49,032 --> 00:04:53,118
代码的一部分，所以 我们来看看 

97
00:04:51,075 --> 00:04:55,131
信号和非本地跳转下一讲 

98
00:04:54,018 --> 00:04:56,111
今天我们来看看例外 

99
00:04:56,031 --> 00:05:02,950
和

100
00:04:57,011 --> 00:05:07,027
疾病所以例外是的转印

101
00:05:03,229 --> 00:05:09,322
控制到操作系统 内核 

102
00:05:07,027 --> 00:05:13,028
其中内核 是常驻内存 

103
00:05:10,159 --> 00:05:14,930
你知道这样的操作系统的一部分

104
00:05:13,037 --> 00:05:19,426
操作系统提供 各种 

105
00:05:14,093 --> 00:05:22,094
节目喜欢列出文件改变 

106
00:05:19,759 --> 00:05:26,150
目录列出当前 

107
00:05:23,003 --> 00:05:27,077
流程，使所有 的东西 

108
00:05:26,015 --> 00:05:29,314
构成操作系统的 

109
00:05:27,077 --> 00:05:33,103
内核是操作系统的一部分 

110
00:05:29,449 --> 00:05:37,930
系统总是驻留在内存中 

111
00:05:34,003 --> 00:05:40,192
所以一个例外，这真的是低级别 

112
00:05:37,093 --> 00:05:41,099
控制转移 到操作 

113
00:05:40,219 --> 00:05:44,295
系统，因为事情发生在 

114
00:05:41,099 --> 00:05:48,148
系统所以你执行你的代码 

115
00:05:44,979 --> 00:05:51,022
用户代码，然后有事 

116
00:05:49,039 --> 00:05:54,460
一些事件，因此通过事件，我们 需要有 

117
00:05:51,409 --> 00:05:57,860
在系统状态的某些变化

118
00:05:54,046 --> 00:06:00,068
针对存在的异常 

119
00:05:57,086 --> 00:06:04,088
转让从用户控制

120
00:06:00,068 --> 00:06:06,146
代码在其内核代码

121
00:06:05,006 --> 00:06:10,015
所谓异常处理程序，然后 

122
00:06:07,046 --> 00:06:13,315
内核回应了一些变化

123
00:06:10,069 --> 00:06:17,330
方式这 就是所谓的例外 

124
00:06:13,729 --> 00:06:18,800
处理，然后有三个

125
00:06:17,033 --> 00:06:21,077
有三件事情 可能 发生 

126
00:06:18,008 --> 00:06:24,011
后内核 处理该异常 

127
00:06:21,077 --> 00:06:27,140
它可以返回并重新执行该 

128
00:06:24,083 --> 00:06:29,662
当前指令没关系，我们会看到 

129
00:06:28,004 --> 00:06:32,383
这是，这是非常有用的东西 像 

130
00:06:30,409 --> 00:06:36,740
页面错误使 我们能够实现 

131
00:06:32,779 --> 00:06:40,815
虚拟内存它可以返回 

132
00:06:36,074 --> 00:06:44,074
接下来的指令，我在 这里显示 

133
00:06:41,139 --> 00:06:44,740
或者它可能中止

134
00:06:45,085 --> 00:06:50,142
现在异常由实施 

135
00:06:48,037 --> 00:06:54,130
硬件和软件，以便实际

136
00:06:51,042 --> 00:06:58,093
控制转移，你知道的变化 

137
00:06:55,003 --> 00:07:01,069
在程序计数器或IP是是是 

138
00:06:58,093 --> 00:07:05,155
由硬件，但代码做到这一点 

139
00:07:01,096 --> 00:07:07,129
执行为例外的结果 

140
00:07:06,055 --> 00:07:11,134
设置，并通过所确定的 

141
00:07:08,029 --> 00:07:14,080
操作系统 内核所以每家每户 

142
00:07:12,034 --> 00:07:17,038
事件的类型都有一个唯一的例外 

143
00:07:14,008 --> 00:07:18,099
其用作索引的数

144
00:07:17,038 --> 00:07:24,039
跳转表称为异常表 

145
00:07:19,071 --> 00:07:27,169
好了，所以当事件发生ķ时 

146
00:07:24,048 --> 00:07:30,139
那么硬件看起来使用K作为 一个 

147
00:07:28,069 --> 00:07:32,161
索引此表，并获取 

148
00:07:31,039 --> 00:07:37,050
对于异常处理程序的地址 

149
00:07:33,061 --> 00:07:40,108
这对于 该异常等 

150
00:07:37,005 --> 00:07:45,060
每次事件发生ķ 当时 

151
00:07:41,008 --> 00:07:48,097
处理程序处理的情况下，现在被调用 

152
00:07:46,005 --> 00:07:50,104
有一个不同类型的异常 

153
00:07:48,097 --> 00:07:53,103
我们区分它们为 

154
00:07:51,004 --> 00:07:57,085
异步或同步异步

155
00:07:54,003 --> 00:08:00,099
例外情况发生，因为变化的结果 

156
00:07:57,085 --> 00:08:04,141
在状态发生了外面的那 

157
00:08:00,099 --> 00:08:07,099
所述处理器的外部，以便这些 

158
00:08:05,041 --> 00:08:11,125
所谓的中断和这些变化 

159
00:08:07,099 --> 00:08:13,174
状态，所述处理器被通知

160
00:08:12,025 --> 00:08:16,108
关于通过设置状态的那些变化 

161
00:08:14,074 --> 00:08:20,131
上所述处理器上的销

162
00:08:17,008 --> 00:08:24,016
外部引脚称为中断引脚使

163
00:08:21,031 --> 00:08:27,046
这是那种说的磁盘时的 

164
00:08:24,016 --> 00:08:30,040
控制器完成这样做的直接 

165
00:08:27,046 --> 00:08:32,505
从存储器存取和复制数据 

166
00:08:30,004 --> 00:08:35,095
磁盘到内存的通知 

167
00:08:32,919 --> 00:08:41,370
， 它的完成该副本处理器

168
00:08:36,031 --> 00:08:46,053
在喜设置中断好吗 

169
00:08:41,037 --> 00:08:47,115
因此中断发生后， 

170
00:08:46,053 --> 00:08:51,102
处理程序返回到下一条指令 

171
00:08:48,015 --> 00:08:53,064
因此中断通常 这是因为虽然 

172
00:08:52,002 --> 00:08:54,009
你运行你的程序你 

173
00:08:53,064 --> 00:08:57,066
运行该程序 ，然后有 

174
00:08:54,072 --> 00:08:58,149
像这样的小 有这样的 

175
00:08:57,066 --> 00:09:00,066
稍微停顿而中断处理程序 

176
00:08:59,049 --> 00:09:02,088
运行，然后将你的 程序公正 

177
00:09:00,066 --> 00:09:04,122
继续 好 运行 ，因此这是它的 

178
00:09:02,088 --> 00:09:08,177
通常 在幕后 排序完成 

179
00:09:05,022 --> 00:09:12,066
并且不不 影响你 

180
00:09:09,077 --> 00:09:16,173
你的程序的执行现在最 

181
00:09:12,066 --> 00:09:20,070
一个 中断 的 共同的 一个常见的例子 

182
00:09:17,073 --> 00:09:22,170
是定时器中断 使你的所有 

183
00:09:20,007 --> 00:09:26,013
系统有一个内置的计时器，去 

184
00:09:23,007 --> 00:09:27,096
关闭每隔几毫秒 ，当它 

185
00:09:26,076 --> 00:09:30,117
当计时器熄灭它集 

186
00:09:28,059 --> 00:09:32,145
中断高 ，有一个特殊的 

187
00:09:31,017 --> 00:09:36,066
除了排名第四的定时器

188
00:09:33,045 --> 00:09:38,127
中断，这是我们需要在这 

189
00:09:36,066 --> 00:09:41,154
为了使这使得我们需要这个 

190
00:09:39,027 --> 00:09:44,031
允许内核得到控制

191
00:09:42,054 --> 00:09:46,059
系统再次否则用户 

192
00:09:44,031 --> 00:09:49,053
节目可能只是在运行下去

193
00:09:46,059 --> 00:09:51,093
无限循环，没有人就没有办法 

194
00:09:49,053 --> 00:09:53,115
操作系统 去 获得 

195
00:09:51,093 --> 00:09:57,099
控制，每隔几毫秒这 

196
00:09:54,015 --> 00:10:00,036
计时器熄灭， 导致短暂 

197
00:09:57,099 --> 00:10:03,102
异常进入到内核中， 

198
00:10:00,036 --> 00:10:04,122
那么内核可以为我们所看到的内核 

199
00:10:04,002 --> 00:10:07,071
可以决定做什么 

200
00:10:05,022 --> 00:10:13,029
也许可能安排一个新的流程或 

201
00:10:07,071 --> 00:10:14,082
让正确的进程中运行 ，然后和 

202
00:10:13,029 --> 00:10:16,104
然后这一个I / O从结束了 

203
00:10:14,082 --> 00:10:18,168
外部设备也是一种常见的 

204
00:10:17,004 --> 00:10:21,096
比如现在在等经典例外 

205
00:10:19,068 --> 00:10:26,076
是同步异常和有 

206
00:10:21,096 --> 00:10:29,147
三个班的一个是 一个 

207
00:10:26,076 --> 00:10:32,103
类被称为阱的阱是 

208
00:10:30,047 --> 00:10:34,086
故意例外，所以这是一个

209
00:10:33,003 --> 00:10:37,074
多数民众赞成故意所致异常

210
00:10:34,086 --> 00:10:40,095
该方案和最最常见 

211
00:10:37,074 --> 00:10:42,138
陷阱的形式是一个系统调用，所以你 

212
00:10:41,076 --> 00:10:45,078
知道操作系统内核 

213
00:10:43,038 --> 00:10:47,073
提供各种服务，以向 

214
00:10:45,096 --> 00:10:49,179
程序，但你的程序没有 

215
00:10:47,073 --> 00:10:51,150
直接访问你的程序无法调用 

216
00:10:50,079 --> 00:10:53,167
它不能访问内核函数

217
00:10:52,005 --> 00:10:55,092
数据直接在内核

218
00:10:54,067 --> 00:10:59,110
因为内存保护， 

219
00:10:56,037 --> 00:11:02,121
不可用的用户程序有啥 

220
00:11:00,001 --> 00:11:06,007
内核并为它提供了一个 

221
00:11:03,021 --> 00:11:09,025
接口，它允许程序 来 

222
00:11:06,016 --> 00:11:11,020
也 求 有效的 调用 

223
00:11:09,025 --> 00:11:13,054
在内核中，并使功能

224
00:11:11,002 --> 00:11:16,014
各种 服务，这要求

225
00:11:13,054 --> 00:11:18,106
这个接口被称为系统调用 

226
00:11:16,032 --> 00:11:24,076
好了，所以程序 进行系统调用 

227
00:11:19,006 --> 00:11:26,011
并和并要求各种功能 

228
00:11:24,076 --> 00:11:29,140
从内核内核提供 

229
00:11:26,056 --> 00:11:31,095
这些种类发生反应的这一请求，并 

230
00:11:30,004 --> 00:11:34,090
然后返回 控制回 

231
00:11:31,095 --> 00:11:36,181
函数 有调用 程序，以便 

232
00:11:35,026 --> 00:11:41,029
你可以 为一种 认为 系统 调用 

233
00:11:37,081 --> 00:11:42,112
它是一个它看起来像 一个 函数调用 

234
00:11:41,056 --> 00:11:47,119
但它的真正控制权转

235
00:11:43,012 --> 00:11:51,024
进入内核 好吧，那么有一些 

236
00:11:48,019 --> 00:11:53,086
所以陷阱是有意的故障有 

237
00:11:51,024 --> 00:12:00,060
无意但却可能是可恢复的 

238
00:11:53,086 --> 00:12:02,149
好吧所以像页面错误 ，其 

239
00:12:00,006 --> 00:12:04,102
当我们将 更多地 了解这些的时候 

240
00:12:03,049 --> 00:12:07,111
我们研究了虚拟内存，但事

241
00:12:05,056 --> 00:12:09,079
如页面错误 ，它实际上 

242
00:12:08,011 --> 00:12:13,012
可恢复它只是在内核 

243
00:12:09,079 --> 00:12:13,171
污垢就意味着数据部分 

244
00:12:13,012 --> 00:12:17,101
地址空间的，你的程序 

245
00:12:14,071 --> 00:12:19,150
引用的其实不是在内存中

246
00:12:18,001 --> 00:12:22,072
需要从 磁盘复制它的 

247
00:12:20,005 --> 00:12:24,058
存储到存储器中，然后 该 

248
00:12:22,072 --> 00:12:26,125
指令造成的故障 

249
00:12:25,003 --> 00:12:30,010
需要刚刚重启， 然后 它的工作原理 

250
00:12:27,025 --> 00:12:34,033
该内存是存在的，那么 

251
00:12:30,073 --> 00:12:36,151
指令工作正常 ，但 其他 

252
00:12:34,033 --> 00:12:39,034
故障是不可恢复的非故意

253
00:12:37,051 --> 00:12:42,073
像保护故障，所以如果你尝试 

254
00:12:39,034 --> 00:12:46,045
访问的存储器的一部分就是这样的 

255
00:12:42,073 --> 00:12:48,109
未分配或浮点

256
00:12:46,045 --> 00:12:53,119
例外很多时候那些那些能 

257
00:12:49,009 --> 00:12:56,011
可恢复所以在这两种情况下吃 

258
00:12:54,019 --> 00:12:57,028
当有故障，要么做出反应

259
00:12:56,029 --> 00:13:01,075
Acutes当前指令或 

260
00:12:58,009 --> 00:13:03,018
船或或板，然后有 

261
00:13:01,075 --> 00:13:05,122
非故意和不可恢复

262
00:13:03,099 --> 00:13:07,135
例外，被称为 板的 

263
00:13:06,022 --> 00:13:10,054
而那些总是那些董事会的 

264
00:13:08,035 --> 00:13:12,061
因此，如果你执行一个非法指令 

265
00:13:10,054 --> 00:13:15,061
如果有你的 内存 有问题 

266
00:13:12,061 --> 00:13:18,067
内存，它的损坏， 或者，如果有 

267
00:13:16,024 --> 00:13:22,093
一些问题与 那些 机器 

268
00:13:18,067 --> 00:13:24,148
创意疣是始终 是 

269
00:13:22,093 --> 00:13:28,144
不可恢复的，从来没有回返回 

270
00:13:25,048 --> 00:13:32,131
在该程序现在的系统调用 

271
00:13:29,044 --> 00:13:34,060
有许多 不同 种类 的 系统 

272
00:13:33,031 --> 00:13:39,037
电话，他们都有自己独特的 

273
00:13:34,006 --> 00:13:44,017
其是通过Linux的分配数，以便 

274
00:13:39,091 --> 00:13:45,157
在例如读取文件有 

275
00:13:44,071 --> 00:13:49,162
叫读系统调用是

276
00:13:46,057 --> 00:13:59,083
打开文件数0 只是 一个电话 

277
00:13:50,062 --> 00:14:03,075
2号等，并有一个有 

278
00:13:59,083 --> 00:14:06,118
称为思科的指令，其 

279
00:14:03,075 --> 00:14:08,152
实际现在执行系统调用

280
00:14:07,018 --> 00:14:10,096
你平时不 使用的系统调用 

281
00:14:09,052 --> 00:14:13,117
并开始 断念调用指令 

282
00:14:10,096 --> 00:14:15,151
直接在您的节目 D的Linux包 

283
00:14:14,017 --> 00:14:20,044
在那些系统级功能，其 

284
00:14:16,051 --> 00:14:21,112
实际上你调用，但它的 

285
00:14:20,044 --> 00:14:24,133
有趣的，看看它是如何工作 

286
00:14:22,012 --> 00:14:26,020
那么究竟要打开一个文件，你 

287
00:14:25,033 --> 00:14:29,119
调用称为系统级功能 

288
00:14:26,092 --> 00:14:35,176
与文件名 和一些 选项 打开 

289
00:14:30,019 --> 00:14:40,027
只能说只读，所以写在 

290
00:14:36,076 --> 00:14:43,168
思科指令将第一辅助 

291
00:14:40,099 --> 00:14:47,191
电话号码是我们的斧头，然后等 

292
00:14:44,068 --> 00:14:51,100
其他参数都在我们的目录SI RDX

293
00:14:48,091 --> 00:14:53,146
我们的10个R8和R9所以你可以，如果 我们 看到 

294
00:14:52,000 --> 00:14:55,081
看在 open函数调用 

295
00:14:54,046 --> 00:14:58,054
下划线强调开放功能

296
00:14:55,081 --> 00:14:59,170
这实际上调用 系统调用 ，所以如果 

297
00:14:59,026 --> 00:15:02,119
你看那个代码，你看它的动作 

298
00:15:00,007 --> 00:15:06,022
二是SIS的电话号码 

299
00:15:03,019 --> 00:15:11,056
读入到 一把斧头，然后 它做 

300
00:15:06,085 --> 00:15:15,178
SIS呼叫 ，然后将SIS的通话 

301
00:15:11,056 --> 00:15:17,128
返回我们的斧子的地位，如果它是一个 

302
00:15:16,078 --> 00:15:19,095
负数则该装置 

303
00:15:18,028 --> 00:15:23,207
事情发生了一些错误

304
00:15:19,095 --> 00:15:24,484
如果它是一个正数，则 该 

305
00:15:23,459 --> 00:15:27,521
意味着什么没有发生错误 

306
00:15:25,339 --> 00:15:29,432
所以在这种情况下，我在 开 

307
00:15:28,079 --> 00:15:31,740
它返回一个文件描述符 

308
00:15:30,269 --> 00:15:34,490
小整数称为文件描述符 

309
00:15:31,074 --> 00:15:37,223
然后你就可以在以后使用

310
00:15:34,049 --> 00:15:38,768
调用读取和写入，然后你可以 

311
00:15:37,889 --> 00:15:41,790
看到代码检查此 

312
00:15:39,209 --> 00:15:50,430
负的返回值太大，有一个 

313
00:15:41,079 --> 00:15:52,748
整个系列的这些比较让我们 

314
00:15:50,043 --> 00:15:55,202
看一个错误的例子

315
00:15:53,459 --> 00:15:59,516
所以在这里我们 假设我们有这样的计划 

316
00:15:55,589 --> 00:16:02,190
我们正在编写成一个有效的区域 

317
00:16:00,029 --> 00:16:04,103
内存，但它不是实际存储 

318
00:16:02,019 --> 00:16:07,032
它实际上不是在存储它 

319
00:16:04,769 --> 00:16:11,600
需要从 磁盘装入到 

320
00:16:07,032 --> 00:16:14,087
内存所以这 是一个所谓的缺页 

321
00:16:11,006 --> 00:16:17,022
所以这本指令这一举动大号 

322
00:16:14,087 --> 00:16:21,176
因为这一点，因为 在这个 内存 

323
00:16:17,076 --> 00:16:25,149
地址是不是不可触发 

324
00:16:21,959 --> 00:16:28,560
缺页，使得创建

325
00:16:26,049 --> 00:16:30,081
异常控制转移到 

326
00:16:28,056 --> 00:16:33,063
在内核页面错误处理程序

327
00:16:30,081 --> 00:16:37,125
该副本从磁盘页面

328
00:16:33,063 --> 00:16:39,111
内存中，然后返回，当它 

329
00:16:38,025 --> 00:16:42,104
返回它重新执行移动大号 

330
00:16:40,011 --> 00:16:45,980
指令所以这样的冷却，从而 

331
00:16:42,329 --> 00:16:48,720
现在内存可用 ，现在 

332
00:16:46,079 --> 00:16:52,880
此举L此举动 提单资料时 

333
00:16:48,072 --> 00:16:55,137
它是 急性 发生反应 “添加和完成 

334
00:16:52,088 --> 00:16:58,092
然后我们继续现在其它类型 的 

335
00:16:56,037 --> 00:17:00,129
故障是无效的内存引用，以便 

336
00:16:58,092 --> 00:17:03,174
在这里，我们有我们的访问 

337
00:17:01,029 --> 00:17:06,072
的元件，其不存在 ，并且 

338
00:17:04,074 --> 00:17:10,273
这是一个非法它是一个无效的 

339
00:17:06,072 --> 00:17:13,137
参考所以在这种情况下，移动大号 

340
00:17:10,939 --> 00:17:17,880
指令它看起来像它看起来 

341
00:17:14,037 --> 00:17:19,256
如页面错误，但是内核检测 

342
00:17:17,088 --> 00:17:20,136
这是一个无效的地址，有 

343
00:17:19,589 --> 00:17:24,150
没有什么可以 从 被加载 

344
00:17:21,036 --> 00:17:28,050
磁盘这是 的 无效 区域 

345
00:17:24,015 --> 00:17:32,088
虚拟地址空间，以便 它发送一个 

346
00:17:28,005 --> 00:17:33,030
信号给到处理 ，然后 

347
00:17:32,088 --> 00:17:36,162
永远永远

348
00:17:33,075 --> 00:17:39,174
打开它使信号 的上升是 

349
00:17:37,062 --> 00:17:44,139
臭名昭著分割信号 

350
00:17:40,074 --> 00:17:47,160
使臭名昭著分段错误 

351
00:17:45,039 --> 00:17:50,040
信息打印出来，我们会看到未来 

352
00:17:48,006 --> 00:17:56,007
演讲中，我们会看到，我们将看到如何将这些 

353
00:17:50,049 --> 00:17:58,140
实际上信号实际上好工作，所以我 

354
00:17:56,061 --> 00:17:59,117
说，我们已经 看到 了 异常或非常 

355
00:17:59,004 --> 00:18:02,049
低级别 

356
00:18:00,017 --> 00:18:04,038
控制的那些传输 

357
00:18:02,085 --> 00:18:07,089
通过硬件 和实施

358
00:18:04,038 --> 00:18:11,046
操作系统软件 在 葛藤 

359
00:18:08,025 --> 00:18:14,049
较高的水平是另一种形式的 

360
00:18:11,046 --> 00:18:16,085
异常控制流打来电话，我们 

361
00:18:14,049 --> 00:18:21,066
看到它在在的情况下

362
00:18:16,085 --> 00:18:24,164
进程上下文切换，从而让我们来看看 

363
00:18:21,066 --> 00:18:27,138
让我们看一个过程是什么什么 

364
00:18:25,064 --> 00:18:29,115
这样一个过程一个过程的想法 

365
00:18:28,038 --> 00:18:32,099
最 根本的一个和 

366
00:18:30,015 --> 00:18:36,036
在计算机科学的重要思想和 

367
00:18:32,099 --> 00:18:37,164
这一 经典 定义是， 

368
00:18:36,036 --> 00:18:42,054
过程是一个正在运行的实例 

369
00:18:38,064 --> 00:18:45,090
计划好了这是从不同的 

370
00:18:42,054 --> 00:18:47,055
节目的节目中存在可在存在 

371
00:18:45,009 --> 00:18:50,025
许多不同的地方权的方案 

372
00:18:47,055 --> 00:18:54,152
在yourseif存在在一个C文件中的文本

373
00:18:51,006 --> 00:19:00,045
它可以作为存在的点文字部分 

374
00:18:55,052 --> 00:19:02,115
它可以作为具有字节存在的二进制

375
00:19:00,045 --> 00:19:04,110
被加载到存储器 的过程中的一个 

376
00:19:03,015 --> 00:19:12,092
程序的实例就是这样的

377
00:19:05,001 --> 00:19:16,079
运行在执行和 

378
00:19:12,092 --> 00:19:19,179
流程提供了两个关键的抽象

379
00:19:16,088 --> 00:19:22,164
还好它的第一层抽象是 

380
00:19:20,079 --> 00:19:27,108
它给它 给你的错觉， 

381
00:19:23,064 --> 00:19:30,090
你必须在CPU独占访问 

382
00:19:28,008 --> 00:19:32,013
在 和寄存器好了，所以当 

383
00:19:30,009 --> 00:19:34,044
你当你运行你的运行

384
00:19:32,058 --> 00:19:37,059
程序，你永远不会有一个过程 

385
00:19:35,025 --> 00:19:40,038
担心任何其他任何其他程序 

386
00:19:37,059 --> 00:19:42,147
修改你的寄存器和你

387
00:19:40,038 --> 00:19:45,096
甚至不能告诉大家，甚至还有其他 

388
00:19:43,047 --> 00:19:46,070
在系统正确的IT运行的进程

389
00:19:45,096 --> 00:19:48,098
容貌

390
00:19:46,007 --> 00:19:50,018
除了像偶尔延迟

391
00:19:48,098 --> 00:19:53,147
指令 只需要一点点 

392
00:19:50,081 --> 00:19:56,099
更长的时间，除了它看起来运行 

393
00:19:54,047 --> 00:19:59,126
就像你有独一无二的专属独家 

394
00:19:56,099 --> 00:20:02,153
使用的处理器， 并将 它在 

395
00:20:00,026 --> 00:20:04,034
其寄存器的另一抽象 

396
00:20:03,053 --> 00:20:08,090
它提供的是幻想 

397
00:20:05,006 --> 00:20:11,060
你有自己的地址空间， 所以没关系 

398
00:20:08,009 --> 00:20:14,020
你这 是 由 提供 

399
00:20:11,006 --> 00:20:17,015
机制称为虚拟 存储器，从而每个 

400
00:20:15,001 --> 00:20:22,049
每个 正在运行 的 程序有它自己的代码 

401
00:20:18,005 --> 00:20:25,043
数据堆栈和你永远不会看到 

402
00:20:22,049 --> 00:20:27,055
代码，你永远看不到内存 

403
00:20:25,088 --> 00:20:30,122
多数民众赞成被其他进程 

404
00:20:27,055 --> 00:20:32,147
好了，所以它看起来 对所有意图和 

405
00:20:31,022 --> 00:20:35,090
目的过程为您提供了这种错觉 

406
00:20:33,047 --> 00:20:38,102
你有机会获得独家 

407
00:20:35,009 --> 00:20:43,043
访问所有的内存和 和 

408
00:20:39,002 --> 00:20:48,016
处理器现在系统运行 

409
00:20:44,024 --> 00:20:52,040
许多这些方法的同时 

410
00:20:48,016 --> 00:20:55,028
甚至连与 单 核 的系统 

411
00:20:52,004 --> 00:20:57,016
许多这些多个进程是 

412
00:20:55,028 --> 00:20:59,099
同时实际运行 

413
00:20:57,052 --> 00:21:03,068
同时，你可以看到，如果这个你 

414
00:20:59,099 --> 00:21:07,175
看看这个在这里我跑顶部在我的Mac上 

415
00:21:03,068 --> 00:21:10,082
你可以看到它的运行123 123 

416
00:21:08,075 --> 00:21:14,093
总流程5可放置 

417
00:21:10,082 --> 00:21:17,120
实际运行和这些每一个

418
00:21:14,093 --> 00:21:20,116
流程都有其独特的进程ID

419
00:21:18,002 --> 00:21:20,098
这是一个整数 

420
00:21:23,013 --> 00:21:27,082
现在的方式，所以它看起来它 看起来像 

421
00:21:25,929 --> 00:21:32,140
你有独特的访问或独占 

422
00:21:27,082 --> 00:21:34,135
进入到系统中 ，但 

423
00:21:32,014 --> 00:21:38,403
现实上假设我们有一个单一的

424
00:21:35,035 --> 00:21:40,069
在你的核心实际上是共享 

425
00:21:38,529 --> 00:21:42,700
系统和操作操作 

426
00:21:40,069 --> 00:21:48,918
系统有几分是管理

427
00:21:42,007 --> 00:21:52,596
共享，以便他们做的是我们有

428
00:21:49,539 --> 00:21:58,960
这个过程的运行，它有它的 

429
00:21:53,289 --> 00:22:01,377
拥有它有它自己的地址 空间 ，并 

430
00:21:58,096 --> 00:22:05,158
它有它的，它有自己的寄存器

431
00:22:02,169 --> 00:22:08,241
现在在某些时候可能是因为它 

432
00:22:06,058 --> 00:22:11,074
削减在某一时刻发生异常

433
00:22:08,889 --> 00:22:14,931
要么是因为 定时器 中断 或 

434
00:22:11,074 --> 00:22:16,263
某种故障或 一些陷阱 

435
00:22:15,309 --> 00:22:20,355
点操作系统得到 

436
00:22:16,929 --> 00:22:21,966
该系统和并在此的控制

437
00:22:20,769 --> 00:22:27,000
案例让我们说这决定了它要 

438
00:22:22,299 --> 00:22:28,386
运行另一个进程，以便它复制 

439
00:22:27,000 --> 00:22:31,051
注册该电流的电流 

440
00:22:29,169 --> 00:22:35,500
寄存器值到存储器中，并保存

441
00:22:31,051 --> 00:22:39,560
他们然后调度下一

442
00:22:35,005 --> 00:22:43,042
处理来执行，它加载 

443
00:22:40,019 --> 00:22:45,108
这 是从保存 的寄存器 

444
00:22:43,087 --> 00:22:47,106
上次那个进程正在运行 

445
00:22:45,909 --> 00:22:50,110
它加载到这些CPU寄存器 

446
00:22:47,889 --> 00:22:53,830
然后将其切换地址空间 

447
00:22:50,011 --> 00:22:58,012
地址空间 为这个 

448
00:22:53,083 --> 00:23:00,032
工艺使该地址空间 和 

449
00:22:58,012 --> 00:23:05,017
寄存器值是上下文和 

450
00:23:00,779 --> 00:23:08,320
因此，上下文切换是什么 

451
00:23:05,062 --> 00:23:11,134
在更改地址空间 和 

452
00:23:08,032 --> 00:23:16,063
寄存器确定，所以然后作为一个点的 

453
00:23:12,034 --> 00:23:19,973
这个过程在现实中现在正在运行

454
00:23:16,063 --> 00:23:22,232
在多核现代系统

455
00:23:20,279 --> 00:23:25,332
操作系统将安排 

456
00:23:22,799 --> 00:23:27,822
关于这些多个内核 进程 和 

457
00:23:25,809 --> 00:23:29,980
那么，如果没有，如果没有足够的

458
00:23:28,029 --> 00:23:32,082
当然，处理过程则 

459
00:23:29,098 --> 00:23:34,161
将执行上下文切换，就像

460
00:23:32,559 --> 00:23:35,610
我们之前向

461
00:23:36,079 --> 00:23:42,116
现在每一个过程代表了我们 

462
00:23:40,034 --> 00:23:44,069
调用逻辑控制流，所以如果你是 

463
00:23:43,016 --> 00:23:46,091
你知道有一个物理控制 

464
00:23:44,069 --> 00:23:51,077
如果我们只是看了所有的流动，这

465
00:23:46,091 --> 00:23:53,093
我们会被执行指令 TC值

466
00:23:52,049 --> 00:23:55,100
从一个进程， 然后将所有的 

467
00:23:54,011 --> 00:23:58,070
突然之间，我们会从另一个执行

468
00:23:56,000 --> 00:24:00,047
的过程，但一个进程中 

469
00:23:58,007 --> 00:24:01,093
有其是一个逻辑控制流 

470
00:24:00,047 --> 00:24:05,126
所有该进程的 说明 

471
00:24:02,056 --> 00:24:08,093
现在我们说的是两个进程运行 

472
00:24:06,026 --> 00:24:11,048
同时，如果 它们的流重叠在 

473
00:24:08,093 --> 00:24:13,130
时间，否则他们是这样的顺序 

474
00:24:11,048 --> 00:24:16,082
让我们来看看让我们看 一个 例子，我们 

475
00:24:14,003 --> 00:24:20,012
有三种工艺处理的运行 

476
00:24:16,082 --> 00:24:22,097
一段时间，然后是它的中断 

477
00:24:20,039 --> 00:24:24,131
通过处理B和处理C，然后

478
00:24:22,097 --> 00:24:28,142
最终它继续运行，然后 

479
00:24:25,031 --> 00:24:31,034
它终止处理B中断

480
00:24:29,042 --> 00:24:35,048
过程中，然后运行 了一段时间 

481
00:24:31,034 --> 00:24:37,133
然后它终止处理C一旦 

482
00:24:36,002 --> 00:24:41,060
当处理B然后结束处理C

483
00:24:38,033 --> 00:24:43,058
得到跑了一会儿， 然后处理 

484
00:24:41,006 --> 00:24:45,068
运行一段时间， 然后处理C 

485
00:24:43,058 --> 00:24:52,079
终止好吗因此，考虑给予这 

486
00:24:46,022 --> 00:24:55,120
并发 的定义 ，其中的 

487
00:24:52,079 --> 00:24:55,120
这些进程同时运行 

488
00:24:57,063 --> 00:25:10,122
怎么样一个 一个 和B是那么那么一和 

489
00:25:07,098 --> 00:25:22,116
这些流动乙这些流动与重叠 

490
00:25:11,022 --> 00:25:27,117
艾滋病流 权利，使BB开始结束 

491
00:25:23,016 --> 00:25:31,113
和成品 一些部分该部分 

492
00:25:28,017 --> 00:25:33,096
B的流的重叠用A的流动等 

493
00:25:32,013 --> 00:25:36,039
由于B是仍在运行没有 

494
00:25:33,096 --> 00:25:38,193
完成好了，那么A和B是 

495
00:25:36,039 --> 00:25:43,104
并发为并且类似地C和一个 

496
00:25:39,093 --> 00:25:45,162
重叠， 所以他们的并发，但B和 

497
00:25:44,004 --> 00:25:54,018
C 不被并发 这些权 

498
00:25:46,062 --> 00:25:57,108
前C结束，现在开始这个想法 

499
00:25:54,018 --> 00:25:59,084
并发 它没有这个这个 

500
00:25:58,008 --> 00:26:02,067
并发的定义持有 

501
00:25:59,084 --> 00:26:03,165
无论核心数量的权 

502
00:26:02,067 --> 00:26:06,114
如果即使你有一个核心的这 

503
00:26:04,065 --> 00:26:08,133
例如，我向 您 展示 了一个 

504
00:26:07,014 --> 00:26:11,075
核心但即使你有多个内核

505
00:26:09,033 --> 00:26:15,081
只要流在时间上重叠 

506
00:26:11,075 --> 00:26:17,157
他们是并发的，但是我们可以想到的 

507
00:26:15,081 --> 00:26:19,083
这些不管是什么，我们可以我们可以认为 

508
00:26:18,057 --> 00:26:20,148
这些 作为 平行运行 

509
00:26:20,001 --> 00:26:25,046
彼此从点 至少 

510
00:26:21,048 --> 00:26:24,146
鉴于这些各个过程的 

511
00:26:29,096 --> 00:26:37,110
现在这个这个概念上下文切换 

512
00:26:33,065 --> 00:26:40,071
是它的由它管理的管理 

513
00:26:38,001 --> 00:26:42,003
内核很好，而且重要的是要 

514
00:26:40,071 --> 00:26:43,086
认识到内核不喜欢 

515
00:26:42,003 --> 00:26:45,012
独立过程的运行它 

516
00:26:43,086 --> 00:26:49,149
始终运行在某些情况下 

517
00:26:45,039 --> 00:26:52,092
现有的流程和它的是它是它的

518
00:26:50,049 --> 00:26:55,068
只是代码，在上部 

519
00:26:52,092 --> 00:26:58,170
这被 作为 执行的地址空间 

520
00:26:55,068 --> 00:27:00,075
异常的结果， 所以什么什么 

521
00:26:59,007 --> 00:27:03,033
恰好想想这是方法

522
00:27:01,038 --> 00:27:05,085
您有运行此过程 

523
00:27:03,096 --> 00:27:06,191
然后一个异常发生时

524
00:27:05,085 --> 00:27:10,128
将控制权交给内核 

525
00:27:07,091 --> 00:27:12,144
内核调用它的调度器 

526
00:27:11,028 --> 00:27:16,074
决定是否让继续运行 

527
00:27:13,044 --> 00:27:19,071
或做上下文切换和运行

528
00:27:16,074 --> 00:27:23,142
新工艺另一个进程所以在这

529
00:27:19,071 --> 00:27:27,128
例如调度决定运行 

530
00:27:24,042 --> 00:27:31,071
处理B 所以它执行代码，然后 

531
00:27:28,028 --> 00:27:34,035
排序变化的那种，一旦它重新指向 

532
00:27:31,071 --> 00:27:37,071
S'的地址空间，那么它的运行 

533
00:27:34,098 --> 00:27:40,170
在过程B 和它 的上下文 

534
00:27:37,071 --> 00:27:43,071
完成加载为寄存器 

535
00:27:41,007 --> 00:27:45,102
处理B 通用寄存器和 

536
00:27:43,071 --> 00:27:51,072
然后将控制转移到B和进料 

537
00:27:46,065 --> 00:27:53,078
占用 它离开的地方好，然后 

538
00:27:51,072 --> 00:27:56,103
在某些 时候会出现其他异常 

539
00:27:53,078 --> 00:27:58,119
而在内核决定转移 

540
00:27:57,003 --> 00:28:00,068
控制返回以处理其拾取 

541
00:27:59,019 --> 00:28:03,072
离开的地方就在这里 

542
00:28:00,068 --> 00:28:06,105
所以它完成任何指令

543
00:28:03,072 --> 00:28:07,155
执行任何 指示指令 

544
00:28:07,005 --> 00:28:10,056
在的执行时发生

545
00:28:08,055 --> 00:28:12,131
例外执行下一条指令

546
00:28:10,056 --> 00:28:12,131
这里

547
00:28:16,549 --> 00:28:21,632
现在Linux提供了许多 功能 

548
00:28:20,009 --> 00:28:24,107
你 可以，你 可以从用户调用 

549
00:28:22,379 --> 00:28:26,438
程序操作过程中，这

550
00:28:24,989 --> 00:28:29,015
这此过程中的这一行为 

551
00:28:26,969 --> 00:28:32,060
我们所说的操作流程

552
00:28:29,249 --> 00:28:35,294
现在过程控制 所有 这些 

553
00:28:32,879 --> 00:28:37,930
大多数功能都是我应该说大部分的 

554
00:28:35,699 --> 00:28:40,796
这些函数调用调用系统 

555
00:28:38,389 --> 00:28:43,463
使系统调用，但 他们在 那里 

556
00:28:41,669 --> 00:28:45,713
他们包裹在较高水平我们 

557
00:28:44,129 --> 00:28:47,177
调用系统级 功能即是 

558
00:28:46,109 --> 00:28:52,181
你实际上是从打电话的事

559
00:28:47,609 --> 00:28:54,647
用户程序 在 现在的系统级 

560
00:28:52,829 --> 00:28:56,834
Linux系统级功能即会 

561
00:28:54,989 --> 00:28:58,085
通常返回一减一，如果有 

562
00:28:56,879 --> 00:29:00,956
一个错误，那么他们就会设置一个全局 

563
00:28:58,949 --> 00:29:04,970
变量 称为错误 没有指示 

564
00:29:01,649 --> 00:29:07,747
之所以这么有一个硬性规定

565
00:29:05,159 --> 00:29:12,194
当你调用当你做 

566
00:29:08,629 --> 00:29:14,671
系统级功能，你必须检查 

567
00:29:12,509 --> 00:29:17,606
从这些函数 的 返回值 

568
00:29:15,049 --> 00:29:21,068
你应该和这个 你永远你会得到 

569
00:29:18,479 --> 00:29:22,523
它，你会陷入巨大的 麻烦 ，如果你 

570
00:29:21,239 --> 00:29:25,283
如果你忽略检查返回 

571
00:29:22,919 --> 00:29:28,925
值好了，你不应该做 

572
00:29:25,679 --> 00:29:31,703
系统的系统 级功能调用 

573
00:29:28,979 --> 00:29:33,005
不检查返回值的 

574
00:29:31,919 --> 00:29:37,922
而唯一的例外 有一些 

575
00:29:33,239 --> 00:29:43,241
返回void如功能

576
00:29:38,219 --> 00:29:44,276
退出或免费不返回任何这样 

577
00:29:43,259 --> 00:29:47,261
途中你会做的典型方式

578
00:29:44,789 --> 00:29:50,190
这就像fork调用 我们使用 

579
00:29:47,459 --> 00:29:52,511
创建进程返回过程 

580
00:29:50,019 --> 00:29:55,388
的的过程 是理念

581
00:29:52,979 --> 00:29:57,044
创造这 始终 是 正面的 ，如果 

582
00:29:55,559 --> 00:29:59,576
有一个错误的回报减去1，所以 我们 

583
00:29:57,629 --> 00:30:02,675
检查 返回值 要少 

584
00:29:59,729 --> 00:30:06,767
比0， 然后我们我们处理 的是 

585
00:30:03,089 --> 00:30:10,163
错误在这种情况下，我们只是以某种方式确定 

586
00:30:07,109 --> 00:30:12,206
打印的 消息现在这个离开 

587
00:30:10,829 --> 00:30:17,855
获得虽然 要做到这一点 非常必要 

588
00:30:13,079 --> 00:30:19,118
它得到那种从我的分叉

589
00:30:18,089 --> 00:30:21,098
来看我们试图呈现 

590
00:30:19,469 --> 00:30:23,477
代码给你

591
00:30:21,179 --> 00:30:26,278
它变得非常 凌乱 它占用了大量 

592
00:30:24,269 --> 00:30:26,278
空间是 

593
00:30:30,032 --> 00:30:35,048
我检查，它是小于 零的哦 

594
00:30:36,038 --> 00:30:41,064
是的，这大概应该是 

595
00:30:39,041 --> 00:30:45,057
通常的惯例是返回 

596
00:30:41,064 --> 00:30:46,107
非零 所以你说得对，这不是一个 

597
00:30:45,057 --> 00:30:48,105
硬性规定 ，但 就是这样的 

598
00:30:47,007 --> 00:30:54,069
通常惯例，所以我想这 

599
00:30:49,005 --> 00:30:57,036
要退出一个所以我们会做的 

600
00:30:54,069 --> 00:30:58,101
在代码简化这个我们 

601
00:30:57,036 --> 00:30:59,043
现在你和代码， 我们 

602
00:30:59,001 --> 00:31:02,067
目前您在书 

603
00:31:00,006 --> 00:31:07,017
好，我们将定义错误报告 

604
00:31:02,067 --> 00:31:08,073
功能，使UNIX风格的错误，我们的 

605
00:31:07,017 --> 00:31:14,082
函数返回-1，并设置有 

606
00:31:09,027 --> 00:31:17,073
没有意志，如果我们 得到的那种，如果我们 

607
00:31:14,082 --> 00:31:19,083
得到这样的空气就会将打印 

608
00:31:17,073 --> 00:31:21,138
你将打印的消息， 我们将 

609
00:31:19,083 --> 00:31:24,117
报告中，我们之前是什么错误是

610
00:31:22,038 --> 00:31:28,044
退出，所以后来在代码中我们可以 

611
00:31:25,017 --> 00:31:31,044
更换的该机构如果 

612
00:31:28,044 --> 00:31:32,127
只是一个单一的行语句好吗 

613
00:31:31,044 --> 00:31:35,109
以便 使 一个小的代码 

614
00:31:33,027 --> 00:31:38,031
更紧但 我们会走得更远比 

615
00:31:36,009 --> 00:31:41,064
这一点，我们将定义 这些包装 

616
00:31:38,031 --> 00:31:44,055
这是由一个大首创

617
00:31:41,064 --> 00:31:48,081
技术作家W¯¯ 史蒂文斯的理查兹 

618
00:31:44,055 --> 00:31:50,063
我们在这里做的 是我们，我们更换 

619
00:31:48,081 --> 00:31:55,092
与包装的误差每个功能 

620
00:31:51,035 --> 00:31:58,035
具有相同的接口作为 

621
00:31:55,092 --> 00:32:00,108
发挥原有的功能，它 

622
00:31:58,035 --> 00:32:03,099
有首的 第一个字母大写 

623
00:32:01,008 --> 00:32:06,107
然后这个包装做的是什么呢

624
00:32:03,099 --> 00:32:09,105
调用它调用原来的功能

625
00:32:07,007 --> 00:32:12,048
检查的错误，然后再

626
00:32:10,005 --> 00:32:15,036
如果没有返回错误是什么 

627
00:32:12,048 --> 00:32:16,140
原函数将返回如此 

628
00:32:15,036 --> 00:32:20,043
此包装的行为 

629
00:32:17,004 --> 00:32:22,086
等同于包装的函数，如果 

630
00:32:21,006 --> 00:32:25,011
有没有好吧，如果有错误

631
00:32:23,022 --> 00:32:27,087
是一个错误，那么它处理它

632
00:32:25,056 --> 00:32:30,099
以某种方式与显示一条消息，因此然后 

633
00:32:27,087 --> 00:32:32,169
这使我们能够使我们的代码 真的 

634
00:32:30,099 --> 00:32:34,131
紧凑而不违背这个又硬又 

635
00:32:33,069 --> 00:32:37,094
我们 必须快速，我们的规则必须 

636
00:32:35,031 --> 00:32:37,094
检查错误 

637
00:32:39,047 --> 00:32:44,996
没关系最简单的功能流程 

638
00:32:43,169 --> 00:32:47,100
控制功能是函数 

639
00:32:45,419 --> 00:32:49,980
让你得到 了 PID” 为 

640
00:32:47,001 --> 00:32:52,050
当前过程是GETPID或 

641
00:32:49,098 --> 00:32:54,407
父进程 的处理器想法

642
00:32:52,059 --> 00:32:56,148
创建当前处理好了， 

643
00:32:55,289 --> 00:32:59,360
这这些拿不出论据和他们 

644
00:32:57,048 --> 00:33:01,136
返回一个整数，其是一个过程 

645
00:32:59,999 --> 00:33:02,360
再次

646
00:33:04,019 --> 00:33:10,958
现在Linux提供的方法来创建和 

647
00:33:07,739 --> 00:33:12,767
终止从工艺和

648
00:33:11,129 --> 00:33:14,183
程序员的角度来看，我们能想到的 

649
00:33:13,019 --> 00:33:18,071
一个过程如 在三个中的一个是 

650
00:33:14,669 --> 00:33:20,714
国家在这种情况下运行，以便 

651
00:33:18,539 --> 00:33:25,590
过程实际上是运行和 执行 

652
00:33:21,119 --> 00:33:27,134
说明或其它可以预定 

653
00:33:25,059 --> 00:33:27,878
也许它没有运行，但它可以是 

654
00:33:27,269 --> 00:33:32,270
计划在以后的时间

655
00:33:28,409 --> 00:33:36,494
感谢和它的等待正在等待 

656
00:33:32,369 --> 00:33:40,448
调度进程可以停止 ，这意味着 

657
00:33:37,259 --> 00:33:42,323
该执行被挂起 ，并不会 

658
00:33:41,159 --> 00:33:44,850
计划，直至另行通知，所以我们会 

659
00:33:42,899 --> 00:33:46,590
看到这是如何工作和 我们研究的信号 

660
00:33:44,085 --> 00:33:48,514
在接下来的演讲，但 通常一 

661
00:33:46,059 --> 00:33:51,878
过程停止，因为它接收 

662
00:33:49,279 --> 00:33:54,314
某种信号，然后将 

663
00:33:52,409 --> 00:33:58,430
过程变成方式停止它不会 

664
00:33:54,629 --> 00:34:01,691
执行它不会被排至 

665
00:33:58,619 --> 00:34:04,622
你明确告诉它安排 

666
00:34:02,249 --> 00:34:06,311
oyel过程可以被终止，其 

667
00:34:04,649 --> 00:34:10,520
意味着它永久停好了， 

668
00:34:06,869 --> 00:34:12,944
它永远不会被再次安排它的完成

669
00:34:10,052 --> 00:34:15,147
现在一个流程可以终止针对一个 

670
00:34:13,619 --> 00:34:18,662
有三个原因使一个接收到 

671
00:34:16,047 --> 00:34:22,098
信号， 其默认行为是 

672
00:34:19,049 --> 00:34:25,061
其终止或您的 程序 

673
00:34:22,098 --> 00:34:26,717
从主程序所以你返回

674
00:34:25,169 --> 00:34:30,242
知道你可以的，如果你知道 定义 

675
00:34:27,599 --> 00:34:33,510
主数据类型为int 看到主例程始终 

676
00:34:30,899 --> 00:34:36,270
返回一个int，所以你可以从返回

677
00:34:33,051 --> 00:34:37,910
主，将终止您的活动 

678
00:34:36,027 --> 00:34:42,146
它将终止 过程，也 可以 

679
00:34:38,369 --> 00:34:46,740
显式调用exit函数的 

680
00:34:42,389 --> 00:34:49,436
退出功能退出程序 用 

681
00:34:46,074 --> 00:34:51,233
的它的参数，从而退出状态 

682
00:34:49,859 --> 00:34:54,863
只要你指出， 

683
00:34:51,899 --> 00:34:56,921
约定是正常的回报是 

684
00:34:54,899 --> 00:34:59,996
回到零 ，然后 非零 上 

685
00:34:57,119 --> 00:35:03,134
错误或 您可以另一种方式来做到这一点 

686
00:35:00,869 --> 00:35:04,910
刚刚返回从一个整数值 

687
00:35:03,269 --> 00:35:08,303
主程序和意志，将设置 

688
00:35:05,279 --> 00:35:10,950
退出状态 立即退出是怎么样 的 

689
00:35:08,609 --> 00:35:13,710
不寻常的，你会看到这是一个典型 

690
00:35:10,095 --> 00:35:15,164
所有这些过程控制功能

691
00:35:13,071 --> 00:35:18,920
他们通常的功能调用

692
00:35:16,019 --> 00:35:21,101
他们一次，然后他们返回一个OK 

693
00:35:19,559 --> 00:35:25,652
你永远不会调用一个，然后将其出口

694
00:35:21,839 --> 00:35:30,450
返回 好吧，这是如此，这是一个 

695
00:35:26,489 --> 00:35:32,546
有点不寻常现在父进程可以 

696
00:35:30,045 --> 00:35:40,204
通过调用创建子进程 

697
00:35:33,059 --> 00:35:45,155
fork函数所以叉不带任何参数 

698
00:35:40,609 --> 00:35:50,730
和它返回一个整数 它创建一个 

699
00:35:46,019 --> 00:35:55,070
新的子进程，然后在返回 

700
00:35:50,073 --> 00:35:56,192
无论是家长和孩子，所以 这是 

701
00:35:55,529 --> 00:35:57,630
有点难以绕到你的头 

702
00:35:56,849 --> 00:36:01,850
首先 

703
00:35:57,063 --> 00:36:04,095
它是由父调用一次，但它 

704
00:36:01,859 --> 00:36:06,960
然后返回在这两个它会创建一个新的

705
00:36:04,095 --> 00:36:09,914
进程，然后 返回在两个 

706
00:36:06,096 --> 00:36:13,122
父母和孩子 ，并 给孩子它 

707
00:36:10,769 --> 00:36:16,792
返回零到它 返回 父 

708
00:36:14,022 --> 00:36:19,801
它 回到了孩子的进程ID 

709
00:36:16,999 --> 00:36:19,999
好的 

710
00:36:20,829 --> 00:36:26,830
孩子得到的相同的副本

711
00:36:23,929 --> 00:36:29,022
父母的虚拟地址空间，但

712
00:36:26,929 --> 00:36:33,025
单独在那里他们是截然不同的 

713
00:36:29,859 --> 00:36:35,923
但叉后立即返回

714
00:36:33,889 --> 00:36:37,945
地址的地址空间 

715
00:36:36,499 --> 00:36:40,582
相同的，使得指 所有的 

716
00:36:38,449 --> 00:36:44,485
变量所有的 全局变量 

717
00:36:41,329 --> 00:36:45,400
栈的代码一切都是相同 

718
00:36:44,809 --> 00:36:48,844
和孩子

719
00:36:46,039 --> 00:36:53,071
它具有完全相同的值， 因为它 

720
00:36:49,159 --> 00:36:55,186
确实在父母的孩子变 

721
00:36:53,359 --> 00:36:59,377
父母开的相同副本

722
00:36:55,429 --> 00:37:01,462
打开文件描述符所以孩子有 

723
00:36:59,539 --> 00:37:02,617
访问包括像所有打开的文件 

724
00:37:01,759 --> 00:37:05,845
在标准和标准出来了

725
00:37:03,319 --> 00:37:07,402
父母曾和唯一的区别 是 

726
00:37:06,619 --> 00:37:11,668
孩子 得到一个不同的过程 

727
00:37:08,149 --> 00:37:16,150
ID 比母体所以叉子是真的 

728
00:37:12,109 --> 00:37:17,200
奇怪，因为它被称为是一次 

729
00:37:16,159 --> 00:37:22,159
在父返回一次两次， 

730
00:37:18,019 --> 00:37:27,025
在孩子一旦所以这里是一个 例子 

731
00:37:22,159 --> 00:37:31,180
这这里的，这是一个例子 

732
00:37:27,079 --> 00:37:33,091
具有其程序有 一个 地方 

733
00:37:31,369 --> 00:37:37,390
在堆栈上可变称为X 

734
00:37:33,199 --> 00:37:42,238
初始化为1，然后它调用叉 

735
00:37:37,579 --> 00:37:46,651
和叉创建子和回报 

736
00:37:42,589 --> 00:37:50,653
在它返回一个值，无论是 

737
00:37:47,299 --> 00:37:52,351
父母和孩子 ，我们的 只有我们的方法 

738
00:37:51,229 --> 00:37:54,274
是否我们执行可以区分 

739
00:37:52,819 --> 00:37:56,914
在父母或孩子 检查 

740
00:37:54,679 --> 00:37:59,776
该返回值 好了，所以在这里，如果 

741
00:37:57,769 --> 00:38:02,797
进程ID是坑为0，那么 我们 

742
00:38:00,649 --> 00:38:05,737
在孩子执行并记住 

743
00:38:03,049 --> 00:38:13,096
孩子得了一模一样 具有完全相同 

744
00:38:06,529 --> 00:38:18,571
相同的存储器 和与码作为 

745
00:38:13,519 --> 00:38:20,584
所以家长中的X孩子是1，所以当 

746
00:38:18,949 --> 00:38:23,977
我们打印我们打印此消息来自 

747
00:38:21,169 --> 00:38:28,174
小时候我们增加X，然后打印此 

748
00:38:24,229 --> 00:38:32,840
此消息使孩子将打印1 + 1 

749
00:38:28,669 --> 00:38:35,270
2，然后退出

750
00:38:32,084 --> 00:38:36,128
在父，当我们检查这 

751
00:38:35,027 --> 00:38:39,029
进程ID 这将是非零 

752
00:38:37,028 --> 00:38:43,031
因为它的过程想法的 

753
00:38:39,029 --> 00:38:45,062
孩子因此在这种情况下，如此如此父 

754
00:38:43,031 --> 00:38:47,039
不会执行这个这个身体 

755
00:38:45,062 --> 00:38:50,090
有条件所以家长将将就 

756
00:38:48,011 --> 00:38:53,057
执行这个printf和父我们

757
00:38:50,009 --> 00:38:56,104
减量X之前， 我们打印 所以 

758
00:38:53,057 --> 00:39:01,088
家长打印出一减一为零 

759
00:38:57,085 --> 00:39:03,098
现在有没有保证，我们没有 

760
00:39:01,088 --> 00:39:06,092
保证无论是童年父 

761
00:39:03,098 --> 00:39:09,113
先执行它可能发生在 

762
00:39:06,092 --> 00:39:10,190
叉当车叉返回 的 

763
00:39:10,013 --> 00:39:15,017
内核可以决定安排孩子

764
00:39:11,009 --> 00:39:16,094
第一没关系，其中在这种情况下，该 

765
00:39:15,017 --> 00:39:20,042
在有条件 的主体代码

766
00:39:17,075 --> 00:39:23,075
将运行或者可能它可以决定运行 

767
00:39:20,042 --> 00:39:25,133
家长首先可以的，而且也 没有 

768
00:39:23,075 --> 00:39:28,091
办法预测， 这是错误的它是一个 

769
00:39:26,033 --> 00:39:29,129
错误做出那样的任何假设

770
00:39:28,091 --> 00:39:32,165
这是怎么回事首先将运行 

771
00:39:30,029 --> 00:39:35,083
孩子的父母， 你可以看到 ， 

772
00:39:33,065 --> 00:39:38,081
它们共享相同的打开的文件，因为

773
00:39:35,083 --> 00:39:40,112
无论是家长和孩子 要 打印 

774
00:39:38,081 --> 00:39:46,130
标准输出，它打印在 

775
00:39:41,012 --> 00:39:48,080
终端还好是什么，如果这个问题 

776
00:39:47,003 --> 00:39:52,037
是，如果你所说的叉多次 

777
00:39:48,008 --> 00:39:53,093
我会告诉你那些它的一些例子 

778
00:39:52,064 --> 00:39:55,163
变得有点毛茸茸的 ，我们将有一个 意志 

779
00:39:54,065 --> 00:40:00,151
使用一种称为一个过程图，以模型

780
00:39:56,063 --> 00:40:00,151
排序排序的理解发生了什么 

781
00:40:03,061 --> 00:40:09,134
好了，所以像 刚才像你说的叉子 

782
00:40:06,002 --> 00:40:12,017
叉或种类可以是一种复杂的 

783
00:40:10,034 --> 00:40:14,038
和了解 ， 特别是 如果他们 

784
00:40:12,017 --> 00:40:16,064
嵌套或者你叫他们多次 

785
00:40:14,038 --> 00:40:21,080
所以我们用所谓的进程工具 

786
00:40:16,064 --> 00:40:24,080
图表捕捉到那种什么什么 

787
00:40:21,008 --> 00:40:25,016
当我们调用福克斯正确的，我们都可能发生

788
00:40:24,008 --> 00:40:27,059
可我们不能，我们不能做任何 

789
00:40:26,006 --> 00:40:30,101
假设有关的排序 

790
00:40:28,031 --> 00:40:33,044
不同的过程，但 我们可以捕捉 

791
00:40:31,055 --> 00:40:36,074
利用事件的偏序

792
00:40:33,044 --> 00:40:37,118
这本工具称为一个过程图，从而 

793
00:40:36,074 --> 00:40:39,152
我们要做的是，我们会让每一个顶点 

794
00:40:38,018 --> 00:40:42,092
对应的执行

795
00:40:40,052 --> 00:40:45,098
语句，然后 它是 一个边缘 

796
00:40:42,092 --> 00:40:47,177
之前的关系因此发生情况

797
00:40:45,098 --> 00:40:50,132
对于B，我们将标签与目前的边缘 

798
00:40:48,077 --> 00:40:53,129
变量的值，如果我们有一个 

799
00:40:51,032 --> 00:40:55,121
打印顶点 的打印输出一个 顶点 

800
00:40:54,029 --> 00:40:58,097
对应于一个printf我们可以 

801
00:40:56,021 --> 00:41:00,119
标签与输出 ，然后 

802
00:40:58,097 --> 00:41:03,131
每个图形与一个顶点开始 

803
00:41:01,019 --> 00:41:06,038
知道在边缘，从而给出该曲线图

804
00:41:04,031 --> 00:41:09,098
然后任何拓扑排序的曲线图的

805
00:41:06,038 --> 00:41:13,040
代表了一些可行 一些可行 

806
00:41:09,098 --> 00:41:14,165
事件 和 总排序 

807
00:41:13,004 --> 00:41:17,042
拓扑排序，我们指的是总

808
00:41:15,065 --> 00:41:21,152
顶点的顺序，其中所有的 

809
00:41:17,078 --> 00:41:22,169
边缘从左向右走OK让我们 

810
00:41:22,052 --> 00:41:28,129
看看如何做到这一点 的 工作， 我们的 

811
00:41:23,069 --> 00:41:32,075
这里的示例程序，我们有父 

812
00:41:29,029 --> 00:41:36,035
最初X等于 1，则 

813
00:41:32,075 --> 00:41:40,079
父调用fork叉返回

814
00:41:36,089 --> 00:41:42,182
无论是家长和孩子的孩子 

815
00:41:41,015 --> 00:41:47,084
打印和双方家长和 孩子 

816
00:41:43,082 --> 00:41:49,130
打印 x 的 值 后递增 

817
00:41:47,084 --> 00:41:53,093
或递减，然后他们都退出 

818
00:41:50,003 --> 00:41:56,087
好吧，你 能 想到的 这些，因为它是 

819
00:41:54,074 --> 00:41:57,943
发生这样 这些同时发生 

820
00:41:57,014 --> 00:42:02,018
正确的，这 意味着他们可以 

821
00:41:58,609 --> 00:42:04,580
以任何方式交错并 因此在 

822
00:42:02,054 --> 00:42:09,071
拓扑排序这个图会告诉 

823
00:42:04,058 --> 00:42:15,077
我们一个可行的什么是一个可行的 是 什么 

824
00:42:09,071 --> 00:42:17,102
可行的交错 确定，所以我们 可以这样 

825
00:42:15,077 --> 00:42:19,124
如果我们如果我们真正能够在图形只是 

826
00:42:18,002 --> 00:42:26,099
保持它的简单， 所以 如果我们真正能够在 这些 

827
00:42:20,024 --> 00:42:31,031
只有单个字母那么这个边缘

828
00:42:26,099 --> 00:42:32,108
全序一癸FD表示 

829
00:42:31,031 --> 00:42:36,074
表示这是一个拓扑排序 

830
00:42:33,089 --> 00:42:41,068
因此，一个可行的总体排序所以在这里 

831
00:42:36,074 --> 00:42:44,090
我们有一个执行则D，那么E 

832
00:42:41,869 --> 00:42:50,710
执行 罪的孩子，然后在此 

833
00:42:44,009 --> 00:42:53,048
点内核决定换出 

834
00:42:50,071 --> 00:42:56,156
换出Ë 换出的孩子，现在 

835
00:42:54,029 --> 00:42:59,041
让家长跑那么父精选 

836
00:42:57,056 --> 00:43:02,150
并执见

837
00:42:59,041 --> 00:43:04,115
然后，然后它被重新安排 

838
00:43:03,005 --> 00:43:07,016
聊天那么孩子被安排和

839
00:43:05,015 --> 00:43:10,022
执行f和然后父 

840
00:43:07,061 --> 00:43:11,153
父运行并最终完成右

841
00:43:10,022 --> 00:43:14,096
所以这 是这是不太可能， 它 

842
00:43:12,053 --> 00:43:18,056
你只问你一个指令 

843
00:43:14,096 --> 00:43:20,099
然后再B， 然后有一个上下文 

844
00:43:18,056 --> 00:43:23,093
切换但它是很可行权 

845
00:43:20,099 --> 00:43:25,190
因为它代表，因为该

846
00:43:23,093 --> 00:43:32,096
总排序是它是一个拓扑 

847
00:43:26,009 --> 00:43:35,093
订货，另一方面这是该 

848
00:43:32,096 --> 00:43:37,103
是不可行的，因为这里˚F在这 

849
00:43:36,074 --> 00:43:41,078
我们 之前 正在执行 f总播放排序

850
00:43:38,066 --> 00:43:44,114
E和你可以看到， 这只是 

851
00:43:41,078 --> 00:43:46,106
不能发生 这样 的权利 的 边缘上 

852
00:43:45,014 --> 00:43:49,037
这些逻辑流程由下式表示

853
00:43:47,006 --> 00:43:52,103
这个孩子在这个顺序发生 

854
00:43:49,037 --> 00:43:57,110
第一 E和F然后由恰到好处 

855
00:43:53,003 --> 00:44:03,095
因为F，准备如下吃正确的代码

856
00:43:58,001 --> 00:44:06,007
暂时不会对编译器来它不是 

857
00:44:03,095 --> 00:44:07,099
要改变这些 

858
00:44:06,007 --> 00:44:13,024
好了，所以如果 现在如果我们有 发生 

859
00:44:08,035 --> 00:44:16,069
两个连续的福克斯也让我们画 

860
00:44:13,087 --> 00:44:16,153
该过程图将帮助我们 

861
00:44:16,069 --> 00:44:21,112
明白这一点

862
00:44:17,053 --> 00:44:25,108
所以在父我们打印L 0，然后

863
00:44:22,012 --> 00:44:29,038
叉子和创建一个孩子和两个 

864
00:44:26,008 --> 00:44:31,009
所以叉返回到这的printf

865
00:44:29,038 --> 00:44:34,062
在家长和孩子让他们都

866
00:44:31,009 --> 00:44:38,020
无论是家长和孩子打印大号1 

867
00:44:34,062 --> 00:44:41,133
然后家长和孩子的

868
00:44:38,002 --> 00:44:44,008
执行一个叉， 使 创建 

869
00:44:42,033 --> 00:44:48,061
创建创建 两个 另一个孩子 

870
00:44:44,008 --> 00:44:52,015
现在更多二两孩子 好，然后 

871
00:44:48,061 --> 00:44:55,132
因此，返回到其的printf 

872
00:44:52,087 --> 00:44:57,136
通过 这种调用，这样的结果说

873
00:44:56,032 --> 00:45:02,089
叉这样两次 是创建 

874
00:44:58,036 --> 00:45:04,048
4个处理器没关系，你 可以，如果 

875
00:45:02,089 --> 00:45:05,125
它混淆你 总是 可以 解决它 

876
00:45:04,048 --> 00:45:09,049
不与这样处理图 

877
00:45:06,025 --> 00:45:12,052
好了，所以我们就可以削弱 我们，我们可以看到 

878
00:45:09,058 --> 00:45:13,150
可行和不可行排序以便 

879
00:45:12,052 --> 00:45:17,056
这一个可行的把我的话 

880
00:45:14,005 --> 00:45:17,014
这是一个可行的，然后，让我们来看看 

881
00:45:17,092 --> 00:45:23,113
为什么

882
00:45:18,004 --> 00:45:28,012
所以它的L 0，有没有办法来 

883
00:45:24,013 --> 00:45:30,019
第一音叉 没事 前通过打印

884
00:45:28,048 --> 00:45:31,117
所以这是不可行的，如果我们如果我们 画 

885
00:45:30,073 --> 00:45:35,148
这一过程图，我们就会有一个 

886
00:45:32,017 --> 00:45:36,048
向后向后边缘 

887
00:45:37,071 --> 00:45:41,148
现在没事了会发生什么，如果我们 外汇 窝 

888
00:45:40,074 --> 00:45:43,163
在父好吧，我不知道为什么 

889
00:45:42,048 --> 00:45:50,627
你想这样做除了可能 对 

890
00:45:43,829 --> 00:45:52,530
折磨到13名学生，但所以我们可以 

891
00:45:51,059 --> 00:45:55,800
刚刚工作了这一点，通过绘制 

892
00:45:52,053 --> 00:45:58,089
过程图所以在这里，我们有父 

893
00:45:55,008 --> 00:46:06,057
它打印L 0，然后它叉所以 

894
00:45:58,089 --> 00:46:10,116
创建AA孩子这样，孩子若 

895
00:46:07,029 --> 00:46:12,117
叉不等于 0，那么我们在 

896
00:46:11,016 --> 00:46:17,094
父权所以这段代码执行罪 

897
00:46:13,017 --> 00:46:19,092
家长如果叉为0，那么我们 

898
00:46:17,094 --> 00:46:22,176
执行儿童和孩子刚

899
00:46:19,092 --> 00:46:25,125
通过再然后终止其打印

900
00:46:23,076 --> 00:46:30,093
最终结束 我并没有表现出来 

901
00:46:26,025 --> 00:46:33,093
在这里，如果它调用exit 认为功能 

902
00:46:30,093 --> 00:46:37,145
调用此函数调用退出以 

903
00:46:33,093 --> 00:46:41,462
父所以叉不等于0 

904
00:46:38,045 --> 00:46:44,654
表示这是 父，因此 

905
00:46:42,299 --> 00:46:50,270
家长打印L1，然后它 

906
00:46:45,059 --> 00:46:50,270
另一个叉是叉创建一个子 

907
00:46:50,096 --> 00:46:57,141
因此，如果如果如果叉 不等于 0，那么 

908
00:46:55,044 --> 00:47:00,138
我们是在父因此父版画 

909
00:46:58,041 --> 00:47:06,120
L2，然后退出这个条件和 

910
00:47:01,038 --> 00:47:08,717
通过如果如果叉然后返回0的打印

911
00:47:07,002 --> 00:47:11,046
意味着我们正在执行儿童，所以我们 

912
00:47:09,059 --> 00:47:14,460
不执行此代码，我们跳出 

913
00:47:11,064 --> 00:47:23,127
这种有条件的，那么孩子刚

914
00:47:14,046 --> 00:47:25,143
按OK打印，我们可以复制所以这本 

915
00:47:24,027 --> 00:47:28,816
表示从一个不可行输出 

916
00:47:26,043 --> 00:47:28,672
这个程序 

917
00:47:29,089 --> 00:47:38,430
10 周 叉 使L 0，然后通过 

918
00:47:34,074 --> 00:47:40,453
这是可行的，然后依次用L 1 

919
00:47:38,043 --> 00:47:40,732
没关系 

920
00:47:42,000 --> 00:47:48,078
再接下来团购是 好的，但 它 

921
00:47:44,064 --> 00:47:53,157
只是我们不能有这一点 ，我们不能有 

922
00:47:48,078 --> 00:47:56,109
这个由这L2因为L2前述 

923
00:47:54,057 --> 00:48:01,095
将这个printf的会前执行 

924
00:47:57,009 --> 00:48:09,038
这个printf的好，我会让你的工作 

925
00:48:01,095 --> 00:48:10,140
出这一个作为一个练习的所有 

926
00:48:09,119 --> 00:48:14,168
现在， 当 ，当一个进程 

927
00:48:11,004 --> 00:48:16,005
终止无论什么原因， 

928
00:48:14,609 --> 00:48:20,640
系统实际上保持它周围 

929
00:48:16,005 --> 00:48:23,007
直到它的收获，究其原因 ，直到 

930
00:48:20,064 --> 00:48:25,107
它是由其父和收获的原因 

931
00:48:23,052 --> 00:48:27,054
它这是家长可能想 

932
00:48:26,007 --> 00:48:30,009
了解 的 退出 状态 

933
00:48:27,072 --> 00:48:32,471
孩子左右，但如果父母创建一个子

934
00:48:30,027 --> 00:48:36,072
它可能要等待孩子 

935
00:48:33,119 --> 00:48:38,940
完成和并检查其退出状态，因此 

936
00:48:36,072 --> 00:48:40,128
当任何进程终止时

937
00:48:38,094 --> 00:48:42,503
系统离开它不它不 

938
00:48:41,028 --> 00:48:45,042
完全从 系统中 删除 它 它 

939
00:48:43,349 --> 00:48:47,760
保持它或状态 的一点点

940
00:48:45,042 --> 00:48:51,461
在该形式相关联的子 

941
00:48:47,076 --> 00:48:54,114
的孩子和的 退出 状态 

942
00:48:51,839 --> 00:48:57,660
还有一些其他表其他一些操作系统 

943
00:48:55,014 --> 00:49:00,096
表是因为这个孩子是 

944
00:48:57,066 --> 00:49:01,149
终止，但它不会消失它他们 

945
00:49:00,096 --> 00:49:08,157
所谓的僵尸所以有几分一半 

946
00:49:02,049 --> 00:49:12,668
半活半死等的处理的 

947
00:49:09,057 --> 00:49:15,144
僵尸仍然僵尸，直到它的它的 

948
00:49:13,109 --> 00:49:18,560
它是通过使用它的父收获 

949
00:49:16,044 --> 00:49:21,072
函数调用的重量或 加权和 

950
00:49:18,056 --> 00:49:23,058
作为因为这样做的结果的结果

951
00:49:21,072 --> 00:49:24,153
重量或重量父具有 

952
00:49:23,058 --> 00:49:27,120
给出退出状态信息和 

953
00:49:25,053 --> 00:49:32,094
那么内核删除僵尸 

954
00:49:28,002 --> 00:49:34,098
流程现在如果什么家长不 

955
00:49:32,094 --> 00:49:40,253
不读其子的这一个

956
00:49:35,016 --> 00:49:43,715
僵尸所以它如果有父母，如果 

957
00:49:41,099 --> 00:49:46,260
然后父终止该系统 

958
00:49:43,859 --> 00:49:48,510
安排 在第一个过程， 

959
00:49:46,026 --> 00:49:50,885
在所谓的 初始化 系统存在

960
00:49:48,051 --> 00:49:52,056
方法，该方法具有一个 它的进程ID 

961
00:49:51,119 --> 00:49:56,150
安排在ANIT进程读取 

962
00:49:53,001 --> 00:49:56,015
这是孩子

963
00:49:56,018 --> 00:50:03,087
所以有这么孤儿的孤儿 

964
00:49:59,057 --> 00:50:05,121
将始终由ANIT可以通过收获 

965
00:50:03,087 --> 00:50:11,109
过程，所以我们才真正担心 

966
00:50:06,021 --> 00:50:13,083
约约在收获僵尸

967
00:50:12,009 --> 00:50:17,016
情况下，我们 有长期运行的父母 

968
00:50:13,083 --> 00:50:19,158
因为像在弹或服务器 

969
00:50:17,079 --> 00:50:22,173
区分一台服务器可以创造数百万个

970
00:50:20,058 --> 00:50:26,112
子进程的每一个 每一个 

971
00:50:23,073 --> 00:50:28,077
其中的一个确实 的那些中的 每 一个 

972
00:50:27,012 --> 00:50:30,021
孩子，当他们终止进程

973
00:50:28,077 --> 00:50:33,141
成为僵尸，他们自己有状态 

974
00:50:31,002 --> 00:50:36,075
这会占用房间 的内核，所以你 

975
00:50:34,041 --> 00:50:39,045
能得到这个是内存泄漏的一种形式 

976
00:50:36,075 --> 00:50:40,119
如果你没有，如果你不 获得这些 

977
00:50:39,045 --> 00:50:44,108
僵尸的孩子，最终可以填补 

978
00:50:41,019 --> 00:50:44,108
占用的内存空间，并导致内核崩溃 

979
00:50:47,081 --> 00:50:52,125
所以对于 您拥有情况 

980
00:50:51,003 --> 00:50:55,068
长久运行的程序，然后我们有我们 

981
00:50:53,025 --> 00:50:58,092
必须使用等待或等待可以看 

982
00:50:55,068 --> 00:51:03,153
孩子们让我们来看一个例子

983
00:50:58,092 --> 00:51:06,110
首先让我们来看看 这样 一个例子 

984
00:51:04,053 --> 00:51:09,141
所以这里的僵尸现象，我们有一个 

985
00:51:07,001 --> 00:51:14,013
函数中，我们调用fork， 然后内 

986
00:51:10,041 --> 00:51:15,099
孩子 ，我们打印的消息 

987
00:51:14,022 --> 00:51:19,095
那个孩子的过程想法， 然后我们 

988
00:51:15,099 --> 00:51:20,106
父我们内退出的孩子

989
00:51:19,095 --> 00:51:22,188
打印一个消息，然后 我们进入一个 

990
00:51:21,069 --> 00:51:26,154
无限循环 好了，所以这是一个父 

991
00:51:23,088 --> 00:51:29,163
那是一种永远不会到达孩子 

992
00:51:27,054 --> 00:51:36,057
它所创建的，所以如果我们运行这个 

993
00:51:30,063 --> 00:51:39,069
程序调用福克斯 ，你可以看到它 

994
00:51:36,084 --> 00:51:41,148
打印这两个消息的父 

995
00:51:40,023 --> 00:51:46,122
打印消息和孩子打印 

996
00:51:42,048 --> 00:51:48,117
消息，然后我们在各自运行它 

997
00:51:47,022 --> 00:51:50,094
这个符号 的 背景 好吗 

998
00:51:49,017 --> 00:51:53,058
因为我们要否则 

999
00:51:50,094 --> 00:51:56,121
会它会是它仍在运行

1000
00:51:53,058 --> 00:51:58,074
我们将 无法 对其进行检查 ，以便 

1001
00:51:57,021 --> 00:52:01,026
之后我们在运行这个程序 

1002
00:51:58,074 --> 00:52:02,157
背景然后我们用PS打印 

1003
00:52:01,026 --> 00:52:05,073
当前进程，我们可以看到， 

1004
00:52:03,057 --> 00:52:08,059
有两家，我们可以看到在这里 的 

1005
00:52:05,073 --> 00:52:10,962
父这是进程ID 663 

1006
00:52:08,077 --> 00:52:15,088
然后孩子这为六六四 

1007
00:52:11,619 --> 00:52:21,970
零和 的倒闭表明， 

1008
00:52:15,088 --> 00:52:24,047
现在没事了僵尸，如果我们杀了6 

1009
00:52:21,097 --> 00:52:27,115
中6 个九家是父和 

1010
00:52:24,839 --> 00:52:30,010
然后到另一个PS你看到 

1011
00:52:28,015 --> 00:52:31,944
僵尸走了，孩子不见了 

1012
00:52:30,001 --> 00:52:37,039
因为它已经被EMIT达到

1013
00:52:32,079 --> 00:52:39,040
现在过程中的一个，如果发生了什么 

1014
00:52:37,039 --> 00:52:42,067
孩子不会终止你可能想知道 

1015
00:52:39,004 --> 00:52:48,033
就像如果如果父母创建了一个孩子 ， 

1016
00:52:42,067 --> 00:52:51,142
这时家长再聊天和 

1017
00:52:48,069 --> 00:52:53,800
孩子永远不会终止和 

1018
00:52:52,042 --> 00:52:57,043
然后父终止，会发生什么 

1019
00:52:53,008 --> 00:53:00,072
很多所以我们只让我们来看一个 

1020
00:52:57,052 --> 00:53:03,381
那些例子，看看所以在这里我们 

1021
00:53:01,044 --> 00:53:06,933
我们调用fork，我们正在创建一个 

1022
00:53:03,849 --> 00:53:09,760
我们打印 的 孩子 中的孩子

1023
00:53:07,329 --> 00:53:14,230
消息，那么孩子进入一个 

1024
00:53:09,076 --> 00:53:16,635
无限循环 和家长一个打印 

1025
00:53:14,023 --> 00:53:21,028
消息，然后退出，所以如果我们 运行这个 

1026
00:53:17,319 --> 00:53:25,347
程序，你可以看到两个 

1027
00:53:21,073 --> 00:53:27,088
家长和孩子，然后消息

1028
00:53:25,599 --> 00:53:30,624
如果我们看一下，如果我们看一下 

1029
00:53:27,088 --> 00:53:33,090
预言我们可以看到，我们可以 看到 ， 

1030
00:53:30,849 --> 00:53:33,900
孩子仍在运行 

1031
00:53:38,589 --> 00:53:42,592
好了，所以信道过程仍然是 

1032
00:53:40,094 --> 00:53:45,169
运行即使父母 的有 

1033
00:53:42,619 --> 00:53:55,400
终止，现在如果我们杀了这个孩子 

1034
00:53:46,069 --> 00:53:56,120
六六 七六 ， 然后如果我们杀了它 

1035
00:53:55,004 --> 00:54:00,073
那么我们可以看到，它的消失也没有 

1036
00:53:57,002 --> 00:54:01,046
再在系统好让孩子 

1037
00:54:00,469 --> 00:54:04,400
当我们的时候，我们把它打死了那 

1038
00:54:01,064 --> 00:54:07,723
终止它，它没有父母所以 

1039
00:54:04,004 --> 00:54:14,027
ANIT进程 读取它， 它一点也不 

1040
00:54:08,299 --> 00:54:18,140
不再是僵尸这样 的功能 

1041
00:54:14,063 --> 00:54:21,065
我们用它来与孩子同步 

1042
00:54:18,014 --> 00:54:26,173
和 阅读 最简单的一个被称为 

1043
00:54:21,065 --> 00:54:29,404
等待，等待它带有一个可选 

1044
00:54:26,299 --> 00:54:31,393
状态在那里你可以得到退出状态 

1045
00:54:29,989 --> 00:54:36,890
的检查的退出状态 

1046
00:54:32,239 --> 00:54:39,243
孩子基本上等待暂停 

1047
00:54:36,089 --> 00:54:40,678
调用它的进程的执行

1048
00:54:39,279 --> 00:54:43,351
直到一个或它的一个子 

1049
00:54:41,479 --> 00:54:46,400
终止，它没有指定哪些 

1050
00:54:43,999 --> 00:54:49,056
一个它只是 等待 的 一个 

1051
00:54:46,004 --> 00:54:54,005
孩子们，它创建和终止 

1052
00:54:49,569 --> 00:54:56,630
那么如果这个孩子的状态不是 不超过 

1053
00:54:54,041 --> 00:54:57,850
它返回的整数是 

1054
00:54:56,063 --> 00:55:00,065
整数，它指向，这是一个 

1055
00:54:58,219 --> 00:55:02,630
指针整数它指向 

1056
00:55:00,065 --> 00:55:03,904
将被设置为指示 某个值 

1057
00:55:02,063 --> 00:55:06,292
之所以孩子终止其 

1058
00:55:04,489 --> 00:55:10,501
退出状态，你可以，你 可以检查 

1059
00:55:06,859 --> 00:55:11,953
使用 这些宏，你的你 

1060
00:55:10,609 --> 00:55:16,708
教科书更加详细地介绍和 

1061
00:55:12,799 --> 00:55:20,630
让你呃让我们看看如何如何 

1062
00:55:17,599 --> 00:55:23,671
在一个简单的例子作品所以这里我们 

1063
00:55:20,063 --> 00:55:27,262
调用fork和创建子 其 

1064
00:55:24,319 --> 00:55:30,394
打印消息，然后退出该 

1065
00:55:27,829 --> 00:55:32,880
父打印一条消息 ，然后将它 

1066
00:55:31,069 --> 00:55:36,145
等待孩子和终止 

1067
00:55:33,339 --> 00:55:39,346
当孩子终止它打印 

1068
00:55:36,829 --> 00:55:41,896
消息，并表示子 

1069
00:55:40,039 --> 00:55:44,131
通过这样，如果我们终止，然后打印

1070
00:55:42,499 --> 00:55:46,585
分别来看看的 过程 图 

1071
00:55:44,959 --> 00:55:49,024
这个你会看到，我们 将有 

1072
00:55:47,359 --> 00:55:52,190
叉创建父和 

1073
00:55:49,609 --> 00:55:55,657
孩子都在父母和孩子 

1074
00:55:52,019 --> 00:56:01,078
通过他们 自己的printf，然后 

1075
00:55:56,089 --> 00:56:03,094
家长等待它挂起，直至 发生 

1076
00:56:01,249 --> 00:56:08,690
通过调用在这种情况下，子进程终止

1077
00:56:03,589 --> 00:56:13,591
退出好 了，这是什么 意思是它的 

1078
00:56:08,069 --> 00:56:15,145
这是不可行的 ，所以你可以打个招呼 

1079
00:56:13,609 --> 00:56:16,450
从父 

1080
00:56:17,078 --> 00:56:24,086
这是不可行的，虽然这本 

1081
00:56:20,093 --> 00:56:29,188
子封端的消息CT 发生 

1082
00:56:24,086 --> 00:56:30,088
再见，因为前

1083
00:56:34,016 --> 00:56:40,049
因为孩子还没有 

1084
00:56:36,026 --> 00:56:42,119
终止所以这两个这两个 

1085
00:56:40,049 --> 00:56:47,144
消息将永远不会被打印， 直到 

1086
00:56:43,019 --> 00:56:56,117
孩子是通过调用exit终止这样

1087
00:56:48,044 --> 00:57:09,082
是明确的 是 这样的问题 是可以 

1088
00:56:57,017 --> 00:57:15,104
您 有一个输出 惠普HP HC CT是 

1089
00:57:09,082 --> 00:57:18,089
是因为父前王子惠普是一家 

1090
00:57:16,004 --> 00:57:22,022
上下文该儿童版画HC和 

1091
00:57:18,089 --> 00:57:24,182
然后退出，现在的家长会的 

1092
00:57:22,022 --> 00:57:36,047
等待返回，然后 打印 CT 

1093
00:57:25,082 --> 00:57:39,131
由还好这里的这是，这是一个 

1094
00:57:36,047 --> 00:57:42,080
稍微走一点更多 地参与 

1095
00:57:40,031 --> 00:57:43,130
例如所以这里我们想要 做的我们 

1096
00:57:42,008 --> 00:57:45,086
要创建一帮 孩子 ， 

1097
00:57:44,003 --> 00:57:48,080
那么我们要等到他们都 

1098
00:57:46,058 --> 00:57:50,120
终止，我们要等待，但我们 

1099
00:57:49,007 --> 00:57:51,080
将无法在任何特定的等待 

1100
00:57:51,002 --> 00:57:57,151
订购 

1101
00:57:51,008 --> 00:58:00,104
我们 只所以在这里我们有一个循环0〜 

1102
00:57:57,349 --> 00:58:05,180
n和在每个循环体，我们要 

1103
00:58:01,076 --> 00:58:06,101
我们要fork一个孩子和退出 

1104
00:58:05,018 --> 00:58:11,114
与这回事返回状态

1105
00:58:07,001 --> 00:58:15,089
告诉 我们它是在哪个子 

1106
00:58:12,014 --> 00:58:21,014
父母，所以我们这样做，我们做一个结束 

1107
00:58:15,089 --> 00:58:24,128
时间，然后再 事后 

1108
00:58:21,014 --> 00:58:28,993
类似的环0到内部母体内 

1109
00:58:25,028 --> 00:58:30,080
加上等待孩子如此终止

1110
00:58:29,119 --> 00:58:38,030
它会它会工作它将等待结束 

1111
00:58:30,008 --> 00:58:41,069
孩子终止等待返回 的方式 

1112
00:58:38,003 --> 00:58:44,098
返回到进程ID，然后 

1113
00:58:42,041 --> 00:58:44,098
状态

1114
00:58:45,029 --> 00:58:53,033
这是在这个孩子的状态

1115
00:58:50,054 --> 00:58:55,109
可变的，因此，我们采取的是变量 

1116
00:58:53,033 --> 00:58:57,131
现在，我们可以用这个WF退出宏 

1117
00:58:56,009 --> 00:59:01,012
以确定它是否正常终止

1118
00:58:58,031 --> 00:59:03,113
通过调用exit如果这样退出

1119
00:59:01,039 --> 00:59:07,124
那么我们就可以用检查它的退出状态 

1120
00:59:04,013 --> 00:59:12,020
在W退出状态，否则宏如果 

1121
00:59:08,024 --> 00:59:14,087
是 WF退出它是假的则意味着 

1122
00:59:12,002 --> 00:59:16,037
有些东西孩子终止 

1123
00:59:14,087 --> 00:59:23,156
因其他理由而不是因为 它 

1124
00:59:16,055 --> 00:59:27,083
所谓退出还好有一个 我们可以我们 

1125
00:59:24,056 --> 00:59:29,072
可以实际使用的等待 孩子这是 

1126
00:59:27,083 --> 00:59:31,169
类似的等待，但它可以让 我们等待 

1127
00:59:29,072 --> 00:59:34,160
对于具体 处理的特定子 

1128
00:59:32,069 --> 00:59:37,070
具体处理 的特定的 孩子 

1129
00:59:35,006 --> 00:59:42,020
一个特定的进程 ID终止并 

1130
00:59:37,007 --> 00:59:45,029
我会我会告诉你，你可以等待它的 

1131
00:59:42,074 --> 00:59:47,156
真正参与和它的描述 

1132
00:59:45,092 --> 00:59:49,106
详细的 教材，所以你会 

1133
00:59:48,056 --> 00:59:54,110
需要看你需要看看那里 

1134
00:59:50,006 --> 00:59:57,011
关于如何 工作的，现在 细节 

1135
00:59:55,001 --> 01:00:02,033
另一个重要的，所以我们已经学会了如何 

1136
00:59:57,011 --> 01:00:04,049
创建新的预言，但我们 

1137
01:00:02,042 --> 01:00:05,138
还没有学会如何当我们 的时候，我们 

1138
01:00:04,049 --> 01:00:08,147
呼唤 它我们 只是创建一个精确副本 

1139
01:00:06,038 --> 01:00:11,096
的孩子 仅仅 是 完全相同的副本 

1140
01:00:09,047 --> 01:00:15,092
父母的运行相同的代码 

1141
01:00:11,096 --> 01:00:16,178
同样的程序相同的变量好吗运行 

1142
01:00:15,092 --> 01:00:20,173
的过程的内部的不同的节目 

1143
01:00:17,078 --> 01:00:27,167
我们使用了一个名为 EXEC去功能 

1144
01:00:21,073 --> 01:00:30,140
鸡蛋IK内的加载和运行 

1145
01:00:28,067 --> 01:00:33,074
当前进程 加载并运行 

1146
01:00:31,004 --> 01:00:36,035
这是它的第一个可执行文件名

1147
01:00:33,074 --> 01:00:40,157
参数和文件名可以 是 

1148
01:00:36,071 --> 01:00:43,142
二进制可执行的二进制正确的 ，或者它 可以 

1149
01:00:41,057 --> 01:00:48,113
是一个脚本，它可以是一个文本文件 

1150
01:00:44,042 --> 01:00:52,054
所谓的脚本文件启动其 

1151
01:00:49,013 --> 01:00:52,054
第一行以开始 

1152
01:00:52,055 --> 01:00:56,132
磅砰， 然后再有一个 

1153
01:00:54,092 --> 01:00:58,097
一些翻译所以例如路径

1154
01:00:57,032 --> 01:01:01,831
如果你，如果你想写 一个shell 

1155
01:00:58,097 --> 01:01:05,144
脚本您在外壳的第一行 

1156
01:01:02,119 --> 01:01:09,050
脚本是英镑的一声，然后将

1157
01:01:06,044 --> 01:01:11,090
bash shell中的路径名，然后 

1158
01:01:09,005 --> 01:01:14,093
将将执行 - 再

1159
01:01:11,009 --> 01:01:17,012
bash将将在读取行 

1160
01:01:14,093 --> 01:01:19,097
以下并解释它们，就像 

1161
01:01:18,002 --> 01:01:23,099
虽然你 键入他们这是一个在 

1162
01:01:20,033 --> 01:01:25,115
命令行，以便在任一情况下它 

1163
01:01:24,017 --> 01:01:29,066
执行任一解释器或者它 

1164
01:01:26,015 --> 01:01:33,047
执行与谁的 争论 二进制 

1165
01:01:29,066 --> 01:01:37,151
有参数列表 是 V和列表 

1166
01:01:33,047 --> 01:01:40,141
在英P环境变量的好吗 

1167
01:01:38,051 --> 01:01:43,139
现在默认争论的第一个参数 

1168
01:01:41,041 --> 01:01:46,124
在我们的V是该文件的名称 

1169
01:01:44,039 --> 01:01:51,047
多数民众赞成执行所以它的它的这个 

1170
01:01:47,024 --> 01:01:54,098
文件名等什么，让你做 

1171
01:01:52,019 --> 01:01:56,036
是在你的代码，你可以 ，如果 检查 我们的V-0 

1172
01:01:54,098 --> 01:01:56,180
要打印出来的名字 

1173
01:01:56,036 --> 01:02:02,044
文件， 该文件的程序的名称 

1174
01:01:57,008 --> 01:02:01,072
执行你刚刚打印出我们的D0 

1175
01:02:04,094 --> 01:02:12,101
还好现在 退出 所有的代码和 

1176
01:02:09,093 --> 01:02:15,120
数据，并将 其覆盖在堆栈 

1177
01:02:13,064 --> 01:02:18,773
完全覆盖虚拟地址 

1178
01:02:16,002 --> 01:02:23,351
空间所以一旦你叫鸡蛋 蛋内的 

1179
01:02:19,349 --> 01:02:26,150
一个进程中它吹走 

1180
01:02:23,549 --> 01:02:28,595
目前的计划就是这样好吗 

1181
01:02:26,015 --> 01:02:30,066
然而，它保留了它仍然是 

1182
01:02:29,009 --> 01:02:35,970
同样的过程，它只是 现在运行 

1183
01:02:30,066 --> 01:02:38,094
不同的程序，因此它保留 了 

1184
01:02:35,097 --> 01:02:43,188
进程ID和所有打开的文件，你 

1185
01:02:38,094 --> 01:02:46,423
有这么像鸡蛋真的是真的 

1186
01:02:44,088 --> 01:02:53,088
令人兴奋的，因为 它被调用一次 

1187
01:02:47,269 --> 01:02:55,367
但它永远不会返回，除非有 

1188
01:02:53,088 --> 01:02:56,987
一个错误，所以如果这个文件不 存在 

1189
01:02:56,249 --> 01:03:00,308
例如，然后再鸡蛋鸡蛋意志 

1190
01:02:57,779 --> 01:03:06,180
在正常的回报-1但在其他方面 

1191
01:03:00,839 --> 01:03:06,908
操作它永远不会返回所有权利，使 

1192
01:03:06,018 --> 01:03:10,117
让我们来看看它的结构 

1193
01:03:07,529 --> 01:03:13,580
当这个新的程序启动后使

1194
01:03:10,279 --> 01:03:17,430
X后后后的卵 卵已经 

1195
01:03:14,039 --> 01:03:22,920
完成其工作， 它会创建一个新的堆栈 

1196
01:03:17,043 --> 01:03:27,112
在新的代码加载和数据创建 

1197
01:03:22,092 --> 01:03:30,041
新的空荒地 确定一切的新 

1198
01:03:27,499 --> 01:03:34,499
它创建的堆栈有 

1199
01:03:30,869 --> 01:03:36,180
下面的表格 确定在底部这里的 

1200
01:03:34,499 --> 01:03:40,583
堆栈的底部， 我们的堆栈 

1201
01:03:36,018 --> 01:03:44,927
越来越多这样 使第一功能 

1202
01:03:41,339 --> 01:03:47,342
执行被称为函数 

1203
01:03:45,089 --> 01:03:51,184
库ç下划线开始强调主

1204
01:03:47,369 --> 01:03:51,436
使得有它具有一个堆栈帧 

1205
01:03:53,011 --> 01:03:56,110
所以让我们来看看，这是我展示什么

1206
01:03:54,085 --> 01:04:00,090
这里的情况是 前右 

1207
01:03:57,001 --> 01:04:04,048
启动代码调用main 所以有 

1208
01:04:01,035 --> 01:04:06,126
有主将来堆栈帧 

1209
01:04:04,057 --> 01:04:10,150
将在这里在这之上 

1210
01:04:07,026 --> 01:04:14,092
继堆栈的顶部还有的 

1211
01:04:11,005 --> 01:04:19,048
一些填充，然后参数列表 

1212
01:04:14,092 --> 01:04:21,174
在 RV被包含在堆栈上 

1213
01:04:19,093 --> 01:04:25,093
从而使RV是指针列表 

1214
01:04:22,074 --> 01:04:27,127
由空指针和每一个终止

1215
01:04:25,093 --> 01:04:30,096
这些指针之一指向了成 

1216
01:04:28,027 --> 01:04:35,080
对应于一个参数串

1217
01:04:31,023 --> 01:04:38,067
好了，所以，当你运行你的程序 

1218
01:04:35,008 --> 01:04:37,095
指定

