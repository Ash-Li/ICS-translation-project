1
00:00:00,000 --> 00:00:06,012
我想一件事II上午 的休息 

2
00:00:03,003 --> 00:00:08,025
工作人员的要求是， 你 只要你 

3
00:00:06,012 --> 00:00:10,781
有你第一次读这本书的一个问题

4
00:00:08,025 --> 00:00:13,544
然后 你重读 分配 和 

5
00:00:10,889 --> 00:00:16,560
你也许再 然后 你 再读一遍 

6
00:00:13,769 --> 00:00:18,840
问我们，因为有很多 的问题， 

7
00:00:16,056 --> 00:00:21,093
我们得到的是那些在这里我们只说 

8
00:00:18,084 --> 00:00:23,160
看这页书看的 

9
00:00:21,093 --> 00:00:26,432
本款分配的样子在 

10
00:00:24,006 --> 00:00:31,044
你是该文件 的这一部分 

11
00:00:27,269 --> 00:00:34,590
给予所以我的意思是有很多的 

12
00:00:31,098 --> 00:00:36,017
的东西，我了解有时 

13
00:00:34,059 --> 00:00:38,067
它很容易错过事情，所以不是说 

14
00:00:36,899 --> 00:00:41,520
永远不要问的问题，但 之前 

15
00:00:39,039 --> 00:00:44,043
你问你的问题，试图弄清楚 

16
00:00:41,052 --> 00:00:46,571
我是否 真的应该 来过 

17
00:00:44,043 --> 00:00:48,602
我可以看到，如果资源

18
00:00:47,039 --> 00:00:55,770
回答我的 问题是 可 

19
00:00:48,989 --> 00:00:57,930
发现有这么反正享受网络进行，因此

20
00:00:55,077 --> 00:01:00,150
今天是一个排序的第二部分

21
00:00:57,093 --> 00:01:02,932
在整数和整数两部分讲座

22
00:01:01,005 --> 00:01:07,005
算术最后一次 看 

23
00:01:03,769 --> 00:01:11,580
有关如何位模式表示

24
00:01:07,005 --> 00:01:13,038
可被解释为任一无符号的 

25
00:01:11,058 --> 00:01:18,063
数字意味着它们的范围 0 之间 

26
00:01:13,083 --> 00:01:20,115
和两 字的大小减去一个或 

27
00:01:19,008 --> 00:01:24,024
二补数这是 

28
00:01:21,015 --> 00:01:25,089
最恭维你而去代表 

29
00:01:24,024 --> 00:01:27,090
什么有时 被称为 符号数 

30
00:01:25,089 --> 00:01:29,142
者也可以是 他们的 消极或 

31
00:01:27,009 --> 00:01:31,053
积极 的方式还有 其他 

32
00:01:30,042 --> 00:01:35,093
的方式来表示有符号数出 

33
00:01:32,034 --> 00:01:38,453
有，但牙齿的补充等等等等 

34
00:01:35,093 --> 00:01:41,145
绝大多数最常用的系统， 

35
00:01:38,759 --> 00:01:45,020
这就是我们专注于什么今天 

36
00:01:42,045 --> 00:01:46,053
我们要做的是 现在超越 

37
00:01:45,002 --> 00:01:49,601
这些值的表示说话 

38
00:01:47,025 --> 00:01:53,324
在他们关于算术运算和 

39
00:01:49,619 --> 00:01:55,530
它们的一些性质，以及我们将 

40
00:01:53,549 --> 00:01:58,140
做一般 我们谈论 的无符号 

41
00:01:55,053 --> 00:01:59,136
情况下这是在某些方面更容易 

42
00:01:58,014 --> 00:02:02,100
了解更直观 ，然后 

43
00:02:00,036 --> 00:02:05,975
说说补这样的情况下 

44
00:02:03,000 --> 00:02:11,043
在这个基本的规则是，如果你拿 

45
00:02:06,299 --> 00:02:13,780
两个数字达之间的范围 

46
00:02:11,043 --> 00:02:16,054
一个无符号数的 最大值 

47
00:02:13,078 --> 00:02:18,154
加上他们，但 在原则上 ，你可能需要 

48
00:02:16,054 --> 00:02:21,055
以获得额外的比特来表示 

49
00:02:19,054 --> 00:02:23,095
如果你想代表真正的拇指 

50
00:02:21,055 --> 00:02:24,081
某种这两个整数总和 

51
00:02:23,095 --> 00:02:26,116
数字 

52
00:02:24,081 --> 00:02:29,110
因为你加倍并 

53
00:02:27,016 --> 00:02:32,040
不幸的是，我们不能 只是出去 

54
00:02:30,001 --> 00:02:35,068
更多位添加到您的计算机 

55
00:02:32,004 --> 00:02:39,031
无限期所以我们只是 阻止它的一些 

56
00:02:35,077 --> 00:02:41,092
点 ，说什么也 发生了 一点 

57
00:02:39,067 --> 00:02:43,072
要在那种未来/位 

58
00:02:41,092 --> 00:02:45,411
位置，我们只是要删除它 和 

59
00:02:43,072 --> 00:02:47,119
假装它不存在，并说， 

60
00:02:46,239 --> 00:02:51,790
另外的结果就是什么

61
00:02:48,019 --> 00:02:54,028
W位模式你，如果你只 

62
00:02:51,079 --> 00:02:59,101
考虑第1W位出它与 

63
00:02:55,009 --> 00:03:01,908
无警告没有消息 没有错误或 

64
00:03:00,001 --> 00:03:07,075
什么这 只是它发生 

65
00:03:01,989 --> 00:03:12,400
这样默默地在每个恭维这 

66
00:03:07,075 --> 00:03:13,153
是不是这样一个困难的事情理解 

67
00:03:12,004 --> 00:03:17,011
它可以被看作 只是模块化 的 

68
00:03:14,053 --> 00:03:19,069
算术运算模的两 

69
00:03:17,047 --> 00:03:20,143
字的大小，所以我打算 使用 

70
00:03:19,069 --> 00:03:22,090
一些例子， 这一次我有 

71
00:03:21,043 --> 00:03:26,322
他们多一点经过深思熟虑 

72
00:03:22,009 --> 00:03:28,054
所以我会弄混尽可能多的和我们 

73
00:03:26,709 --> 00:03:32,560
用四个词大小在这里和我 

74
00:03:29,035 --> 00:03:34,674
上次提到的它确实有帮助 

75
00:03:32,056 --> 00:03:37,117
这个工作做小例子

76
00:03:34,989 --> 00:03:40,061
字长得到了你的直觉 

77
00:03:38,017 --> 00:03:43,072
而不是尝试写出来 

78
00:03:40,709 --> 00:03:45,670
32位数字或64位数字或

79
00:03:43,072 --> 00:03:52,371
类似的东西，所以，如果你认为 

80
00:03:45,067 --> 00:03:57,067
关于在无符号的情况下 的4位 

81
00:03:53,019 --> 00:04:03,070
数意味着它将之间的范围内 

82
00:03:57,067 --> 00:04:06,090
0 和2至第四减1或15右 

83
00:04:03,007 --> 00:04:11,010
所以，让我们只是 做了几个 例子 

84
00:04:06,009 --> 00:04:15,042
它溢出，所以如果你添加的情况下

85
00:04:11,037 --> 00:04:15,123
13〜5 

86
00:04:20,009 --> 00:04:24,970
首先你知道，我认为已经 

87
00:04:23,011 --> 00:04:28,350
你只需添加二进制数的方式 

88
00:04:24,097 --> 00:04:29,125
你 的只是在做 学校里学到的 

89
00:04:28,449 --> 00:04:36,452
携带等等，除了它的所有 

90
00:04:30,025 --> 00:04:41,029
模2 所以这是零携带一个一个 

91
00:04:36,479 --> 00:04:44,500
零携带一个零携带一个 

92
00:04:41,065 --> 00:04:47,163
所以在原则上表示总和 

93
00:04:44,005 --> 00:04:52,039
这是这是5，以便以代表18 

94
00:04:48,063 --> 00:04:54,072
你需要五个比特不是四个 ，但我们 

95
00:04:52,084 --> 00:04:58,086
只是要方便丢弃 

96
00:04:54,639 --> 00:05:03,780
数说，这 其实 是 2 

97
00:04:58,086 --> 00:05:05,149
这当然就是18模块16 

98
00:05:03,078 --> 00:05:13,087
所以无符号的情况是真的很漂亮 

99
00:05:06,049 --> 00:05:16,078
简单， 我们可以想像 

100
00:05:13,087 --> 00:05:20,155
这在该图片的书 太受 

101
00:05:16,078 --> 00:05:24,527
他说，如果你 在X代表 

102
00:05:21,055 --> 00:05:27,954
和y轴他们所谓的 U和V是 

103
00:05:25,229 --> 00:05:30,276
0 和15之间的范围内的值

104
00:05:28,449 --> 00:05:32,440
可能的无符号数，如果我们

105
00:05:30,699 --> 00:05:37,150
要添加这些，我们可以得到一个总和 

106
00:05:32,044 --> 00:05:39,096
多达高达 30会在 

107
00:05:37,015 --> 00:05:42,087
原则需要5个比特来表示 

108
00:05:39,096 --> 00:05:44,125
但我们要做的是，我们将仅仅通过 

109
00:05:42,087 --> 00:05:47,316
下降，大多数显著位什么 

110
00:05:45,025 --> 00:05:52,027
我们做的是创造一个 夹子 ，当你 

111
00:05:48,099 --> 00:05:54,153
从15至16，而不是它滴翻转

112
00:05:52,027 --> 00:05:58,072
一路下跌到0，这就是 

113
00:05:54,639 --> 00:06:00,660
被称为溢出，然后从 

114
00:05:58,072 --> 00:06:04,108
这样，我们就建立了最大

115
00:06:00,849 --> 00:06:08,020
这里的值 将是14这是30个负 

116
00:06:05,008 --> 00:06:10,093
16 所以我们所做的基本上 为 

117
00:06:08,002 --> 00:06:14,151
这个图片显示，当我们 溢出我们 

118
00:06:10,093 --> 00:06:16,158
有效地减去关2至从 W 

119
00:06:14,169 --> 00:06:21,400
总和，并保持它的内 

120
00:06:17,058 --> 00:06:25,144
W位数字表示的范围， 

121
00:06:21,004 --> 00:06:28,015
这是不计时的 补一次 

122
00:06:26,044 --> 00:06:30,083
我想说服你第一件事 是 

123
00:06:28,051 --> 00:06:35,057
两个补码加法 

124
00:06:30,083 --> 00:06:39,130
看起来就像一个普通 版的 

125
00:06:36,011 --> 00:06:43,019
换句话说，我可以执行减法 

126
00:06:40,003 --> 00:06:45,017
和另外数的减法 

127
00:06:43,019 --> 00:06:47,074
通过使用这种牙齿恭维 

128
00:06:45,044 --> 00:06:50,060
表现为负数，以便 

129
00:06:47,074 --> 00:06:58,115
还有让我告诉你一些 例子 

130
00:06:50,006 --> 00:07:00,011
那所以首先 请记住 ， 

131
00:06:59,015 --> 00:07:02,096
什么范围的值有什么最小

132
00:07:01,001 --> 00:07:05,096
可 与一个 来表示数

133
00:07:02,096 --> 00:07:10,105
四位最负排名第四 

134
00:07:06,005 --> 00:07:18,077
位二进制补码数零下八 

135
00:07:11,005 --> 00:07:23,005
而最大的加七太感谢你 

136
00:07:18,077 --> 00:07:22,105
我们只是做了一些例子，如果我们把 

137
00:07:25,084 --> 00:07:34,163
这个数字1 1 0 1为二的 

138
00:07:31,076 --> 00:07:43,153
补数为零下3， 我们添加 

139
00:07:35,063 --> 00:07:43,072
它5，我们会得到什么，我们之前得到 

140
00:07:51,000 --> 00:07:54,096
我们不善于我们要 

141
00:07:52,008 --> 00:07:58,035
忽略任何 随身携带的出价是等 

142
00:07:54,096 --> 00:08:01,134
结果是-我 要看见 那 

143
00:07:59,007 --> 00:08:06,051
什么五减三 是看起来是这样的 

144
00:08:02,034 --> 00:08:07,098
像变魔术一样 ，因为它是周二和 

145
00:08:06,051 --> 00:08:09,090
这就是为什么部分为什么我 

146
00:08:07,098 --> 00:08:10,107
选择的补充是 最 

147
00:08:09,009 --> 00:08:13,092
代表签署了常用的方法

148
00:08:11,088 --> 00:08:17,120
数字，因为同一个硬件平台 

149
00:08:14,073 --> 00:08:21,114
被用来做相同的算法

150
00:08:18,002 --> 00:08:32,100
除了在工作无符号或 

151
00:08:22,014 --> 00:08:37,080
二补数和这个作品

152
00:08:33,018 --> 00:08:41,037
如干脆如果溢出给你看 

153
00:08:37,008 --> 00:08:47,049
去如果所得到的膜是那张 

154
00:08:41,037 --> 00:08:53,108
所以其他的方式，如果我有零下3号和减号

155
00:08:48,021 --> 00:08:53,108
5加3， 我添加这些在一起 

156
00:09:02,068 --> 00:09:13,099
我会得到1 1 1 0，这是零下2 SO 

157
00:09:10,031 --> 00:09:17,039
如果您再次使用相同的模式 

158
00:09:13,099 --> 00:09:19,166
对于除了为你做同样的规则

159
00:09:18,011 --> 00:09:24,080
用一个无符号的情况下，你会得到两个 

160
00:09:20,066 --> 00:09:27,125
互补 节奏让 我们来看 一个 

161
00:09:24,008 --> 00:09:38,056
少数情况下，补码

162
00:09:28,025 --> 00:09:39,028
溢出，所以如果我们采取3 

163
00:09:44,092 --> 00:10:00,051
和-6，我们把它们加起来，我们将 

164
00:09:57,429 --> 00:10:08,478
得到一个一个一个零 ， 我们要 降 

165
00:10:00,879 --> 00:10:10,904
关闭这就是7所以进

166
00:10:08,919 --> 00:10:12,963
我们已经添加了两个负数和 

167
00:10:11,129 --> 00:10:15,132
它已经成为积极的

168
00:10:13,359 --> 00:10:24,393
而这被称为 负 

169
00:10:15,429 --> 00:10:27,504
溢出， 当然原因是 

170
00:10:24,699 --> 00:10:34,740
数量减去9不能代表 

171
00:10:28,179 --> 00:10:39,970
在一4位补码 ，因此 

172
00:10:35,109 --> 00:10:42,144
你溢的会发现成本 

173
00:10:39,097 --> 00:10:46,135
当然7 由 从负9的不同之 

174
00:10:42,459 --> 00:10:50,410
16这不是旁边，然后去 

175
00:10:47,035 --> 00:10:58,214
另一方向，如果我们有两个大 

176
00:10:50,041 --> 00:10:58,160
正数，所以如果我们增加7和5 

177
00:11:08,079 --> 00:11:26,110
我们会减去六所以这是七 

178
00:11:14,579 --> 00:11:29,050
加五 等于减 四所以这是 

179
00:11:27,001 --> 00:11:39,420
提到我们已经为正溢出

180
00:11:29,005 --> 00:11:40,098
采取了两个正数并添加

181
00:11:39,519 --> 00:11:43,930
他们在一起，并得到一个 负 

182
00:11:40,098 --> 00:11:46,099
结果，你可以顺便看到这个 

183
00:11:43,093 --> 00:11:48,181
如果你 认为这个 此外，我们采取了 

184
00:11:46,099 --> 00:11:51,558
七其中5位为十二，这 

185
00:11:49,081 --> 00:11:54,154
是的位级表示 

186
00:11:52,449 --> 00:11:58,494
12 这只是因为这 是 

187
00:11:55,054 --> 00:12:04,087
没有时间位我们认为， 随着 

188
00:11:58,899 --> 00:12:07,905
减四不积极十二年等等 

189
00:12:04,087 --> 00:12:10,105
这是两个互补的想法

190
00:12:07,959 --> 00:12:15,041
溢出，你可以看到有两家

191
00:12:11,005 --> 00:12:19,018
这里不同的情况 之一是当 

192
00:12:15,779 --> 00:12:22,120
数量总和是，如果我们看

193
00:12:19,018 --> 00:12:25,063
真正的总和数字，你会得到 

194
00:12:22,012 --> 00:12:27,531
例如12 太大代表 

195
00:12:25,063 --> 00:12:28,572
所以，当我们认为 ，作为一个二进制 

196
00:12:27,639 --> 00:12:30,160
补数现在变成一个 

197
00:12:29,139 --> 00:12:32,232
负数

198
00:12:30,016 --> 00:12:35,074
所以这是积极的溢出同样，如果 

199
00:12:33,069 --> 00:12:38,115
我们 有两个负数 和我们添加 

200
00:12:35,074 --> 00:12:40,138
他们在一起，使 之和过 

201
00:12:38,529 --> 00:12:42,597
小到负来表示则 

202
00:12:41,038 --> 00:12:45,100
那些成为正数这 

203
00:12:43,209 --> 00:12:49,180
负溢出，你可以看到， 

204
00:12:46,000 --> 00:12:53,949
在这张照片 同样的想法之前 

205
00:12:49,018 --> 00:12:56,047
除了有三个区域，这是和 

206
00:12:53,949 --> 00:13:00,480
顺便说一下，现在你会看到我们的数字 

207
00:12:56,047 --> 00:13:04,093
零下8 和正 7 和之间范围

208
00:13:00,048 --> 00:13:09,717
总和来 还会之间的范围 

209
00:13:04,093 --> 00:13:12,117
零下8 和积极的 7，但有 

210
00:13:10,149 --> 00:13:16,167
这三个区域之一 是哪里 

211
00:13:13,017 --> 00:13:18,906
一切都 很好 

212
00:13:16,329 --> 00:13:22,401
它是表示的范围内， 

213
00:13:19,059 --> 00:13:24,670
另一种是其中总和是迄今为止向 

214
00:13:23,049 --> 00:13:28,083
它成为 负侧 

215
00:13:24,067 --> 00:13:31,646
正面或者它是在如此之高

216
00:13:28,389 --> 00:13:36,480
它变为负值积极的一面 

217
00:13:32,249 --> 00:13:41,256
等 数据网络的 一部分 ，你会，你会 

218
00:13:37,299 --> 00:13:44,325
学会在相当相当了解这些

219
00:13:41,949 --> 00:13:47,025
但恰恰让这个想法这是一个 

220
00:13:44,559 --> 00:13:49,720
有点违反直觉说你 

221
00:13:47,709 --> 00:13:51,910
知道不知何故， 我可以接受的想法 

222
00:13:49,072 --> 00:13:54,085
模运算的无符号数 

223
00:13:51,091 --> 00:13:57,630
有某种数学之美 

224
00:13:54,085 --> 00:14:03,314
以模块化算术和该 磁盘 

225
00:13:58,449 --> 00:14:08,456
看起来像是那种 从 无用 权 

226
00:14:04,079 --> 00:14:13,116
从一个操作特性，但

227
00:14:09,149 --> 00:14:14,160
这是事情是这样的，我们不得不接受 

228
00:14:13,449 --> 00:14:18,486
它 

229
00:14:14,016 --> 00:14:20,475
和乘法基本上是相同的

230
00:14:18,819 --> 00:14:23,290
想法其实 所有的操作都 

231
00:14:20,619 --> 00:14:24,681
基本上是相同的 想法， 如果你 

232
00:14:23,029 --> 00:14:28,728
字长内不能代表它 

233
00:14:25,239 --> 00:14:33,246
你只需要较低的写位，因此所有 

234
00:14:28,989 --> 00:14:35,058
这里这个复杂的符号仅仅是一个 

235
00:14:33,939 --> 00:14:37,941
原则上说，如果你 采取的方式

236
00:14:35,679 --> 00:14:42,160
2瓦特位数字和它们相乘 

237
00:14:37,959 --> 00:14:44,058
同时 你可能需要一个结果可能 

238
00:14:42,016 --> 00:14:48,995
需要多达2倍数W位

239
00:14:44,949 --> 00:14:50,028
除 以其w加 1 日前代表

240
00:14:49,139 --> 00:14:51,237
乘法你确实有 

241
00:14:50,739 --> 00:14:56,793
双因为你可能 

242
00:14:52,119 --> 00:15:00,160
现蕾数量最多，因此再次 

243
00:14:57,279 --> 00:15:01,365
我们不希望只保留数量增加了一倍 

244
00:15:00,016 --> 00:15:04,048
字长一遍又一遍，我们会运行 

245
00:15:02,139 --> 00:15:13,212
出位的很快呀等等 

246
00:15:04,048 --> 00:15:17,127
我们只截断它为W 位和 

247
00:15:13,869 --> 00:15:18,933
未签名的情况下， 它的模块化再次 

248
00:15:17,559 --> 00:15:24,602
算术它的东西，你可以

249
00:15:19,509 --> 00:15:24,557
一种理解和相信但 

250
00:15:25,019 --> 00:15:30,230
二等再次让我们只是做了一些 

251
00:15:28,048 --> 00:15:33,080
例子， 我不会尝试 

252
00:15:30,023 --> 00:15:36,050
制定乘以二进制 像 

253
00:15:33,008 --> 00:15:37,064
在小数乘以你做一个大 

254
00:15:36,005 --> 00:15:41,011
表中， 并需要很长的 时间，所以我 

255
00:15:38,036 --> 00:15:54,041
不会尝试这样做， 但我只想 

256
00:15:42,001 --> 00:15:58,010
展示一些例子，所以如果我乘 

257
00:15:54,041 --> 00:16:01,330
三次五是 当然等于 

258
00:15:58,019 --> 00:16:13,085
15和一个无符号数我可以 

259
00:16:01,699 --> 00:16:22,699
代表权所以这是 好的，但 

260
00:16:13,085 --> 00:16:27,634
如果我乘五个乘五则 

261
00:16:22,699 --> 00:16:30,500
这将有代表性，如果我是

262
00:16:28,399 --> 00:16:31,790
作为可能想想 多达 

263
00:16:30,005 --> 00:16:40,022
八位那就有 

264
00:16:31,079 --> 00:16:42,125
一个额外的位，我表示 

265
00:16:40,067 --> 00:16:45,796
要扔这部分路程 ，所以我最好 

266
00:16:43,025 --> 00:16:49,069
叫那九这当然是 相等 

267
00:16:46,399 --> 00:16:49,690
25 960 

268
00:16:52,079 --> 00:16:58,080
UM和等那的总体思路 

269
00:16:56,085 --> 00:17:00,171
它是 不管的无论是在这 

270
00:16:58,089 --> 00:17:03,096
该产品的工作上部

271
00:17:01,071 --> 00:17:05,148
我只是要 丢弃 ， 只 

272
00:17:03,096 --> 00:17:07,595
看看下一个副 得到了 

273
00:17:06,048 --> 00:17:11,052
更 有趣一点与两个的 

274
00:17:08,459 --> 00:17:18,482
补充的情况下让我们看看什么 

275
00:17:11,052 --> 00:17:21,077
，做答案是连 

276
00:17:18,689 --> 00:17:24,300
有点陌生 ，你不仅 

277
00:17:21,077 --> 00:17:26,756
树干扔掉任何高阶 

278
00:17:24,003 --> 00:17:29,007
位恰好是有，但无论位 

279
00:17:27,449 --> 00:17:31,500
在这个位置上离开被将 

280
00:17:29,007 --> 00:17:34,052
确定它是否是一个积极或

281
00:17:31,005 --> 00:17:38,007
阴性结果即使与 

282
00:17:35,015 --> 00:17:42,039
完全不考虑的迹象 

283
00:17:38,052 --> 00:17:45,116
原来两个操作数，这样就可以 

284
00:17:42,039 --> 00:17:45,116
让你去所有 的 地方 

285
00:18:01,065 --> 00:18:16,065
所以，如果我们有五次四 ，20 

286
00:18:09,076 --> 00:18:15,165
将在这8位形式来表示 

287
00:18:22,038 --> 00:18:31,042
像这样，我们只是调用 右 

288
00:18:28,069 --> 00:18:39,115
在我们这个展示遥远，但如果我们这样做 

289
00:18:31,078 --> 00:18:42,114
五次五象我们看到的前

290
00:18:40,015 --> 00:18:42,114
这样表示

291
00:18:49,077 --> 00:18:56,079
这一数额现在变得如此我们 

292
00:18:54,051 --> 00:19:00,084
扔掉这一点，这将成为我们的

293
00:18:56,097 --> 00:19:06,126
符号位，因此结果为负8加1 

294
00:19:00,084 --> 00:19:07,176
或零下7所以你看，这是一个类似 

295
00:19:07,026 --> 00:19:11,825
一个例子，我们表现出在开始 

296
00:19:08,076 --> 00:19:14,082
第一 讲 的 ， 你 可以有 

297
00:19:12,059 --> 00:19:18,600
两个正数 和 它们 相乘 

298
00:19:14,082 --> 00:19:19,691
并获得并且因为阴性结果 

299
00:19:18,006 --> 00:19:26,034
排序这个溢出 ，当然

300
00:19:20,429 --> 00:19:30,517
问题还有 哦，我 只是把25 和 

301
00:19:26,088 --> 00:19:34,166
以二进制写它是啊，如果你想 

302
00:19:31,309 --> 00:19:38,520
你知道你开始使用两个号码 

303
00:19:35,066 --> 00:19:39,102
我不打算 其实这个 很好办 

304
00:19:38,052 --> 00:19:41,148
一个是一个容易有一个把戏 

305
00:19:40,002 --> 00:19:44,079
这一点，如果你想知道一个乘以 

306
00:19:42,048 --> 00:19:47,051
通过两个动力 ， 我们要数

307
00:19:44,079 --> 00:19:54,171
结果表明 ， 以后 你刚接班 离开 

308
00:19:47,078 --> 00:19:57,084
由两个 位置，一个是一个 简单的 

309
00:19:55,071 --> 00:19:59,112
一个否则， 你写出来的 

310
00:19:57,084 --> 00:20:03,090
表， 总结所有的结果和所有 

311
00:20:00,012 --> 00:20:05,111
这些东西我喜欢什么样的电脑做 

312
00:20:03,009 --> 00:20:05,030
那

313
00:20:12,929 --> 00:20:20,770
，这再次补充 一个 东西 

314
00:20:17,077 --> 00:20:24,082
有趣的特点是，它适用 于 

315
00:20:20,077 --> 00:20:25,162
我们负数 过，所以如果你做 

316
00:20:25,027 --> 00:20:29,556
这一招扔掉 的 

317
00:20:26,062 --> 00:20:31,221
高阶 位，你就会有溢出 

318
00:20:29,799 --> 00:20:33,804
案件像以前一样，因为你是 

319
00:20:31,779 --> 00:20:36,460
扔掉信息，但较低

320
00:20:34,299 --> 00:20:39,100
如果比特数可表示

321
00:20:36,046 --> 00:20:45,255
你会得到正确的结果 ，所以让我 

322
00:20:39,001 --> 00:20:49,099
只是证明给你，让这 

323
00:20:45,669 --> 00:20:52,750
为负3，但 你记住，这 

324
00:20:50,008 --> 00:21:01,084
是相当于13为一个无符号 

325
00:20:52,075 --> 00:21:04,134
数，这是减去2， 其 

326
00:21:01,084 --> 00:21:10,173
相当于我14为一个 无符号 

327
00:21:04,809 --> 00:21:16,690
所以现在，如果我们数乘以13倍的14 

328
00:21:10,929 --> 00:21:19,976
你会得到182并具有六角 

329
00:21:16,069 --> 00:21:19,778
B6的表示

330
00:21:27,012 --> 00:21:36,036
所以只盯着低顺序 

331
00:21:31,048 --> 00:21:40,072
位 是0 1 1 0是6 和确实是 

332
00:21:36,036 --> 00:21:43,335
负的 3 倍减去2是 6，因此 

333
00:21:40,072 --> 00:21:44,781
点是哦，我挥舞着我的手 

334
00:21:43,659 --> 00:21:47,980
这里，是因为我不想去通过 

335
00:21:45,429 --> 00:21:52,360
所有的细节，但补充 

336
00:21:47,098 --> 00:21:55,120
乘法也给你，如果你能 

337
00:21:52,036 --> 00:21:57,112
做到这一点使用完全相同的规则和 

338
00:21:56,002 --> 00:22:00,007
你无符号乘法做

339
00:21:58,012 --> 00:22:04,191
完全相同的硬件，我应该提 

340
00:22:00,025 --> 00:22:05,122
这一点，也有在说明 

341
00:22:04,299 --> 00:22:09,130
电脑的方式， 你可以得到 

342
00:22:06,022 --> 00:22:10,701
乘法的上字 也和 

343
00:22:09,013 --> 00:22:13,022
虽然它的位模式

344
00:22:10,899 --> 00:22:15,370
根据不同的是否 

345
00:22:13,139 --> 00:22:17,139
作为齿补码处理

346
00:22:15,037 --> 00:22:19,051
与无符号所以这些通常 

347
00:22:17,139 --> 00:22:23,620
这样做，不同的指令

348
00:22:19,051 --> 00:22:26,340
但计算的时间或99％ 以上 

349
00:22:23,062 --> 00:22:27,981
你刚才在看这个下部 

350
00:22:26,799 --> 00:22:29,862
该 产品 的 ，这就是同一 

351
00:22:28,539 --> 00:22:34,575
无论它是一个二进制补码或 

352
00:22:30,429 --> 00:22:36,477
无符号，它处理负数 

353
00:22:34,899 --> 00:22:39,690
积极的，但它有这些溢出

354
00:22:36,909 --> 00:22:39,690
特点

355
00:22:42,779 --> 00:22:48,831
因此，正如我说的 是有一个 

356
00:22:46,539 --> 00:22:51,940
技巧我们可以通过做乘以 

357
00:22:49,299 --> 00:22:54,010
的 两个电源，其 仅仅是 移位 

358
00:22:51,094 --> 00:22:56,146
数到左边 ，你会经常看到 

359
00:22:54,001 --> 00:22:59,550
当您 在代码中 有 我想要 

360
00:22:57,046 --> 00:23:01,635
四你会乘以一定数目

361
00:22:59,559 --> 00:23:04,360
在C代码写的，如果你看一下 

362
00:23:02,049 --> 00:23:07,240
汇编代码，你会看到什么 

363
00:23:04,036 --> 00:23:09,735
编译器生成只是说：哦，只要

364
00:23:07,024 --> 00:23:11,113
移位它留下两所以一般和 

365
00:23:10,059 --> 00:23:21,250
你可以看到为什么这 是真的由 

366
00:23:12,013 --> 00:23:35,071
这样，如果你 想的那样的数 

367
00:23:21,025 --> 00:23:38,184
位的总和，其中X子我是冰 

368
00:23:35,071 --> 00:23:42,124
位和X 是代表 如果该号码 

369
00:23:38,409 --> 00:23:45,630
我想，如果我转向一切由左 

370
00:23:43,024 --> 00:23:49,048
2 什么我切实做好为 

371
00:23:45,063 --> 00:23:52,069
通过这个数字增加自己的体重 

372
00:23:49,048 --> 00:23:56,747
位置所以我们只用一个移 

373
00:23:52,069 --> 00:23:56,558
如果我通过一个移动的一切向左 

374
00:24:00,036 --> 00:24:10,108
我们这样写，并看到两个 

375
00:24:03,025 --> 00:24:13,584
左边两个较少的符号，所以我采取这一 

376
00:24:11,008 --> 00:24:16,060
总和，但现在由两个等待盘 

377
00:24:13,809 --> 00:24:19,833
是我加上一个由多一个，当然 

378
00:24:16,006 --> 00:24:27,033
这等于 原来的 两倍 什么 

379
00:24:20,049 --> 00:24:34,074
总和为，所以我们双数和 

380
00:24:27,087 --> 00:24:36,088
该作品虽然即使你转移 

381
00:24:34,299 --> 00:24:39,010
事情让你失去了一些正确的位 

382
00:24:36,088 --> 00:24:41,119
他们他们转移到左边 所有 

383
00:24:39,001 --> 00:24:42,510
你正在做的是乘法的方式 

384
00:24:42,019 --> 00:24:45,085
作品

385
00:24:42,519 --> 00:24:48,460
无论如何的截断为W位产品，以便 

386
00:24:45,085 --> 00:24:51,121
你会看到这是我相当提到

387
00:24:48,046 --> 00:24:53,137
经常在编译代码的机器水平 

388
00:24:52,021 --> 00:24:55,036
他们正在做的变化，你的代码 

389
00:24:54,037 --> 00:24:57,037
可能指望他们 

390
00:24:55,036 --> 00:24:59,067
是做乘法 和 

391
00:24:57,037 --> 00:25:01,063
原因是 一个优化 

392
00:24:59,067 --> 00:25:03,070
历史上的乘法 

393
00:25:01,063 --> 00:25:07,117
指令采取了很多长于 

394
00:25:03,097 --> 00:25:10,158
移位指令说， 一个时钟周期 

395
00:25:08,017 --> 00:25:15,048
做的移位，并将其用于像 11 12 

396
00:25:11,058 --> 00:25:20,065
30个时钟周期来执行一个乘法 

397
00:25:15,048 --> 00:25:22,054
如今像 我们使用的计算机 

398
00:25:20,065 --> 00:25:23,101
锋利的机器 只需要三 

399
00:25:22,054 --> 00:25:26,086
时钟周期做乘法 

400
00:25:24,001 --> 00:25:29,550
因为他们增加了大量 的硬件来 

401
00:25:26,086 --> 00:25:32,134
这样做，但三个时钟周期仍然是 

402
00:25:29,559 --> 00:25:35,410
更多的时间超过一个，所以当你可以 

403
00:25:33,034 --> 00:25:37,039
逃脱的转变通常一个是 

404
00:25:35,041 --> 00:25:41,430
更好的主意，编译器都有 自己的 

405
00:25:37,084 --> 00:25:44,095
一种判断来电时，它是不是在

406
00:25:41,799 --> 00:25:52,600
更高效的替代一个

407
00:25:44,095 --> 00:25:54,120
另一个操作为什么我们 设计输 

408
00:25:52,006 --> 00:25:54,012
这里地面

409
00:25:59,099 --> 00:26:09,177
还好这样的想法 ，如果我们 想 

410
00:26:06,098 --> 00:26:19,131
乘以2东西去K 我们只是 

411
00:26:10,077 --> 00:26:23,088
接班留下的千 比特的事实证明 ， 

412
00:26:20,031 --> 00:26:25,074
同样的，几乎 适用于除以2 

413
00:26:23,088 --> 00:26:27,177
还有，如果你想要分割 

414
00:26:25,074 --> 00:26:32,160
由东西2的幂 ，你可以转移 

415
00:26:28,077 --> 00:26:34,155
它的权利在同一个总体 思路 

416
00:26:33,006 --> 00:26:37,053
只有成为 一点点 的事情 

417
00:26:35,055 --> 00:26:40,104
离奇的是还有什么，如果你的号码

418
00:26:38,007 --> 00:26:53,061
已经是不实际整除 

419
00:26:41,004 --> 00:27:07,070
2的幂这样， 例如，如果我们有 

420
00:26:53,061 --> 00:27:12,095
电话号码0 1什么它要使用啊 

421
00:27:07,007 --> 00:27:21,084
所以这是 6，所以如果我们用 1 右移它 

422
00:27:12,095 --> 00:27:25,137
我们会得到0 0 1 0 1 1感谢你这是 

423
00:27:22,047 --> 00:27:33,141
3， 这就是6除以2是 3，如果我们 

424
00:27:26,037 --> 00:27:39,039
转变，我们再次将得到 1但 

425
00:27:34,041 --> 00:27:43,119
当然，你知道，3 两半或1.5 

426
00:27:39,039 --> 00:27:48,081
整数除法法则是你详谈

427
00:27:44,019 --> 00:27:53,046
下一轮它推向0，并让 去 

428
00:27:48,081 --> 00:27:57,159
1，因此这是 无符号的情况下， 

429
00:27:53,046 --> 00:28:00,122
工作得很好，我不正弦情况 

430
00:27:58,059 --> 00:28:00,122
有一个幻灯片 

431
00:28:05,159 --> 00:28:13,172
是相当少 一 点点哦 

432
00:28:11,999 --> 00:28:15,014
首先你会注意到，如果它是一个 

433
00:28:13,289 --> 00:28:18,341
正数换档权利 

434
00:28:15,149 --> 00:28:21,161
将是正确的事情哦，就像 

435
00:28:18,809 --> 00:28:30,821
是不定时，但让我们来数 

436
00:28:21,269 --> 00:28:36,290
这是负的，因此这是加二 

437
00:28:30,929 --> 00:28:39,017
减去六 ，现在这里的地方 

438
00:28:36,479 --> 00:28:41,522
记得我告诉过你在前面 

439
00:28:39,809 --> 00:28:43,883
讲座有两种方法可以做到移 

440
00:28:41,909 --> 00:28:46,961
还有就是你填写的逻辑移位

441
00:28:44,549 --> 00:28:53,970
在用零和算术移位 

442
00:28:47,429 --> 00:28:55,950
在您填写与那些和猜测 

443
00:28:53,097 --> 00:28:58,736
其中算术移位来在这

444
00:28:55,095 --> 00:29:01,034
是不是当你想保留符号 

445
00:28:59,609 --> 00:29:04,622
一些当你将其除以 

446
00:29:01,889 --> 00:29:07,973
的两个大国想要算术移位 

447
00:29:04,739 --> 00:29:11,700
所以，如果我们通过一个移动这一点，我们会继续 

448
00:29:08,729 --> 00:29:16,470
该符号位，然后复制 其他 

449
00:29:11,007 --> 00:29:19,406
那些在 所有的权利 ，所以我们只是保留 

450
00:29:16,047 --> 00:29:26,816
这里该位复制其他的人 

451
00:29:20,099 --> 00:29:29,180
过去，这是减三等 

452
00:29:27,239 --> 00:29:36,307
这是很好的，但现在，如果我们再次转移 

453
00:29:29,909 --> 00:29:36,910
算术我们会得到什么 

454
00:29:40,022 --> 00:29:46,074
不错-我能看到你们需要 知道 

455
00:29:43,095 --> 00:29:48,108
如何否定号码的权利 ，你不 

456
00:29:46,074 --> 00:29:51,863
知道， 所以我会告诉 你在第二 

457
00:29:49,008 --> 00:29:58,067
所以这里是有点问题的 是 ， 

458
00:29:52,529 --> 00:29:59,564
我们转移，我们要除以2，但 

459
00:29:58,139 --> 00:30:02,180
规则应该是 相同的， 你 

460
00:29:59,879 --> 00:30:05,580
要圆趋向于 零，什么这个 

461
00:30:02,549 --> 00:30:06,554
正在做的是它向负舍入 

462
00:30:05,058 --> 00:30:09,072
无限的舍入

463
00:30:07,049 --> 00:30:14,051
朝向比更负的数 

464
00:30:09,072 --> 00:30:18,111
真理的东西，所以有一 点点可爱 

465
00:30:14,249 --> 00:30:21,360
小动作，说你转移前 

466
00:30:19,011 --> 00:30:24,036
之前 除以 二 的幂 

467
00:30:21,036 --> 00:30:33,036
你 做的转变 之前， 你应该添加 

468
00:30:24,036 --> 00:30:34,955
偏见在这种情况下也只是 

469
00:30:33,036 --> 00:30:37,235
一个，我会告诉你在哪里 自带 

470
00:30:35,279 --> 00:30:42,340
来自所以如果我们增加这些数字 

471
00:30:37,559 --> 00:30:42,592
我们一起会得到一个一个一个 零 

472
00:30:44,269 --> 00:30:54,293
右，现在当我们上移 

473
00:30:47,369 --> 00:30:56,432
我们会得到1 1 1 1和零下 

474
00:30:54,509 --> 00:30:58,561
1所以有一个窍门，你再会 

475
00:30:56,999 --> 00:31:02,003
你会看到， 编译器做这个地方 

476
00:30:59,029 --> 00:31:04,127
你已经在你的代码除以16 

477
00:31:02,399 --> 00:31:06,464
我们将添加一个偏见，然后它会做 

478
00:31:05,009 --> 00:31:09,450
右移，而不是调用师 

479
00:31:07,049 --> 00:31:12,131
顺便说一句师真的是 

480
00:31:09,045 --> 00:31:15,964
慢甚至现代计算机像什么 

481
00:31:12,869 --> 00:31:20,070
你有需要的鲨鱼机 

482
00:31:16,369 --> 00:31:22,830
30个加时钟周期，以便在任何时间 

483
00:31:20,007 --> 00:31:25,011
编译器可避免想出一个绝招 

484
00:31:22,083 --> 00:31:29,762
与移位和调整做它 

485
00:31:25,047 --> 00:31:31,706
它周围的东西会 是如此，我意识到我 

486
00:31:30,509 --> 00:31:34,513
应该告诉你有一对夫妇 方式 

487
00:31:32,129 --> 00:31:34,207
你 可以 

488
00:31:35,029 --> 00:31:39,047
否定的数量都得心应手知道 

489
00:31:37,076 --> 00:31:44,078
你曾经有这样做在你的头上 或 

490
00:31:39,047 --> 00:31:46,142
在纸上的标准方法是什么 

491
00:31:44,096 --> 00:31:52,127
所谓的补充和增量所以这 

492
00:31:47,042 --> 00:31:58,121
是如何从 X 到零下X，所以如果我 

493
00:31:53,027 --> 00:32:00,092
有一些，我想否定它

494
00:31:59,021 --> 00:32:03,110
无论是当前负数 

495
00:32:00,092 --> 00:32:05,120
或者它是一个正数， 同样的伎俩 

496
00:32:04,001 --> 00:32:11,072
工作原理是什么，我会做的是它的补充 

497
00:32:06,002 --> 00:32:19,088
这意味着我会翻转所有的位，然后 

498
00:32:11,081 --> 00:32:29,146
我将添加一个到做正规 

499
00:32:20,006 --> 00:32:32,084
和，所以这是六点为-6 

500
00:32:30,046 --> 00:32:34,058
所以，如果你曾经有手工做 

501
00:32:32,084 --> 00:32:35,107
这是 做一个恭维的 方式 

502
00:32:34,058 --> 00:32:43,157
增加和它走另一 条路 

503
00:32:36,007 --> 00:32:50,078
你会看到，如果我 赞美 这和我 

504
00:32:44,057 --> 00:32:54,079
增加它， 我会回来给我 

505
00:32:50,078 --> 00:32:54,079
以前的号码，那就是把戏 

506
00:32:55,033 --> 00:33:00,074
当你做这几乎是唯一 有用的 

507
00:32:57,086 --> 00:33:03,124
事情在黑板上或当您 

508
00:33:00,074 --> 00:33:03,079
要解决在数据网络中的问题 

509
00:33:09,088 --> 00:33:19,160
所以无论如何这个想法用起来做的 

510
00:33:18,062 --> 00:33:21,071
向右移动做的两个电源 

511
00:33:20,006 --> 00:33:24,011
师实际上这是整个 

512
00:33:22,052 --> 00:33:27,073
理由算术移位在 

513
00:33:24,065 --> 00:33:31,067
其中第一个地方在 NC 的 方式 

514
00:33:27,073 --> 00:33:34,154
还有如何没有固定的要求 

515
00:33:31,085 --> 00:33:36,544
移作品 下签号码 

516
00:33:35,054 --> 00:33:40,063
无符号它必须是一个逻辑 

517
00:33:37,309 --> 00:33:44,360
转移迹象号C标准说 

518
00:33:40,063 --> 00:33:46,094
有没有固定的定义， 现实 

519
00:33:44,036 --> 00:33:49,058
是我们的机器大部分机器 刚 

520
00:33:46,094 --> 00:33:51,122
大约每机器在 那里时，它的 

521
00:33:49,058 --> 00:33:53,087
两公司时，它的补数

522
00:33:52,022 --> 00:33:55,981
负在那里的 分配 数量 

523
00:33:53,087 --> 00:33:58,896
补，当你做一个移 

524
00:33:56,179 --> 00:33:59,184
这将是一个算术移位 

525
00:34:06,077 --> 00:34:12,706
所以又 回到 了他们这个总结 

526
00:34:09,098 --> 00:34:14,787
你看到的第一个 整数运算 

527
00:34:13,399 --> 00:34:18,730
所有不管 是签署 您的签名 

528
00:34:15,669 --> 00:34:23,200
的加法或乘法 

529
00:34:18,073 --> 00:34:26,078
操作是一样的它是否是一个 

530
00:34:23,002 --> 00:34:31,055
无符号数或补和

531
00:34:27,023 --> 00:34:33,029
它的工作原理负面 的东西出来的作品作为 

532
00:34:31,073 --> 00:34:38,242
只要 你 没有溢出和 

533
00:34:33,083 --> 00:34:40,132
你也可以通过溢出最终只有一个

534
00:34:38,899 --> 00:34:44,300
在两个无符号溢出型

535
00:34:40,879 --> 00:34:47,240
类型4 符号数，但它不是 

536
00:34:44,003 --> 00:34:50,054
像他们只是溢出且产生 

537
00:34:47,024 --> 00:34:52,121
随机数 有一些图案 

538
00:34:50,081 --> 00:34:55,123
什么导致它们是什么，以及如何 

539
00:34:53,021 --> 00:34:56,023
他们可以 解释 

540
00:35:00,065 --> 00:35:06,066
所以我谈到这一点 

541
00:35:03,099 --> 00:35:07,176
最后一次，给了类似的这个例子 

542
00:35:06,075 --> 00:35:12,117
这可是让我走 在它一点点 

543
00:35:08,076 --> 00:35:15,078
你可能会觉得有点一件事

544
00:35:13,017 --> 00:35:18,033
而如果它是无符号和签署的东西 

545
00:35:15,078 --> 00:35:20,094
变得这么黑暗 ，我们看到了一些有趣的 

546
00:35:18,033 --> 00:35:23,109
例子最后一次也许我们应该 

547
00:35:20,094 --> 00:35:25,185
从消失的无符号数 

548
00:35:24,009 --> 00:35:29,103
宇宙，只允许补 

549
00:35:26,085 --> 00:35:31,089
而这正是 这是规则 

550
00:35:30,003 --> 00:35:37,005
在Java中采用例如他们说 

551
00:35:32,025 --> 00:35:38,121
这太诡异了 什么让我们只 说 

552
00:35:37,023 --> 00:35:44,075
每一个数字是二进制补码

553
00:35:39,021 --> 00:35:52,032
只是他们做的诀窍是他们 把一个 

554
00:35:44,075 --> 00:36:01,170
三重右移指逻辑移位 

555
00:35:52,032 --> 00:36:06,125
这 是Java中，这不是C，而 

556
00:36:02,007 --> 00:36:06,062
双是一个 算术 

557
00:36:13,022 --> 00:36:18,098
是因为他们上涨有很多的

558
00:36:16,007 --> 00:36:20,406
当你要玩可爱的小 倍 

559
00:36:18,098 --> 00:36:24,122
事情的技巧和你需要的 

560
00:36:21,099 --> 00:36:27,560
逻辑率移 ，这实际上 

561
00:36:25,022 --> 00:36:29,117
一种方法或其他更现代

562
00:36:27,056 --> 00:36:32,063
语言和 Si 说这没关系 

563
00:36:30,017 --> 00:36:34,052
有符号和无符号，但我们不这样做 

564
00:36:32,063 --> 00:36:35,072
希望他们有点神秘地被

565
00:36:34,052 --> 00:36:38,099
投来回的方式，将

566
00:36:36,053 --> 00:36:41,632
程序员可能无法识别等 

567
00:36:38,099 --> 00:36:43,166
你必须明确地做一个投 

568
00:36:42,109 --> 00:36:46,790
而不是含蓄，我想 

569
00:36:44,066 --> 00:36:48,985
这是更好的做法，但看到我 

570
00:36:46,079 --> 00:36:52,106
提到这是否隐式转换 和 

571
00:36:49,579 --> 00:36:59,990
所以正如我们所看到的最后一次会发生什么

572
00:36:53,006 --> 00:37:03,098
有了这个程序，当 你运行它 

573
00:36:59,099 --> 00:37:05,122
通过阵列倒计时你 

574
00:37:03,098 --> 00:37:05,122
记得 

575
00:37:08,078 --> 00:37:16,142
还有我，如果是无符号 会出现什么 

576
00:37:13,007 --> 00:37:18,079
这个测试总是成功发生 

577
00:37:17,042 --> 00:37:21,065
这样的事情将是一个无限 循环 

578
00:37:19,042 --> 00:37:24,119
居然会发生什么是它 会尝试 

579
00:37:21,065 --> 00:37:27,122
访问我 会下降到 0，然后 

580
00:37:25,019 --> 00:37:30,178
它 会环绕 成为 

581
00:37:28,022 --> 00:37:31,115
最大可能的无符号数，其 

582
00:37:30,349 --> 00:37:34,350
可能是出路的平衡; 

583
00:37:32,015 --> 00:37:37,031
会给出一个内存错误

584
00:37:34,359 --> 00:37:38,458
但它不会做什么的应该是 

585
00:37:37,031 --> 00:37:40,127
正如我这些事情之前提到的

586
00:37:39,349 --> 00:37:43,640
有很多不方便的方面，这 

587
00:37:41,027 --> 00:37:46,052
可问题的方式显示出来你可能

588
00:37:43,064 --> 00:37:52,033
从来没有想到这样的例子中， 

589
00:37:46,052 --> 00:37:55,118
运营商的sizeof定义说 有 

590
00:37:52,609 --> 00:37:58,880
大一个特定的 数据类型 是它是一个非常 

591
00:37:56,018 --> 00:38:01,927
有用的运营商，但它是它的回归 

592
00:37:58,088 --> 00:38:03,163
值是 一个什么叫做大小 

593
00:38:02,089 --> 00:38:09,162
强调其定义 是 T 

594
00:38:04,063 --> 00:38:12,071
长无符号数，因此，如果我们只是 

595
00:38:09,819 --> 00:38:16,640
在这样的不断抛出那么 这 

596
00:38:13,043 --> 00:38:19,130
减法，我们有一个迹象 是现在诠释 

597
00:38:16,064 --> 00:38:23,101
但的sizeof是无符号的，所以它会 

598
00:38:20,003 --> 00:38:26,024
强制转换为无符号的含蓄 和 

599
00:38:24,001 --> 00:38:30,610
当你把它比作0您将有 

600
00:38:26,051 --> 00:38:32,063
同样的问题，因为以前那么只是为了 显示 

601
00:38:30,619 --> 00:38:37,010
你 认为 这些 东西可以说在 

602
00:38:32,063 --> 00:38:41,081
非常棘手的方式，使一个这样做的方式 

603
00:38:37,001 --> 00:38:47,008
然后只是不要使用无符号 等， 

604
00:38:41,081 --> 00:38:50,102
要确保，如果这是可能的AA 

605
00:38:47,071 --> 00:38:53,430
无符号数，你 将 其转换 为签署 

606
00:38:51,002 --> 00:38:57,011
你要确保这是公认签署 

607
00:38:54,069 --> 00:38:59,510
但还有另一种方式，实际上是在 

608
00:38:57,092 --> 00:39:00,113
至少有 在 的一个老乡 在 

609
00:38:59,051 --> 00:39:04,052
软件工程 学会评选 

610
00:39:01,013 --> 00:39:10,031
罗伯特·塞科德谁 写书 

611
00:39:04,052 --> 00:39:12,119
被 认为越早的 黄金 

612
00:39:10,031 --> 00:39:14,093
标准如何编写安全的代码，他 

613
00:39:13,019 --> 00:39:16,678
适用于这个组织叫 

614
00:39:14,093 --> 00:39:20,165
计算机应急响应团队， 

615
00:39:16,849 --> 00:39:25,849
就在那里跟踪坏事 

616
00:39:21,065 --> 00:39:27,143
在计算机 安全 和一个 事 

617
00:39:25,849 --> 00:39:29,893
他和其他人做的事情是

618
00:39:28,043 --> 00:39:33,712
试着拿出标准，使 

619
00:39:30,289 --> 00:39:36,230
谁写程序的人会知道 

620
00:39:34,099 --> 00:39:37,670
避免一些让陷阱 

621
00:39:36,023 --> 00:39:41,027
他们的节目易受 

622
00:39:37,067 --> 00:39:43,070
法律 安全 攻击等他 

623
00:39:41,063 --> 00:39:45,101
推荐的技术是，当 我第一 

624
00:39:43,097 --> 00:39:51,706
看到这个它是如此有悖常理 来 

625
00:39:46,001 --> 00:39:54,008
我 来说它几乎是有道理的权利，所以 你 

626
00:39:52,579 --> 00:39:57,410
开始， 这同样是所有未经签名 

627
00:39:54,071 --> 00:40:00,720
算术所以我开始倒计时

628
00:39:57,041 --> 00:40:03,700
我测试的时候我不到计数

629
00:40:01,359 --> 00:40:06,406
所以这里是我开始的东西

630
00:40:04,069 --> 00:40:09,145
小于计数，它只是为

631
00:40:06,829 --> 00:40:16,970
递减所以当将这个测试过 

632
00:40:09,829 --> 00:40:19,940
失败嗯，当它溢出时，它会返回 

633
00:40:16,097 --> 00:40:21,191
围绕权 当 我从 零和 

634
00:40:19,094 --> 00:40:25,483
计数下降到 现在什么是你最大 

635
00:40:22,091 --> 00:40:27,188
这 会导致 测试 失败而这正是 

636
00:40:26,329 --> 00:40:31,670
当你想让 它停下来 了 

637
00:40:28,088 --> 00:40:33,101
观察是看有符号

638
00:40:31,067 --> 00:40:36,496
数字有 上 没有保证 什么 

639
00:40:34,001 --> 00:40:38,069
与我说，大部分发生溢出

640
00:40:37,099 --> 00:40:40,520
人们只是认为这将是 

641
00:40:38,069 --> 00:40:41,144
补，但是如果你真的想 

642
00:40:40,052 --> 00:40:44,090
要小心， 你不应该假设 

643
00:40:42,044 --> 00:40:46,143
C标准的 以外的任何与 

644
00:40:44,009 --> 00:40:48,041
如果你想编写安全的代码 

645
00:40:46,539 --> 00:40:53,572
它可能是一个好主意，要谨慎 

646
00:40:49,022 --> 00:40:56,063
是 另一方面的C保守 

647
00:40:53,869 --> 00:40:59,000
标准保证了它是无符号

648
00:40:56,063 --> 00:41:00,071
算术将模运算等等 

649
00:40:59,000 --> 00:41:04,019
它保证，如果你减去一个

650
00:41:01,043 --> 00:41:07,139
从 零，你会得到最多 

651
00:41:04,019 --> 00:41:11,698
这 可以 表示所以这将是 

652
00:41:08,039 --> 00:41:14,188
好吧 ，事实上他建议，而不是 

653
00:41:11,869 --> 00:41:18,140
使用无符号这是对我们的

654
00:41:14,539 --> 00:41:21,547
机只是一个32位的值，可以 

655
00:41:18,014 --> 00:41:25,723
称之为码T这是 一个64位 的值 

656
00:41:21,619 --> 00:41:28,670
所以，写代码的方式， 

657
00:41:25,849 --> 00:41:30,868
我给你，所以我实际上已经 开始 

658
00:41:28,067 --> 00:41:32,686
这样 ，一旦你样的习惯 

659
00:41:31,039 --> 00:41:34,260
它 是写代码的OK的方式 ，但 

660
00:41:33,289 --> 00:41:37,890
这是很 

661
00:41:34,026 --> 00:41:44,121
奇怪的看着这样一件事 

662
00:41:37,089 --> 00:41:49,128
我要指出的是会发生什么，如果 

663
00:41:45,021 --> 00:41:55,059
如果数是有符号数 和INT 

664
00:41:50,028 --> 00:42:01,035
它是你，这 是少 

665
00:41:55,059 --> 00:42:10,062
大于零的有什么 会发生在这里 等我 

666
00:42:01,098 --> 00:42:12,141
不到数会 发生 什么样 的权利 

667
00:42:10,089 --> 00:42:14,172
因此它成为一个非常 大的正 

668
00:42:13,041 --> 00:42:17,139
数量和本次测试 将几乎 

669
00:42:15,072 --> 00:42:20,091
一定会成功，所以你有相同的

670
00:42:18,039 --> 00:42:24,057
这个代码不避陷阱它 

671
00:42:20,091 --> 00:42:25,182
只是把它转移到说你最好使 

672
00:42:24,057 --> 00:42:30,149
确保你不知道这个测试 

673
00:42:26,082 --> 00:42:36,120
如果你进入它之前事先 

674
00:42:31,049 --> 00:42:38,142
所以我觉得它的一部分 是观察 

675
00:42:37,002 --> 00:42:43,014
那个男人，如果你要小心和 

676
00:42:39,042 --> 00:42:45,114
编写代码， 这是保证 

677
00:42:43,032 --> 00:42:47,097
正确的不管是什么实现 

678
00:42:46,014 --> 00:42:50,040
只要它是 CIE 内继续

679
00:42:47,097 --> 00:42:59,121
标准这是相当棘手的业务 

680
00:42:50,004 --> 00:43:04,059
怀疑那里是

681
00:43:00,021 --> 00:43:07,028
这是不幸的权 所以是这 

682
00:43:04,095 --> 00:43:08,181
正是它的隐含规则 

683
00:43:07,028 --> 00:43:12,114
默默的C编译器不给任何 

684
00:43:09,081 --> 00:43:16,110
警告你永远不知道它转换 它的 

685
00:43:13,014 --> 00:43:19,083
无符号和这些 例子表明，当 

686
00:43:17,001 --> 00:43:22,089
你盯着代码，你认为 

687
00:43:19,083 --> 00:43:24,102
了解 它真的很容易 有错误 

688
00:43:22,098 --> 00:43:26,130
您刚才你可以看看它 

689
00:43:25,002 --> 00:43:31,005
一千次，没有意识到 它的 

690
00:43:27,003 --> 00:43:34,032
错误这是一个非常并且有实例 

691
00:43:31,032 --> 00:43:38,034
书中安全的这些例子

692
00:43:34,059 --> 00:43:42,104
在排序非常重要的库缺陷

693
00:43:38,034 --> 00:43:42,041
软件 由于这个问题正是 

694
00:43:44,047 --> 00:43:48,119
所以我们在教学的部分原因

695
00:43:46,094 --> 00:43:52,503
当然是只是让你明白， 

696
00:43:49,019 --> 00:43:56,848
这是 这 一个怪癖 ，看到 

697
00:43:53,349 --> 00:43:59,422
再次 的99％的时间你 甚至 永远 都 

698
00:43:57,019 --> 00:44:02,026
它不会打扰你的所有，但有 

699
00:44:00,079 --> 00:44:08,173
会有一些古怪的情况下，你可以 

700
00:44:02,089 --> 00:44:13,156
惹上麻烦 这么其它地方 

701
00:44:09,019 --> 00:44:16,045
你会 发现无符号运算 

702
00:44:13,759 --> 00:44:17,794
有用的无符号表示是第一 

703
00:44:16,279 --> 00:44:21,650
当你做模块化的所有

704
00:44:18,109 --> 00:44:25,670
算术其例如 路 

705
00:44:21,065 --> 00:44:27,092
大多数加密算法的工作或当 

706
00:44:25,067 --> 00:44:30,226
您正在使用的比特不代表 

707
00:44:27,092 --> 00:44:34,681
数字，但表示台的路上我 

708
00:44:30,829 --> 00:44:38,180
描述它之前， 你不希望 

709
00:44:35,509 --> 00:44:45,544
它是最容易 只是觉得， 作为 

710
00:44:38,018 --> 00:44:48,095
无符号数好了 ，所以最后 的事情 

711
00:44:45,859 --> 00:44:50,950
今天 要谈 的 是一些 

712
00:44:48,095 --> 00:44:54,994
数字的低级别交涉 

713
00:44:51,769 --> 00:45:00,825
存储器内，并且主要的一点是当 

714
00:44:55,849 --> 00:45:00,897
您在计算机上 运行的程序 

715
00:45:01,509 --> 00:45:07,640
从编程的角度 无论是 

716
00:45:04,004 --> 00:45:10,633
甚至作为一个组件水平程序员不 

717
00:45:07,064 --> 00:45:12,493
就像在你的心中一个C程序员 

718
00:45:11,029 --> 00:45:15,100
内存字节的只是这个大阵 

719
00:45:13,069 --> 00:45:19,092
这是一个从0开始编号高达一些 

720
00:45:15,739 --> 00:45:22,824
最大数量，以便例如在

721
00:45:19,299 --> 00:45:29,450
我们使用64位机器的机器

722
00:45:23,589 --> 00:45:31,880
的地址被以64个比特表示，但 

723
00:45:29,045 --> 00:45:34,141
其实最大地址你

724
00:45:31,088 --> 00:45:40,091
不允许在当前机器使用 一个 

725
00:45:35,041 --> 00:45:43,420
47位和到 第四十七是 

726
00:45:41,018 --> 00:45:46,115
仍然是一个相当 大 的 数量， 以便 更 

727
00:45:43,789 --> 00:45:49,190
内存比任何人的能 买权 

728
00:45:47,015 --> 00:45:51,044
现在无论如何，所以它是一个合理的

729
00:45:49,019 --> 00:45:54,026
限制，但问题是， 

730
00:45:51,044 --> 00:45:56,453
逻辑程序认为它 

731
00:45:54,089 --> 00:45:58,089
具有的阵列

732
00:45:56,849 --> 00:46:00,854
在许多叮咬 ，让我们试着找出 

733
00:45:58,089 --> 00:46:08,228
任何人有多大，以四十七 知道它关闭 

734
00:46:01,349 --> 00:46:12,397
他们的头顶 ， 所以有窍门 

735
00:46:09,029 --> 00:46:12,037
如果你想获得一个大致的想法 

736
00:46:13,097 --> 00:46:23,121
这是 说，2 至10日 这 

737
00:46:18,809 --> 00:46:29,190
是110 24约等于 10 

738
00:46:24,021 --> 00:46:31,610
第三 ，你说哦 那 

739
00:46:29,019 --> 00:46:36,428
真正有用的 是什么意思的是，10 

740
00:46:31,799 --> 00:46:38,630
位数的身价是差不多的

741
00:46:36,599 --> 00:46:48,180
作为 三个十进制数字 

742
00:46:38,063 --> 00:46:56,942
没事因此，例如2到20 

743
00:46:48,018 --> 00:47:03,093
大约是10〜6 2到它的第30 

744
00:46:57,509 --> 00:47:08,543
约10至9日到周围40 

745
00:47:03,093 --> 00:47:14,642
10至12日 ，因此这会告诉 

746
00:47:08,849 --> 00:47:17,870
你说2到48-47 大约是 128 

747
00:47:15,479 --> 00:47:23,430
乘以10， 其是128第十二

748
00:47:18,059 --> 00:47:26,078
TB的正确的塔拉 10到12，所以如果 

749
00:47:23,043 --> 00:47:28,922
你只想说你也知道得到 

750
00:47:26,249 --> 00:47:31,301
快图4，当然这些都是 

751
00:47:29,309 --> 00:47:34,170
近似的，但如果你只是想 

752
00:47:31,769 --> 00:47:35,777
得到了多大的次数迅速把手 

753
00:47:34,017 --> 00:47:38,091
你知道什么值范围 可我 

754
00:47:36,569 --> 00:47:42,569
与它这个很多位代表

755
00:47:38,091 --> 00:47:44,190
是 一个非常简单的 把戏 做到这一点，因此 

756
00:47:42,569 --> 00:47:51,960
点是128兆兆字节

757
00:47:45,009 --> 00:47:53,438
是很多，你可以买到磁盘驱动器 

758
00:47:51,096 --> 00:47:55,191
夫妇磁盘驱动器会替 

759
00:47:54,329 --> 00:47:59,700
你，但你不能买上没有足够的DRAM 

760
00:47:56,091 --> 00:48:01,146
正常预算得到的那种 

761
00:47:59,007 --> 00:48:04,029
内存中，这样的电流 范围 

762
00:48:02,046 --> 00:48:08,075
值，但在逻辑上，当您运行

763
00:48:04,092 --> 00:48:09,150
程序它认为它有 

764
00:48:08,489 --> 00:48:12,900
现在可能范围之

765
00:48:10,005 --> 00:48:15,006
并不是真的，事实上发生了什么 

766
00:48:12,009 --> 00:48:16,100
是操作系统只允许 

767
00:48:15,051 --> 00:48:20,067
该存储器内的某些区域是 

768
00:48:17,081 --> 00:48:22,116
引用等地区，如果你尝试

769
00:48:20,067 --> 00:48:24,075
访问这些它会创建一个它会 

770
00:48:23,016 --> 00:48:27,108
发出错误信号人们常说的 

771
00:48:24,075 --> 00:48:28,173
分段错误，但 在逻辑 

772
00:48:28,008 --> 00:48:32,040
至少这是因为，如果你有这个大阵 

773
00:48:29,073 --> 00:48:33,102
现在的字节在现实中 ，我们会去 

774
00:48:32,004 --> 00:48:38,090
到这个时候，我们谈论 的是如何 

775
00:48:34,002 --> 00:48:39,026
存储系统虚拟内存的作品

776
00:48:40,061 --> 00:48:45,084
有这种非常复杂的组合 

777
00:48:43,044 --> 00:48:48,093
硬件和 软件， 使该 

778
00:48:45,084 --> 00:48:51,090
节目的一个非常大的这一形象是什么 

779
00:48:48,093 --> 00:48:53,138
你叫襟翼空间只是一个大阵列 

780
00:48:51,009 --> 00:48:56,073
而实际上它的洗牌字节

781
00:48:54,038 --> 00:48:59,064
你的内存的 不同区域之间

782
00:48:57,054 --> 00:49:02,063
甚至你的记忆和你之间 

783
00:48:59,064 --> 00:49:08,073
在您的 计算机 上的磁盘驱动器 ，使它 

784
00:49:03,044 --> 00:49:11,061
实现这个特别的想法，你 

785
00:49:09,054 --> 00:49:13,089
有个字节的这个大阵，这就是

786
00:49:11,061 --> 00:49:16,125
所有处理正如我所说的 操作 

787
00:49:13,089 --> 00:49:18,144
系统 由计算机硬件 ，它的 

788
00:49:17,025 --> 00:49:20,112
主要是无形 甚至到 机器 

789
00:49:19,044 --> 00:49:29,118
级程序员甚至还有人写

790
00:49:21,012 --> 00:49:32,028
汇编代码，你会经常听到这个词

791
00:49:30,018 --> 00:49:35,055
字的大小，它可以变得 非常混乱 

792
00:49:32,028 --> 00:49:37,112
如今混乱的，因为没有 

793
00:49:35,055 --> 00:49:41,055
的字长是真正固定观念

794
00:49:38,012 --> 00:49:45,081
但大致来说字长 

795
00:49:41,055 --> 00:49:51,102
应该是无论数量最多 

796
00:49:45,081 --> 00:49:54,102
表示的该或范围那样

797
00:49:52,002 --> 00:49:58,065
有多大的指针是在此语言或 

798
00:49:55,002 --> 00:50:01,002
明智五金最大的 那种大块的 

799
00:49:58,065 --> 00:50:02,121
硬件针对有标准 

800
00:50:01,002 --> 00:50:06,018
用于存放算术支持

801
00:50:03,021 --> 00:50:09,045
操作等等，所以当我们说 

802
00:50:06,018 --> 00:50:12,050
这是一个64位的 机器我们的意思是 

803
00:50:09,045 --> 00:50:15,117
它它经常和定期 

804
00:50:12,005 --> 00:50:19,026
操纵 64位值宁可 

805
00:50:16,017 --> 00:50:22,095
算术运算并且还具有 

806
00:50:19,071 --> 00:50:23,130
指针或地址的值是

807
00:50:22,095 --> 00:50:27,147
64 位 

808
00:50:24,003 --> 00:50:30,027
即使现在 只有 47 

809
00:50:28,047 --> 00:50:34,068
位是可用的，它仍然 被认为是 

810
00:50:30,054 --> 00:50:40,095
64位计算机一件事情 ，奇怪的是， 

811
00:50:34,068 --> 00:50:48,129
在机器的的特征之一

812
00:50:40,095 --> 00:50:52,116
比如我们吧，如果我编译 

813
00:50:49,029 --> 00:50:56,061
使用GCC 标准的程序

814
00:50:53,016 --> 00:51:02,052
编译器我可以指定 我想它 

815
00:50:56,061 --> 00:51:07,146
为64位的代码或32位代码 作为 

816
00:51:02,052 --> 00:51:10,056
标志，它实际上会生成两个 

817
00:51:08,046 --> 00:51:13,065
不同种类 的对象代码作为 

818
00:51:10,092 --> 00:51:15,171
结果，我们将在一起来看看有关谈话

819
00:51:13,065 --> 00:51:19,122
这些后来但对现在的点 

820
00:51:16,071 --> 00:51:22,100
是硬件本身不 

821
00:51:20,022 --> 00:51:25,068
一定规定字长是 什么 

822
00:51:23,000 --> 00:51:27,081
它是整合了硬件和 

823
00:51:25,068 --> 00:51:29,130
决定什么 是编译器

824
00:51:27,081 --> 00:51:32,172
字的大小 在此 特定 使用 

825
00:51:30,003 --> 00:51:36,018
程序和代码可以 在运行 

826
00:51:33,072 --> 00:51:38,133
点是64比特机器， 如我们 

827
00:51:36,045 --> 00:51:43,086
有大部分机器都可以时下 

828
00:51:39,033 --> 00:51:51,117
插入的向后兼容性风格

829
00:51:43,086 --> 00:51:54,117
还 执行32位代码，并为我们也 

830
00:51:52,017 --> 00:51:57,036
看到的其他特征之一，即使是 

831
00:51:55,017 --> 00:52:01,029
虽然这是一个64位字长的数据 

832
00:51:57,036 --> 00:52:04,068
没有任何其它限定符来int类型

833
00:52:01,029 --> 00:52:07,035
它仅仅是32位 ，因此排序的这 

834
00:52:04,068 --> 00:52:09,150
到底有多大的事情都那么当混合 

835
00:52:07,035 --> 00:52:12,057
人们只是说的词或字的大小 和 

836
00:52:10,005 --> 00:52:14,010
假设给出一个确切的定义 

837
00:52:12,057 --> 00:52:16,062
这不是一个非常有意义的期限和

838
00:52:15,000 --> 00:52:19,038
我们有点把它周围的时候，我们 

839
00:52:17,007 --> 00:52:21,012
意味着排序位的通用块的

840
00:52:19,038 --> 00:52:24,047
不尝试假设它有一个 

841
00:52:21,057 --> 00:52:24,128
位 到它 的特定数 

842
00:52:34,009 --> 00:52:42,017
是这样的事情之一是，如果我们曾经

843
00:52:37,076 --> 00:52:46,130
得到64位的话 这将是16 

844
00:52:43,007 --> 00:52:48,100
高数量18个PB的意见 如何 

845
00:52:47,003 --> 00:52:53,006
当这些数字变大定义

846
00:52:49,063 --> 00:52:57,089
误差由于这种近似变 

847
00:52:53,033 --> 00:52:59,114
更显著但一些10倍

848
00:52:57,089 --> 00:53:11,120
到15字节，但现在我们可以 

849
00:53:00,014 --> 00:53:14,096
只得到128次，每次10到 12这样 

850
00:53:12,002 --> 00:53:17,084
反正它的想法， 记忆 

851
00:53:14,096 --> 00:53:20,153
本身就是一系列的字节数，但我们可以 

852
00:53:18,002 --> 00:53:24,020
基团的那些成的字块 

853
00:53:21,053 --> 00:53:28,130
不同的字长，我们做的方式 

854
00:53:24,002 --> 00:53:33,008
通常是通过假定 的 

855
00:53:29,003 --> 00:53:35,099
字的地址是最低值

856
00:53:33,008 --> 00:53:40,069
解决它，我们通常还会

857
00:53:36,026 --> 00:53:47,125
尝试协调这使得例如一个 

858
00:53:41,041 --> 00:53:50,042
32位字将是一个行，以便 它的第一 

859
00:53:47,359 --> 00:53:53,770
字节的最低字节在所有零

860
00:53:50,051 --> 00:53:53,077
弗里克东西

861
00:53:57,059 --> 00:54:05,066
在前五位位置向右 

862
00:54:01,569 --> 00:54:08,920
现年32 4 对不起最低的两个字节 

863
00:54:05,759 --> 00:54:15,880
右从而这个例子说明了其 

864
00:54:08,092 --> 00:54:16,731
地址是0 4 8和12，他们应该有 

865
00:54:15,088 --> 00:54:20,140
真的写了这个十六进制，并说这是

866
00:54:17,559 --> 00:54:23,631
C I想这些都是十进制 

867
00:54:21,004 --> 00:54:27,453
无论如何所以是这些都是十进制数 

868
00:54:24,279 --> 00:54:31,286
所以0 4 8 12 所以你看这些都是 

869
00:54:27,849 --> 00:54:33,970
的比特边界的4的倍数和 

870
00:54:31,349 --> 00:54:36,423
类似地，64位的字是在 

871
00:54:33,097 --> 00:54:38,140
8的倍数和那些被称为 

872
00:54:37,089 --> 00:54:41,230
对齐的字，并且一般 会 

873
00:54:39,004 --> 00:54:42,079
见编译器工作很辛苦 

874
00:54:41,023 --> 00:54:44,098
让事情，因为对齐 

875
00:54:43,015 --> 00:54:48,091
硬件更有效地运行， 这样 

876
00:54:44,098 --> 00:54:49,917
但主要的一点是 ， 我们可以只 

877
00:54:48,091 --> 00:54:51,172
因为我们希望采取尽可能多的字节， 

878
00:54:50,799 --> 00:54:57,700
收集在一起，并把它称为一个字 

879
00:54:52,072 --> 00:54:58,851
不管是什么字的大小，我们需要和我们 

880
00:54:57,007 --> 00:55:00,846
认为我们看到这个表的一个变种 

881
00:54:59,499 --> 00:55:04,581
之前，但 这样 的机器，我们会 

882
00:55:01,539 --> 00:55:09,460
工作的标准int是 

883
00:55:05,319 --> 00:55:12,210
仍然只有32 位 ，但如果我们晋级 

884
00:55:09,046 --> 00:55:15,088
一些为错误的，那么这将是 

885
00:55:12,021 --> 00:55:16,880
64位， 往往会做到这一点有 

886
00:55:15,088 --> 00:55:17,817
两个不同的浮点 

887
00:55:17,069 --> 00:55:21,138
我们将谈论交涉

888
00:55:18,609 --> 00:55:25,480
然后一个64 位 的主要特征 

889
00:55:21,759 --> 00:55:30,792
机是它有一个8字节或64位

890
00:55:25,048 --> 00:55:34,117
指针相比，32现在有 

891
00:55:31,089 --> 00:55:38,130
一个其他类型的细节， 说好了，所以 

892
00:55:35,017 --> 00:55:40,416
如果一个单词中有多个字节什么 

893
00:55:38,499 --> 00:55:44,980
为了应这些字节是 它 应该 是 

894
00:55:40,569 --> 00:55:47,615
在这两个 基本方面，这可能 

895
00:55:44,098 --> 00:55:49,707
去一个就是你把 字节 

896
00:55:48,029 --> 00:55:52,083
什么是被称为小尾数顺序 

897
00:55:50,589 --> 00:55:54,940
这意味着 在单词 的 第一个字节 

898
00:55:52,569 --> 00:55:57,880
是最显著字节，然后 

899
00:55:54,094 --> 00:55:58,189
接下来再 下 ，最终 

900
00:55:57,088 --> 00:56:03,097
在字字节是最显著 

901
00:55:59,089 --> 00:56:04,788
或者你可以翻转周围那些 

902
00:56:03,097 --> 00:56:08,118
被称为小端和大端

903
00:56:05,589 --> 00:56:09,180
是个 

904
00:56:09,031 --> 00:56:18,330
排序条件的那所附带

905
00:56:12,099 --> 00:56:20,410
从英语书叫格列佛 

906
00:56:18,609 --> 00:56:23,680
游记里面也没有预料 

907
00:56:20,041 --> 00:56:24,139
在所有的计算机，但它是一个有趣的 

908
00:56:23,068 --> 00:56:26,997
如何自带约故事

909
00:56:25,039 --> 00:56:29,508
所以在外面的世界，你会发现 

910
00:56:27,609 --> 00:56:31,707
这两种类型的 机器 大的印度和 

911
00:56:29,859 --> 00:56:34,780
事实证明，小印度的机器， 

912
00:56:32,589 --> 00:56:38,290
越来越它越来越难找到 

913
00:56:34,078 --> 00:56:42,387
印度大型机器那么一点实际上所有 

914
00:56:38,029 --> 00:56:45,098
86是小印度和原来 

915
00:56:43,089 --> 00:56:48,910
ARM处理器一样，你有什么

916
00:56:45,359 --> 00:56:52,990
这里几乎每个手机是ARM 

917
00:56:48,091 --> 00:56:54,091
处理器和硬件和那些罐 

918
00:56:52,099 --> 00:56:57,948
实际上被配置为运行无论哪种方式 

919
00:56:54,091 --> 00:56:59,176
大端或小端，但是当 

920
00:56:58,839 --> 00:57:02,560
你在任何 标准的运行它 

921
00:57:00,076 --> 00:57:06,079
上ARM上运行的操作系统 

922
00:57:02,056 --> 00:57:09,103
处理器则它的运行 小 

923
00:57:06,079 --> 00:57:12,378
印度因此曾经有 一个品牌 

924
00:57:10,003 --> 00:57:16,075
所谓Sun Microsystems和他们 

925
00:57:13,089 --> 00:57:20,230
在校园里相当普遍的，然后再 在 

926
00:57:16,075 --> 00:57:21,172
在Macintosh他们前86 

927
00:57:20,023 --> 00:57:26,071
处理器他们跑了一个叫

928
00:57:22,072 --> 00:57:28,191
PowerPC的， 这是一个大引擎 

929
00:57:26,071 --> 00:57:31,126
机器，但这些都是长在 

930
00:57:28,839 --> 00:57:34,990
遥远的过去有关的唯一互联网 

931
00:57:32,026 --> 00:57:37,365
放置在那里，当你发送的数据包 

932
00:57:34,099 --> 00:57:40,108
在 互联网 上 ，你 要发送 的 

933
00:57:37,599 --> 00:57:43,690
他们实际上是在发送 32位 字 

934
00:57:41,008 --> 00:57:45,100
大端秩序等在网络 

935
00:57:43,069 --> 00:57:48,978
接口就得之间进行转换 

936
00:57:46,000 --> 00:57:54,055
这两个如此反复 只是 为了说明 

937
00:57:49,599 --> 00:57:57,540
我的意思是，这是一个字节的思考 

938
00:57:54,055 --> 00:58:00,082
像这样和字节值值

939
00:57:57,054 --> 00:58:02,071
请记住，在路上，我们写号 

940
00:58:00,082 --> 00:58:04,105
是我们把最显著的

941
00:58:02,071 --> 00:58:06,126
左边和最不显著 

942
00:58:05,005 --> 00:58:07,026
对

943
00:58:09,059 --> 00:58:16,082
所以现在有一个 大端 插入 

944
00:58:13,038 --> 00:58:19,247
从这一角度直观一个

945
00:58:16,289 --> 00:58:21,362
在自行车 ，如果你写的字 

946
00:58:19,589 --> 00:58:24,602
从最小地址内存 

947
00:58:22,019 --> 00:58:27,083
以最高的大端将整理 

948
00:58:24,719 --> 00:58:30,758
映射到你所看到的 ， 而 

949
00:58:27,659 --> 00:58:36,686
小尾数看起来很奇怪的是 

950
00:58:31,109 --> 00:58:38,180
你说0 1 2 3 4 5 6 7 6因为7是 

951
00:58:36,929 --> 00:58:40,890
实际上至少显著 这里 字节 

952
00:58:38,819 --> 00:58:46,820
所以在首先出现在小尾数 

953
00:58:40,089 --> 00:58:48,090
顺序和与如此使用的它是

954
00:58:46,919 --> 00:58:51,900
人们会得到热情的论据 

955
00:58:48,009 --> 00:58:56,858
这个那种 在遥远 

956
00:58:51,009 --> 00:58:59,828
过去，但人们 说你知道和 

957
00:58:57,749 --> 00:59:02,880
在 某种主要 特征 

958
00:59:00,719 --> 00:59:04,775
印度 大型 坚果 的说法是这样的 

959
00:59:02,088 --> 00:59:07,427
此功能 ，当 你看它 

960
00:59:05,279 --> 00:59:09,362
它更容易写下来，但电脑

961
00:59:08,219 --> 00:59:11,297
真的不关心他们要么很高兴

962
00:59:10,109 --> 00:59:13,202
方式 ，所以他们只是 想要一个约定 

963
00:59:11,999 --> 00:59:17,006
或另一就像我说的一些 

964
00:59:14,039 --> 00:59:19,097
硬件的可以通过一种实际上是一个 

965
00:59:17,069 --> 00:59:21,161
标志以被大端翻转 

966
00:59:19,619 --> 00:59:24,626
到小印度， 但 现实的情况是 最 

967
00:59:21,989 --> 00:59:27,083
机器一个计数器 ， 你会遇到 

968
00:59:24,689 --> 00:59:30,691
小端机stoudek只是 

969
00:59:27,929 --> 00:59:32,993
在这里举一个例子是一些 

970
00:59:30,709 --> 00:59:36,710
结果我从实际 的机器 了 

971
00:59:33,569 --> 00:59:38,880
曾经有一些机器 使 周围 

972
00:59:36,809 --> 00:59:40,844
早在过去，我可以运行这个我 

973
00:59:38,088 --> 00:59:43,247
甚至不知道从哪里 得到大 

974
00:59:41,159 --> 00:59:48,215
endian机器了，所以这些都是排序 

975
00:59:44,039 --> 00:59:50,114
传统的结果 ，但你会看到， 

976
00:59:48,719 --> 00:59:52,766
主要特点是小印度之间

977
00:59:50,789 --> 00:59:56,630
和大端机器 ，当你 有 

978
00:59:53,189 --> 00:59:59,243
整数自行车出行翻转 

979
00:59:56,063 --> 01:00:01,342
使再 显著 字节来 

980
00:59:59,729 --> 01:00:05,780
首先在小端机 

981
01:00:01,909 --> 01:00:08,942
最后在大端机器，这就是 

982
01:00:06,239 --> 01:00:13,241
负数也是如此说 

983
01:00:09,239 --> 01:00:17,730
你会在一个大先拿到符号位 

984
01:00:13,259 --> 01:00:22,440
endian机器长时间 

985
01:00:17,073 --> 01:00:24,132
你会看到， 唯一 的 区别 

986
01:00:22,044 --> 01:00:27,045
32位 机器64位 之间 

987
01:00:25,032 --> 01:00:28,128
机器是你有更多的零以上

988
01:00:27,045 --> 01:00:33,054
那些视 它是否是一个积极的 

989
01:00:29,028 --> 01:00:37,071
或负数 ，再次 太阳和 

990
01:00:34,035 --> 01:00:40,035
如果我有访问64位机 太阳 

991
01:00:37,071 --> 01:00:42,129
现在由一家名为制造

992
01:00:40,035 --> 01:00:44,067
甲骨文所以在原则上我可以去喝 

993
01:00:43,029 --> 01:00:46,077
这些机器中的一个并运行此 

994
01:00:44,067 --> 01:00:49,145
实验，但它真的不是一个 很 

995
01:00:46,077 --> 01:00:49,145
有趣的实验，所以我不会打扰 

996
01:00:50,066 --> 01:00:57,515
所以在原则上，我可以尝试 在一个 

997
01:00:53,004 --> 01:01:03,045
64位Oracle机，并且告诉你 

998
01:00:58,109 --> 01:01:06,840
不同的东西这样一两件事， 

999
01:01:03,081 --> 01:01:08,124
一种有用的 工具书去 

1000
01:01:06,084 --> 01:01:12,129
通过这样一些实例中是一个 

1001
01:01:09,024 --> 01:01:16,089
小程序， 将采取 一系列 

1002
01:01:13,029 --> 01:01:19,125
开始 在 一些位置 开始 的字节 

1003
01:01:16,089 --> 01:01:23,124
也为了然而，许多字节您

1004
01:01:20,025 --> 01:01:29,384
要求，只是打印出十六进制格式 

1005
01:01:24,024 --> 01:01:33,090
两个十六进制数字代表的是 

1006
01:01:29,609 --> 01:01:37,610
咬阀，在这里这个词指针

1007
01:01:33,009 --> 01:01:41,084
我使用的是无符号的关怀作为一个指针

1008
01:01:37,619 --> 01:01:42,650
键入一种通用的指针类型 

1009
01:01:45,079 --> 01:01:56,144
所以再次，如果我在86运行此 

1010
01:01:53,012 --> 01:01:59,021
机哦，哦，我也顺便说一下 

1011
01:01:57,044 --> 01:02:03,107
打印出的实际地址 

1012
01:01:59,021 --> 01:02:05,107
这个字符存储 在太 等 

1013
01:02:04,007 --> 01:02:11,015
你会看到有这些地址 

1014
01:02:06,007 --> 01:02:13,085
有很多的手段是什么1408米 

1015
01:02:11,015 --> 01:02:15,023
它是这个 47位 的上端 

1016
01:02:13,085 --> 01:02:18,161
如果你的工作，通过地址空间

1017
01:02:15,095 --> 01:02:23,174
有七个是三一，然后 

1018
01:02:19,061 --> 01:02:28,061
这里有足够的十六进制数字来 

1019
01:02:24,074 --> 01:02:32,078
对应所以有11个十六进制数字 

1020
01:02:28,061 --> 01:02:34,094
超越七，你会看到，

1021
01:02:32,078 --> 01:02:39,155
这些地址是在连续的字节 

1022
01:02:34,094 --> 01:02:41,165
BC乙DB EB F和值是63 乙0 0 

1023
01:02:40,055 --> 01:02:48,106
0 0 这是最显著字节 

1024
01:02:42,065 --> 01:02:53,126
而这些都是连续字节和一个 

1025
01:02:49,006 --> 01:02:57,014
类似的，我可以，我可以用它来检查 

1026
01:02:54,026 --> 01:02:58,088
不同的种类 可以和我 的指针

1027
01:02:57,014 --> 01:03:02,051
考察不同的价值观和刚刚获得

1028
01:02:58,088 --> 01:03:04,088
其低级别的字节表示和 

1029
01:03:02,051 --> 01:03:06,065
所以我做了这个回来时，我能 得到一个 

1030
01:03:04,088 --> 01:03:07,157
孙机它有一种方式 

1031
01:03:06,065 --> 01:03:10,070
代表一个指针和主

1032
01:03:08,057 --> 01:03:13,145
点甚至是跨机器是否 

1033
01:03:10,007 --> 01:03:15,050
这是一个字节顺序或任何你会

1034
01:03:14,045 --> 01:03:17,093
获得指针不同的值

1035
01:03:16,013 --> 01:03:20,036
有没有保证， 当你 加载 

1036
01:03:17,093 --> 01:03:21,182
这些计算机程序为一体机 

1037
01:03:20,036 --> 01:03:26,057
并运行它，它会使用相同的 

1038
01:03:22,082 --> 01:03:27,140
地址为相同的编程 

1039
01:03:26,057 --> 01:03:29,120
在不同的机器，即使上运行

1040
01:03:28,004 --> 01:03:32,092
其实他们是相同的硬件 和 

1041
01:03:30,002 --> 01:03:35,060
操作系统可以有变化 

1042
01:03:33,028 --> 01:03:38,033
因为指针不是你不行

1043
01:03:35,078 --> 01:03:44,084
直接指针从一台计算机复制

1044
01:03:38,033 --> 01:03:47,078
另一个对一件事也是 

1045
01:03:45,038 --> 01:03:51,062
无论字节的排序顺序 

1046
01:03:47,078 --> 01:03:53,156
的字符是相同的，所以

1047
01:03:51,062 --> 01:03:57,101
在C字符串总是 由 表示 

1048
01:03:54,056 --> 01:03:58,117
一系列字节，其中最后一个字节是 

1049
01:03:58,001 --> 01:04:02,052
0 

1050
01:03:59,017 --> 01:04:05,166
所谓空值终止和 

1051
01:04:02,052 --> 01:04:07,401
单个字节对应于 

1052
01:04:05,319 --> 01:04:11,322
该数字的字符代码和 

1053
01:04:07,869 --> 01:04:13,890
这些字符代码只是有时 

1054
01:04:11,349 --> 01:04:16,540
所谓的ASCII格式这是一个小 

1055
01:04:14,079 --> 01:04:18,760
位的方式老式的有 

1056
01:04:16,054 --> 01:04:24,363
更现代的字符代码 也可以 

1057
01:04:18,076 --> 01:04:26,083
代表非 英文字母 ，但 

1058
01:04:24,849 --> 01:04:31,690
C标准仍然是早在天 

1059
01:04:27,046 --> 01:04:52,051
只有配套的ASCII格式

1060
01:04:31,069 --> 01:05:00,076
问题 嗯没错 所以这应该有 

1061
01:04:52,051 --> 01:05:03,103
一直 没有 好 ，这是很好的 ，所以我铸造 

1062
01:05:00,076 --> 01:05:05,080
我想显示为一口大小事件 

1063
01:05:04,003 --> 01:05:09,004
对于因为这是一个int我 

1064
01:05:06,016 --> 01:05:12,019
代表指针让我们来看看 

1065
01:05:09,013 --> 01:05:16,182
代码中，我们要打印指针这一切 

1066
01:05:12,046 --> 01:05:20,053
符号％P是说指令 

1067
01:05:16,299 --> 01:05:24,000
打印出的指针提出正确的和％ 

1068
01:05:20,053 --> 01:05:27,372
X是打印 出的十六进制 指令 

1069
01:05:24,000 --> 01:05:30,028
代表，所以它都打印出来 

1070
01:05:27,849 --> 01:05:32,380
该地址的起始位置

1071
01:05:30,028 --> 01:05:35,047
该特定字节和的值

1072
01:05:32,038 --> 01:05:37,104
该字节作为两个不同的 东西 呢 

1073
01:05:35,047 --> 01:05:37,104
这回答你的问题 

1074
01:05:39,549 --> 01:05:58,660
返回上层深色可以，但请记住

1075
01:05:52,088 --> 01:06:01,807
显示字节报错一个指针和 

1076
01:05:58,066 --> 01:06:04,075
长度还等什么，这是什么 

1077
01:06:02,599 --> 01:06:08,480
它的说法是从该地址开始

1078
01:06:04,075 --> 01:06:10,166
打印 出下一个 系列的字节 

1079
01:06:08,048 --> 01:06:13,055
我我有多少字节的要求和 

1080
01:06:11,066 --> 01:06:17,102
这种情况下，我是我创建的指针

1081
01:06:14,018 --> 01:06:20,039
这个整数，但 我想显示的 

1082
01:06:18,002 --> 01:06:22,097
在整数字节的四个字节 

1083
01:06:20,039 --> 01:06:24,128
组成该整数 ，这就是为什么 

1084
01:06:22,097 --> 01:06:32,141
我给 它排名 第四这里 

1085
01:06:25,028 --> 01:06:37,124
而不是8 是它是的，它 会 

1086
01:06:33,041 --> 01:06:40,049
这很好，因为在此代码我 

1087
01:06:38,024 --> 01:06:43,028
使用％ 对指令 

1088
01:06:41,021 --> 01:06:46,360
指定如何打印 出指针 

1089
01:06:43,028 --> 01:06:47,797
以及将打印的字节数 

1090
01:06:46,549 --> 01:06:51,530
它需要为特定的机器 

1091
01:06:48,049 --> 01:06:53,690
它的 运行就这么％的 P是 

1092
01:06:51,053 --> 01:06:55,076
实际上是一个非常方便的指令，如果你 

1093
01:06:53,069 --> 01:06:56,138
要打印像地址 

1094
01:06:55,076 --> 01:06:59,185
调试的目的或东西，因为 

1095
01:06:57,038 --> 01:07:04,497
它会自动适应任何 

1096
01:06:59,869 --> 01:07:03,966
机器它的问题上运行

1097
01:07:06,082 --> 01:07:12,158
还有我定义它是一个无符号 

1098
01:07:09,071 --> 01:07:16,109
关心这里，所以类型定义是一种方法，

1099
01:07:13,058 --> 01:07:18,146
对于一些数据类型的引入名字

1100
01:07:17,009 --> 01:07:24,032
右 ，所以我刚刚宣布 

1101
01:07:19,046 --> 01:07:28,085
指针引用指针指到 

1102
01:07:24,032 --> 01:07:32,096
无符号的护理如果你没有一个无效加上星 

1103
01:07:28,085 --> 01:07:36,179
不会满意这个参考 

1104
01:07:32,096 --> 01:07:39,098
在这里 对 你不能，你 不能引用 

1105
01:07:37,079 --> 01:07:41,087
空洞明星只是一种 绕过 路 

1106
01:07:40,016 --> 01:07:44,024
一个通用的指针，但你不能真正

1107
01:07:41,087 --> 01:07:46,184
引用元素，我还等什么 

1108
01:07:44,024 --> 01:07:51,047
基本上做的是说 这 句话的 引用 

1109
01:07:47,084 --> 01:07:52,136
是像对待你对待一个数组我 

1110
01:07:51,047 --> 01:08:00,113
一系列字节 是一个数组和打印 

1111
01:07:53,036 --> 01:08:07,105
出每个阵列中的字节和 

1112
01:08:01,013 --> 01:08:11,014
所以在这里，我是一个是一个数字，我 

1113
01:08:08,005 --> 01:08:14,083
采取这一整数的地址， 

1114
01:08:11,014 --> 01:08:17,111
铸造它是一个无符号的护理明星 

1115
01:08:14,083 --> 01:08:19,097
所以排序的一个通用略微通用 

1116
01:08:18,011 --> 01:08:23,032
指针，但并不像一般为void

1117
01:08:19,097 --> 01:08:24,194
星吧，然后打印出来了 

1118
01:08:23,032 --> 01:08:32,033
它是由好很容易好的 问题 

1119
01:08:25,094 --> 01:08:34,100
路好了，所以点在于 

1120
01:08:32,042 --> 01:08:38,129
字符串仅仅是字符串，这就是 

1121
01:08:35,000 --> 01:08:41,093
从一台机器一样到下一行不行 

1122
01:08:39,029 --> 01:08:44,087
我们今天完成了一些困惑 

1123
01:08:41,093 --> 01:08:47,174
而这些有这种恼人的方式

1124
01:08:44,087 --> 01:08:51,095
显示出来的考试， 所以它是值得的 

1125
01:08:48,074 --> 01:08:53,162
能够做这类事情 和 

1126
01:08:52,067 --> 01:08:57,163
你还会注意到 我巧妙地没 

1127
01:08:54,062 --> 01:08:58,063
包括在幻灯片的答案

1128
01:09:00,199 --> 01:09:04,201
所以你不能，你不能只是提前偷看

1129
01:09:02,066 --> 01:09:05,075
并找出问题的答案是如此 

1130
01:09:04,219 --> 01:09:07,190
让我们只是通过他们去，但我 

1131
01:09:05,075 --> 01:09:09,137
实际工作出来，以 确保我 

1132
01:09:07,019 --> 01:09:12,110
有入口区 ，所以如果X和基本 

1133
01:09:10,037 --> 01:09:15,616
这些类型的语句， 你 

1134
01:09:13,001 --> 01:09:18,430
要说这些都是要么 总是正确的 

1135
01:09:15,949 --> 01:09:21,710
也许还有背后为什么一些逻辑 

1136
01:09:18,529 --> 01:09:24,020
它总是真或假的可能 和 

1137
01:09:21,071 --> 01:09:26,114
你会不会 给一些例子 

1138
01:09:24,002 --> 01:09:28,064
会提出这样的假让我们去 

1139
01:09:27,014 --> 01:09:32,039
通过这些多达我们有时间 

1140
01:09:28,064 --> 01:09:35,413
并看到我们去，所以如果我走 

1141
01:09:32,039 --> 01:09:39,238
X和我双击它乘以2，如果X 

1142
01:09:35,989 --> 01:09:41,008
谁是阴性，我保证 

1143
01:09:39,589 --> 01:09:47,000
2X将是 负 

1144
01:09:41,179 --> 01:09:50,330
没有那么顺便说一个普通的方式找到 

1145
01:09:47,000 --> 01:09:53,033
相反的例子是尝试队在它的 

1146
01:09:50,033 --> 01:09:55,064
一个很好的一个，并且在这里工作 

1147
01:09:53,033 --> 01:09:56,131
右如果我带的团队n的是一个和 

1148
01:09:55,064 --> 01:09:59,102
一串零的我加倍 喜欢 

1149
01:09:57,031 --> 01:10:06,113
移，但 左，它将成为 

1150
01:10:00,002 --> 01:10:09,041
什么0右就是等再次 假设 

1151
01:10:07,013 --> 01:10:12,086
X是任何负数和 

1152
01:10:09,041 --> 01:10:16,094
UX是它的无符号对不起 

1153
01:10:12,086 --> 01:10:18,128
二进制补码数和用户体验是什么 

1154
01:10:16,094 --> 01:10:20,117
如果发生我投它 是无符号等等 

1155
01:10:19,028 --> 01:10:25,121
为u 总是X 你比大于或 

1156
01:10:21,017 --> 01:10:31,546
等于零 ， 是啊，这稍微 

1157
01:10:26,021 --> 01:10:34,990
晦涩如果我带X和我屏蔽掉 7 

1158
01:10:31,699 --> 01:10:38,440
你还记得是位模式1 1 1 所以 

1159
01:10:35,179 --> 01:10:41,690
如我屏蔽掉所有，但最低的 3个比特 

1160
01:10:38,044 --> 01:10:43,091
我发现，这些 都是一个我 

1161
01:10:41,069 --> 01:10:46,154
这里已经给你答案和 

1162
01:10:43,091 --> 01:10:50,098
然后我转向它由30位留下什么 

1163
01:10:47,054 --> 01:10:50,098
我可以说结果 

1164
01:10:59,269 --> 01:11:21,320
所以我知道前必须完成 3：1 

1165
01:11:04,076 --> 01:11:22,585
正确的，我的转变，由30 这 

1166
01:11:21,032 --> 01:11:25,109
这些将是 唯一 的 两位是 

1167
01:11:23,269 --> 01:11:29,300
在换档之后的左和他们将 

1168
01:11:26,009 --> 01:11:32,368
最显著位置等什么

1169
01:11:29,003 --> 01:11:35,032
我可以说 这个数字为负 

1170
01:11:32,449 --> 01:11:39,530
所以这是一个真正的语句，而 

1171
01:11:35,329 --> 01:11:42,400
晦涩，但它是真实的 UX 更大 

1172
01:11:39,053 --> 01:11:41,140
比减 一 

1173
01:11:44,559 --> 01:11:58,621
这几乎是真正的权利 的一个 计数器 

1174
01:11:51,679 --> 01:12:00,727
例如会是怎样的动物园 以及 

1175
01:11:59,179 --> 01:12:03,208
其实也没什么，你是对的还有很多 

1176
01:12:01,159 --> 01:12:04,207
的例子是几乎没有真正的是 

1177
01:12:03,469 --> 01:12:07,460
几乎都是假的

1178
01:12:04,639 --> 01:12:13,656
我错了的事情中唯一会 

1179
01:12:07,046 --> 01:12:19,285
它是真的会是十一它从来没有真正的 

1180
01:12:13,809 --> 01:12:22,340
好了，这是从来没有真正的好 ，如果X是 

1181
01:12:19,699 --> 01:12:24,720
大于Y是负X小于 

1182
01:12:22,034 --> 01:12:24,603
减Y

1183
01:12:34,012 --> 01:12:40,070
没有这样的方式一件事 我们没有 

1184
01:12:38,009 --> 01:12:48,032
真正涵盖什么是负的 

1185
01:12:40,007 --> 01:12:58,007
茶男人看到，我们可以用 我们的 

1186
01:12:48,032 --> 01:13:03,035
补收益 工具 欺骗等等 

1187
01:12:58,007 --> 01:13:06,038
当你赞美 一个增量T最小 

1188
01:13:03,062 --> 01:13:10,085
你T最小，这就是为什么它是这样一个

1189
01:13:07,001 --> 01:13:18,088
伟大的反例所以特别

1190
01:13:10,085 --> 01:13:21,092
如果Y是t最小和X是别的东西 

1191
01:13:18,088 --> 01:13:24,184
那么左侧部分 为真 

1192
01:13:21,092 --> 01:13:24,184
但右侧部分不会是真的 

1193
01:13:26,008 --> 01:13:33,013
行x倍X大于或等于 

1194
01:13:28,079 --> 01:13:35,113
零个，我们已经看到 了 存在 的例子 

1195
01:13:33,013 --> 01:13:36,013
假

1196
01:13:36,919 --> 01:13:41,014
如果X是它只是有种傻 如果X是 

1197
01:13:40,007 --> 01:13:47,009
大于 零且Y 大于 

1198
01:13:41,869 --> 01:13:48,898
零为X加上Y大于零，如果没有 

1199
01:13:47,009 --> 01:13:53,026
X是大于或 等于零的 

1200
01:13:49,159 --> 01:13:53,260
减去X 小于或等于零 

1201
01:13:53,053 --> 01:13:57,712
疑难杂症

1202
01:13:54,008 --> 01:14:01,177
你是对的这是真的正确的，因为 

1203
01:13:58,189 --> 01:14:03,286
这一点，但我们把 它 对口如果X 

1204
01:14:01,969 --> 01:14:07,820
小于 或等于零是减去 x 

1205
01:14:04,159 --> 01:14:10,340
平方 等于零 队n右 等等 

1206
01:14:07,082 --> 01:14:12,961
右边的点是，最大的 

1207
01:14:10,034 --> 01:14:16,063
任何正数可以表示 

1208
01:14:13,699 --> 01:14:18,590
为阴性，但有一个负 

1209
01:14:16,369 --> 01:14:21,430
不能被表示为 编号 

1210
01:14:18,059 --> 01:14:25,061
积极使不对称是为什么 

1211
01:14:21,979 --> 01:14:28,984
你如果我不同的答案，这些 

1212
01:14:25,061 --> 01:14:33,400
拍X 我期待在零下X和我转移 

1213
01:14:29,479 --> 01:14:36,547
他们由31右 我该怎么 

1214
01:14:33,949 --> 01:14:39,012
让所有 的人，这是一个非常奇怪的 

1215
01:14:37,159 --> 01:14:39,201
声明

1216
01:14:47,085 --> 01:14:53,136
因此它实际上样的作品的权利，如果我 

1217
01:14:51,037 --> 01:14:53,136
采取一切为零 

1218
01:15:01,809 --> 01:15:07,800
我减去一个我会减一 

1219
01:15:10,289 --> 01:15:28,780
我还是他们的作品有啥错 

1220
01:15:19,078 --> 01:15:30,130
本那是什么 哦，但如果我转向 

1221
01:15:28,078 --> 01:15:44,094
它正确 地31这是怎么回事 

1222
01:15:31,003 --> 01:15:48,342
转移算术aliy那是什么啊 

1223
01:15:44,094 --> 01:15:49,233
我看看哦对不起 

1224
01:15:48,639 --> 01:15:56,658
我已经跳到了一个不同的 

1225
01:15:50,079 --> 01:15:58,154
拼图X和X负和我 所以你 

1226
01:15:56,829 --> 01:16:04,845
其实权

1227
01:15:58,829 --> 01:16:09,610
如果这两个数字是 零，我还是 

1228
01:16:04,989 --> 01:16:12,044
那些我得到零，但你会找出 

1229
01:16:09,061 --> 01:16:15,900
如果它是任何非零你会发现 

1230
01:16:12,539 --> 01:16:18,670
实际上这将是真实的 ，并且是一个 

1231
01:16:16,449 --> 01:16:20,710
有趣的功能，所以有一对夫妇 

1232
01:16:18,067 --> 01:16:21,151
其他的拼图，我会我会告诉你 

1233
01:16:20,071 --> 01:16:24,084
解决这些你自己，我们都是集 

1234
01:16:22,051 --> 01:16:24,084
今天 

