1
00:00:00,000 --> 00:00:04,500
 I guess one thing I I am the rest of the staff request is that you?

2
00:00:05,500 --> 00:00:08,250
 Whenever you have a question. You first read the book

3
00:00:08,530 --> 00:00:12,540
 And then you reread the assignment and you maybe reread it again

4
00:00:12,580 --> 00:00:16,559
 And then you ask us because a lot of the questions

5
00:00:16,560 --> 00:00:18,840
 We're getting are ones where we just say?

6
00:00:19,330 --> 00:00:24,809
 Look at this page of the book look at this paragraph of the assignment look at this

7
00:00:25,539 --> 00:00:28,469
 part of the file that you were given and

8
00:00:29,230 --> 00:00:35,610
 So I mean there's a lot of stuff and I understand how sometimes it's easy to miss things

9
00:00:35,610 --> 00:00:42,419
 So not saying don't ever ask questions, but just before you ask your questions trying to figure out if I really

10
00:00:43,210 --> 00:00:50,520
 Should have come through the resources. I have available to see if the answer to my question is can be found there, so

11
00:00:51,640 --> 00:00:53,170
 anyways

12
00:00:53,170 --> 00:00:55,170
 enjoy the Web

13
00:00:55,270 --> 00:00:59,369
 So today is a sort of second part of a two-part lecture on

14
00:01:00,250 --> 00:01:03,629
 integers and integer arithmetic last time we looked at

15
00:01:04,269 --> 00:01:07,919
 representations about how bit patterns can be

16
00:01:08,619 --> 00:01:10,619
 interpreted as either

17
00:01:11,080 --> 00:01:13,919
 unsigned numbers meaning they range between zero and

18
00:01:14,560 --> 00:01:21,960
 Two to the word size minus one or as two's complement numbers, which is the most compliment?

19
00:01:22,720 --> 00:01:28,559
 You away to represent. What are sometimes called signed numbers ones it can be their negative or positive and

20
00:01:29,170 --> 00:01:34,439
 by the way there are other ways to represent signed numbers out there, but tooth complemented, so

21
00:01:35,020 --> 00:01:36,430
 so

22
00:01:36,430 --> 00:01:40,110
 Overwhelmingly the most used system that that's what we concentrate on

23
00:01:41,619 --> 00:01:44,549
 Today what we'll do is now. Go Beyond the

24
00:01:45,520 --> 00:01:51,839
 representations of these values to talk about arithmetic operations on them and some of their properties and

25
00:01:52,869 --> 00:01:54,090
 What we'll do in general

26
00:01:54,090 --> 00:01:55,860
 We talk about the unsigned case

27
00:01:55,860 --> 00:02:02,009
 Which is in some ways easier to understand and more intuitive and then talk about the two's complement case

28
00:02:02,500 --> 00:02:04,589
 so the basic rule on this is

29
00:02:05,320 --> 00:02:08,129
 if you take two numbers that range between

30
00:02:10,300 --> 00:02:17,710
 Up to the maximum value of an unsigned number add them but in principle you might need to get an extra bit

31
00:02:18,380 --> 00:02:24,159
 To represent that thumb if you want to represent the true some sort of integer sum of those two numbers

32
00:02:25,310 --> 00:02:31,899
 Because you're doubling it and unfortunately we can't just go out and add more bits to your computer

33
00:02:32,900 --> 00:02:37,900
 Indefinitely, so we just stop it at some point and say well, whatever

34
00:02:38,570 --> 00:02:44,049
 Bit happened to be in that sort of next bit position. We're just going to drop it and pretend

35
00:02:44,050 --> 00:02:50,589
 It doesn't exist and say that the result of addition is just whatever the w bit pattern you get

36
00:02:50,959 --> 00:02:53,919
 If you only consider the first w bits out of it

37
00:02:54,590 --> 00:02:56,890
 with no warning no

38
00:02:57,530 --> 00:02:59,180
 messages no

39
00:02:59,180 --> 00:03:02,500
 Error or anything? This is just it happens silently

40
00:03:04,370 --> 00:03:08,410
 So for at each compliment. This is not such a

41
00:03:10,730 --> 00:03:14,649
 Hard thing to understand it can be thought of as just modular arithmetic

42
00:03:15,590 --> 00:03:18,070
 Computing modulo the two to the word size

43
00:03:18,410 --> 00:03:22,899
 And so I'm going to use some examples and this time I've got them worked out a little more carefully

44
00:03:22,900 --> 00:03:25,179
 So I will get mixed up as much

45
00:03:25,790 --> 00:03:30,219
 And we'll use the word size of four here and as I mentioned last time

46
00:03:30,769 --> 00:03:35,589
 It really helps with this to work do the examples with small word sizes

47
00:03:35,989 --> 00:03:39,759
 To get a your intuition for it rather than trying to write out

48
00:03:41,209 --> 00:03:47,078
 32-bit numbers or 64-bit numbers or something like that so if you think about in the unsigned case?

49
00:03:51,230 --> 00:03:53,410
 a 4-bit number

50
00:03:56,299 --> 00:03:58,959
 means that it will range between 0 and

51
00:04:00,170 --> 00:04:06,399
 2 to the 4th minus 1 or 15 right and so let's just do a few examples of

52
00:04:07,400 --> 00:04:09,400
 cases where it overflows

53
00:04:10,280 --> 00:04:12,399
 so if you add 13 to

54
00:04:13,730 --> 00:04:15,730
 5

55
00:04:20,509 --> 00:04:26,259
 first of all you know I assume already that you just add binary numbers the way you learned in school of

56
00:04:27,289 --> 00:04:33,519
 Just doing carries and so forth except it's all modulo two, so this is zero carry one

57
00:04:34,490 --> 00:04:36,490
 one

58
00:04:36,979 --> 00:04:38,979
 zero Carry one

59
00:04:39,830 --> 00:04:41,830
 zero Carry one

60
00:04:42,110 --> 00:04:44,830
 so in principle to represent the sum which is

61
00:04:45,500 --> 00:04:48,220
 This is five so to represent 18

62
00:04:49,130 --> 00:04:51,519
 you need five bits not four but

63
00:04:52,340 --> 00:04:57,639
 We're just going to conveniently drop that number and say that this is actually 2

64
00:04:59,360 --> 00:05:06,639
 Which of course is what 18 module 16 is so the unsigned case is really pretty straightforward

65
00:05:12,560 --> 00:05:18,429
 And we can visualize this in this pictures in the book too by saying if you are representing

66
00:05:20,210 --> 00:05:23,829
 On the x and y axis what they call u and V are

67
00:05:25,729 --> 00:05:32,919
 Values between 0 and 15 the range of possible unsigned numbers and if we're going to add those we could get a sum that up

68
00:05:32,919 --> 00:05:34,919
 to as much as 30

69
00:05:36,229 --> 00:05:38,889
 Which would in principle require 5 bits to represent?

70
00:05:40,460 --> 00:05:42,789
 But what we'll do is. We'll just by

71
00:05:43,370 --> 00:05:50,889
 Dropping that most significant bit what we do is to create a clip that when you roll over from 15 to 16

72
00:05:51,349 --> 00:05:55,989
 Instead it drops all the way down to 0 and that's referred to as an overflow

73
00:05:57,110 --> 00:06:03,430
 And then from there, we'll build up to the maximum value here will be 14 which is

74
00:06:04,280 --> 00:06:09,880
 30 minus 16 so what we've done is basically as this picture shows when we overflow

75
00:06:10,430 --> 00:06:14,650
 We effectively subtract off 2 to the w from the sum

76
00:06:15,590 --> 00:06:20,049
 And keep it within the representable range of w bit numbers

77
00:06:20,900 --> 00:06:22,900
 So that's untimed

78
00:06:23,720 --> 00:06:25,639
 Two's complement

79
00:06:25,639 --> 00:06:31,939
 once the first thing I want to convince you of is that two's complement addition looks just like a

80
00:06:33,150 --> 00:06:35,150
 regular Edition

81
00:06:35,610 --> 00:06:39,199
 In other words I can perform a subtraction

82
00:06:40,800 --> 00:06:47,479
 and addition of subtraction of numbers by using this tooth compliment representation for negative numbers, so

83
00:06:48,240 --> 00:06:51,229
 Well, let me just show you some examples of that, so

84
00:06:57,360 --> 00:07:05,090
 First of all remember that what range of values what's the smallest number that could be represented with a four bit the most negative number?

85
00:07:05,550 --> 00:07:07,550
 four bit two's complement number

86
00:07:09,000 --> 00:07:11,000
 minus eight

87
00:07:11,550 --> 00:07:13,550
 and the largest

88
00:07:14,190 --> 00:07:16,190
 Plus seven thank you

89
00:07:18,270 --> 00:07:21,049
 So let's just do some examples if we took

90
00:07:26,340 --> 00:07:28,999
 this number 1 1 0 1

91
00:07:29,880 --> 00:07:31,050
 as

92
00:07:31,050 --> 00:07:33,979
 the two's complement number is minus 3 and

93
00:07:34,920 --> 00:07:36,920
 we add it to

94
00:07:37,200 --> 00:07:39,200
 5

95
00:07:40,440 --> 00:07:42,530
 We'll get what we got before

96
00:07:51,000 --> 00:07:55,890
 And we're not good at we're going to ignore. Whatever carry bid it is and so the result is -

97
00:07:56,530 --> 00:07:57,940
 I'm

98
00:07:57,940 --> 00:08:00,660
 Going behold. That's what five minus three is so

99
00:08:01,480 --> 00:08:03,689
 It seems like Magic because it is

100
00:08:05,890 --> 00:08:13,379
 Tuesday, and that's why part of the reason why I choose complement is to the most commonly used way of representing signed numbers because the

101
00:08:13,380 --> 00:08:16,589
 Same hardware the same algorithms that are used for doing

102
00:08:18,700 --> 00:08:22,979
 addition in work for either unsigned or two's complement numbers

103
00:08:31,090 --> 00:08:32,289
 and

104
00:08:32,289 --> 00:08:34,348
 This works as well just to

105
00:08:35,050 --> 00:08:41,849
 Show you if the overflow goes if the resulting film is goes the other way

106
00:08:45,460 --> 00:08:52,079
 So if I have minus 3 and minus 5 and plus 3 and I add those together

107
00:09:03,180 --> 00:09:07,190
 I'll get 1 1 1 0 which is minus 2

108
00:09:09,810 --> 00:09:13,310
 so again if you use the same patterns for

109
00:09:14,490 --> 00:09:16,490
 the same Rule for addition as

110
00:09:17,250 --> 00:09:21,530
 You do with an unsigned case you'll get two complementary rhythm

111
00:09:23,640 --> 00:09:25,640
 So let's look at a few cases where?

112
00:09:27,000 --> 00:09:29,000
 the Two's complement overflows

113
00:09:35,640 --> 00:09:37,640
 so if we take 3

114
00:09:44,920 --> 00:09:46,920
 and

115
00:09:53,929 --> 00:09:55,220
 -6

116
00:09:55,220 --> 00:10:02,019
 And we add them together. We'll get one one one zero we're going to drop off the carry

117
00:10:02,540 --> 00:10:04,540
 Which is what?

118
00:10:05,089 --> 00:10:07,089
 seven

119
00:10:08,419 --> 00:10:16,149
 So we've added two negative numbers, and it's become positive and that's referred to as a negative overflow

120
00:10:22,999 --> 00:10:25,629
 And the reason of course is the number minus nine

121
00:10:26,869 --> 00:10:29,469
 Can't be represented in a 4-bit

122
00:10:30,470 --> 00:10:32,470
 to compliment number so

123
00:10:34,609 --> 00:10:36,609
 It overflowed

124
00:10:37,100 --> 00:10:39,100
 you'll notice that the

125
00:10:39,470 --> 00:10:44,739
 cost seven of course differs from minus 9 by 16 and that's not next to

126
00:10:45,230 --> 00:10:47,739
 and then going the other direction

127
00:10:48,439 --> 00:10:52,599
 if we had two large positive numbers, so if we add 7

128
00:10:54,019 --> 00:10:56,019
 &

129
00:10:56,029 --> 00:10:58,029
 5

130
00:11:09,290 --> 00:11:15,909
 We'll get minus six, so this was seven plus five

131
00:11:20,149 --> 00:11:22,149
 Is minus four?

132
00:11:25,430 --> 00:11:29,739
 And so this is referred to as positive overflow. We've taken two

133
00:11:37,579 --> 00:11:40,869
 Positive numbers and added them together and gotten a negative

134
00:11:41,480 --> 00:11:46,630
 Result and you could see this by the way if you think about this addition

135
00:11:46,630 --> 00:11:52,749
 We took seven and five would be twelve, and this is the bit level representation of Twelve

136
00:11:53,329 --> 00:11:56,409
 It's just that because this is not the time bit

137
00:11:57,740 --> 00:12:00,639
 We think of that as minus four not positive twelve

138
00:12:02,899 --> 00:12:04,370
 and

139
00:12:04,370 --> 00:12:08,889
 so that's the the idea of two's complement overflow and

140
00:12:09,920 --> 00:12:12,039
 You can see there's two different cases here

141
00:12:13,279 --> 00:12:15,279
 one is where the

142
00:12:16,279 --> 00:12:19,869
 Number that the Sum was if we looked at the true sum

143
00:12:20,569 --> 00:12:23,889
 the numbers that you'd get for example 12 is

144
00:12:24,170 --> 00:12:29,829
 Too big to represent and so when we think of that as a two's complement number it becomes now a negative number

145
00:12:30,160 --> 00:12:32,160
 So that's positive overflow

146
00:12:32,480 --> 00:12:37,269
 Similarly if we have two negative numbers and we add them together so that the sum is

147
00:12:38,029 --> 00:12:44,198
 Too small to negative to represent then those become positive numbers. That's negative overflow

148
00:12:44,199 --> 00:12:46,809
 And you can see that in this picture

149
00:12:47,720 --> 00:12:50,980
 The same ideas before except there's three regions

150
00:12:51,740 --> 00:12:53,449
 this is

151
00:12:53,449 --> 00:12:59,499
 and by the way now you'll see our numbers range between minus 8 and positive 7 and

152
00:13:00,980 --> 00:13:02,980
 the sum

153
00:13:03,019 --> 00:13:08,078
 to come will also range between minus 8 and a positive 7

154
00:13:09,230 --> 00:13:12,760
 But there's these three regions one is the where

155
00:13:13,670 --> 00:13:15,670
 everything's fine

156
00:13:16,329 --> 00:13:21,368
 it's within the representable range the other is where the sum was so

157
00:13:22,249 --> 00:13:30,249
 Far Toward the negative side that it becomes positive or where it's so high on the positive side that it becomes negative

158
00:13:32,749 --> 00:13:34,610
 and

159
00:13:34,610 --> 00:13:40,269
 So part of data web you'll you'll learn to understand these quite

160
00:13:40,970 --> 00:13:46,239
 In quite precisely, but that lets the idea it's a little bit counterintuitive to say

161
00:13:47,209 --> 00:13:53,738
 You know somehow I can accept the idea the modular arithmetic for unsigned numbers. There's some sort of mathematical

162
00:13:54,350 --> 00:13:55,639
 beauty to a

163
00:13:55,639 --> 00:13:57,350
 modular arithmetic

164
00:13:57,350 --> 00:13:59,649
 and this disk looks like kind of

165
00:14:01,670 --> 00:14:05,259
 useless right from a from a

166
00:14:06,679 --> 00:14:11,079
 operational characteristic, but it's the way it is and

167
00:14:12,529 --> 00:14:15,159
 we're stuck with it and

168
00:14:16,579 --> 00:14:17,989
 multiplication is

169
00:14:17,989 --> 00:14:22,599
 basically the same idea in fact all the operations are basically the same idea that if

170
00:14:22,790 --> 00:14:30,069
 You can't represent it within the word size you just take the lower w bits so all this complicated

171
00:14:32,749 --> 00:14:38,139
 Notation here is just a way of saying in principle. If you take 2w, bit numbers and multiply them together

172
00:14:38,899 --> 00:14:40,699
 you may need a

173
00:14:40,699 --> 00:14:44,979
 The result may require as much as 2 times w bits to represent?

174
00:14:46,189 --> 00:14:48,488
 before addition its w plus 1

175
00:14:49,639 --> 00:14:54,399
 multiplication you actually have to double because you're potentially squaring the largest number and

176
00:14:55,040 --> 00:14:56,779
 so

177
00:14:56,779 --> 00:14:58,779
 Again, we don't want to just keep

178
00:14:59,449 --> 00:15:01,628
 Doubling our word size over and over again

179
00:15:01,629 --> 00:15:06,969
 we'll run out of bits very quickly that way and so we just truncate it at W bits and

180
00:15:13,369 --> 00:15:19,899
 For the unsigned case it's again modular arithmetic. It's something that you can kind of

181
00:15:20,569 --> 00:15:22,100
 understand and believe

182
00:15:22,100 --> 00:15:24,100
 but for

183
00:15:25,519 --> 00:15:31,069
 Two and so again, let's just do a few examples, and I won't try and work out

184
00:15:31,740 --> 00:15:37,760
 Multiplying in binary is like multiplying in decimal you do a big table, and it takes a long time

185
00:15:37,829 --> 00:15:39,829
 So I won't try to do that

186
00:15:40,050 --> 00:15:42,050
 but let me just

187
00:15:42,600 --> 00:15:44,600
 show a few examples, so

188
00:15:53,519 --> 00:15:56,089
 if I multiply three times five is

189
00:15:57,060 --> 00:15:59,060
 of course equal to 15 and

190
00:16:00,029 --> 00:16:02,388
 In an unsigned number I can represent that

191
00:16:05,339 --> 00:16:08,208
 Right, so that's okay

192
00:16:13,350 --> 00:16:15,949
 but if I multiply a five times five

193
00:16:22,199 --> 00:16:24,889
 Then that would have representation

194
00:16:27,540 --> 00:16:32,779
 If I were to think about it as possibly as many as eight bits. It would have a representation

195
00:16:38,399 --> 00:16:43,939
 With an extra bit and I'm going to throw this part away, and so I'd call that nine

196
00:16:45,029 --> 00:16:47,689
 Which of course is equal to 25 960?

197
00:16:53,290 --> 00:17:00,839
 um and and so that's the general idea of it is regardless of whatever is in this upper part of the work of the

198
00:17:01,210 --> 00:17:01,710
 product

199
00:17:01,710 --> 00:17:09,329
 I'm just going to discard that and only look at the lower one and vice gets a little more interesting with the two's complement case

200
00:17:10,240 --> 00:17:12,240
 So let's look at what that does

201
00:17:14,589 --> 00:17:16,589
 and the answer is

202
00:17:17,920 --> 00:17:20,489
 even a little bit stranger that you not only

203
00:17:22,270 --> 00:17:25,589
 Trunk throw away, whatever high order bits happen to be there

204
00:17:26,020 --> 00:17:32,249
 But whatever bit gets left in this position will determine whether it's a positive or a negative result

205
00:17:33,130 --> 00:17:35,130
 even though with

206
00:17:35,650 --> 00:17:37,179
 completely

207
00:17:37,179 --> 00:17:39,809
 Irrespective of the signs of the original two operands

208
00:17:41,050 --> 00:17:44,159
 So that can make you go all over the place

209
00:18:02,150 --> 00:18:04,839
 so if we had five times four

210
00:18:06,260 --> 00:18:08,260
 or 20

211
00:18:09,260 --> 00:18:14,650
 that would be represented in this 8-bit form

212
00:18:22,880 --> 00:18:26,109
 like so and we just call that for

213
00:18:28,190 --> 00:18:32,650
 Right is we're showing this away, but if we did five times five

214
00:18:37,760 --> 00:18:41,140
 As we saw before that's represented like this

215
00:18:49,870 --> 00:18:51,870
 And that sum

216
00:18:52,510 --> 00:18:57,569
 Now becomes so we're throwing away this and this becomes our sign bit

217
00:18:57,880 --> 00:19:01,949
 So the result is minus 8 plus 1 or minus 7

218
00:19:05,260 --> 00:19:09,089
 So you see this is a similar to an example. We showed at the beginning of

219
00:19:10,210 --> 00:19:16,260
 the first lecture that you can have two positive numbers and multiply them and get a negative result and

220
00:19:18,070 --> 00:19:21,720
 Because of the sort of course of this overflow question there oh

221
00:19:24,730 --> 00:19:27,540
 I'm just taking 25 and writing it in binary

222
00:19:30,010 --> 00:19:34,170
 Yeah, if you want to you know you start with the two numbers

223
00:19:36,160 --> 00:19:39,420
 I'm not going to do well actually this one's an easy one

224
00:19:39,420 --> 00:19:43,619
 There's a trick for this if you want to know multiply a number by a power of two

225
00:19:44,140 --> 00:19:46,709
 We're going to show that later. You just shift it left

226
00:19:48,280 --> 00:19:50,280
 by two position

227
00:19:54,550 --> 00:20:00,929
 So that one's an easy one otherwise you have to write out the table and sum all the results and all that stuff I

228
00:20:02,559 --> 00:20:04,559
 Prefer to what computers do that?

229
00:20:13,429 --> 00:20:14,900
 and

230
00:20:14,900 --> 00:20:19,150
 again this to complement stuff one interesting feature is that

231
00:20:19,820 --> 00:20:22,390
 It works for our negative numbers, too

232
00:20:23,330 --> 00:20:27,250
 So if you do this trick of throwing away, the high-order bit

233
00:20:27,980 --> 00:20:35,349
 and you'll have overflow cases like before because you're throwing away information, but the lower bits if the number is

234
00:20:35,960 --> 00:20:41,409
 Representable you'll get the right result so let me just demonstrate to that to you

235
00:20:44,929 --> 00:20:46,929
 So this is a minus 3

236
00:20:47,809 --> 00:20:54,278
 but you remember that this is equivalent to 13 as an unsigned number and

237
00:20:57,380 --> 00:20:59,380
 this is

238
00:20:59,690 --> 00:21:07,480
 Minus 2 which is equivalent to my 14 as an unsigned number, so now if we multiply

239
00:21:09,500 --> 00:21:13,059
 13 times 14 you get 182

240
00:21:14,000 --> 00:21:15,559
 and

241
00:21:15,559 --> 00:21:18,398
 That has a hex representation of B6

242
00:21:27,620 --> 00:21:29,390
 and

243
00:21:29,390 --> 00:21:35,589
 So just looking at the low order for bit are 0 1 1 0 is 6 and indeed that?

244
00:21:36,860 --> 00:21:39,189
 Negative 3 times minus 2 is 6 so

245
00:21:40,220 --> 00:21:41,600
 the point being oh

246
00:21:41,600 --> 00:21:46,059
 And I'm waving my hands here because I don't want to go through all the details

247
00:21:46,549 --> 00:21:50,379
 But to complement multiplication also gives you

248
00:21:51,200 --> 00:21:54,789
 if you can do it using the exact same rules and

249
00:21:55,700 --> 00:22:00,549
 As you do for unsigned multiplication the exact same hardware. I should mention that

250
00:22:02,149 --> 00:22:09,789
 And there are instructions in the computer in ways that you can get the upper word of a multiplication too and though

251
00:22:09,789 --> 00:22:11,450
 It's the bit patterns are different

252
00:22:11,450 --> 00:22:13,450
 depending on whether it

253
00:22:13,639 --> 00:22:16,239
 Treated as a tooth compliment number versus unsigned

254
00:22:16,240 --> 00:22:22,419
 So these typically different instructions for doing that computation but 99% of the time

255
00:22:22,789 --> 00:22:25,329
 Or more you just are looking at this lower

256
00:22:26,299 --> 00:22:30,819
 Part of the product and that's the same whether it's a two's complement or an unsigned

257
00:22:33,080 --> 00:22:37,689
 And it handles negative numbers positive, but it has these overflow characteristics

258
00:22:43,279 --> 00:22:44,750
 so

259
00:22:44,750 --> 00:22:47,919
 as I was talking about there's a trick we can do for

260
00:22:48,590 --> 00:22:50,590
 multiplying by a power of two which

261
00:22:50,600 --> 00:22:56,350
 Is just to shift the number to the left and you'll often see that when you have in your code I?

262
00:22:56,960 --> 00:23:02,679
 Want to multiply some number by four you'll write in your C code if you look at the assembly code

263
00:23:02,679 --> 00:23:07,989
 You'll see that what the compiler generated is just says oh, just shift it left by two

264
00:23:08,779 --> 00:23:13,389
 so in general and you could see why this is true by the way if you think of the

265
00:23:15,380 --> 00:23:17,380
 number

266
00:23:19,070 --> 00:23:23,110
 as the sum of the bits

267
00:23:34,159 --> 00:23:39,969
 Where x sub I is the ice bit and x is the number it represents if I want to?

268
00:23:40,460 --> 00:23:45,579
 If I shift everything left by two what I'm effectively doing is

269
00:23:46,130 --> 00:23:48,130
 increasing their weight by

270
00:23:48,679 --> 00:23:55,179
 That number of positions, so let's just shift by one if I shift everything to the left by one

271
00:24:00,860 --> 00:24:05,709
 Which we write like this and see two left two less symbols

272
00:24:09,980 --> 00:24:11,380
 So I taking that sum

273
00:24:11,380 --> 00:24:18,010
 But now waiting the disk by two to be I plus one by one more and of course that's equal to twice

274
00:24:19,010 --> 00:24:21,010
 What the original sum was?

275
00:24:22,460 --> 00:24:24,669
 And so we double the number

276
00:24:27,350 --> 00:24:29,350
 and that works

277
00:24:32,570 --> 00:24:39,970
 Although even if you shift things so that you lose some bits, right they they shift off to the left all you're doing is

278
00:24:40,760 --> 00:24:44,649
 The way multiplication works anyhow of truncating to w bit?

279
00:24:45,019 --> 00:24:49,239
 Product so you'll see this as I mentioned quite often in in

280
00:24:50,450 --> 00:24:55,809
 Compiled code machine level code that they're doing shifts where you might expect them to be doing

281
00:24:56,059 --> 00:24:59,349
 multiplications and the reason for that is an optimization is

282
00:25:00,170 --> 00:25:05,920
 Historically the multiplication instruction took a lot longer than a shift instruction say

283
00:25:06,530 --> 00:25:11,499
 One clock cycle to do a shift and it used to be like 11 12

284
00:25:12,080 --> 00:25:14,860
 30 clock cycles to do a multiplication

285
00:25:15,980 --> 00:25:18,099
 Nowadays like on the computers

286
00:25:20,120 --> 00:25:24,910
 we use the sharp machines it only take three clock cycles to do multiplication because they

287
00:25:25,309 --> 00:25:27,309
 Added a lot of hardware to do that

288
00:25:27,559 --> 00:25:34,298
 But three clock cycles is still more time than one and so when you can get away with a shift

289
00:25:34,340 --> 00:25:38,590
 It's generally a better idea and the compiler has its own kind of

290
00:25:39,740 --> 00:25:42,160
 Judgment calls on when is it more?

291
00:25:43,070 --> 00:25:46,000
 efficient to substitute one operation for another

292
00:25:51,049 --> 00:25:53,199
 Did we design lose ground here?

293
00:26:00,490 --> 00:26:02,490
 okay, so

294
00:26:04,450 --> 00:26:12,360
 The idea that if we want to multiply something by 2 to the k we just shift it left by K bit

295
00:26:19,000 --> 00:26:21,000
 It turns out that the same

296
00:26:21,370 --> 00:26:28,949
 Almost works for dividing by 2 as well that if you want to divide something by a power of 2 you can shift it

297
00:26:28,950 --> 00:26:30,850
 right by

298
00:26:30,850 --> 00:26:32,850
 in the same general idea

299
00:26:33,100 --> 00:26:36,959
 The only thing that becomes a little bit quirky is well

300
00:26:36,960 --> 00:26:41,820
 What if the number you have is not actually divisible by that power of 2?

301
00:26:51,010 --> 00:26:54,359
 so for example if we had the number 0 1

302
00:26:59,320 --> 00:27:01,320
 What it's going to use?

303
00:27:07,180 --> 00:27:09,180
 Yeah, so that's 6

304
00:27:10,480 --> 00:27:16,620
 so if we shift it right by 1 we'll get 0 0 1 0

305
00:27:19,540 --> 00:27:27,329
 1 1 thank you, which is 3 and that's 6 divided by 2 is 3 if we shift that again

306
00:27:31,720 --> 00:27:37,110
 We'll get 1 but of course you know that 3 halves or 1.5

307
00:27:38,890 --> 00:27:42,060
 the rule on integer division is you

308
00:27:43,450 --> 00:27:45,780
 round it down Round it Towards 0

309
00:27:47,320 --> 00:27:49,649
 and so that goes to 1 so

310
00:27:50,890 --> 00:27:54,089
 This is what the unsigned case works fine

311
00:27:55,060 --> 00:27:57,060
 the sine Case

312
00:27:57,910 --> 00:27:59,910
 which I don't have a slide for

313
00:28:05,159 --> 00:28:09,659
 Is a little bit less of pretty oh

314
00:28:11,499 --> 00:28:17,009
 Well first of all you notice if it's a positive number the shifting rights going to be the right thing. Oh

315
00:28:18,129 --> 00:28:21,719
 Just as is for untime but let's take a number that is

316
00:28:27,340 --> 00:28:31,590
 Negative, so this is plus two minus six

317
00:28:33,639 --> 00:28:35,639
 right now

318
00:28:35,679 --> 00:28:38,309
 here's where remember I told you in the

319
00:28:39,309 --> 00:28:42,178
 previous lecture, there's two ways to do shifting there's

320
00:28:42,940 --> 00:28:49,169
 Logical shifting where you fill in with zeros and arithmetic shifting where you fill in with ones?

321
00:28:49,899 --> 00:28:51,899
 and

322
00:28:53,470 --> 00:28:56,309
 Guess where arithmetic shifting comes in this is it?

323
00:28:56,979 --> 00:29:04,739
 When you want to preserve the sign of a number while you're dividing it by powers of two you want arithmetic shifts?

324
00:29:05,109 --> 00:29:07,109
 so if we shift this by one

325
00:29:08,019 --> 00:29:12,029
 We'll keep that sign bit and then copy the other ones

326
00:29:12,759 --> 00:29:14,529
 over

327
00:29:14,529 --> 00:29:17,098
 All right, so we just preserve this bit

328
00:29:18,159 --> 00:29:21,329
 here and copied the other ones over and

329
00:29:21,999 --> 00:29:23,999
 This is minus three

330
00:29:26,200 --> 00:29:30,929
 and so that's good, but now if we shift again arithmetic, we

331
00:29:34,059 --> 00:29:36,059
 Will get what?

332
00:29:40,720 --> 00:29:42,340
 Nice - I

333
00:29:42,340 --> 00:29:44,340
 can see you guys need to know how to

334
00:29:44,919 --> 00:29:49,079
 Negate numbers right you don't know that so I'll show you in a second

335
00:29:49,480 --> 00:29:53,399
 So here is a little bit problematic that we shifted

336
00:29:54,519 --> 00:29:56,519
 We want to divide by two

337
00:29:57,639 --> 00:30:04,378
 But the rule should be the same that you should round toward zero and what this is doing is it's Rounding Toward

338
00:30:05,080 --> 00:30:10,620
 Minus infinity its rounding toward a more negative number than the truth thing

339
00:30:11,440 --> 00:30:14,789
 And so there's a little cute little trick

340
00:30:17,110 --> 00:30:24,779
 That says before you shift before you divide by a power of two before you do the shift. You should add a bias

341
00:30:31,659 --> 00:30:35,878
 Which in this case would just be one and I'll tell you where that comes from and so

342
00:30:36,279 --> 00:30:38,789
 if we add those numbers together we'll get

343
00:30:39,549 --> 00:30:41,549
 one One one zero

344
00:30:44,769 --> 00:30:47,638
 Right and now when we do the shift on that

345
00:30:49,419 --> 00:30:51,009
 we'll get

346
00:30:51,009 --> 00:30:53,009
 1 1 1 1 and

347
00:30:53,499 --> 00:30:58,799
 That's minus 1 so there's a trick and you'll again you'll see the compiler doing this where

348
00:30:59,529 --> 00:31:03,569
 You have in your code divided by 16, and we'll add a bias

349
00:31:03,570 --> 00:31:10,499
 and then it will do a right shift instead of calling division and by the way division really really is slow even on a

350
00:31:11,499 --> 00:31:15,689
 Modern computer like what you have the shark machines it takes

351
00:31:16,869 --> 00:31:24,629
 Thirty plus clock cycles so anytime the compiler can avoid figure out a trick that does it with shifting and

352
00:31:24,970 --> 00:31:26,970
 Tweaking things around it will oh

353
00:31:28,059 --> 00:31:29,799
 So I

354
00:31:29,799 --> 00:31:32,908
 Realized I should tell you there's a couple ways you can

355
00:31:35,790 --> 00:31:40,459
 Negated number that are handy to know if you ever have to do it in your head or on paper

356
00:31:41,700 --> 00:31:43,440
 and

357
00:31:43,440 --> 00:31:49,579
 The standard way is what's called complement and increment, so this is how do I go from x to minus x?

358
00:31:52,230 --> 00:31:54,230
 so if I have a number

359
00:31:56,160 --> 00:31:57,420
 and

360
00:31:57,420 --> 00:32:04,310
 I want to negate it whether it's currently a negative number, or it's a positive number the same trick works

361
00:32:04,560 --> 00:32:07,849
 what I'll do is complement it meaning I'll flip all the bits and

362
00:32:11,310 --> 00:32:13,310
 Then I'll add one to that

363
00:32:17,100 --> 00:32:20,360
 And do the regular sum

364
00:32:25,020 --> 00:32:29,180
 And so this is six, this is minus six

365
00:32:30,960 --> 00:32:36,020
 So if you ever have to do it by hand, that's the way to do a compliment in increment, and it goes the other way

366
00:32:36,570 --> 00:32:38,570
 You'll see if I compliment this

367
00:32:43,980 --> 00:32:47,120
 And I increment it. I'll get

368
00:32:49,890 --> 00:32:52,790
 Back to my previous number, so that's the trick that

369
00:32:55,830 --> 00:33:02,240
 It's pretty much only useful when you do things on the blackboard or when you have to solve a problem in Data Web

370
00:33:10,380 --> 00:33:12,380
 so

371
00:33:13,080 --> 00:33:15,080
 anyway this idea of

372
00:33:16,800 --> 00:33:17,970
 doing a

373
00:33:17,970 --> 00:33:25,250
 Using up shifting to the right to do power of two division is actually that's the whole justification for arithmetic shifting in the first place

374
00:33:25,590 --> 00:33:27,590
 Which by the way in NC?

375
00:33:28,230 --> 00:33:29,850
 There's no

376
00:33:29,850 --> 00:33:37,640
 Fixed requirement for how shifting works in C for signed numbers for unsigned it has to be a logical shift

377
00:33:38,309 --> 00:33:40,399
 sign numbers the C standard says

378
00:33:41,130 --> 00:33:48,140
 There's no fixed definition. The reality is on our machines most machines just about every machine out there

379
00:33:48,870 --> 00:33:54,800
 When it's a two's complement number when it's a negative where it's assigned number two's complement

380
00:33:54,800 --> 00:33:57,679
 And when you do a shift, it will be an arithmetic shift

381
00:34:06,780 --> 00:34:10,639
 So getting back to them summarizing this integer arithmetic

382
00:34:11,460 --> 00:34:15,139
 You see that first of all whether it's signed your unsigned

383
00:34:16,169 --> 00:34:18,199
 the addition or multiplication

384
00:34:19,230 --> 00:34:21,230
 Operations are the same

385
00:34:21,840 --> 00:34:23,700
 whether it's A

386
00:34:23,700 --> 00:34:25,700
 unsigned number or two's complement

387
00:34:26,730 --> 00:34:28,730
 And it works

388
00:34:28,830 --> 00:34:35,899
 The negative stuff works out as long as you don't have an overflow and you can end up with an overflow

389
00:34:38,129 --> 00:34:44,569
 only one type of overflow for unsigned in two types four signed numbers, but it's not like

390
00:34:45,330 --> 00:34:48,799
 They just overflow and generate random numbers. There's some of

391
00:34:49,379 --> 00:34:54,229
 A pattern to what result what they are and how they can be interpreted

392
00:35:01,150 --> 00:35:02,170
 so

393
00:35:02,170 --> 00:35:07,260
 We I talked about this a little bit last time and gave this example similar to this

394
00:35:07,260 --> 00:35:09,260
 But let me go over it a little bit more

395
00:35:10,600 --> 00:35:11,830
 one

396
00:35:11,830 --> 00:35:19,559
 Thing you might think of while if it's unsigned and signed stuff gets so murky and we saw some funny examples last time

397
00:35:19,960 --> 00:35:21,960
 Maybe we should just vanished

398
00:35:22,360 --> 00:35:28,559
 unsigned numbers from the universe and only allow Two's complement, and that's exactly the

399
00:35:29,230 --> 00:35:33,539
 Rule that was adopted for example in Java. They said this is too weird

400
00:35:35,650 --> 00:35:40,619
 What let's just say every number is two's complement. The only trick. They did was

401
00:35:42,640 --> 00:35:44,640
 they put in a

402
00:35:45,250 --> 00:35:47,399
 triple right shift

403
00:35:50,830 --> 00:35:54,120
 Means logical shift this is Java. This is not C

404
00:36:01,990 --> 00:36:05,250
 Whereas the double is a arithmetic

405
00:36:13,230 --> 00:36:14,640
 so

406
00:36:14,640 --> 00:36:22,579
 Because they rise there's a lot of cute little times when you want to play tricks with things and you need that logical rate shift

407
00:36:23,819 --> 00:36:31,039
 So that's actually one approach or other more modern languages and Si are saying it's okay to have signed and unsigned

408
00:36:31,710 --> 00:36:36,919
 But we don't want them sort of mysteriously being cast back and forth in ways that the programmer

409
00:36:37,260 --> 00:36:39,800
 Might not recognize and so you have to explicitly

410
00:36:40,890 --> 00:36:45,410
 Do a cast rather than implicitly and I think that's the better approach

411
00:36:45,480 --> 00:36:53,480
 But see as I mentioned does this implicit casting and so as we saw for last time what happens with this

412
00:36:53,910 --> 00:36:55,910
 Program when you run it

413
00:36:59,490 --> 00:37:04,219
 To count down through an array. Do you remember?

414
00:37:08,849 --> 00:37:14,689
 Well as I if it's unsigned what will happen with this test?

415
00:37:16,109 --> 00:37:22,009
 It always succeed so the thing will be in an infinite. Loop actually what will happen is it will try to access

416
00:37:22,920 --> 00:37:30,050
 I will go down to 0 and then it will wrap around to become the largest possible unsigned number

417
00:37:30,050 --> 00:37:33,619
 Which is probably way out of balance, and it will give a memory error

418
00:37:34,859 --> 00:37:42,109
 But it won't do what's supposed to be and as I mentioned before these things there's a lot of sneaky ways this problem can show

419
00:37:42,109 --> 00:37:48,529
 Up in ways you might never think of so for example the operators Sizeof is

420
00:37:49,410 --> 00:37:51,410
 defined to

421
00:37:51,900 --> 00:37:54,680
 say, how big a particular datatype is

422
00:37:55,319 --> 00:37:59,689
 it's a very useful operator, but it's its return value is a

423
00:38:00,869 --> 00:38:04,399
 what's called a size underscore t which is defined to be a

424
00:38:05,130 --> 00:38:07,130
 long unsigned number and

425
00:38:07,589 --> 00:38:08,790
 so

426
00:38:08,790 --> 00:38:10,319
 if we just

427
00:38:10,319 --> 00:38:13,669
 Throw in a constant like this then this subtraction

428
00:38:14,010 --> 00:38:21,979
 We have a sign is now int but Sizeof is unsigned and so it will cast that to be unsigned

429
00:38:22,380 --> 00:38:24,380
 implicitly and

430
00:38:24,510 --> 00:38:27,349
 When you compare it to 0 you'll have the same problem as before?

431
00:38:28,890 --> 00:38:32,990
 So just to show you that these things can speak in in very

432
00:38:33,810 --> 00:38:38,479
 Tricky ways so one way to do that. Then is just don't use

433
00:38:40,109 --> 00:38:46,639
 Unsigned like and make sure if this is a a possible

434
00:38:48,210 --> 00:38:53,990
 Unsigned number you cast it to signed you make sure this is recognized signed

435
00:38:54,569 --> 00:38:56,749
 But there's another way that actually

436
00:38:57,420 --> 00:39:02,060
 At least there's a fellow over in the software engineering institute named Robert secord

437
00:39:02,460 --> 00:39:06,079
 who has written the books that are Sooner considered the

438
00:39:06,750 --> 00:39:08,750
 the

439
00:39:09,810 --> 00:39:12,259
 gold standard for how to write secure code

440
00:39:12,690 --> 00:39:18,079
 He works for this organization called the computer emergency response team which is out there

441
00:39:18,839 --> 00:39:21,019
 Tracking down bad things

442
00:39:21,930 --> 00:39:24,619
 going on in computer Security and

443
00:39:25,200 --> 00:39:31,760
 One of the things he and others have done is to try and come up with standards so that people who write programs

444
00:39:32,279 --> 00:39:33,480
 will

445
00:39:33,480 --> 00:39:39,139
 You know avoid some of the pitfalls that make their programs vulnerable to the security of laws to

446
00:39:39,930 --> 00:39:46,159
 Attack and so his recommended technique is when I first saw this it was so counterintuitive to me

447
00:39:46,829 --> 00:39:48,829
 it

448
00:39:48,990 --> 00:39:50,990
 It hardly made sense

449
00:39:51,510 --> 00:39:53,659
 Right so you start and again

450
00:39:53,660 --> 00:40:01,010
 This is all unsigned arithmetic. So I'm starting to count down and my test is when I is less than count

451
00:40:01,859 --> 00:40:07,578
 So here's the thing I started off smaller than count and it's only being decremented

452
00:40:07,980 --> 00:40:10,189
 so when would this test ever fail

453
00:40:13,710 --> 00:40:15,329
 Hmm

454
00:40:15,329 --> 00:40:23,329
 When it overflows when it wraps around right when I goes from zero and counts down to what would now be you max this

455
00:40:24,450 --> 00:40:32,029
 Test will fail, which is exactly when you want it to stop and his observation is and see with signed numbers

456
00:40:32,029 --> 00:40:38,149
 There's no guarantee on what happens with overflowing as I said most people just assume

457
00:40:38,150 --> 00:40:39,440
 It's going to be two's complement

458
00:40:39,440 --> 00:40:46,490
 But if you really want to be careful you shouldn't assume anything outside of the C standard and if you're trying to write secure code

459
00:40:47,039 --> 00:40:50,929
 It's probably a good idea to be cautious be conservative

460
00:40:52,349 --> 00:40:58,219
 On the other hand the C standard guarantees it that unsigned arithmetic will be modular arithmetic

461
00:40:58,500 --> 00:41:05,239
 So it guarantees that if you subtract one from zero you'll get the largest number that could be represented

462
00:41:05,520 --> 00:41:07,520
 So it will

463
00:41:07,890 --> 00:41:09,890
 be okay, and in fact

464
00:41:10,380 --> 00:41:16,520
 He recommends instead of using unsigned which is on our machines. Just a 32-bit value

465
00:41:17,400 --> 00:41:21,829
 That you call it a size t. Which is a 64-bit value and

466
00:41:22,859 --> 00:41:26,209
 So and write your code the way that I showed you

467
00:41:27,210 --> 00:41:34,099
 So I've actually started doing this and once you kind of get used to it. It's an ok way to write code, but it's very

468
00:41:34,630 --> 00:41:36,630
 Strange looking in this way

469
00:41:37,180 --> 00:41:39,180
 One thing I'll point out is

470
00:41:43,870 --> 00:41:47,279
 what would happen if if count were a

471
00:41:49,030 --> 00:41:51,030
 signed number and int and

472
00:41:51,820 --> 00:41:57,389
 It were you were and it was less than zero. What would happen here, so

473
00:42:01,480 --> 00:42:04,139
 I less than count. What would happen

474
00:42:10,390 --> 00:42:16,680
 Right and so it become a very large positive number and this test would almost certainly succeed

475
00:42:16,680 --> 00:42:22,169
 So you have the same this code doesn't avoid the Pitfall it just shifts it to saying

476
00:42:23,290 --> 00:42:27,870
 You better make sure you don't you know test for this case beforehand?

477
00:42:28,660 --> 00:42:30,660
 Before you get into it

478
00:42:31,990 --> 00:42:33,990
 So I

479
00:42:35,410 --> 00:42:40,440
 Think part of it is the observation that man if you want to be careful and write code that

480
00:42:41,320 --> 00:42:44,999
 That is guaranteed correct no matter what?

481
00:42:45,640 --> 00:42:51,120
 Implementation goes on as long as it's within the cie standard. It's pretty tricky business to question up there

482
00:42:59,440 --> 00:43:01,530
 Yes, which is unfortunate?

483
00:43:03,580 --> 00:43:07,139
 Right so yes, that's exactly the rule that it's implicitly

484
00:43:07,780 --> 00:43:12,870
 Silently the C compiler doesn't give any warnings. You'll never know it cast

485
00:43:12,870 --> 00:43:15,870
 It's unsigned and as these examples show

486
00:43:16,600 --> 00:43:20,339
 When you stare at that code and you think about it?

487
00:43:20,890 --> 00:43:27,690
 It's really easy to have bugs that you just you can look at it a thousand times and not realize that it's a bug

488
00:43:27,850 --> 00:43:29,879
 it's a very and there's

489
00:43:30,820 --> 00:43:32,879
 examples these examples in the book of

490
00:43:34,090 --> 00:43:36,090
 security flaws in

491
00:43:36,460 --> 00:43:41,040
 Sort of very important library software due to this problem exactly

492
00:43:44,970 --> 00:43:52,069
 So part of the reason we teach in the course is just so you appreciate that. This is a quirk in this and see that

493
00:43:53,849 --> 00:43:55,259
 again

494
00:43:55,259 --> 00:43:57,889
 99% of the time you'll never even it

495
00:43:58,410 --> 00:44:03,230
 won't bother you at all, but there will be some oddball cases that you can get in trouble with

496
00:44:07,829 --> 00:44:10,939
 So the other place that you'll find

497
00:44:12,690 --> 00:44:14,690
 unsigned arithmetic unsigned

498
00:44:15,059 --> 00:44:18,199
 Representation useful is first of all when you're doing modular arithmetic

499
00:44:18,749 --> 00:44:20,749
 Which is for example?

500
00:44:20,940 --> 00:44:24,499
 the way most Encryption algorithms work or

501
00:44:25,170 --> 00:44:32,779
 When you're using the bits not to represent numbers, but to represent sets the way I described it before then

502
00:44:34,529 --> 00:44:38,989
 You don't want it. It's easiest to just think of that as unsigned numbers

503
00:44:44,369 --> 00:44:47,239
 Okay, so the final thing to talk about today is

504
00:44:48,210 --> 00:44:53,329
 some of the Low-level representations of numbers within memory and

505
00:44:54,420 --> 00:44:56,420
 The main Point is when you are

506
00:44:57,869 --> 00:44:59,869
 Running a program on a computer

507
00:45:02,009 --> 00:45:08,869
 From the programming perspective either even as an assembly level programmer, not just as a C programmer

508
00:45:09,690 --> 00:45:16,009
 In your mind, the memory is just this big array of bytes. That's numbered from 0 up to some maximum

509
00:45:16,559 --> 00:45:18,829
 number so for example in the

510
00:45:19,799 --> 00:45:22,219
 Machines, we're using the 64-bit machines

511
00:45:24,089 --> 00:45:27,439
 An address is represented in 64 bits

512
00:45:28,950 --> 00:45:35,029
 but in fact the maximum address you're allowed to use in current machines is a

513
00:45:35,910 --> 00:45:37,910
 47 Bits and

514
00:45:39,720 --> 00:45:45,139
 To the Forty-Seventh is still a pretty big number, so that's more memory than anyone's

515
00:45:45,809 --> 00:45:52,129
 Able to buy right now anyhow and so it's a reasonable restriction, but the point is that logically?

516
00:45:52,739 --> 00:45:56,329
 your program thinks that it has a array of

517
00:45:56,849 --> 00:46:02,038
 At many bites let's try and figure out how big to Xlvii is anyone know it off the top of their head

518
00:46:06,729 --> 00:46:10,829
 So there's a trick if you want to get an approximate idea

519
00:46:14,470 --> 00:46:17,549
 Which is to say that 2 to the 10th?

520
00:46:18,309 --> 00:46:19,839
 which is

521
00:46:19,839 --> 00:46:21,640
 110 24

522
00:46:21,640 --> 00:46:23,079
 is

523
00:46:23,079 --> 00:46:25,079
 Approximately equal to 10 to the third

524
00:46:27,759 --> 00:46:32,129
 You say oh, well that's really helpful. What it means is that 10 bits?

525
00:46:33,729 --> 00:46:38,339
 Worth of number is about the same as three decimal digits

526
00:46:39,130 --> 00:46:41,489
 All right, so for example

527
00:46:42,220 --> 00:46:44,220
 2 to the

528
00:46:47,680 --> 00:46:49,680
 20th is

529
00:46:51,880 --> 00:46:53,880
 around 10 to the 6

530
00:46:54,759 --> 00:46:58,619
 2 to the 30th it's around 10 to the 9th

531
00:47:00,489 --> 00:47:02,489
 to the 40th

532
00:47:03,430 --> 00:47:05,519
 around 10 to the 12th and

533
00:47:07,630 --> 00:47:13,559
 So that would tell you that 2 to the 48-47 is around

534
00:47:14,979 --> 00:47:19,139
 128 times 10 to the 12th which is 128 Terabyte, right?

535
00:47:20,859 --> 00:47:22,779
 Tara 10 to the 12

536
00:47:22,779 --> 00:47:29,968
 So if you just want to say you know get a quick figure 4 and of course these are approximations

537
00:47:30,460 --> 00:47:34,169
 But if you just want to get a quick handle on how big a number?

538
00:47:34,170 --> 00:47:40,920
 You know what range of values can I represent with so many bits of it? This is a really easy trick to do that

539
00:47:41,890 --> 00:47:43,890
 so the point is a

540
00:47:44,589 --> 00:47:48,028
 128 Terabytes is a lot

541
00:47:50,140 --> 00:47:56,969
 you can buy disk drives a couple of disk drives will do that for you, but you couldn't buy enough dram on a

542
00:47:57,549 --> 00:47:59,849
 normal budget to get that kind of memory

543
00:48:00,279 --> 00:48:02,819
 So that's the current range of values

544
00:48:02,819 --> 00:48:09,629
 But logically when you run a program it thinks that it has that possible range now

545
00:48:09,670 --> 00:48:15,750
 It doesn't really and in fact what happens is that the operating system only allows certain

546
00:48:16,030 --> 00:48:18,030
 regions within that memory to be

547
00:48:18,310 --> 00:48:26,070
 Referenced and other regions if you try to access them it will create a it will signal an error what they call a segmentation fault

548
00:48:26,650 --> 00:48:31,320
 But logically at least it's as if you have this big array of bytes now in reality

549
00:48:31,450 --> 00:48:35,129
 And we'll go into this when we talk about how the memory system is

550
00:48:35,770 --> 00:48:37,770
 works in Virtual memory

551
00:48:41,110 --> 00:48:47,969
 There's this very complex combination of hardware and software that gives the program this image of a very large

552
00:48:48,430 --> 00:48:54,180
 What you call flap space just a big array of bytes when in reality it's shuffling

553
00:48:54,880 --> 00:49:01,500
 Between different regions of your memory and even between your memory and your disk drive on your computer

554
00:49:02,380 --> 00:49:03,940
 to make it

555
00:49:03,940 --> 00:49:05,940
 implement this particular

556
00:49:08,440 --> 00:49:14,730
 idea that you have this big array of bytes, and that's all handled as I said by the operating system by the

557
00:49:15,490 --> 00:49:21,719
 Computer hardware, and it's largely invisible even to the machine level programmer even people writing assembly code

558
00:49:28,960 --> 00:49:34,230
 you'll often hear the term word size and it can get very confusing confusing nowadays because

559
00:49:34,870 --> 00:49:39,809
 There's no really fixed idea of what a word size is but roughly speaking

560
00:49:40,510 --> 00:49:43,949
 The word size should be whatever the largest

561
00:49:45,070 --> 00:49:47,070
 Number is that or

562
00:49:49,450 --> 00:49:56,909
 The range that sort of signifies. How big a pointer is in this language or hardware wise the largest?

563
00:49:57,790 --> 00:50:04,830
 Sort of chunk of hardware for which there's standard support for storing it for arithmetic operations and so forth

564
00:50:05,170 --> 00:50:07,350
 So when we say it's a 64-bit machine

565
00:50:08,410 --> 00:50:10,410
 What we mean is that it it?

566
00:50:10,900 --> 00:50:12,900
 regular and Routinely

567
00:50:13,000 --> 00:50:15,000
 manipulate 64-bit values

568
00:50:15,040 --> 00:50:21,689
 err on arithmetic operations and also it has a pointers or the values of

569
00:50:22,270 --> 00:50:24,270
 Addresses are 64 bits

570
00:50:24,400 --> 00:50:26,400
 even if for right now

571
00:50:27,010 --> 00:50:31,469
 Only 47 of those bits are usable. It's still considered a 64-bit machine

572
00:50:32,980 --> 00:50:36,390
 one thing that strange is in one of the features of

573
00:50:39,430 --> 00:50:42,330
 of machines such as we have

574
00:50:45,220 --> 00:50:46,510
 Huh?

575
00:50:46,510 --> 00:50:47,980
 is

576
00:50:47,980 --> 00:50:50,880
 that if I compile a program using a

577
00:50:51,940 --> 00:50:58,200
 GCC the standard compiler I can specify either. I want it to be 64 bit code

578
00:50:59,710 --> 00:51:03,360
 Or 32-bit code as a flag

579
00:51:06,730 --> 00:51:08,909
 And it will actually generate two different

580
00:51:09,460 --> 00:51:16,830
 Kinds of object code as a result and we'll talk in a look about these later, but for right now the point is

581
00:51:18,070 --> 00:51:22,409
 The hardware itself doesn't necessarily define. What the word size is

582
00:51:23,500 --> 00:51:27,330
 It's a combination of the hardware and the compiler that Determines

583
00:51:27,330 --> 00:51:30,509
 What is the word size being used in this particular program?

584
00:51:30,510 --> 00:51:38,459
 And that code can be run on the point is the 64 bit machine such as we have and most machines are nowadays

585
00:51:38,830 --> 00:51:40,830
 can insert of a

586
00:51:41,410 --> 00:51:43,360
 backward compatibility

587
00:51:43,360 --> 00:51:46,199
 style also execute 32-bit code

588
00:51:50,170 --> 00:51:57,930
 And as we also saw one of the other features is even though. It's a 64 bit word size the data type int

589
00:51:58,930 --> 00:52:00,670
 without any other

590
00:52:00,670 --> 00:52:03,180
 Qualifiers to it is just 32 bits

591
00:52:03,180 --> 00:52:09,270
 So the sort of this mixture of how big things are so when people just say word or word size

592
00:52:10,000 --> 00:52:12,570
 And let's say give a precise definition

593
00:52:12,700 --> 00:52:18,060
 That's not a very meaningful term and we'll sort of throw it around when we mean sort of a generic

594
00:52:18,490 --> 00:52:23,280
 Chunk of bits without trying to assume that it has a particular number of bits to it

595
00:52:35,400 --> 00:52:39,350
 Yes, so one of the things is if we ever get to 64-bit words

596
00:52:40,920 --> 00:52:42,920
 It will be

597
00:52:43,200 --> 00:52:45,090
 16 PetabyTes

598
00:52:45,090 --> 00:52:49,279
 18 Petabytes opinion, how you define when you those numbers get big?

599
00:52:50,130 --> 00:52:54,650
 The error due to this approximation gets more significant

600
00:52:56,400 --> 00:53:00,889
 but something times 10 to the 15th bytes, but right now we can only get to

601
00:53:02,910 --> 00:53:04,910
 128 times 10 to the 12

602
00:53:11,700 --> 00:53:16,700
 So anyway, it's the idea that the memory itself is a series of bytes

603
00:53:17,160 --> 00:53:20,389
 But we can group those into blocks of words

604
00:53:21,030 --> 00:53:24,469
 Of different word sizes and the way we do that is

605
00:53:25,260 --> 00:53:26,850
 usually by

606
00:53:26,850 --> 00:53:28,800
 assuming that the

607
00:53:28,800 --> 00:53:32,330
 The address of the word is the lowest

608
00:53:33,300 --> 00:53:38,689
 valued address in it and we also will generally try to align these so that

609
00:53:39,359 --> 00:53:41,359
 for example a

610
00:53:41,910 --> 00:53:43,910
 32-bit Word

611
00:53:44,130 --> 00:53:51,770
 Would be a line so its first byte its lowest byte has all zeros in the frick stuff

612
00:53:57,559 --> 00:54:01,629
 In the first five bit positions right now

613
00:54:02,539 --> 00:54:05,289
 32 4 I'm sorry the lowest two bytes

614
00:54:06,259 --> 00:54:11,289
 Right so as this example shows their address is 0 4 8 and

615
00:54:14,630 --> 00:54:18,099
 12 they should have really written this in hex and said it's C I

616
00:54:19,430 --> 00:54:21,789
 Guess these are all in decimal anyhow

617
00:54:22,519 --> 00:54:29,319
 so yeah these are decimal numbers so 0 4 8 12 so you see these are in multiples of 4 of

618
00:54:29,930 --> 00:54:31,849
 bit boundaries and

619
00:54:31,849 --> 00:54:35,139
 similarly the 64-bit words are in multiples of 8 and

620
00:54:36,170 --> 00:54:42,129
 Those are known as aligned words and will generally will see that the compiler works pretty hard to keep things aligned

621
00:54:42,470 --> 00:54:45,909
 because the hardware runs more efficiently that way but

622
00:54:46,730 --> 00:54:50,799
 the main point is that we can just take as many bytes as we want and

623
00:54:50,869 --> 00:54:54,399
 Collect them together and call it a word for whatever word size. We need

624
00:54:55,190 --> 00:54:56,539
 and

625
00:54:56,539 --> 00:55:02,349
 As we think we saw a variant of this table before, but this is the machines, we'll be working on that

626
00:55:03,710 --> 00:55:07,899
 the Standard int is still only 32 bits, but if we

627
00:55:08,960 --> 00:55:14,739
 Qualify something as being wrong then it will be 64 bits and will tend to do that

628
00:55:15,380 --> 00:55:17,380
 There's two different floating-point

629
00:55:17,569 --> 00:55:21,579
 Representations that we'll talk about and then the main feature of a 64

630
00:55:21,579 --> 00:55:27,729
 Bit machine is it has an 8 byte or 64 bit pointer as compared to 32?

631
00:55:30,319 --> 00:55:31,970
 Now there's one other

632
00:55:31,970 --> 00:55:37,689
 Kind of detail that says ok so if a word has multiple bytes in it

633
00:55:37,999 --> 00:55:40,899
 what order should those bytes be should it be the

634
00:55:42,920 --> 00:55:47,829
 And these two basic ways this could go one is that you put the bytes in

635
00:55:48,529 --> 00:55:54,369
 What's known as little endian order meaning that the first byte in the word is the least significant byte?

636
00:55:54,369 --> 00:55:59,889
 And then the next and then the next and the final byte in the word is the most significant

637
00:56:00,049 --> 00:56:02,079
 or you can flip that around and

638
00:56:03,470 --> 00:56:07,179
 those are called Little-Endian and Big-endian is the

639
00:56:09,619 --> 00:56:12,459
 the sort of terms for that which comes from A

640
00:56:15,349 --> 00:56:17,349
 English book

641
00:56:17,630 --> 00:56:21,550
 Called Gulliver's travels, which didn't anticipate computers at all

642
00:56:22,040 --> 00:56:24,999
 But it's an interesting story of how that comes about

643
00:56:25,460 --> 00:56:32,589
 So in out there in the world you'll find both types of machines big Indian and little Indian machines it turns out that

644
00:56:33,020 --> 00:56:36,009
 Increasingly, it's getting hard to find big Indian machines

645
00:56:36,920 --> 00:56:40,480
 so little indeed all of X86 is little Indian and

646
00:56:42,109 --> 00:56:45,219
 It turns out arm processors like what you have in

647
00:56:45,859 --> 00:56:49,659
 Almost every cell phone here is an arm processor

648
00:56:50,330 --> 00:56:51,500
 and

649
00:56:51,500 --> 00:56:56,260
 The hardware, and those can actually be configured to run either way big-endian or little-Endian

650
00:56:57,619 --> 00:57:03,249
 But when you're running it on any of the standard operating systems that run on arm processors

651
00:57:05,210 --> 00:57:07,449
 then it's running little Indian, so

652
00:57:08,359 --> 00:57:10,749
 There used to be a brand called sun

653
00:57:11,450 --> 00:57:14,530
 Microsystems and they were fairly common on campus

654
00:57:15,200 --> 00:57:18,339
 and then back in the Macintosh before they were

655
00:57:19,730 --> 00:57:23,740
 X86 processors they ran one called the PowerPC and

656
00:57:25,430 --> 00:57:29,530
 That was a big engine machine, but those are long in the distant past

657
00:57:30,500 --> 00:57:38,409
 The internet about the only place out there when you send packets over the internet you want to send in 32-bit

658
00:57:39,080 --> 00:57:46,719
 Words, they're actually sent in big Endian order and so at the network interface you have to translate between those two

659
00:57:47,810 --> 00:57:52,749
 so again just to illustrate what I mean by this is think of a

660
00:57:54,050 --> 00:57:57,459
 Byte value for byte value like this and

661
00:57:58,040 --> 00:57:59,300
 remember that

662
00:57:59,300 --> 00:58:05,259
 The way we write numbers is we put the most significant to the left and the least significant to the right

663
00:58:09,059 --> 00:58:10,089
 and

664
00:58:10,089 --> 00:58:14,369
 So now with a big-endian inserted the intuitive one

665
00:58:15,189 --> 00:58:22,439
 From that perspective in that the bike if you write the words in memory from the smallest address up to the highest

666
00:58:23,140 --> 00:58:25,919
 The Big Endian will sort of map to what you see

667
00:58:27,039 --> 00:58:29,039
 Whereas the Little Endian will look

668
00:58:30,099 --> 00:58:34,708
 Confusing that you say 0 1 2 3 4 5 6 7 because

669
00:58:35,859 --> 00:58:42,298
 6 7 is actually the least significant byte here and so that comes first in Little-Endian order and

670
00:58:43,689 --> 00:58:45,069
 and

671
00:58:45,069 --> 00:58:49,379
 So the it used to be people would get in passionate arguments about this

672
00:58:50,019 --> 00:58:52,019
 that sort of in the distant past

673
00:58:52,689 --> 00:58:54,689
 But and people saying you know

674
00:58:57,249 --> 00:58:59,519
 and the main feature in some

675
00:59:00,130 --> 00:59:06,329
 Sort of argument of Big Indian nuts is this feature here that when you look at it. It's easier to write down

676
00:59:07,299 --> 00:59:09,039
 But computers don't really care

677
00:59:09,039 --> 00:59:10,259
 They're happy either way

678
00:59:10,259 --> 00:59:15,869
 and so they just want one convention or another and like I said some hardware's can actually be a

679
00:59:16,059 --> 00:59:20,369
 By a sort of flag to flip it from being big Endian to Little Indian

680
00:59:20,589 --> 00:59:26,369
 But the reality is most of machines one counter you'll encounter a little Endian machine stoudek

681
00:59:27,219 --> 00:59:29,219
 But just to give you an example

682
00:59:29,769 --> 00:59:31,209
 here's some

683
00:59:31,209 --> 00:59:35,309
 Results that I got from actual machines there used to be some machines around

684
00:59:36,309 --> 00:59:42,178
 So back in the old days I could run this I don't even know where to get a big Endian machine anymore

685
00:59:42,880 --> 00:59:44,880
 So these are sort of legacy

686
00:59:45,579 --> 00:59:47,439
 result

687
00:59:47,439 --> 00:59:51,629
 But you'll see that the main feature is between a little Indian and a big Endian machine

688
00:59:52,299 --> 00:59:54,299
 when you have an integer

689
00:59:54,819 --> 00:59:56,819
 the bikes get flipped around

690
00:59:57,130 --> 01:00:04,679
 so that the re significant byte comes first in a little endian machine and last in a big Endian machine and

691
01:00:05,739 --> 01:00:09,928
 that's true with negative numbers as well that you'll get the

692
01:00:10,929 --> 01:00:14,219
 sign bits first in a big Endian machine a

693
01:00:16,209 --> 01:00:18,010
 long

694
01:00:18,010 --> 01:00:20,010
 You'll see that

695
01:00:21,369 --> 01:00:23,369
 the only difference between a

696
01:00:23,470 --> 01:00:30,810
 32-bit machine the 64-bit machine is you have more zeros or more ones depending whether it's a positive or negative number and

697
01:00:31,240 --> 01:00:33,240
 again, the

698
01:00:33,520 --> 01:00:38,040
 Sun, and if I had access to a 64-bit machine sun is now

699
01:00:38,920 --> 01:00:42,570
 Manufactured by a company called oracle so in principle

700
01:00:42,570 --> 01:00:48,449
 I could go get one of these machines and run this experiment, but it's really not a very interesting experiment. So I won't bother

701
01:00:51,160 --> 01:00:58,680
 So in principle, I could try it on a 64-bit oracle machine and show you something different

702
01:01:02,830 --> 01:01:09,779
 So one thing that kind of a useful tool the book goes through some examples of this is a little

703
01:01:10,630 --> 01:01:13,710
 program that will take a series of bytes

704
01:01:14,680 --> 01:01:17,159
 starting at some position start and

705
01:01:18,160 --> 01:01:22,619
 Do it for however many bytes you request and just print out in

706
01:01:23,350 --> 01:01:27,509
 hex Format, the two hex digits that

707
01:01:28,930 --> 01:01:30,930
 represent that bite valve and

708
01:01:31,900 --> 01:01:36,480
 Here this term pointer. I'm using an unsigned care as a

709
01:01:37,119 --> 01:01:39,119
 pointer type a sort of Generic

710
01:01:39,910 --> 01:01:41,910
 pointer type

711
01:01:46,290 --> 01:01:48,290
 and

712
01:01:48,870 --> 01:01:51,319
 so again if I run this on a

713
01:01:52,620 --> 01:01:54,620
 X86 Machine oh

714
01:01:55,170 --> 01:01:59,450
 Oh, and I'm also by the way printing out the actual address that this

715
01:02:01,230 --> 01:02:07,609
 character is stored in too, and so you'll see that there is these addresses with a lot of

716
01:02:08,430 --> 01:02:16,309
 7f of what that means is it's in the upper end of this 47 bit address space if you work it through there's

717
01:02:17,130 --> 01:02:20,329
 seven is three ones, and then there's

718
01:02:22,290 --> 01:02:29,540
 Enough hex digits here to correspond to so there's 11 hex digits Beyond the seven

719
01:02:31,470 --> 01:02:35,929
 And you'll see that these addresses are at successive bytes Bc. B

720
01:02:35,930 --> 01:02:42,649
 Db Eb f and the values are 63 b 0 0 0 0 this is the least significant byte

721
01:02:42,650 --> 01:02:44,650
 And these are the successive byte

722
01:02:46,920 --> 01:02:48,060
 and

723
01:02:48,060 --> 01:02:49,560
 A

724
01:02:49,560 --> 01:02:51,560
 similar I can I

725
01:02:52,140 --> 01:02:56,119
 Can use this to examine pointers of various Sorts?

726
01:02:56,250 --> 01:03:01,069
 And I can examine different values and just get their low-level byte representations

727
01:03:02,010 --> 01:03:03,450
 And so I did this

728
01:03:03,450 --> 01:03:07,789
 back when I could get to a sun machine it had one way of representing a pointer and

729
01:03:07,890 --> 01:03:12,260
 the main Point is even across machines whether it's a byte ordering or

730
01:03:13,020 --> 01:03:16,129
 Whatever, you'll get different values for pointers

731
01:03:16,130 --> 01:03:23,720
 there's no guarantee that when you load them a computer program into one machine and run it that it will use the same addresses as

732
01:03:25,380 --> 01:03:32,119
 That same programming running on a different machine even if actually they're identical hardware and operating system there can be variation

733
01:03:33,780 --> 01:03:38,899
 Because pointers aren't you can't directly copy a pointer from one machine to another?

734
01:03:41,160 --> 01:03:42,690
 on

735
01:03:42,690 --> 01:03:44,310
 one thing about

736
01:03:44,310 --> 01:03:48,200
 also is regardless of byte ordering the ordering of of

737
01:03:49,320 --> 01:03:56,210
 Characters is the same and so a string in C is always represented by a series of bytes

738
01:03:56,640 --> 01:03:58,640
 Where the final byte is 0?

739
01:03:59,270 --> 01:04:01,869
 called null-terminated and the

740
01:04:03,020 --> 01:04:09,909
 individual bytes correspond to the character codes for that number and these character codes are just

741
01:04:10,849 --> 01:04:12,849
 sometimes called Ascii format

742
01:04:13,190 --> 01:04:15,369
 Which is a little bit old-fashioned by the way

743
01:04:16,040 --> 01:04:18,969
 There's more modern character codes too that can represent

744
01:04:20,240 --> 01:04:22,240
 non English

745
01:04:23,150 --> 01:04:28,089
 Alphabets, but the C standard is still back in the days of only

746
01:04:29,150 --> 01:04:32,440
 supporting the the Ascii Format question

747
01:04:37,430 --> 01:04:39,430
 Uh-Huh?

748
01:04:49,940 --> 01:04:52,750
 Yes, so this should have been

749
01:04:57,890 --> 01:05:00,760
 Well, no, this is good. So I'm casting

750
01:05:00,890 --> 01:05:06,760
 I want to show the for bite-size event for because this is an int. I'm representing

751
01:05:07,280 --> 01:05:13,179
 The pointer let's see the code. We're printing the pointer all this notation

752
01:05:13,880 --> 01:05:17,260
 % p is the directive to say print out a pointer

753
01:05:17,839 --> 01:05:19,839
 proposed right and

754
01:05:20,030 --> 01:05:23,979
 % x is the directive to print out a hex

755
01:05:24,500 --> 01:05:26,000
 representation

756
01:05:26,000 --> 01:05:34,000
 So it's printing out both the address the starting position of that particular byte and the value of that byte as two different things

757
01:05:34,970 --> 01:05:36,970
 Does that answer your question?

758
01:05:40,049 --> 01:05:42,529
 returning upper Darker yes

759
01:05:52,109 --> 01:05:54,109
 but remember show bytes

760
01:05:54,990 --> 01:05:56,460
 is

761
01:05:56,460 --> 01:05:58,460
 being given a pointer and

762
01:05:59,160 --> 01:06:04,639
 A length and so what this is and what it's saying is starting at that address

763
01:06:05,250 --> 01:06:07,459
 Print out the next series of bytes

764
01:06:07,980 --> 01:06:12,109
 For me. How many bytes I asked for and in this case

765
01:06:12,109 --> 01:06:16,969
 I'm I'm creating a pointer to this integer, but I want to show the

766
01:06:17,520 --> 01:06:21,889
 The bytes in that integer the four bytes that make up that integer

767
01:06:22,079 --> 01:06:26,539
 And that's why I'm giving it the number four here instead of eight is it

768
01:06:32,400 --> 01:06:36,799
 Yes, it will be and that's fine because in this code

769
01:06:37,740 --> 01:06:40,189
 I'm using the percent P directive

770
01:06:40,710 --> 01:06:45,109
 to designate how to print out the pointer and that will print it as

771
01:06:45,510 --> 01:06:49,010
 Many bytes as it takes for that particular machine that it's running on

772
01:06:50,130 --> 01:06:57,770
 So percent p is actually a very handy directive if you have to print addresses like for debugging purposes or something because it will

773
01:06:58,440 --> 01:07:00,950
 Automatically adapt to whatever machine. It's running on

774
01:07:02,339 --> 01:07:04,339
 question

775
01:07:07,320 --> 01:07:12,499
 Well, I've defined it to be an unsigned care here. So type. Def is a

776
01:07:13,020 --> 01:07:15,739
 way to introduce a name for some of

777
01:07:16,260 --> 01:07:19,669
 Data type right and so I've just declared a pointer

778
01:07:20,430 --> 01:07:22,430
 quote pointer

779
01:07:23,250 --> 01:07:27,469
 To refer to an unsigned care if you did a void star

780
01:07:28,350 --> 01:07:34,700
 It would not be happy with this reference here right you can't

781
01:07:36,240 --> 01:07:41,240
 You can't reference a void star is just a way to pass around a generic pointer

782
01:07:41,240 --> 01:07:45,560
 But you can't actually reference that element so what I'm basically doing is saying

783
01:07:46,740 --> 01:07:49,159
 This reference is treated like an array

784
01:07:50,250 --> 01:07:56,030
 You treat my series of bytes is an array and print out each of the bytes in that array

785
01:08:00,630 --> 01:08:02,630
 and so here where I'm

786
01:08:03,060 --> 01:08:04,350
 A

787
01:08:04,350 --> 01:08:06,120
 is A

788
01:08:06,120 --> 01:08:08,120
 number and I'm

789
01:08:08,550 --> 01:08:10,939
 taking the address of that integer and

790
01:08:11,640 --> 01:08:14,300
 Casting it to be an unsigned care star

791
01:08:15,330 --> 01:08:22,190
 So sort of a generic slightly generic pointer, but not quite as generic as void star and then printing it up

792
01:08:23,820 --> 01:08:26,119
 Was it good quite easy good questions by the way

793
01:08:30,660 --> 01:08:37,249
 Okay, so the point being that strings are just strings, and that's the same from one machine to the next

794
01:08:38,790 --> 01:08:42,620
 Okay, let's finish up today with some puzzles and these have

795
01:08:43,560 --> 01:08:45,979
 This annoying way of showing up on exams

796
01:08:46,650 --> 01:08:49,909
 So it's worth being able to do these kind of things

797
01:08:52,170 --> 01:08:56,629
 And you'll also notice I cleverly did not include the answers in the slide

798
01:09:00,239 --> 01:09:05,209
 So you can't you can't just peek ahead and figure out what the answers are so let's just go through them

799
01:09:05,219 --> 01:09:07,789
 But I actually worked them out to make sure I had the entry zone

800
01:09:08,370 --> 01:09:11,209
 so if x and basically these are sort of

801
01:09:12,060 --> 01:09:14,330
 Statements that you want to say these are either

802
01:09:15,089 --> 01:09:19,639
 always true, and maybe there's some logic behind why it's always true or

803
01:09:20,219 --> 01:09:24,948
 Possibly False, and you won't have to give some example that would make that False

804
01:09:25,620 --> 01:09:29,479
 so let's go through these as many as we have time for and

805
01:09:30,239 --> 01:09:36,709
 See where we get to so if I take x and I double it multiply it by 2 if x who are negative

806
01:09:37,350 --> 01:09:40,969
 And my guaranteed that 2x will be negative

807
01:09:41,640 --> 01:09:43,640
 no, so

808
01:09:44,130 --> 01:09:51,500
 by the way one general way to find counter examples is to try team in it's a really good one and

809
01:09:52,170 --> 01:09:57,230
 that works here right if I take team N, which is one and a bunch of zeros, I double it like

810
01:09:57,810 --> 01:10:00,259
 Shifting it, but left and it will become what?

811
01:10:01,080 --> 01:10:03,080
 zero right

812
01:10:03,600 --> 01:10:04,830
 is

813
01:10:04,830 --> 01:10:11,209
 And so again assume that x is that any negative number and ux is it's unsigned

814
01:10:11,489 --> 01:10:14,419
 I'm sorry two's complement number and

815
01:10:14,940 --> 01:10:16,440
 Ux is

816
01:10:16,440 --> 01:10:21,679
 What happens if I cast it to be unsigned so as u x always you're greater than or equal to zero?

817
01:10:22,620 --> 01:10:24,620
 Yeah

818
01:10:25,290 --> 01:10:29,179
 That's slightly more obscure if I take x and I mask off

819
01:10:31,199 --> 01:10:37,789
 Seven you, remember is the bit pattern 1 1 1 so as I mask off all but the lowest 3 bits

820
01:10:38,940 --> 01:10:46,489
 And I find that those are all one. I'm already giving you the answer here, and then I shift it left by 30 position

821
01:10:47,040 --> 01:10:49,040
 What can I say about the result?

822
01:10:59,269 --> 01:11:01,269
 So I know the Ex

823
01:11:02,760 --> 01:11:08,059
 must finish with 3:1 right and I shift that

824
01:11:11,670 --> 01:11:13,670
 by 30

825
01:11:18,239 --> 01:11:20,239
 and

826
01:11:20,820 --> 01:11:26,420
 this these will be the only two bits that are left after the shifting and they will be in the

827
01:11:27,389 --> 01:11:30,409
 Most significant position, so what can I say about that number?

828
01:11:31,650 --> 01:11:34,039
 Is negative so this is a true statement?

829
01:11:34,829 --> 01:11:36,829
 Rather obscure, but it is true

830
01:11:37,769 --> 01:11:40,399
 Is Ux greater than minus one?

831
01:11:45,059 --> 01:11:47,059
 It's almost true, right?

832
01:11:50,610 --> 01:11:52,670
 The one counter example would be what?

833
01:11:56,760 --> 01:11:58,679
 the Zoo

834
01:11:58,679 --> 01:12:04,459
 Well actually no you're right. There's a lot of examples. It's hardly ever true. It's almost always false

835
01:12:04,639 --> 01:12:07,669
 I was wrong the only thing that would make it

836
01:12:08,219 --> 01:12:10,219
 True would be

837
01:12:11,489 --> 01:12:13,489
 XI it's never true

838
01:12:14,309 --> 01:12:16,309
 Okay, so it's never true

839
01:12:17,969 --> 01:12:22,908
 Okay, if x is greater than y is minus x less than minus y

840
01:12:34,620 --> 01:12:41,180
 No, so by the way one thing we didn't really cover is what is the negative of tea men?

841
01:12:45,750 --> 01:12:50,119
 And to see that we can use our complement income instrument trick

842
01:12:58,200 --> 01:13:00,200
 so when you

843
01:13:01,080 --> 01:13:08,419
 Compliment an increment t. Min you get t min, and that's why it's such a great counter example

844
01:13:10,050 --> 01:13:12,050
 so in particular if

845
01:13:14,280 --> 01:13:16,280
 Y is t min?

846
01:13:16,980 --> 01:13:18,980
 And x is something else

847
01:13:19,380 --> 01:13:23,839
 Then that left-hand part will be true, but the right-hand part will not be true

848
01:13:26,580 --> 01:13:34,129
 Okay, x times x greater than or equal to zero we've seen examples of that being False

849
01:13:36,919 --> 01:13:43,039
 If x is it is just kind of silly if x is greater than zero and y is greater than zero is x plus y

850
01:13:43,039 --> 01:13:45,039
 Greater than zero no

851
01:13:46,590 --> 01:13:51,259
 If x is greater than or equal to zero is minus x less than or equal to zero

852
01:13:54,030 --> 01:13:56,630
 Gotcha you're right. It's true, right?

853
01:13:57,689 --> 01:13:59,610
 because that

854
01:13:59,610 --> 01:14:05,149
 But let's take it counterpart if x is less than or equal to zero is minus x squared equals zero

855
01:14:06,300 --> 01:14:11,329
 Team N. Right so right the point being that the largest any

856
01:14:11,880 --> 01:14:19,429
 positive number can be represented as negative, but there's one negative number that can't be represented as positive and

857
01:14:20,249 --> 01:14:23,569
 So that asymmetry is why you get different answers to these?

858
01:14:24,780 --> 01:14:31,070
 If I take x and I look at minus x and I shift them to the right by 31

859
01:14:32,489 --> 01:14:34,549
 Am I going to get all ones?

860
01:14:35,939 --> 01:14:37,939
 This is a really weird statement

861
01:14:48,350 --> 01:14:52,359
 So it actually kind of works right if I take all zeros

862
01:15:02,270 --> 01:15:05,799
 And I subtract one I'll get minus one

863
01:15:10,789 --> 01:15:12,789
 And I or them

864
01:15:17,179 --> 01:15:20,138
 That works, so what's wrong with this?

865
01:15:24,679 --> 01:15:32,408
 What's that? Oh, but if I shift it to the right 31 places that's going to shift arithmetic Aliy

866
01:15:41,750 --> 01:15:43,750
 What's that?

867
01:15:44,030 --> 01:15:50,230
 Oh, I see. Oh, I'm sorry. I already jumped ahead to a different puzzle

868
01:15:52,340 --> 01:15:54,340
 x and minus x and I

869
01:15:56,119 --> 01:15:58,119
 So you're right actually?

870
01:15:59,329 --> 01:16:01,659
 if the two numbers is zero

871
01:16:03,289 --> 01:16:06,129
 And I or those I get zero

872
01:16:08,630 --> 01:16:11,710
 But you'll figure out you'll notice if it's anything non zero

873
01:16:13,039 --> 01:16:15,039
 actually this will be true and

874
01:16:15,710 --> 01:16:22,839
 That's an interesting feature, so there's a couple other puzzles, and I'll I'll let you solve those on your own. We're all set for today

