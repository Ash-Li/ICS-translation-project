1
00:00:00,000 --> 00:00:06,012
I guess one thing I I am the rest of the

2
00:00:03,003 --> 00:00:08,025
staff request is that you whenever you

3
00:00:06,012 --> 00:00:10,781
have a question you first read the book

4
00:00:08,025 --> 00:00:13,544
and then you reread the assignment and

5
00:00:10,889 --> 00:00:16,560
you maybe reread it again and then you

6
00:00:13,769 --> 00:00:18,840
ask us because a lot of the questions

7
00:00:16,056 --> 00:00:21,093
we're getting are ones where we just say

8
00:00:18,084 --> 00:00:23,160
look at this page of the book look at

9
00:00:21,093 --> 00:00:26,432
this paragraph of the assignment look at

10
00:00:24,006 --> 00:00:31,044
this part of the file that you were

11
00:00:27,269 --> 00:00:34,590
given and so I mean there's a lot of

12
00:00:31,098 --> 00:00:36,017
stuff and I understand how sometimes

13
00:00:34,059 --> 00:00:38,067
it's easy to miss things so not saying

14
00:00:36,899 --> 00:00:41,520
don't ever ask questions but just before

15
00:00:39,039 --> 00:00:44,043
you ask your questions trying to figure

16
00:00:41,052 --> 00:00:46,571
out if I really should have come through

17
00:00:44,043 --> 00:00:48,602
the resources I have available to see if

18
00:00:47,039 --> 00:00:55,770
the answer to my question is can be

19
00:00:48,989 --> 00:00:57,930
found there so anyways enjoy the web so

20
00:00:55,077 --> 00:01:00,150
today is a sort of second part of a

21
00:00:57,093 --> 00:01:02,932
two-part lecture on integers and integer

22
00:01:01,005 --> 00:01:07,005
arithmetic last time we looked at

23
00:01:03,769 --> 00:01:11,580
representations about how bit patterns

24
00:01:07,005 --> 00:01:13,038
can be interpreted as either unsigned

25
00:01:11,058 --> 00:01:18,063
numbers meaning they range between zero

26
00:01:13,083 --> 00:01:20,115
and two to the word size minus one or as

27
00:01:19,008 --> 00:01:24,024
two's complement numbers which is the

28
00:01:21,015 --> 00:01:25,089
most compliment you away to represent

29
00:01:24,024 --> 00:01:27,090
what are sometimes called signed numbers

30
00:01:25,089 --> 00:01:29,142
ones it can be their negative or

31
00:01:27,009 --> 00:01:31,053
positive and by the way there are other

32
00:01:30,042 --> 00:01:35,093
ways to represent signed numbers out

33
00:01:32,034 --> 00:01:38,453
there but tooth complemented so so

34
00:01:35,093 --> 00:01:41,145
overwhelmingly the most used system that

35
00:01:38,759 --> 00:01:45,020
that's what we concentrate on today what

36
00:01:42,045 --> 00:01:46,053
we'll do is now go beyond the

37
00:01:45,002 --> 00:01:49,601
representations of these values to talk

38
00:01:47,025 --> 00:01:53,324
about arithmetic operations on them and

39
00:01:49,619 --> 00:01:55,530
some of their properties and what we'll

40
00:01:53,549 --> 00:01:58,140
do in general we talk about the unsigned

41
00:01:55,053 --> 00:01:59,136
case which is in some ways easier to

42
00:01:58,014 --> 00:02:02,100
understand and more intuitive and then

43
00:02:00,036 --> 00:02:05,975
talk about the two's complement case so

44
00:02:03,000 --> 00:02:11,043
the basic rule on this is if you take

45
00:02:06,299 --> 00:02:13,780
two numbers that range between up to the

46
00:02:11,043 --> 00:02:16,054
maximum value of an unsigned number

47
00:02:13,078 --> 00:02:18,154
add them but in principle you might need

48
00:02:16,054 --> 00:02:21,055
to get an extra bit to represent that

49
00:02:19,054 --> 00:02:23,095
thumb if you want to represent the true

50
00:02:21,055 --> 00:02:24,081
some sort of integer sum of those two

51
00:02:23,095 --> 00:02:26,116
numbers

52
00:02:24,081 --> 00:02:29,110
because you're doubling it and

53
00:02:27,016 --> 00:02:32,040
unfortunately we can't just go out and

54
00:02:30,001 --> 00:02:35,068
add more bits to your computer

55
00:02:32,004 --> 00:02:39,031
indefinitely so we just stop it at some

56
00:02:35,077 --> 00:02:41,092
point and say well whatever bit happened

57
00:02:39,067 --> 00:02:43,072
to be in that sort of next / bit

58
00:02:41,092 --> 00:02:45,411
position we're just going to drop it and

59
00:02:43,072 --> 00:02:47,119
pretend it doesn't exist and say that

60
00:02:46,239 --> 00:02:51,790
the result of addition is just whatever

61
00:02:48,019 --> 00:02:54,028
the W bit pattern you get if you only

62
00:02:51,079 --> 00:02:59,101
consider the first W bits out of it with

63
00:02:55,009 --> 00:03:01,908
no warning no messages no error or

64
00:03:00,001 --> 00:03:07,075
anything this is just it happens

65
00:03:01,989 --> 00:03:12,400
silently so for at each compliment this

66
00:03:07,075 --> 00:03:13,153
is not such a hard thing to understand

67
00:03:12,004 --> 00:03:17,011
it can be thought of as just modular

68
00:03:14,053 --> 00:03:19,069
arithmetic computing modulo the two to

69
00:03:17,047 --> 00:03:20,143
the word size and so I'm going to use

70
00:03:19,069 --> 00:03:22,090
some examples and this time I've got

71
00:03:21,043 --> 00:03:26,322
them worked out a little more carefully

72
00:03:22,009 --> 00:03:28,054
so I will get mixed up as much and we'll

73
00:03:26,709 --> 00:03:32,560
use the word size of four here and as I

74
00:03:29,035 --> 00:03:34,674
mentioned last time it really helps with

75
00:03:32,056 --> 00:03:37,117
this to work do the examples with small

76
00:03:34,989 --> 00:03:40,061
word sizes to get a your intuition for

77
00:03:38,017 --> 00:03:43,072
it rather than trying to write out

78
00:03:40,709 --> 00:03:45,670
32-bit numbers or 64-bit numbers or

79
00:03:43,072 --> 00:03:52,371
something like that so if you think

80
00:03:45,067 --> 00:03:57,067
about in the unsigned case a 4-bit

81
00:03:53,019 --> 00:04:03,070
number means that it will range between

82
00:03:57,067 --> 00:04:06,090
0 and 2 to the 4th minus 1 or 15 right

83
00:04:03,007 --> 00:04:11,010
and so let's just do a few examples of

84
00:04:06,009 --> 00:04:15,042
cases where it overflows so if you add

85
00:04:11,037 --> 00:04:15,123
13 to 5

86
00:04:20,009 --> 00:04:24,970
first of all you know I assume already

87
00:04:23,011 --> 00:04:28,350
that you just add binary numbers the way

88
00:04:24,097 --> 00:04:29,125
you learned in school of just doing

89
00:04:28,449 --> 00:04:36,452
carries and so forth except it's all

90
00:04:30,025 --> 00:04:41,029
modulo two so this is zero carry one one

91
00:04:36,479 --> 00:04:44,500
zero carry one zero carry one

92
00:04:41,065 --> 00:04:47,163
so in principle to represent the sum

93
00:04:44,005 --> 00:04:52,039
which is this is five so to represent 18

94
00:04:48,063 --> 00:04:54,072
you need five bits not four but we're

95
00:04:52,084 --> 00:04:58,086
just going to conveniently drop that

96
00:04:54,639 --> 00:05:03,780
number and say that this is actually 2

97
00:04:58,086 --> 00:05:05,149
which of course is what 18 module 16 is

98
00:05:03,078 --> 00:05:13,087
so the unsigned case is really pretty

99
00:05:06,049 --> 00:05:16,078
straightforward and we can visualize

100
00:05:13,087 --> 00:05:20,155
this in this pictures in the book too by

101
00:05:16,078 --> 00:05:24,527
saying if you are representing on the X

102
00:05:21,055 --> 00:05:27,954
and y axis what they call U and V are

103
00:05:25,229 --> 00:05:30,276
values between 0 and 15 the range of

104
00:05:28,449 --> 00:05:32,440
possible unsigned numbers and if we're

105
00:05:30,699 --> 00:05:37,150
going to add those we could get a sum

106
00:05:32,044 --> 00:05:39,096
that up to as much as 30 which would in

107
00:05:37,015 --> 00:05:42,087
principle require 5 bits to represent

108
00:05:39,096 --> 00:05:44,125
but what we'll do is we'll just by

109
00:05:42,087 --> 00:05:47,316
dropping that most significant bit what

110
00:05:45,025 --> 00:05:52,027
we do is to create a clip that when you

111
00:05:48,099 --> 00:05:54,153
roll over from 15 to 16 instead it drops

112
00:05:52,027 --> 00:05:58,072
all the way down to 0 and that's

113
00:05:54,639 --> 00:06:00,660
referred to as an overflow and then from

114
00:05:58,072 --> 00:06:04,108
there we'll build up to the maximum

115
00:06:00,849 --> 00:06:08,020
value here will be 14 which is 30 minus

116
00:06:05,008 --> 00:06:10,093
16 so what we've done is basically as

117
00:06:08,002 --> 00:06:14,151
this picture shows when we overflow we

118
00:06:10,093 --> 00:06:16,158
effectively subtract off 2 to the W from

119
00:06:14,169 --> 00:06:21,400
the sum and keep it within the

120
00:06:17,058 --> 00:06:25,144
representable range of W bit numbers so

121
00:06:21,004 --> 00:06:28,015
that's untimed two's complement once the

122
00:06:26,044 --> 00:06:30,083
first thing I want to convince you of is

123
00:06:28,051 --> 00:06:35,057
that two's complement addition

124
00:06:30,083 --> 00:06:39,130
looks just like a regular edition in

125
00:06:36,011 --> 00:06:43,019
other words I can perform a subtraction

126
00:06:40,003 --> 00:06:45,017
and addition of subtraction of numbers

127
00:06:43,019 --> 00:06:47,074
by using this tooth compliment

128
00:06:45,044 --> 00:06:50,060
representation for negative numbers so

129
00:06:47,074 --> 00:06:58,115
well let me just show you some examples

130
00:06:50,006 --> 00:07:00,011
of that so first of all remember that

131
00:06:59,015 --> 00:07:02,096
what range of values what's the smallest

132
00:07:01,001 --> 00:07:05,096
number that could be represented with a

133
00:07:02,096 --> 00:07:10,105
four bit the most negative number four

134
00:07:06,005 --> 00:07:18,077
bit two's complement number minus eight

135
00:07:11,005 --> 00:07:23,005
and the largest plus seven thank you so

136
00:07:18,077 --> 00:07:22,105
let's just do some examples if we took

137
00:07:25,084 --> 00:07:34,163
this number 1 1 0 1 as the two's

138
00:07:31,076 --> 00:07:43,153
complement number is minus 3 and we add

139
00:07:35,063 --> 00:07:43,072
it to 5 we'll get what we got before

140
00:07:51,000 --> 00:07:54,096
and we're not good at we're going to

141
00:07:52,008 --> 00:07:58,035
ignore whatever carry bid it is and so

142
00:07:54,096 --> 00:08:01,134
the result is - I'm going behold that's

143
00:07:59,007 --> 00:08:06,051
what five minus three is so it seems

144
00:08:02,034 --> 00:08:07,098
like magic because it is Tuesday and

145
00:08:06,051 --> 00:08:09,090
that's why part of the reason why I

146
00:08:07,098 --> 00:08:10,107
choose complement is to the most

147
00:08:09,009 --> 00:08:13,092
commonly used way of representing signed

148
00:08:11,088 --> 00:08:17,120
numbers because the same hardware the

149
00:08:14,073 --> 00:08:21,114
same algorithms that are used for doing

150
00:08:18,002 --> 00:08:32,100
addition in work for either unsigned or

151
00:08:22,014 --> 00:08:37,080
two's complement numbers and this works

152
00:08:33,018 --> 00:08:41,037
as well just to show you if the overflow

153
00:08:37,008 --> 00:08:47,049
goes if the resulting film is goes the

154
00:08:41,037 --> 00:08:53,108
other way so if I have minus 3 and minus

155
00:08:48,021 --> 00:08:53,108
5 and plus 3 and I add those together

156
00:09:02,068 --> 00:09:13,099
I'll get 1 1 1 0 which is minus 2 so

157
00:09:10,031 --> 00:09:17,039
again if you use the same patterns for

158
00:09:13,099 --> 00:09:19,166
the same rule for addition as you do

159
00:09:18,011 --> 00:09:24,080
with an unsigned case you'll get two

160
00:09:20,066 --> 00:09:27,125
complementary rhythm so let's look at a

161
00:09:24,008 --> 00:09:38,056
few cases where the two's complement

162
00:09:28,025 --> 00:09:39,028
overflows so if we take 3

163
00:09:44,092 --> 00:10:00,051
and -6 and we add them together we'll

164
00:09:57,429 --> 00:10:08,478
get one one one zero we're going to drop

165
00:10:00,879 --> 00:10:10,904
off the carry which is what seven so

166
00:10:08,919 --> 00:10:12,963
we've added two negative numbers and

167
00:10:11,129 --> 00:10:15,132
it's become positive

168
00:10:13,359 --> 00:10:24,393
and that's referred to as a negative

169
00:10:15,429 --> 00:10:27,504
overflow and the reason of course is the

170
00:10:24,699 --> 00:10:34,740
number minus nine can't be represented

171
00:10:28,179 --> 00:10:39,970
in a 4-bit to compliment number so it

172
00:10:35,109 --> 00:10:42,144
overflowed you'll notice that the cost

173
00:10:39,097 --> 00:10:46,135
seven of course differs from minus 9 by

174
00:10:42,459 --> 00:10:50,410
16 and that's not next to and then going

175
00:10:47,035 --> 00:10:58,214
the other direction if we had two large

176
00:10:50,041 --> 00:10:58,160
positive numbers so if we add 7 & 5

177
00:11:08,079 --> 00:11:26,110
we'll get minus six so this was seven

178
00:11:14,579 --> 00:11:29,050
plus five is minus four and so this is

179
00:11:27,001 --> 00:11:39,420
referred to as positive overflow we've

180
00:11:29,005 --> 00:11:40,098
taken two positive numbers and added

181
00:11:39,519 --> 00:11:43,930
them together and gotten a negative

182
00:11:40,098 --> 00:11:46,099
result and you could see this by the way

183
00:11:43,093 --> 00:11:48,181
if you think about this addition we took

184
00:11:46,099 --> 00:11:51,558
seven and five would be twelve and this

185
00:11:49,081 --> 00:11:54,154
is the bit level representation of

186
00:11:52,449 --> 00:11:58,494
twelve it's just that because this is

187
00:11:55,054 --> 00:12:04,087
not the time bit we think of that as

188
00:11:58,899 --> 00:12:07,905
minus four not positive twelve and so

189
00:12:04,087 --> 00:12:10,105
that's the the idea of two's complement

190
00:12:07,959 --> 00:12:15,041
overflow and you can see there's two

191
00:12:11,005 --> 00:12:19,018
different cases here one is where the

192
00:12:15,779 --> 00:12:22,120
number that the sum was if we looked at

193
00:12:19,018 --> 00:12:25,063
the true sum the numbers that you'd get

194
00:12:22,012 --> 00:12:27,531
for example 12 is too big to represent

195
00:12:25,063 --> 00:12:28,572
and so when we think of that as a two's

196
00:12:27,639 --> 00:12:30,160
complement number it becomes now a

197
00:12:29,139 --> 00:12:32,232
negative number

198
00:12:30,016 --> 00:12:35,074
so that's positive overflow similarly if

199
00:12:33,069 --> 00:12:38,115
we have two negative numbers and we add

200
00:12:35,074 --> 00:12:40,138
them together so that the sum is too

201
00:12:38,529 --> 00:12:42,597
small to negative to represent then

202
00:12:41,038 --> 00:12:45,100
those become positive numbers that's

203
00:12:43,209 --> 00:12:49,180
negative overflow and you can see that

204
00:12:46,000 --> 00:12:53,949
in this picture the same ideas before

205
00:12:49,018 --> 00:12:56,047
except there's three regions this is and

206
00:12:53,949 --> 00:13:00,480
by the way now you'll see our numbers

207
00:12:56,047 --> 00:13:04,093
range between minus 8 and positive 7 and

208
00:13:00,048 --> 00:13:09,717
the sum to come will also range between

209
00:13:04,093 --> 00:13:12,117
minus 8 and a positive 7 but there's

210
00:13:10,149 --> 00:13:16,167
these three regions one is the where

211
00:13:13,017 --> 00:13:18,906
everything's fine

212
00:13:16,329 --> 00:13:22,401
it's within the representable range the

213
00:13:19,059 --> 00:13:24,670
other is where the sum was so far toward

214
00:13:23,049 --> 00:13:28,083
the negative side that it becomes

215
00:13:24,067 --> 00:13:31,646
positive or where it's so high on the

216
00:13:28,389 --> 00:13:36,480
positive side that it becomes negative

217
00:13:32,249 --> 00:13:41,256
and so part of data web you'll you'll

218
00:13:37,299 --> 00:13:44,325
learn to understand these quite in quite

219
00:13:41,949 --> 00:13:47,025
precisely but that lets the idea it's a

220
00:13:44,559 --> 00:13:49,720
little bit counterintuitive to say you

221
00:13:47,709 --> 00:13:51,910
know somehow I can accept the idea the

222
00:13:49,072 --> 00:13:54,085
modular arithmetic for unsigned numbers

223
00:13:51,091 --> 00:13:57,630
there's some sort of mathematical beauty

224
00:13:54,085 --> 00:14:03,314
to a modular arithmetic and this disk

225
00:13:58,449 --> 00:14:08,456
looks like kind of useless right from a

226
00:14:04,079 --> 00:14:13,116
from a operational characteristic but

227
00:14:09,149 --> 00:14:14,160
it's the way it is and we're stuck with

228
00:14:13,449 --> 00:14:18,486
it

229
00:14:14,016 --> 00:14:20,475
and multiplication is basically the same

230
00:14:18,819 --> 00:14:23,290
idea in fact all the operations are

231
00:14:20,619 --> 00:14:24,681
basically the same idea that if you

232
00:14:23,029 --> 00:14:28,728
can't represent it within the word size

233
00:14:25,239 --> 00:14:33,246
you just take the lower W bits so all

234
00:14:28,989 --> 00:14:35,058
this complicated notation here is just a

235
00:14:33,939 --> 00:14:37,941
way of saying in principle if you take

236
00:14:35,679 --> 00:14:42,160
2w bit numbers and multiply them

237
00:14:37,959 --> 00:14:44,058
together you may need a the result may

238
00:14:42,016 --> 00:14:48,995
require as much as 2 times W bits to

239
00:14:44,949 --> 00:14:50,028
represent before addition its W plus 1

240
00:14:49,139 --> 00:14:51,237
multiplication you actually have to

241
00:14:50,739 --> 00:14:56,793
double because you're potentially

242
00:14:52,119 --> 00:15:00,160
squaring the largest number and so again

243
00:14:57,279 --> 00:15:01,365
we don't want to just keep doubling our

244
00:15:00,016 --> 00:15:04,048
word size over and over again we'll run

245
00:15:02,139 --> 00:15:13,212
out of bits very quickly that way and so

246
00:15:04,048 --> 00:15:17,127
we just truncate it at W bits and for

247
00:15:13,869 --> 00:15:18,933
the unsigned case it's again modular

248
00:15:17,559 --> 00:15:24,602
arithmetic it's something that you can

249
00:15:19,509 --> 00:15:24,557
kind of understand and believe but for

250
00:15:25,019 --> 00:15:30,230
two and so again let's just do a few

251
00:15:28,048 --> 00:15:33,080
examples and I won't try and

252
00:15:30,023 --> 00:15:36,050
work out multiplying in binary is like

253
00:15:33,008 --> 00:15:37,064
multiplying in decimal you do a big

254
00:15:36,005 --> 00:15:41,011
table and it takes a long time so I

255
00:15:38,036 --> 00:15:54,041
won't try to do that but let me just

256
00:15:42,001 --> 00:15:58,010
show a few examples so if I multiply

257
00:15:54,041 --> 00:16:01,330
three times five is of course equal to

258
00:15:58,019 --> 00:16:13,085
15 and in an unsigned number I can

259
00:16:01,699 --> 00:16:22,699
represent that right so that's okay but

260
00:16:13,085 --> 00:16:27,634
if I multiply a five times five then

261
00:16:22,699 --> 00:16:30,500
that would have representation if I were

262
00:16:28,399 --> 00:16:31,790
to think about it as possibly as many as

263
00:16:30,005 --> 00:16:40,022
eight bits it would have a

264
00:16:31,079 --> 00:16:42,125
representation with an extra bit and I'm

265
00:16:40,067 --> 00:16:45,796
going to throw this part away and so I'd

266
00:16:43,025 --> 00:16:49,069
call that nine which of course is equal

267
00:16:46,399 --> 00:16:49,690
to 25 960

268
00:16:52,079 --> 00:16:58,080
um and and so that's the general idea of

269
00:16:56,085 --> 00:17:00,171
it is regardless of whatever is in this

270
00:16:58,089 --> 00:17:03,096
upper part of the work of the product

271
00:17:01,071 --> 00:17:05,148
I'm just going to discard that and only

272
00:17:03,096 --> 00:17:07,595
look at the lower one and vice gets a

273
00:17:06,048 --> 00:17:11,052
little more interesting with the two's

274
00:17:08,459 --> 00:17:18,482
complement case so let's look at what

275
00:17:11,052 --> 00:17:21,077
that does and the answer is even a

276
00:17:18,689 --> 00:17:24,300
little bit stranger that you not only

277
00:17:21,077 --> 00:17:26,756
trunk throw away whatever high order

278
00:17:24,003 --> 00:17:29,007
bits happen to be there but whatever bit

279
00:17:27,449 --> 00:17:31,500
gets left in this position will

280
00:17:29,007 --> 00:17:34,052
determine whether it's a positive or a

281
00:17:31,005 --> 00:17:38,007
negative result even though with

282
00:17:35,015 --> 00:17:42,039
completely irrespective of the signs of

283
00:17:38,052 --> 00:17:45,116
the original two operands so that can

284
00:17:42,039 --> 00:17:45,116
make you go all over the place

285
00:18:01,065 --> 00:18:16,065
so if we had five times four or 20 that

286
00:18:09,076 --> 00:18:15,165
would be represented in this 8-bit form

287
00:18:22,038 --> 00:18:31,042
like so and we just call that for right

288
00:18:28,069 --> 00:18:39,115
is we're showing this away but if we did

289
00:18:31,078 --> 00:18:42,114
five times five as we saw before that's

290
00:18:40,015 --> 00:18:42,114
represented like this

291
00:18:49,077 --> 00:18:56,079
and that sum now becomes so we're

292
00:18:54,051 --> 00:19:00,084
throwing away this and this becomes our

293
00:18:56,097 --> 00:19:06,126
sign bit so the result is minus 8 plus 1

294
00:19:00,084 --> 00:19:07,176
or minus 7 so you see this is a similar

295
00:19:07,026 --> 00:19:11,825
to an example we showed at the beginning

296
00:19:08,076 --> 00:19:14,082
of the first lecture that you can have

297
00:19:12,059 --> 00:19:18,600
two positive numbers and multiply them

298
00:19:14,082 --> 00:19:19,691
and get a negative result and because of

299
00:19:18,006 --> 00:19:26,034
the sort of course of this overflow

300
00:19:20,429 --> 00:19:30,517
question there oh I'm just taking 25 and

301
00:19:26,088 --> 00:19:34,166
writing it in binary yeah if you want to

302
00:19:31,309 --> 00:19:38,520
you know you start with the two numbers

303
00:19:35,066 --> 00:19:39,102
I'm not going to do well actually this

304
00:19:38,052 --> 00:19:41,148
one's an easy one there's a trick for

305
00:19:40,002 --> 00:19:44,079
this if you want to know multiply a

306
00:19:42,048 --> 00:19:47,051
number by a power of two we're going to

307
00:19:44,079 --> 00:19:54,171
show that later you just shift it left

308
00:19:47,078 --> 00:19:57,084
by two position so that one's an easy

309
00:19:55,071 --> 00:19:59,112
one otherwise you have to write out the

310
00:19:57,084 --> 00:20:03,090
table and sum all the results and all

311
00:20:00,012 --> 00:20:05,111
that stuff I prefer to what computers do

312
00:20:03,009 --> 00:20:05,030
that

313
00:20:12,929 --> 00:20:20,770
and again this to complement stuff one

314
00:20:17,077 --> 00:20:24,082
interesting feature is that it works for

315
00:20:20,077 --> 00:20:25,162
our negative numbers too so if you do

316
00:20:25,027 --> 00:20:29,556
this trick of throwing away the

317
00:20:26,062 --> 00:20:31,221
high-order bit and you'll have overflow

318
00:20:29,799 --> 00:20:33,804
cases like before because you're

319
00:20:31,779 --> 00:20:36,460
throwing away information but the lower

320
00:20:34,299 --> 00:20:39,100
bits if the number is representable

321
00:20:36,046 --> 00:20:45,255
you'll get the right result so let me

322
00:20:39,001 --> 00:20:49,099
just demonstrate to that to you so this

323
00:20:45,669 --> 00:20:52,750
is a minus 3 but you remember that this

324
00:20:50,008 --> 00:21:01,084
is equivalent to 13 as an unsigned

325
00:20:52,075 --> 00:21:04,134
number and this is minus 2 which is

326
00:21:01,084 --> 00:21:10,173
equivalent to my 14 as an unsigned

327
00:21:04,809 --> 00:21:16,690
number so now if we multiply 13 times 14

328
00:21:10,929 --> 00:21:19,976
you get 182 and that has a hex

329
00:21:16,069 --> 00:21:19,778
representation of b6

330
00:21:27,012 --> 00:21:36,036
and so just looking at the low order for

331
00:21:31,048 --> 00:21:40,072
bit are 0 1 1 0 is 6 and indeed that

332
00:21:36,036 --> 00:21:43,335
negative 3 times minus 2 is 6 so the

333
00:21:40,072 --> 00:21:44,781
point being oh and I'm waving my hands

334
00:21:43,659 --> 00:21:47,980
here because I don't want to go through

335
00:21:45,429 --> 00:21:52,360
all the details but to complement

336
00:21:47,098 --> 00:21:55,120
multiplication also gives you if you can

337
00:21:52,036 --> 00:21:57,112
do it using the exact same rules and as

338
00:21:56,002 --> 00:22:00,007
you do for unsigned multiplication the

339
00:21:58,012 --> 00:22:04,191
exact same hardware I should mention

340
00:22:00,025 --> 00:22:05,122
that and there are instructions in the

341
00:22:04,299 --> 00:22:09,130
computer in ways that you can get the

342
00:22:06,022 --> 00:22:10,701
upper word of a multiplication too and

343
00:22:09,013 --> 00:22:13,022
though it's the bit patterns are

344
00:22:10,899 --> 00:22:15,370
different depending on whether it

345
00:22:13,139 --> 00:22:17,139
treated as a tooth compliment number

346
00:22:15,037 --> 00:22:19,051
versus unsigned so these typically

347
00:22:17,139 --> 00:22:23,620
different instructions for doing that

348
00:22:19,051 --> 00:22:26,340
computation but 99% of the time or more

349
00:22:23,062 --> 00:22:27,981
you just are looking at this lower part

350
00:22:26,799 --> 00:22:29,862
of the product and that's the same

351
00:22:28,539 --> 00:22:34,575
whether it's a two's complement or an

352
00:22:30,429 --> 00:22:36,477
unsigned and it handles negative numbers

353
00:22:34,899 --> 00:22:39,690
positive but it has these overflow

354
00:22:36,909 --> 00:22:39,690
characteristics

355
00:22:42,779 --> 00:22:48,831
so as I was talking about there's a

356
00:22:46,539 --> 00:22:51,940
trick we can do for multiplying by a

357
00:22:49,299 --> 00:22:54,010
power of two which is just to shift the

358
00:22:51,094 --> 00:22:56,146
number to the left and you'll often see

359
00:22:54,001 --> 00:22:59,550
that when you have in your code I want

360
00:22:57,046 --> 00:23:01,635
to multiply some number by four you'll

361
00:22:59,559 --> 00:23:04,360
write in your C code if you look at the

362
00:23:02,049 --> 00:23:07,240
assembly code you'll see that what the

363
00:23:04,036 --> 00:23:09,735
compiler generated is just says oh just

364
00:23:07,024 --> 00:23:11,113
shift it left by two so in general and

365
00:23:10,059 --> 00:23:21,250
you could see why this is true by the

366
00:23:12,013 --> 00:23:35,071
way if you think of the number as the

367
00:23:21,025 --> 00:23:38,184
sum of the bits where X sub I is the ice

368
00:23:35,071 --> 00:23:42,124
bit and X is the number it represents if

369
00:23:38,409 --> 00:23:45,630
I want to if I shift everything left by

370
00:23:43,024 --> 00:23:49,048
two what I'm effectively doing is

371
00:23:45,063 --> 00:23:52,069
increasing their weight by that number

372
00:23:49,048 --> 00:23:56,747
of positions so let's just shift by one

373
00:23:52,069 --> 00:23:56,558
if I shift everything to the left by one

374
00:24:00,036 --> 00:24:10,108
which we write like this and see two

375
00:24:03,025 --> 00:24:13,584
left two less symbols so I taking that

376
00:24:11,008 --> 00:24:16,060
sum but now waiting the disk by two to

377
00:24:13,809 --> 00:24:19,833
be I plus one by one more and of course

378
00:24:16,006 --> 00:24:27,033
that's equal to twice what the original

379
00:24:20,049 --> 00:24:34,074
sum was and so we double the number and

380
00:24:27,087 --> 00:24:36,088
that works although even if you shift

381
00:24:34,299 --> 00:24:39,010
things so that you lose some bits right

382
00:24:36,088 --> 00:24:41,119
they they shift off to the left all

383
00:24:39,001 --> 00:24:42,510
you're doing is the way multiplication

384
00:24:42,019 --> 00:24:45,085
works

385
00:24:42,519 --> 00:24:48,460
anyhow of truncating to W bit product so

386
00:24:45,085 --> 00:24:51,121
you'll see this as I mentioned quite

387
00:24:48,046 --> 00:24:53,137
often in in compiled code machine level

388
00:24:52,021 --> 00:24:55,036
code that they're doing shifts where you

389
00:24:54,037 --> 00:24:57,037
might expect them

390
00:24:55,036 --> 00:24:59,067
to be doing multiplications and the

391
00:24:57,037 --> 00:25:01,063
reason for that is an optimization is

392
00:24:59,067 --> 00:25:03,070
historically the multiplication

393
00:25:01,063 --> 00:25:07,117
instruction took a lot longer than a

394
00:25:03,097 --> 00:25:10,158
shift instruction say one clock cycle to

395
00:25:08,017 --> 00:25:15,048
do a shift and it used to be like 11 12

396
00:25:11,058 --> 00:25:20,065
30 clock cycles to do a multiplication

397
00:25:15,048 --> 00:25:22,054
nowadays like on the computers we use

398
00:25:20,065 --> 00:25:23,101
the sharp machines it only take three

399
00:25:22,054 --> 00:25:26,086
clock cycles to do multiplication

400
00:25:24,001 --> 00:25:29,550
because they added a lot of hardware to

401
00:25:26,086 --> 00:25:32,134
do that but three clock cycles is still

402
00:25:29,559 --> 00:25:35,410
more time than one and so when you can

403
00:25:33,034 --> 00:25:37,039
get away with a shift it's generally a

404
00:25:35,041 --> 00:25:41,430
better idea and the compiler has its own

405
00:25:37,084 --> 00:25:44,095
kind of judgment calls on when is it

406
00:25:41,799 --> 00:25:52,600
more efficient to substitute one

407
00:25:44,095 --> 00:25:54,120
operation for another did we design lose

408
00:25:52,006 --> 00:25:54,012
ground here

409
00:25:59,099 --> 00:26:09,177
okay so the idea that if we want to

410
00:26:06,098 --> 00:26:19,131
multiply something by 2 to the K we just

411
00:26:10,077 --> 00:26:23,088
shift it left by K bit it turns out that

412
00:26:20,031 --> 00:26:25,074
the same almost works for dividing by 2

413
00:26:23,088 --> 00:26:27,177
as well that if you want to divide

414
00:26:25,074 --> 00:26:32,160
something by a power of 2 you can shift

415
00:26:28,077 --> 00:26:34,155
it right by in the same general idea the

416
00:26:33,006 --> 00:26:37,053
only thing that becomes a little bit

417
00:26:35,055 --> 00:26:40,104
quirky is well what if the number you

418
00:26:38,007 --> 00:26:53,061
have is not actually divisible by that

419
00:26:41,004 --> 00:27:07,070
power of 2 so for example if we had the

420
00:26:53,061 --> 00:27:12,095
number 0 1 what it's going to use yeah

421
00:27:07,007 --> 00:27:21,084
so that's 6 so if we shift it right by 1

422
00:27:12,095 --> 00:27:25,137
we'll get 0 0 1 0 1 1 thank you which is

423
00:27:22,047 --> 00:27:33,141
3 and that's 6 divided by 2 is 3 if we

424
00:27:26,037 --> 00:27:39,039
shift that again we'll get 1 but of

425
00:27:34,041 --> 00:27:43,119
course you know that 3 halves or 1.5 the

426
00:27:39,039 --> 00:27:48,081
rule on integer division is you round it

427
00:27:44,019 --> 00:27:53,046
down round it towards 0 and so that goes

428
00:27:48,081 --> 00:27:57,159
to 1 so this is what the unsigned case

429
00:27:53,046 --> 00:28:00,122
works fine the sine case which I don't

430
00:27:58,059 --> 00:28:00,122
have a slide for

431
00:28:05,159 --> 00:28:13,172
is a little bit less of pretty oh well

432
00:28:11,999 --> 00:28:15,014
first of all you notice if it's a

433
00:28:13,289 --> 00:28:18,341
positive number the shifting rights

434
00:28:15,149 --> 00:28:21,161
going to be the right thing oh just as

435
00:28:18,809 --> 00:28:30,821
is for untime but let's take a number

436
00:28:21,269 --> 00:28:36,290
that is negative so this is plus two

437
00:28:30,929 --> 00:28:39,017
minus six right now here's where

438
00:28:36,479 --> 00:28:41,522
remember I told you in the previous

439
00:28:39,809 --> 00:28:43,883
lecture there's two ways to do shifting

440
00:28:41,909 --> 00:28:46,961
there's logical shifting where you fill

441
00:28:44,549 --> 00:28:53,970
in with zeros and arithmetic shifting

442
00:28:47,429 --> 00:28:55,950
where you fill in with ones and guess

443
00:28:53,097 --> 00:28:58,736
where arithmetic shifting comes in this

444
00:28:55,095 --> 00:29:01,034
is it when you want to preserve the sign

445
00:28:59,609 --> 00:29:04,622
of a number while you're dividing it by

446
00:29:01,889 --> 00:29:07,973
powers of two you want arithmetic shifts

447
00:29:04,739 --> 00:29:11,700
so if we shift this by one we'll keep

448
00:29:08,729 --> 00:29:16,470
that sign bit and then copy the other

449
00:29:11,007 --> 00:29:19,406
ones over all right so we just preserve

450
00:29:16,047 --> 00:29:26,816
this bit here and copied the other ones

451
00:29:20,099 --> 00:29:29,180
over and this is minus three and so

452
00:29:27,239 --> 00:29:36,307
that's good but now if we shift again

453
00:29:29,909 --> 00:29:36,910
arithmetic we will get what

454
00:29:40,022 --> 00:29:46,074
nice - I can see you guys need to know

455
00:29:43,095 --> 00:29:48,108
how to negate numbers right you don't

456
00:29:46,074 --> 00:29:51,863
know that so I'll show you in a second

457
00:29:49,008 --> 00:29:58,067
so here is a little bit problematic that

458
00:29:52,529 --> 00:29:59,564
we shifted we want to divide by two but

459
00:29:58,139 --> 00:30:02,180
the rule should be the same that you

460
00:29:59,879 --> 00:30:05,580
should round toward zero and what this

461
00:30:02,549 --> 00:30:06,554
is doing is it's rounding toward minus

462
00:30:05,058 --> 00:30:09,072
infinity its rounding

463
00:30:07,049 --> 00:30:14,051
toward a more negative number than the

464
00:30:09,072 --> 00:30:18,111
truth thing and so there's a little cute

465
00:30:14,249 --> 00:30:21,360
little trick that says before you shift

466
00:30:19,011 --> 00:30:24,036
before you divide by a power of two

467
00:30:21,036 --> 00:30:33,036
before you do the shift you should add a

468
00:30:24,036 --> 00:30:34,955
bias which in this case would just be

469
00:30:33,036 --> 00:30:37,235
one and I'll tell you where that comes

470
00:30:35,279 --> 00:30:42,340
from and so if we add those numbers

471
00:30:37,559 --> 00:30:42,592
together we'll get one one one zero

472
00:30:44,269 --> 00:30:54,293
right and now when we do the shift on

473
00:30:47,369 --> 00:30:56,432
that we'll get 1 1 1 1 and that's minus

474
00:30:54,509 --> 00:30:58,561
1 so there's a trick and you'll again

475
00:30:56,999 --> 00:31:02,003
you'll see the compiler doing this where

476
00:30:59,029 --> 00:31:04,127
you have in your code divided by 16 and

477
00:31:02,399 --> 00:31:06,464
we'll add a bias and then it will do a

478
00:31:05,009 --> 00:31:09,450
right shift instead of calling division

479
00:31:07,049 --> 00:31:12,131
and by the way division really really is

480
00:31:09,045 --> 00:31:15,964
slow even on a modern computer like what

481
00:31:12,869 --> 00:31:20,070
you have the shark machines it takes

482
00:31:16,369 --> 00:31:22,830
thirty plus clock cycles so anytime the

483
00:31:20,007 --> 00:31:25,011
compiler can avoid figure out a trick

484
00:31:22,083 --> 00:31:29,762
that does it with shifting and tweaking

485
00:31:25,047 --> 00:31:31,706
things around it will oh so I realized I

486
00:31:30,509 --> 00:31:34,513
should tell you there's a couple ways

487
00:31:32,129 --> 00:31:34,207
you can

488
00:31:35,029 --> 00:31:39,047
negated number that are handy to know if

489
00:31:37,076 --> 00:31:44,078
you ever have to do it in your head or

490
00:31:39,047 --> 00:31:46,142
on paper and the standard way is what's

491
00:31:44,096 --> 00:31:52,127
called complement and increment so this

492
00:31:47,042 --> 00:31:58,121
is how do I go from X to minus X so if I

493
00:31:53,027 --> 00:32:00,092
have a number and I want to negate it

494
00:31:59,021 --> 00:32:03,110
whether it's currently a negative number

495
00:32:00,092 --> 00:32:05,120
or it's a positive number the same trick

496
00:32:04,001 --> 00:32:11,072
works what I'll do is complement it

497
00:32:06,002 --> 00:32:19,088
meaning I'll flip all the bits and then

498
00:32:11,081 --> 00:32:29,146
I'll add one to that and do the regular

499
00:32:20,006 --> 00:32:32,084
sum and so this is six this is minus six

500
00:32:30,046 --> 00:32:34,058
so if you ever have to do it by hand

501
00:32:32,084 --> 00:32:35,107
that's the way to do a compliment in

502
00:32:34,058 --> 00:32:43,157
increment and it goes the other way

503
00:32:36,007 --> 00:32:50,078
you'll see if I compliment this and I

504
00:32:44,057 --> 00:32:54,079
increment it I'll get back to my

505
00:32:50,078 --> 00:32:54,079
previous number so that's the trick that

506
00:32:55,033 --> 00:33:00,074
it's pretty much only useful when you do

507
00:32:57,086 --> 00:33:03,124
things on the blackboard or when you

508
00:33:00,074 --> 00:33:03,079
have to solve a problem in data web

509
00:33:09,088 --> 00:33:19,160
so anyway this idea of doing a using up

510
00:33:18,062 --> 00:33:21,071
shifting to the right to do power of two

511
00:33:20,006 --> 00:33:24,011
division is actually that's the whole

512
00:33:22,052 --> 00:33:27,073
justification for arithmetic shifting in

513
00:33:24,065 --> 00:33:31,067
the first place which by the way in NC

514
00:33:27,073 --> 00:33:34,154
there's no fixed requirement for how

515
00:33:31,085 --> 00:33:36,544
shifting works in C for signed numbers

516
00:33:35,054 --> 00:33:40,063
for unsigned it has to be a logical

517
00:33:37,309 --> 00:33:44,360
shift sign numbers the C standard says

518
00:33:40,063 --> 00:33:46,094
there's no fixed definition the reality

519
00:33:44,036 --> 00:33:49,058
is on our machines most machines just

520
00:33:46,094 --> 00:33:51,122
about every machine out there when it's

521
00:33:49,058 --> 00:33:53,087
a two's complement number when it's a

522
00:33:52,022 --> 00:33:55,981
negative where it's assigned number

523
00:33:53,087 --> 00:33:58,896
two's complement and when you do a shift

524
00:33:56,179 --> 00:33:59,184
it will be an arithmetic shift

525
00:34:06,077 --> 00:34:12,706
so getting back to them summarizing this

526
00:34:09,098 --> 00:34:14,787
integer arithmetic you see that first of

527
00:34:13,399 --> 00:34:18,730
all whether it's signed your unsigned

528
00:34:15,669 --> 00:34:23,200
the addition or multiplication

529
00:34:18,073 --> 00:34:26,078
operations are the same whether it's a

530
00:34:23,002 --> 00:34:31,055
unsigned number or two's complement and

531
00:34:27,023 --> 00:34:33,029
it works the negative stuff works out as

532
00:34:31,073 --> 00:34:38,242
long as you don't have an overflow and

533
00:34:33,083 --> 00:34:40,132
you can end up with an overflow only one

534
00:34:38,899 --> 00:34:44,300
type of overflow for unsigned in two

535
00:34:40,879 --> 00:34:47,240
types four signed numbers but it's not

536
00:34:44,003 --> 00:34:50,054
like they just overflow and generate

537
00:34:47,024 --> 00:34:52,121
random numbers there's some of a pattern

538
00:34:50,081 --> 00:34:55,123
to what result what they are and how

539
00:34:53,021 --> 00:34:56,023
they can be interpreted

540
00:35:00,065 --> 00:35:06,066
so we I talked about this a little bit

541
00:35:03,099 --> 00:35:07,176
last time and gave this example similar

542
00:35:06,075 --> 00:35:12,117
to this but let me go over it a little

543
00:35:08,076 --> 00:35:15,078
bit more one thing you might think of

544
00:35:13,017 --> 00:35:18,033
while if it's unsigned and signed stuff

545
00:35:15,078 --> 00:35:20,094
gets so murky and we saw some funny

546
00:35:18,033 --> 00:35:23,109
examples last time maybe we should just

547
00:35:20,094 --> 00:35:25,185
vanished unsigned numbers from the

548
00:35:24,009 --> 00:35:29,103
universe and only allow two's complement

549
00:35:26,085 --> 00:35:31,089
and that's exactly the rule that was

550
00:35:30,003 --> 00:35:37,005
adopted for example in Java they said

551
00:35:32,025 --> 00:35:38,121
this is too weird what let's just say

552
00:35:37,023 --> 00:35:44,075
every number is two's complement the

553
00:35:39,021 --> 00:35:52,032
only trick they did was they put in a

554
00:35:44,075 --> 00:36:01,170
triple right shift means logical shift

555
00:35:52,032 --> 00:36:06,125
this is Java this is not C whereas the

556
00:36:02,007 --> 00:36:06,062
double is a arithmetic

557
00:36:13,022 --> 00:36:18,098
so because they rise there's a lot of

558
00:36:16,007 --> 00:36:20,406
cute little times when you want to play

559
00:36:18,098 --> 00:36:24,122
tricks with things and you need that

560
00:36:21,099 --> 00:36:27,560
logical rate shift so that's actually

561
00:36:25,022 --> 00:36:29,117
one approach or other more modern

562
00:36:27,056 --> 00:36:32,063
languages and si are saying it's okay to

563
00:36:30,017 --> 00:36:34,052
have signed and unsigned but we don't

564
00:36:32,063 --> 00:36:35,072
want them sort of mysteriously being

565
00:36:34,052 --> 00:36:38,099
cast back and forth in ways that the

566
00:36:36,053 --> 00:36:41,632
programmer might not recognize and so

567
00:36:38,099 --> 00:36:43,166
you have to explicitly do a cast

568
00:36:42,109 --> 00:36:46,790
rather than implicitly and I think

569
00:36:44,066 --> 00:36:48,985
that's the better approach but see as I

570
00:36:46,079 --> 00:36:52,106
mentioned does this implicit casting and

571
00:36:49,579 --> 00:36:59,990
so as we saw for last time what happens

572
00:36:53,006 --> 00:37:03,098
with this program when you run it to

573
00:36:59,099 --> 00:37:05,122
count down through an array do you

574
00:37:03,098 --> 00:37:05,122
remember

575
00:37:08,078 --> 00:37:16,142
well as I if it's unsigned what will

576
00:37:13,007 --> 00:37:18,079
happen with this test it always succeed

577
00:37:17,042 --> 00:37:21,065
so the thing will be in an infinite loop

578
00:37:19,042 --> 00:37:24,119
actually what will happen is it will try

579
00:37:21,065 --> 00:37:27,122
to access I will go down to 0 and then

580
00:37:25,019 --> 00:37:30,178
it will wrap around to become the

581
00:37:28,022 --> 00:37:31,115
largest possible unsigned number which

582
00:37:30,349 --> 00:37:34,350
is probably way out of balance and it

583
00:37:32,015 --> 00:37:37,031
will give a memory error

584
00:37:34,359 --> 00:37:38,458
but it won't do what's supposed to be

585
00:37:37,031 --> 00:37:40,127
and as I mentioned before these things

586
00:37:39,349 --> 00:37:43,640
there's a lot of sneaky ways this

587
00:37:41,027 --> 00:37:46,052
problem can show up in ways you might

588
00:37:43,064 --> 00:37:52,033
never think of so for example the

589
00:37:46,052 --> 00:37:55,118
operators sizeof is defined to say how

590
00:37:52,609 --> 00:37:58,880
big a particular datatype is it's a very

591
00:37:56,018 --> 00:38:01,927
useful operator but it's its return

592
00:37:58,088 --> 00:38:03,163
value is a what's called a size

593
00:38:02,089 --> 00:38:09,162
underscore T which is defined to be a

594
00:38:04,063 --> 00:38:12,071
long unsigned number and so if we just

595
00:38:09,819 --> 00:38:16,640
throw in a constant like this then this

596
00:38:13,043 --> 00:38:19,130
subtraction we have a sign is now int

597
00:38:16,064 --> 00:38:23,101
but sizeof is unsigned and so it will

598
00:38:20,003 --> 00:38:26,024
cast that to be unsigned implicitly and

599
00:38:24,001 --> 00:38:30,610
when you compare it to 0 you'll have the

600
00:38:26,051 --> 00:38:32,063
same problem as before so just to show

601
00:38:30,619 --> 00:38:37,010
you that these things can speak in in

602
00:38:32,063 --> 00:38:41,081
very tricky ways so one way to do that

603
00:38:37,001 --> 00:38:47,008
then is just don't use unsigned like and

604
00:38:41,081 --> 00:38:50,102
make sure if this is a a possible

605
00:38:47,071 --> 00:38:53,430
unsigned number you cast it to signed

606
00:38:51,002 --> 00:38:57,011
you make sure this is recognized signed

607
00:38:54,069 --> 00:38:59,510
but there's another way that actually at

608
00:38:57,092 --> 00:39:00,113
least there's a fellow over in the

609
00:38:59,051 --> 00:39:04,052
software engineering Institute named

610
00:39:01,013 --> 00:39:10,031
Robert Secord who has written the books

611
00:39:04,052 --> 00:39:12,119
that are sooner considered the the gold

612
00:39:10,031 --> 00:39:14,093
standard for how to write secure code he

613
00:39:13,019 --> 00:39:16,678
works for this organization called the

614
00:39:14,093 --> 00:39:20,165
computer emergency response team which

615
00:39:16,849 --> 00:39:25,849
is out there tracking down bad things

616
00:39:21,065 --> 00:39:27,143
going on in computer security and one of

617
00:39:25,849 --> 00:39:29,893
the things he and others have done is to

618
00:39:28,043 --> 00:39:33,712
try and come up with standards so that

619
00:39:30,289 --> 00:39:36,230
people who write programs will you know

620
00:39:34,099 --> 00:39:37,670
avoid some of the pitfalls that make

621
00:39:36,023 --> 00:39:41,027
their programs vulnerable to the

622
00:39:37,067 --> 00:39:43,070
security of laws to attack and so his

623
00:39:41,063 --> 00:39:45,101
recommended technique is when I first

624
00:39:43,097 --> 00:39:51,706
saw this it was so counterintuitive to

625
00:39:46,001 --> 00:39:54,008
me it it hardly made sense right so you

626
00:39:52,579 --> 00:39:57,410
start and again this is all unsigned

627
00:39:54,071 --> 00:40:00,720
arithmetic so I'm starting to count down

628
00:39:57,041 --> 00:40:03,700
and my test is when I is less than count

629
00:40:01,359 --> 00:40:06,406
so here's the thing I started off

630
00:40:04,069 --> 00:40:09,145
smaller than count and it's only being

631
00:40:06,829 --> 00:40:16,970
decremented so when would this test ever

632
00:40:09,829 --> 00:40:19,940
fail hmm when it overflows when it wraps

633
00:40:16,097 --> 00:40:21,191
around right when I goes from zero and

634
00:40:19,094 --> 00:40:25,483
counts down to what would now be you max

635
00:40:22,091 --> 00:40:27,188
this test will fail which is exactly

636
00:40:26,329 --> 00:40:31,670
when you want it to stop and his

637
00:40:28,088 --> 00:40:33,101
observation is and see with signed

638
00:40:31,067 --> 00:40:36,496
numbers there's no guarantee on what

639
00:40:34,001 --> 00:40:38,069
happens with overflowing as I said most

640
00:40:37,099 --> 00:40:40,520
people just assume it's going to be

641
00:40:38,069 --> 00:40:41,144
two's complement but if you really want

642
00:40:40,052 --> 00:40:44,090
to be careful you shouldn't assume

643
00:40:42,044 --> 00:40:46,143
anything outside of the C standard and

644
00:40:44,009 --> 00:40:48,041
if you're trying to write secure code

645
00:40:46,539 --> 00:40:53,572
it's probably a good idea to be cautious

646
00:40:49,022 --> 00:40:56,063
be conservative on the other hand the C

647
00:40:53,869 --> 00:40:59,000
standard guarantees it that unsigned

648
00:40:56,063 --> 00:41:00,071
arithmetic will be modular arithmetic so

649
00:40:59,000 --> 00:41:04,019
it guarantees that if you subtract one

650
00:41:01,043 --> 00:41:07,139
from zero you'll get the largest number

651
00:41:04,019 --> 00:41:11,698
that could be represented so it will be

652
00:41:08,039 --> 00:41:14,188
okay and in fact he recommends instead

653
00:41:11,869 --> 00:41:18,140
of using unsigned which is on our

654
00:41:14,539 --> 00:41:21,547
machines just a 32-bit value that you

655
00:41:18,014 --> 00:41:25,723
call it a size T which is a 64-bit value

656
00:41:21,619 --> 00:41:28,670
and so and write your code the way that

657
00:41:25,849 --> 00:41:30,868
I showed you so I've actually started

658
00:41:28,067 --> 00:41:32,686
doing this and once you kind of get used

659
00:41:31,039 --> 00:41:34,260
to it it's an OK way to write code but

660
00:41:33,289 --> 00:41:37,890
it's very

661
00:41:34,026 --> 00:41:44,121
strange looking in this way one thing

662
00:41:37,089 --> 00:41:49,128
I'll point out is what would happen if

663
00:41:45,021 --> 00:41:55,059
if count were a signed number and int

664
00:41:50,028 --> 00:42:01,035
and it were you were and it was less

665
00:41:55,059 --> 00:42:10,062
than zero what would happen here so I

666
00:42:01,098 --> 00:42:12,141
less than count what would happen right

667
00:42:10,089 --> 00:42:14,172
and so it become a very large positive

668
00:42:13,041 --> 00:42:17,139
number and this test would almost

669
00:42:15,072 --> 00:42:20,091
certainly succeed so you have the same

670
00:42:18,039 --> 00:42:24,057
this code doesn't avoid the pitfall it

671
00:42:20,091 --> 00:42:25,182
just shifts it to saying you better make

672
00:42:24,057 --> 00:42:30,149
sure you don't you know test for this

673
00:42:26,082 --> 00:42:36,120
case beforehand before you get into it

674
00:42:31,049 --> 00:42:38,142
so I think part of it is the observation

675
00:42:37,002 --> 00:42:43,014
that man if you want to be careful and

676
00:42:39,042 --> 00:42:45,114
write code that that is guaranteed

677
00:42:43,032 --> 00:42:47,097
correct no matter what implementation

678
00:42:46,014 --> 00:42:50,040
goes on as long as it's within the CIE

679
00:42:47,097 --> 00:42:59,121
standard it's pretty tricky business to

680
00:42:50,004 --> 00:43:04,059
question up there yes

681
00:43:00,021 --> 00:43:07,028
which is unfortunate right so yes that's

682
00:43:04,095 --> 00:43:08,181
exactly the rule that it's implicitly

683
00:43:07,028 --> 00:43:12,114
silently the C compiler doesn't give any

684
00:43:09,081 --> 00:43:16,110
warnings you'll never know it cast it's

685
00:43:13,014 --> 00:43:19,083
unsigned and as these examples show when

686
00:43:17,001 --> 00:43:22,089
you stare at that code and you think

687
00:43:19,083 --> 00:43:24,102
about it it's really easy to have bugs

688
00:43:22,098 --> 00:43:26,130
that you just you can look at it a

689
00:43:25,002 --> 00:43:31,005
thousand times and not realize that it's

690
00:43:27,003 --> 00:43:34,032
a bug it's a very and there's examples

691
00:43:31,032 --> 00:43:38,034
these examples in the book of security

692
00:43:34,059 --> 00:43:42,104
flaws in sort of very important library

693
00:43:38,034 --> 00:43:42,041
software due to this problem exactly

694
00:43:44,047 --> 00:43:48,119
so part of the reason we teach in the

695
00:43:46,094 --> 00:43:52,503
course is just so you appreciate that

696
00:43:49,019 --> 00:43:56,848
this is a quirk in this and see that

697
00:43:53,349 --> 00:43:59,422
again 99% of the time you'll never even

698
00:43:57,019 --> 00:44:02,026
it won't bother you at all but there

699
00:44:00,079 --> 00:44:08,173
will be some oddball cases that you can

700
00:44:02,089 --> 00:44:13,156
get in trouble with so the other place

701
00:44:09,019 --> 00:44:16,045
that you'll find unsigned arithmetic

702
00:44:13,759 --> 00:44:17,794
unsigned representation useful is first

703
00:44:16,279 --> 00:44:21,650
of all when you're doing modular

704
00:44:18,109 --> 00:44:25,670
arithmetic which is for example the way

705
00:44:21,065 --> 00:44:27,092
most encryption algorithms work or when

706
00:44:25,067 --> 00:44:30,226
you're using the bits not to represent

707
00:44:27,092 --> 00:44:34,681
numbers but to represent sets the way I

708
00:44:30,829 --> 00:44:38,180
described it before then you don't want

709
00:44:35,509 --> 00:44:45,544
it it's easiest to just think of that as

710
00:44:38,018 --> 00:44:48,095
unsigned numbers okay so the final thing

711
00:44:45,859 --> 00:44:50,950
to talk about today is some of the

712
00:44:48,095 --> 00:44:54,994
low-level representations of numbers

713
00:44:51,769 --> 00:45:00,825
within memory and the main point is when

714
00:44:55,849 --> 00:45:00,897
you are running a program on a computer

715
00:45:01,509 --> 00:45:07,640
from the programming perspective either

716
00:45:04,004 --> 00:45:10,633
even as an assembly level programmer not

717
00:45:07,064 --> 00:45:12,493
just as a C programmer in your mind the

718
00:45:11,029 --> 00:45:15,100
memory is just this big array of bytes

719
00:45:13,069 --> 00:45:19,092
that's numbered from 0 up to some

720
00:45:15,739 --> 00:45:22,824
maximum number so for example in the

721
00:45:19,299 --> 00:45:29,450
machines we're using the 64-bit machines

722
00:45:23,589 --> 00:45:31,880
an address is represented in 64 bits but

723
00:45:29,045 --> 00:45:34,141
in fact the maximum address you're

724
00:45:31,088 --> 00:45:40,091
allowed to use in current machines is a

725
00:45:35,041 --> 00:45:43,420
47 bits and to the forty-seventh is

726
00:45:41,018 --> 00:45:46,115
still a pretty big number so that's more

727
00:45:43,789 --> 00:45:49,190
memory than anyone's able to buy right

728
00:45:47,015 --> 00:45:51,044
now anyhow and so it's a reasonable

729
00:45:49,019 --> 00:45:54,026
restriction but the point is that

730
00:45:51,044 --> 00:45:56,453
logically your program thinks that it

731
00:45:54,089 --> 00:45:58,089
has a array of

732
00:45:56,849 --> 00:46:00,854
at many bites let's try and figure out

733
00:45:58,089 --> 00:46:08,228
how big to xlvii is anyone know it off

734
00:46:01,349 --> 00:46:12,397
the top of their head so there's a trick

735
00:46:09,029 --> 00:46:12,037
if you want to get an approximate idea

736
00:46:13,097 --> 00:46:23,121
which is to say that 2 to the 10th which

737
00:46:18,809 --> 00:46:29,190
is 110 24 is approximately equal to 10

738
00:46:24,021 --> 00:46:31,610
to the third you say oh well that's

739
00:46:29,019 --> 00:46:36,428
really helpful what it means is that 10

740
00:46:31,799 --> 00:46:38,630
bits worth of number is about the same

741
00:46:36,599 --> 00:46:48,180
as three decimal digits

742
00:46:38,063 --> 00:46:56,942
all right so for example 2 to the 20th

743
00:46:48,018 --> 00:47:03,093
is around 10 to the 6 2 to the 30th it's

744
00:46:57,509 --> 00:47:08,543
around 10 to the 9th to the 40th around

745
00:47:03,093 --> 00:47:14,642
10 to the 12th and so that would tell

746
00:47:08,849 --> 00:47:17,870
you that 2 to the 48-47 is around 128

747
00:47:15,479 --> 00:47:23,430
times 10 to the 12th which is 128

748
00:47:18,059 --> 00:47:26,078
terabyte right Tara 10 to the 12 so if

749
00:47:23,043 --> 00:47:28,922
you just want to say you know get a

750
00:47:26,249 --> 00:47:31,301
quick figure 4 and of course these are

751
00:47:29,309 --> 00:47:34,170
approximations but if you just want to

752
00:47:31,769 --> 00:47:35,777
get a quick handle on how big a number

753
00:47:34,017 --> 00:47:38,091
you know what range of values can I

754
00:47:36,569 --> 00:47:42,569
represent with so many bits of it this

755
00:47:38,091 --> 00:47:44,190
is a really easy trick to do that so the

756
00:47:42,569 --> 00:47:51,960
point is a 128 terabytes

757
00:47:45,009 --> 00:47:53,438
is a lot you can buy disk drives a

758
00:47:51,096 --> 00:47:55,191
couple of disk drives will do that for

759
00:47:54,329 --> 00:47:59,700
you but you couldn't buy enough DRAM on

760
00:47:56,091 --> 00:48:01,146
a normal budget to get that kind of

761
00:47:59,007 --> 00:48:04,029
memory so that's the current range of

762
00:48:02,046 --> 00:48:08,075
values but logically when you run a

763
00:48:04,092 --> 00:48:09,150
program it thinks that it has that

764
00:48:08,489 --> 00:48:12,900
possible range now it

765
00:48:10,005 --> 00:48:15,006
doesn't really and in fact what happens

766
00:48:12,009 --> 00:48:16,100
is that the operating system only allows

767
00:48:15,051 --> 00:48:20,067
certain regions within that memory to be

768
00:48:17,081 --> 00:48:22,116
referenced and other regions if you try

769
00:48:20,067 --> 00:48:24,075
to access them it will create a it will

770
00:48:23,016 --> 00:48:27,108
signal an error what they call a

771
00:48:24,075 --> 00:48:28,173
segmentation fault but logically at

772
00:48:28,008 --> 00:48:32,040
least it's as if you have this big array

773
00:48:29,073 --> 00:48:33,102
of bytes now in reality and we'll go

774
00:48:32,004 --> 00:48:38,090
into this when we talk about how the

775
00:48:34,002 --> 00:48:39,026
memory system is works in virtual memory

776
00:48:40,061 --> 00:48:45,084
there's this very complex combination of

777
00:48:43,044 --> 00:48:48,093
hardware and software that gives the

778
00:48:45,084 --> 00:48:51,090
program this image of a very large what

779
00:48:48,093 --> 00:48:53,138
you call flap space just a big array of

780
00:48:51,009 --> 00:48:56,073
bytes when in reality it's shuffling

781
00:48:54,038 --> 00:48:59,064
between different regions of your memory

782
00:48:57,054 --> 00:49:02,063
and even between your memory and your

783
00:48:59,064 --> 00:49:08,073
disk drive on your computer to make it

784
00:49:03,044 --> 00:49:11,061
implement this particular idea that you

785
00:49:09,054 --> 00:49:13,089
have this big array of bytes and that's

786
00:49:11,061 --> 00:49:16,125
all handled as I said by the operating

787
00:49:13,089 --> 00:49:18,144
system by the computer hardware and it's

788
00:49:17,025 --> 00:49:20,112
largely invisible even to the machine

789
00:49:19,044 --> 00:49:29,118
level programmer even people writing

790
00:49:21,012 --> 00:49:32,028
assembly code you'll often hear the term

791
00:49:30,018 --> 00:49:35,055
word size and it can get very confusing

792
00:49:32,028 --> 00:49:37,112
confusing nowadays because there's no

793
00:49:35,055 --> 00:49:41,055
really fixed idea of what a word size is

794
00:49:38,012 --> 00:49:45,081
but roughly speaking the word size

795
00:49:41,055 --> 00:49:51,102
should be whatever the largest number is

796
00:49:45,081 --> 00:49:54,102
that or the range that sort of signifies

797
00:49:52,002 --> 00:49:58,065
how big a pointer is in this language or

798
00:49:55,002 --> 00:50:01,002
Hardware wise the largest sort of chunk

799
00:49:58,065 --> 00:50:02,121
of hardware for which there's standard

800
00:50:01,002 --> 00:50:06,018
support for storing it for arithmetic

801
00:50:03,021 --> 00:50:09,045
operations and so forth so when we say

802
00:50:06,018 --> 00:50:12,050
it's a 64-bit machine what we mean is

803
00:50:09,045 --> 00:50:15,117
that it it regular and routinely

804
00:50:12,005 --> 00:50:19,026
manipulate 64-bit values err on

805
00:50:16,017 --> 00:50:22,095
arithmetic operations and also it has a

806
00:50:19,071 --> 00:50:23,130
pointers or the values of addresses are

807
00:50:22,095 --> 00:50:27,147
64 bits

808
00:50:24,003 --> 00:50:30,027
even if for right now only 47 of those

809
00:50:28,047 --> 00:50:34,068
bits are usable it's still considered a

810
00:50:30,054 --> 00:50:40,095
64-bit machine one thing that strange is

811
00:50:34,068 --> 00:50:48,129
in one of the features of of machines

812
00:50:40,095 --> 00:50:52,116
such as we have huh is that if I compile

813
00:50:49,029 --> 00:50:56,061
a program using a GCC the standard

814
00:50:53,016 --> 00:51:02,052
compiler I can specify either I want it

815
00:50:56,061 --> 00:51:07,146
to be 64 bit code or 32-bit code as a

816
00:51:02,052 --> 00:51:10,056
flag and it will actually generate two

817
00:51:08,046 --> 00:51:13,065
different kinds of object code as a

818
00:51:10,092 --> 00:51:15,171
result and we'll talk in a look about

819
00:51:13,065 --> 00:51:19,122
these later but for right now the point

820
00:51:16,071 --> 00:51:22,100
is the hardware itself doesn't

821
00:51:20,022 --> 00:51:25,068
necessarily define what the word size is

822
00:51:23,000 --> 00:51:27,081
it's a combination of the hardware and

823
00:51:25,068 --> 00:51:29,130
the compiler that determines what is the

824
00:51:27,081 --> 00:51:32,172
word size being used in this particular

825
00:51:30,003 --> 00:51:36,018
program and that code can be run on the

826
00:51:33,072 --> 00:51:38,133
point is the 64 bit machine such as we

827
00:51:36,045 --> 00:51:43,086
have and most machines are nowadays can

828
00:51:39,033 --> 00:51:51,117
insert of a backward compatibility style

829
00:51:43,086 --> 00:51:54,117
also execute 32-bit code and as we also

830
00:51:52,017 --> 00:51:57,036
saw one of the other features is even

831
00:51:55,017 --> 00:52:01,029
though it's a 64 bit word size the data

832
00:51:57,036 --> 00:52:04,068
type int without any other qualifiers to

833
00:52:01,029 --> 00:52:07,035
it is just 32 bits so the sort of this

834
00:52:04,068 --> 00:52:09,150
mixture of how big things are so when

835
00:52:07,035 --> 00:52:12,057
people just say word or word size and

836
00:52:10,005 --> 00:52:14,010
let's say give a precise definition

837
00:52:12,057 --> 00:52:16,062
that's not a very meaningful term and

838
00:52:15,000 --> 00:52:19,038
we'll sort of throw it around when we

839
00:52:17,007 --> 00:52:21,012
mean sort of a generic chunk of bits

840
00:52:19,038 --> 00:52:24,047
without trying to assume that it has a

841
00:52:21,057 --> 00:52:24,128
particular number of bits to it

842
00:52:34,009 --> 00:52:42,017
yes so one of the things is if we ever

843
00:52:37,076 --> 00:52:46,130
get to 64-bit words it will be 16

844
00:52:43,007 --> 00:52:48,100
petabytes 18 petabytes opinion how you

845
00:52:47,003 --> 00:52:53,006
define when you those numbers get big

846
00:52:49,063 --> 00:52:57,089
the error due to this approximation gets

847
00:52:53,033 --> 00:52:59,114
more significant but something times 10

848
00:52:57,089 --> 00:53:11,120
to the 15th bytes but right now we can

849
00:53:00,014 --> 00:53:14,096
only get to 128 times 10 to the 12 so

850
00:53:12,002 --> 00:53:17,084
anyway it's the idea that the memory

851
00:53:14,096 --> 00:53:20,153
itself is a series of bytes but we can

852
00:53:18,002 --> 00:53:24,020
group those into blocks of words of

853
00:53:21,053 --> 00:53:28,130
different word sizes and the way we do

854
00:53:24,002 --> 00:53:33,008
that is usually by assuming that the the

855
00:53:29,003 --> 00:53:35,099
address of the word is the lowest valued

856
00:53:33,008 --> 00:53:40,069
address in it and we also will generally

857
00:53:36,026 --> 00:53:47,125
try to align these so that for example a

858
00:53:41,041 --> 00:53:50,042
32-bit word would be a line so its first

859
00:53:47,359 --> 00:53:53,770
byte its lowest byte has all zeros in

860
00:53:50,051 --> 00:53:53,077
the frick stuff

861
00:53:57,059 --> 00:54:05,066
in the first five bit positions right

862
00:54:01,569 --> 00:54:08,920
now 32 4 I'm sorry the lowest two bytes

863
00:54:05,759 --> 00:54:15,880
right so as this example shows their

864
00:54:08,092 --> 00:54:16,731
address is 0 4 8 and 12 they should have

865
00:54:15,088 --> 00:54:20,140
really written this in hex and said it's

866
00:54:17,559 --> 00:54:23,631
C I guess these are all in decimal

867
00:54:21,004 --> 00:54:27,453
anyhow so yeah these are decimal numbers

868
00:54:24,279 --> 00:54:31,286
so 0 4 8 12 so you see these are in

869
00:54:27,849 --> 00:54:33,970
multiples of 4 of bit boundaries and

870
00:54:31,349 --> 00:54:36,423
similarly the 64-bit words are in

871
00:54:33,097 --> 00:54:38,140
multiples of 8 and those are known as

872
00:54:37,089 --> 00:54:41,230
aligned words and will generally will

873
00:54:39,004 --> 00:54:42,079
see that the compiler works pretty hard

874
00:54:41,023 --> 00:54:44,098
to keep things aligned because the

875
00:54:43,015 --> 00:54:48,091
hardware runs more efficiently that way

876
00:54:44,098 --> 00:54:49,917
but the main point is that we can just

877
00:54:48,091 --> 00:54:51,172
take as many bytes as we want and

878
00:54:50,799 --> 00:54:57,700
collect them together and call it a word

879
00:54:52,072 --> 00:54:58,851
for whatever word size we need and as we

880
00:54:57,007 --> 00:55:00,846
think we saw a variant of this table

881
00:54:59,499 --> 00:55:04,581
before but this is the machines we'll be

882
00:55:01,539 --> 00:55:09,460
working on that the standard int is

883
00:55:05,319 --> 00:55:12,210
still only 32 bits but if we qualify

884
00:55:09,046 --> 00:55:15,088
something as being wrong then it will be

885
00:55:12,021 --> 00:55:16,880
64 bits and will tend to do that there's

886
00:55:15,088 --> 00:55:17,817
two different floating-point

887
00:55:17,069 --> 00:55:21,138
representations that we'll talk about

888
00:55:18,609 --> 00:55:25,480
and then the main feature of a 64 bit

889
00:55:21,759 --> 00:55:30,792
machine is it has an 8 byte or 64 bit

890
00:55:25,048 --> 00:55:34,117
pointer as compared to 32 now there's

891
00:55:31,089 --> 00:55:38,130
one other kind of detail that says ok so

892
00:55:35,017 --> 00:55:40,416
if a word has multiple bytes in it what

893
00:55:38,499 --> 00:55:44,980
order should those bytes be should it be

894
00:55:40,569 --> 00:55:47,615
the and these two basic ways this could

895
00:55:44,098 --> 00:55:49,707
go one is that you put the bytes in

896
00:55:48,029 --> 00:55:52,083
what's known as little endian order

897
00:55:50,589 --> 00:55:54,940
meaning that the first byte in the word

898
00:55:52,569 --> 00:55:57,880
is the least significant byte and then

899
00:55:54,094 --> 00:55:58,189
the next and then the next and the final

900
00:55:57,088 --> 00:56:03,097
byte in the word is the most significant

901
00:55:59,089 --> 00:56:04,788
or you can flip that around and those

902
00:56:03,097 --> 00:56:08,118
are called little-endian and big-endian

903
00:56:05,589 --> 00:56:09,180
is the

904
00:56:09,031 --> 00:56:18,330
the sort of terms for that which comes

905
00:56:12,099 --> 00:56:20,410
from a English book called Gulliver's

906
00:56:18,609 --> 00:56:23,680
Travels which didn't anticipate

907
00:56:20,041 --> 00:56:24,139
computers at all but it's an interesting

908
00:56:23,068 --> 00:56:26,997
story of how that comes about

909
00:56:25,039 --> 00:56:29,508
so in out there in the world you'll find

910
00:56:27,609 --> 00:56:31,707
both types of machines big Indian and

911
00:56:29,859 --> 00:56:34,780
little Indian machines it turns out that

912
00:56:32,589 --> 00:56:38,290
increasingly it's getting hard to find

913
00:56:34,078 --> 00:56:42,387
big Indian machines so little indeed all

914
00:56:38,029 --> 00:56:45,098
of x86 is little Indian and it turns out

915
00:56:43,089 --> 00:56:48,910
ARM processors like what you have in

916
00:56:45,359 --> 00:56:52,990
almost every cell phone here is an ARM

917
00:56:48,091 --> 00:56:54,091
processor and the hardware and those can

918
00:56:52,099 --> 00:56:57,948
actually be configured to run either way

919
00:56:54,091 --> 00:56:59,176
big-endian or little-endian but when

920
00:56:58,839 --> 00:57:02,560
you're running it on any of the standard

921
00:57:00,076 --> 00:57:06,079
operating systems that run on ARM

922
00:57:02,056 --> 00:57:09,103
processors then it's running little

923
00:57:06,079 --> 00:57:12,378
Indian so there used to be a brand

924
00:57:10,003 --> 00:57:16,075
called Sun Microsystems and they were

925
00:57:13,089 --> 00:57:20,230
fairly common on campus and then back in

926
00:57:16,075 --> 00:57:21,172
the Macintosh before they were x86

927
00:57:20,023 --> 00:57:26,071
processors they ran one called the

928
00:57:22,072 --> 00:57:28,191
PowerPC and that was a big engine

929
00:57:26,071 --> 00:57:31,126
machine but those are long in the

930
00:57:28,839 --> 00:57:34,990
distant past the internet about the only

931
00:57:32,026 --> 00:57:37,365
place out there when you send packets

932
00:57:34,099 --> 00:57:40,108
over the internet you want to send in

933
00:57:37,599 --> 00:57:43,690
32-bit words they're actually sent in

934
00:57:41,008 --> 00:57:45,100
big endian order and so at the network

935
00:57:43,069 --> 00:57:48,978
interface you have to translate between

936
00:57:46,000 --> 00:57:54,055
those two so again just to illustrate

937
00:57:49,599 --> 00:57:57,540
what I mean by this is think of a byte

938
00:57:54,055 --> 00:58:00,082
value for byte value like this and

939
00:57:57,054 --> 00:58:02,071
remember that the way we write numbers

940
00:58:00,082 --> 00:58:04,105
is we put the most significant to the

941
00:58:02,071 --> 00:58:06,126
left and the least significant to the

942
00:58:05,005 --> 00:58:07,026
right

943
00:58:09,059 --> 00:58:16,082
and so now with a big-endian inserted

944
00:58:13,038 --> 00:58:19,247
the intuitive one from that perspective

945
00:58:16,289 --> 00:58:21,362
in that the bike if you write the words

946
00:58:19,589 --> 00:58:24,602
in memory from the smallest address up

947
00:58:22,019 --> 00:58:27,083
to the highest the big endian will sort

948
00:58:24,719 --> 00:58:30,758
of map to what you see whereas the

949
00:58:27,659 --> 00:58:36,686
little endian will look confusing that

950
00:58:31,109 --> 00:58:38,180
you say 0 1 2 3 4 5 6 7 because 6 7 is

951
00:58:36,929 --> 00:58:40,890
actually the least significant byte here

952
00:58:38,819 --> 00:58:46,820
and so that comes first in little-endian

953
00:58:40,089 --> 00:58:48,090
order and and so the it used to be

954
00:58:46,919 --> 00:58:51,900
people would get in passionate arguments

955
00:58:48,009 --> 00:58:56,858
about this that sort of in the distant

956
00:58:51,009 --> 00:58:59,828
past but and people saying you know and

957
00:58:57,749 --> 00:59:02,880
the main feature in some sort of

958
00:59:00,719 --> 00:59:04,775
argument of big indian nuts is this

959
00:59:02,088 --> 00:59:07,427
feature here that when you look at it

960
00:59:05,279 --> 00:59:09,362
it's easier to write down but computers

961
00:59:08,219 --> 00:59:11,297
don't really care they're happy either

962
00:59:10,109 --> 00:59:13,202
way and so they just want one convention

963
00:59:11,999 --> 00:59:17,006
or another and like I said some

964
00:59:14,039 --> 00:59:19,097
hardware's can actually be a by a sort

965
00:59:17,069 --> 00:59:21,161
of flag to flip it from being big endian

966
00:59:19,619 --> 00:59:24,626
to little Indian but the reality is most

967
00:59:21,989 --> 00:59:27,083
of machines one counter you'll encounter

968
00:59:24,689 --> 00:59:30,691
a little endian machine stoudek but just

969
00:59:27,929 --> 00:59:32,993
to give you an example here's some

970
00:59:30,709 --> 00:59:36,710
results that I got from actual machines

971
00:59:33,569 --> 00:59:38,880
there used to be some machines around so

972
00:59:36,809 --> 00:59:40,844
back in the old days I could run this I

973
00:59:38,088 --> 00:59:43,247
don't even know where to get a big

974
00:59:41,159 --> 00:59:48,215
endian machine anymore so these are sort

975
00:59:44,039 --> 00:59:50,114
of legacy result but you'll see that the

976
00:59:48,719 --> 00:59:52,766
main feature is between a little Indian

977
00:59:50,789 --> 00:59:56,630
and a big endian machine when you have

978
00:59:53,189 --> 00:59:59,243
an integer the bikes get flipped around

979
00:59:56,063 --> 01:00:01,342
so that the re significant byte comes

980
00:59:59,729 --> 01:00:05,780
first in a little endian machine and

981
01:00:01,909 --> 01:00:08,942
last in a big endian machine and that's

982
01:00:06,239 --> 01:00:13,241
true with negative numbers as well that

983
01:00:09,239 --> 01:00:17,730
you'll get the sign bits first in a big

984
01:00:13,259 --> 01:00:22,440
endian machine a long

985
01:00:17,073 --> 01:00:24,132
you'll see that the only difference

986
01:00:22,044 --> 01:00:27,045
between a 32-bit machine the 64-bit

987
01:00:25,032 --> 01:00:28,128
machine is you have more zeros or more

988
01:00:27,045 --> 01:00:33,054
ones depending whether it's a positive

989
01:00:29,028 --> 01:00:37,071
or negative number and again the Sun and

990
01:00:34,035 --> 01:00:40,035
if I had access to a 64-bit machine Sun

991
01:00:37,071 --> 01:00:42,129
is now manufactured by a company called

992
01:00:40,035 --> 01:00:44,067
Oracle so in principle I could go get

993
01:00:43,029 --> 01:00:46,077
one of these machines and run this

994
01:00:44,067 --> 01:00:49,145
experiment but it's really not a very

995
01:00:46,077 --> 01:00:49,145
interesting experiment so I won't bother

996
01:00:50,066 --> 01:00:57,515
so in principle I could try it on a

997
01:00:53,004 --> 01:01:03,045
64-bit Oracle machine and show you

998
01:00:58,109 --> 01:01:06,840
something different so one thing that

999
01:01:03,081 --> 01:01:08,124
kind of a useful tool the book goes

1000
01:01:06,084 --> 01:01:12,129
through some examples of this is a

1001
01:01:09,024 --> 01:01:16,089
little program that will take a series

1002
01:01:13,029 --> 01:01:19,125
of bytes starting at some position start

1003
01:01:16,089 --> 01:01:23,124
and do it for however many bytes you

1004
01:01:20,025 --> 01:01:29,384
request and just print out in hex format

1005
01:01:24,024 --> 01:01:33,090
the two hex digits that represent that

1006
01:01:29,609 --> 01:01:37,610
bite valve and here this term pointer

1007
01:01:33,009 --> 01:01:41,084
I'm using an unsigned care as a pointer

1008
01:01:37,619 --> 01:01:42,650
type a sort of generic pointer type

1009
01:01:45,079 --> 01:01:56,144
and so again if I run this on a x86

1010
01:01:53,012 --> 01:01:59,021
machine oh oh and I'm also by the way

1011
01:01:57,044 --> 01:02:03,107
printing out the actual address that

1012
01:01:59,021 --> 01:02:05,107
this character is stored in too and so

1013
01:02:04,007 --> 01:02:11,015
you'll see that there is these addresses

1014
01:02:06,007 --> 01:02:13,085
with a lot of 7f of what that means is

1015
01:02:11,015 --> 01:02:15,023
it's in the upper end of this 47 bit

1016
01:02:13,085 --> 01:02:18,161
address space if you work it through

1017
01:02:15,095 --> 01:02:23,174
there's seven is three ones and then

1018
01:02:19,061 --> 01:02:28,061
there's enough hex digits here to

1019
01:02:24,074 --> 01:02:32,078
correspond to so there's 11 hex digits

1020
01:02:28,061 --> 01:02:34,094
beyond the seven and you'll see that

1021
01:02:32,078 --> 01:02:39,155
these addresses are at successive bytes

1022
01:02:34,094 --> 01:02:41,165
BC B DB EB F and the values are 63 B 0 0

1023
01:02:40,055 --> 01:02:48,106
0 0 this is the least significant byte

1024
01:02:42,065 --> 01:02:53,126
and these are the successive byte and a

1025
01:02:49,006 --> 01:02:57,014
similar I can I can use this to examine

1026
01:02:54,026 --> 01:02:58,088
pointers of various sorts and I can

1027
01:02:57,014 --> 01:03:02,051
examine different values and just get

1028
01:02:58,088 --> 01:03:04,088
their low-level byte representations and

1029
01:03:02,051 --> 01:03:06,065
so I did this back when I could get to a

1030
01:03:04,088 --> 01:03:07,157
Sun machine it had one way of

1031
01:03:06,065 --> 01:03:10,070
representing a pointer and the main

1032
01:03:08,057 --> 01:03:13,145
point is even across machines whether

1033
01:03:10,007 --> 01:03:15,050
it's a byte ordering or whatever you'll

1034
01:03:14,045 --> 01:03:17,093
get different values for pointers

1035
01:03:16,013 --> 01:03:20,036
there's no guarantee that when you load

1036
01:03:17,093 --> 01:03:21,182
them a computer program into one machine

1037
01:03:20,036 --> 01:03:26,057
and run it that it will use the same

1038
01:03:22,082 --> 01:03:27,140
addresses as that same programming

1039
01:03:26,057 --> 01:03:29,120
running on a different machine even if

1040
01:03:28,004 --> 01:03:32,092
actually they're identical hardware and

1041
01:03:30,002 --> 01:03:35,060
operating system there can be variation

1042
01:03:33,028 --> 01:03:38,033
because pointers aren't you can't

1043
01:03:35,078 --> 01:03:44,084
directly copy a pointer from one machine

1044
01:03:38,033 --> 01:03:47,078
to another on one thing about also is

1045
01:03:45,038 --> 01:03:51,062
regardless of byte ordering the ordering

1046
01:03:47,078 --> 01:03:53,156
of of characters is the same and so a

1047
01:03:51,062 --> 01:03:57,101
string in C is always represented by a

1048
01:03:54,056 --> 01:03:58,117
series of bytes where the final byte is

1049
01:03:58,001 --> 01:04:02,052
0

1050
01:03:59,017 --> 01:04:05,166
called null-terminated and the

1051
01:04:02,052 --> 01:04:07,401
individual bytes correspond to the

1052
01:04:05,319 --> 01:04:11,322
character codes for that number and

1053
01:04:07,869 --> 01:04:13,890
these character codes are just sometimes

1054
01:04:11,349 --> 01:04:16,540
called ASCII format which is a little

1055
01:04:14,079 --> 01:04:18,760
bit old-fashioned by the way there's

1056
01:04:16,054 --> 01:04:24,363
more modern character codes too that can

1057
01:04:18,076 --> 01:04:26,083
represent non English alphabets but the

1058
01:04:24,849 --> 01:04:31,690
C standard is still back in the days of

1059
01:04:27,046 --> 01:04:52,051
only supporting the the ASCII format

1060
01:04:31,069 --> 01:05:00,076
question uh-huh yes so this should have

1061
01:04:52,051 --> 01:05:03,103
been well no this is good so I'm casting

1062
01:05:00,076 --> 01:05:05,080
I want to show the for bite-size event

1063
01:05:04,003 --> 01:05:09,004
for because this is an int I'm

1064
01:05:06,016 --> 01:05:12,019
representing the pointer let's see the

1065
01:05:09,013 --> 01:05:16,182
code we're printing the pointer all this

1066
01:05:12,046 --> 01:05:20,053
notation % P is the directive to say

1067
01:05:16,299 --> 01:05:24,000
print out a pointer proposed right and %

1068
01:05:20,053 --> 01:05:27,372
X is the directive to print out a hex

1069
01:05:24,000 --> 01:05:30,028
representation so it's printing out both

1070
01:05:27,849 --> 01:05:32,380
the address the starting position of

1071
01:05:30,028 --> 01:05:35,047
that particular byte and the value of

1072
01:05:32,038 --> 01:05:37,104
that byte as two different things does

1073
01:05:35,047 --> 01:05:37,104
that answer your question

1074
01:05:39,549 --> 01:05:58,660
returning upper darker yes but remember

1075
01:05:52,088 --> 01:06:01,807
show bytes is being given a pointer and

1076
01:05:58,066 --> 01:06:04,075
a length and so what this is and what

1077
01:06:02,599 --> 01:06:08,480
it's saying is starting at that address

1078
01:06:04,075 --> 01:06:10,166
print out the next series of bytes for

1079
01:06:08,048 --> 01:06:13,055
me how many bytes I asked for and in

1080
01:06:11,066 --> 01:06:17,102
this case I'm I'm creating a pointer to

1081
01:06:14,018 --> 01:06:20,039
this integer but I want to show the the

1082
01:06:18,002 --> 01:06:22,097
bytes in that integer the four bytes

1083
01:06:20,039 --> 01:06:24,128
that make up that integer and that's why

1084
01:06:22,097 --> 01:06:32,141
I'm giving it the number four here

1085
01:06:25,028 --> 01:06:37,124
instead of eight is it yes it will be

1086
01:06:33,041 --> 01:06:40,049
and that's fine because in this code I'm

1087
01:06:38,024 --> 01:06:43,028
using the percent P directive to

1088
01:06:41,021 --> 01:06:46,360
designate how to print out the pointer

1089
01:06:43,028 --> 01:06:47,797
and that will print it as many bytes as

1090
01:06:46,549 --> 01:06:51,530
it takes for that particular machine

1091
01:06:48,049 --> 01:06:53,690
that it's running on so percent P is

1092
01:06:51,053 --> 01:06:55,076
actually a very handy directive if you

1093
01:06:53,069 --> 01:06:56,138
have to print addresses like for

1094
01:06:55,076 --> 01:06:59,185
debugging purposes or something because

1095
01:06:57,038 --> 01:07:04,497
it will automatically adapt to whatever

1096
01:06:59,869 --> 01:07:03,966
machine it's running on question

1097
01:07:06,082 --> 01:07:12,158
well I've defined it to be an unsigned

1098
01:07:09,071 --> 01:07:16,109
care here so type def is a way to

1099
01:07:13,058 --> 01:07:18,146
introduce a name for some of data type

1100
01:07:17,009 --> 01:07:24,032
right and so I've just declared a

1101
01:07:19,046 --> 01:07:28,085
pointer quote pointer to refer to an

1102
01:07:24,032 --> 01:07:32,096
unsigned care if you did a void star it

1103
01:07:28,085 --> 01:07:36,179
would not be happy with this reference

1104
01:07:32,096 --> 01:07:39,098
here right you can't you can't reference

1105
01:07:37,079 --> 01:07:41,087
a void star is just a way to pass around

1106
01:07:40,016 --> 01:07:44,024
a generic pointer but you can't actually

1107
01:07:41,087 --> 01:07:46,184
reference that element so what I'm

1108
01:07:44,024 --> 01:07:51,047
basically doing is saying this reference

1109
01:07:47,084 --> 01:07:52,136
is treated like an array you treat my

1110
01:07:51,047 --> 01:08:00,113
series of bytes is an array and print

1111
01:07:53,036 --> 01:08:07,105
out each of the bytes in that array and

1112
01:08:01,013 --> 01:08:11,014
so here where I'm a is a number and I'm

1113
01:08:08,005 --> 01:08:14,083
taking the address of that integer and

1114
01:08:11,014 --> 01:08:17,111
casting it to be an unsigned care star

1115
01:08:14,083 --> 01:08:19,097
so sort of a generic slightly generic

1116
01:08:18,011 --> 01:08:23,032
pointer but not quite as generic as void

1117
01:08:19,097 --> 01:08:24,194
star and then printing it up

1118
01:08:23,032 --> 01:08:32,033
was it good quite easy good questions by

1119
01:08:25,094 --> 01:08:34,100
the way okay so the point being that

1120
01:08:32,042 --> 01:08:38,129
strings are just strings and that's the

1121
01:08:35,000 --> 01:08:41,093
same from one machine to the next okay

1122
01:08:39,029 --> 01:08:44,087
let's finish up today with some puzzles

1123
01:08:41,093 --> 01:08:47,174
and these have this annoying way of

1124
01:08:44,087 --> 01:08:51,095
showing up on exams so it's worth being

1125
01:08:48,074 --> 01:08:53,162
able to do these kind of things and

1126
01:08:52,067 --> 01:08:57,163
you'll also notice I cleverly did not

1127
01:08:54,062 --> 01:08:58,063
include the answers in the slide

1128
01:09:00,199 --> 01:09:04,201
so you can't you can't just peek ahead

1129
01:09:02,066 --> 01:09:05,075
and figure out what the answers are so

1130
01:09:04,219 --> 01:09:07,190
let's just go through them but I

1131
01:09:05,075 --> 01:09:09,137
actually worked them out to make sure I

1132
01:09:07,019 --> 01:09:12,110
had the entry zone so if X and basically

1133
01:09:10,037 --> 01:09:15,616
these are sort of statements that you

1134
01:09:13,001 --> 01:09:18,430
want to say these are either always true

1135
01:09:15,949 --> 01:09:21,710
and maybe there's some logic behind why

1136
01:09:18,529 --> 01:09:24,020
it's always true or possibly false and

1137
01:09:21,071 --> 01:09:26,114
you won't have to give some example that

1138
01:09:24,002 --> 01:09:28,064
would make that false so let's go

1139
01:09:27,014 --> 01:09:32,039
through these as many as we have time

1140
01:09:28,064 --> 01:09:35,413
for and see where we get to so if I take

1141
01:09:32,039 --> 01:09:39,238
X and I double it multiply it by 2 if X

1142
01:09:35,989 --> 01:09:41,008
who are negative and my guaranteed that

1143
01:09:39,589 --> 01:09:47,000
2x will be negative

1144
01:09:41,179 --> 01:09:50,330
no so by the way one general way to find

1145
01:09:47,000 --> 01:09:53,033
counter examples is to try team in it's

1146
01:09:50,033 --> 01:09:55,064
a really good one and that works here

1147
01:09:53,033 --> 01:09:56,131
right if I take team n which is one and

1148
01:09:55,064 --> 01:09:59,102
a bunch of zeros I double it like

1149
01:09:57,031 --> 01:10:06,113
shifting it but left and it will become

1150
01:10:00,002 --> 01:10:09,041
what zero right is and so again assume

1151
01:10:07,013 --> 01:10:12,086
that X is that any negative number and

1152
01:10:09,041 --> 01:10:16,094
UX is it's unsigned I'm sorry

1153
01:10:12,086 --> 01:10:18,128
two's complement number and UX is what

1154
01:10:16,094 --> 01:10:20,117
happens if I cast it to be unsigned so

1155
01:10:19,028 --> 01:10:25,121
as u X always you're greater than or

1156
01:10:21,017 --> 01:10:31,546
equal to zero yeah that's slightly more

1157
01:10:26,021 --> 01:10:34,990
obscure if I take X and I mask off seven

1158
01:10:31,699 --> 01:10:38,440
you remember is the bit pattern 1 1 1 so

1159
01:10:35,179 --> 01:10:41,690
as I mask off all but the lowest 3 bits

1160
01:10:38,044 --> 01:10:43,091
and I find that those are all one I'm

1161
01:10:41,069 --> 01:10:46,154
already giving you the answer here and

1162
01:10:43,091 --> 01:10:50,098
then I shift it left by 30 position what

1163
01:10:47,054 --> 01:10:50,098
can I say about the result

1164
01:10:59,269 --> 01:11:21,320
so I know the ex must finish with 3:1

1165
01:11:04,076 --> 01:11:22,585
right and I shift that by 30 and this

1166
01:11:21,032 --> 01:11:25,109
these will be the only two bits that are

1167
01:11:23,269 --> 01:11:29,300
left after the shifting and they will be

1168
01:11:26,009 --> 01:11:32,368
in the most significant position so what

1169
01:11:29,003 --> 01:11:35,032
can I say about that number is negative

1170
01:11:32,449 --> 01:11:39,530
so this is a true statement rather

1171
01:11:35,329 --> 01:11:42,400
obscure but it is true is UX greater

1172
01:11:39,053 --> 01:11:41,140
than minus one

1173
01:11:44,559 --> 01:11:58,621
it's almost true right the one counter

1174
01:11:51,679 --> 01:12:00,727
example would be what the zoo well

1175
01:11:59,179 --> 01:12:03,208
actually no you're right there's a lot

1176
01:12:01,159 --> 01:12:04,207
of examples it's hardly ever true it's

1177
01:12:03,469 --> 01:12:07,460
almost always false

1178
01:12:04,639 --> 01:12:13,656
I was wrong the only thing that would

1179
01:12:07,046 --> 01:12:19,285
make it true would be XI it's never true

1180
01:12:13,809 --> 01:12:22,340
okay so it's never true okay if X is

1181
01:12:19,699 --> 01:12:24,720
greater than Y is minus X less than

1182
01:12:22,034 --> 01:12:24,603
minus y

1183
01:12:34,012 --> 01:12:40,070
No so by the way one thing we didn't

1184
01:12:38,009 --> 01:12:48,032
really cover is what is the negative of

1185
01:12:40,007 --> 01:12:58,007
tea men and to see that we can use our

1186
01:12:48,032 --> 01:13:03,035
complement income instrument trick so

1187
01:12:58,007 --> 01:13:06,038
when you compliment an increment T min

1188
01:13:03,062 --> 01:13:10,085
you get T min and that's why it's such a

1189
01:13:07,001 --> 01:13:18,088
great counter example so in particular

1190
01:13:10,085 --> 01:13:21,092
if Y is T min and X is something else

1191
01:13:18,088 --> 01:13:24,184
then that left-hand part will be true

1192
01:13:21,092 --> 01:13:24,184
but the right-hand part will not be true

1193
01:13:26,008 --> 01:13:33,013
okay x times X greater than or equal to

1194
01:13:28,079 --> 01:13:35,113
zero we've seen examples of that being

1195
01:13:33,013 --> 01:13:36,013
false

1196
01:13:36,919 --> 01:13:41,014
if X is it is just kind of silly if X is

1197
01:13:40,007 --> 01:13:47,009
greater than zero and Y is greater than

1198
01:13:41,869 --> 01:13:48,898
zero is X plus y greater than zero no if

1199
01:13:47,009 --> 01:13:53,026
X is greater than or equal to zero is

1200
01:13:49,159 --> 01:13:53,260
minus X less than or equal to zero

1201
01:13:53,053 --> 01:13:57,712
gotcha

1202
01:13:54,008 --> 01:14:01,177
you're right it's true right because

1203
01:13:58,189 --> 01:14:03,286
that but let's take it counterpart if X

1204
01:14:01,969 --> 01:14:07,820
is less than or equal to zero is minus x

1205
01:14:04,159 --> 01:14:10,340
squared equals zero team n right so

1206
01:14:07,082 --> 01:14:12,961
right the point being that the largest

1207
01:14:10,034 --> 01:14:16,063
any positive number can be represented

1208
01:14:13,699 --> 01:14:18,590
as negative but there's one negative

1209
01:14:16,369 --> 01:14:21,430
number that can't be represented as

1210
01:14:18,059 --> 01:14:25,061
positive and so that asymmetry is why

1211
01:14:21,979 --> 01:14:28,984
you get different answers to these if I

1212
01:14:25,061 --> 01:14:33,400
take X and I look at minus X and I shift

1213
01:14:29,479 --> 01:14:36,547
them to the right by 31 am I going to

1214
01:14:33,949 --> 01:14:39,012
get all ones this is a really weird

1215
01:14:37,159 --> 01:14:39,201
statement

1216
01:14:47,085 --> 01:14:53,136
so it actually kind of works right if I

1217
01:14:51,037 --> 01:14:53,136
take all zeros

1218
01:15:01,809 --> 01:15:07,800
and I subtract one I'll get minus one

1219
01:15:10,289 --> 01:15:28,780
and I or them that works so what's wrong

1220
01:15:19,078 --> 01:15:30,130
with this what's that oh but if I shift

1221
01:15:28,078 --> 01:15:44,094
it to the right 31 places that's going

1222
01:15:31,003 --> 01:15:48,342
to shift arithmetic aliy what's that oh

1223
01:15:44,094 --> 01:15:49,233
I see oh I'm sorry

1224
01:15:48,639 --> 01:15:56,658
I already jumped ahead to a different

1225
01:15:50,079 --> 01:15:58,154
puzzle X and minus X and I so you're

1226
01:15:56,829 --> 01:16:04,845
right actually

1227
01:15:58,829 --> 01:16:09,610
if the two numbers is zero and I or

1228
01:16:04,989 --> 01:16:12,044
those I get zero but you'll figure out

1229
01:16:09,061 --> 01:16:15,900
you'll notice if it's anything non zero

1230
01:16:12,539 --> 01:16:18,670
actually this will be true and that's an

1231
01:16:16,449 --> 01:16:20,710
interesting feature so there's a couple

1232
01:16:18,067 --> 01:16:21,151
other puzzles and I'll I'll let you

1233
01:16:20,071 --> 01:16:24,084
solve those on your own we're all set

1234
01:16:22,051 --> 01:16:24,084
for today

