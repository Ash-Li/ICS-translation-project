1
00:00:00,520 --> 00:00:02,520
 Good afternoon everybody welcome

2
00:00:05,230 --> 00:00:07,230
 Good to see you

3
00:00:10,900 --> 00:00:12,900
 so today, we're going to study a

4
00:00:13,480 --> 00:00:16,980
 Arcane area of computer systems known as floating point

5
00:00:17,830 --> 00:00:20,219
 Which is the way that computer systems represent?

6
00:00:21,070 --> 00:00:23,070
 the real numbers

7
00:00:24,070 --> 00:00:26,070
 So you're all familiar with?

8
00:00:26,710 --> 00:00:30,990
 decimal decimals you know something like 3.14 and

9
00:00:31,930 --> 00:00:35,790
 There's a similar a similar idea with with binary numbers

10
00:00:36,520 --> 00:00:37,960
 okay, so uh

11
00:00:37,960 --> 00:00:39,960
 So what what?

12
00:00:40,629 --> 00:00:42,070
 does a

13
00:00:42,070 --> 00:00:44,759
 fractional binary number Like 1 0 1 1

14
00:00:45,489 --> 00:00:47,489
 point 1 0 1

15
00:00:48,370 --> 00:00:50,370
 Represent and how does that work?

16
00:00:51,910 --> 00:00:53,910
 well, it works just like the

17
00:00:54,879 --> 00:00:57,929
 decimal fractional decimal numbers that you use to

18
00:01:04,510 --> 00:01:10,050
 So you have a in this case that they it's a binary point and to the left of the binary point

19
00:01:12,190 --> 00:01:17,190
 You have bit position to representing powers of 2 so 2 to the 0?

20
00:01:17,800 --> 00:01:19,800
 2 to the 1 2 to the 2

21
00:01:20,260 --> 00:01:22,260
 So 1/2

22
00:01:22,960 --> 00:01:26,580
 I'm sorry 1 2 4 and so on and

23
00:01:27,340 --> 00:01:30,180
 to the right of the binary point

24
00:01:31,360 --> 00:01:33,360
 You have 2 to the minus 1?

25
00:01:34,570 --> 00:01:42,209
 1/2 2 to the minus 2 1 4 2 to the minus 3 1 a and so on and so we can we can represent

26
00:01:43,420 --> 00:01:45,160
 any

27
00:01:45,160 --> 00:01:47,160
 fractional binary number

28
00:01:47,530 --> 00:01:48,670
 using

29
00:01:48,670 --> 00:01:50,670
 Using this notation where we sum?

30
00:01:52,450 --> 00:01:54,479
 Each the bit at Position K

31
00:01:55,600 --> 00:01:57,750
 Times 2 to the k ok

32
00:01:58,450 --> 00:02:05,100
 Ok so it's really it really works exactly the same way as as with base 10, just just with Base 2

33
00:02:08,590 --> 00:02:10,590
 So let's look at some of these

34
00:02:12,610 --> 00:02:19,830
 some of these values so 5 and 3/4 we would represent as 1 0 1 point 1 1

35
00:02:21,610 --> 00:02:23,940
 So this this is before

36
00:02:26,290 --> 00:02:28,290
 plus 1 is 5 plus

37
00:02:29,650 --> 00:02:31,650
 1/2 Plus

38
00:02:31,810 --> 00:02:33,810
 1/4 okay, so

39
00:02:35,080 --> 00:02:39,989
 2/4 Plus 1/4 is 3/4 so 5 and 3/4 ok so, that's pretty simple

40
00:02:41,350 --> 00:02:43,350
 2 and 7/8

41
00:02:43,540 --> 00:02:46,589
 is 1 zero point 1 1 1

42
00:02:47,650 --> 00:02:49,390
 so that

43
00:02:49,390 --> 00:02:52,500
 1 0 is 2 of course and

44
00:02:53,799 --> 00:02:57,629
 then point 1 1 1 is 1/2, so

45
00:02:59,680 --> 00:03:01,680
 4 eighths plus

46
00:03:01,989 --> 00:03:03,989
 1/4 is two eighths plus

47
00:03:05,590 --> 00:03:08,429
 1/8 okay, so seven eight

48
00:03:11,220 --> 00:03:13,220
 and 1

49
00:03:14,080 --> 00:03:16,080
 7/16

50
00:03:16,780 --> 00:03:24,479
 would be one point zero 1 1 1 so the one to the left of the binary point is 1 and

51
00:03:24,820 --> 00:03:26,710
 then we have

52
00:03:26,710 --> 00:03:28,330
 1/4

53
00:03:28,330 --> 00:03:30,570
 Plus 1/8 Plus 1/16

54
00:03:31,540 --> 00:03:33,929
 so one 1/4 is

55
00:03:35,800 --> 00:03:37,800
 4 16

56
00:03:40,840 --> 00:03:43,170
 1/8 is to 16 and

57
00:03:45,010 --> 00:03:47,489
 1/16 so you add those after you get 7/16

58
00:03:49,060 --> 00:03:54,089
 Okay now notice that for some of these numbers. We this bit this bit pattern

59
00:03:56,440 --> 00:04:02,309
 101.1 1 if We shift it to the right to get 1 0.111?

60
00:04:04,030 --> 00:04:09,630
 We've divided by 2 right, so we've taken 5 and 3/4 and divided it by 2 and it

61
00:04:10,420 --> 00:04:12,420
 It works the other way too if you shift

62
00:04:12,790 --> 00:04:17,969
 to the left you multiply if you shift to the Left by 1 you multiply by 1 and

63
00:04:18,790 --> 00:04:20,790
 these numbers that

64
00:04:20,919 --> 00:04:23,249
 are all ones to the right of the

65
00:04:24,520 --> 00:04:31,289
 Of the binary point are these are numbers that are just slightly less than than one okay?

66
00:04:33,100 --> 00:04:37,109
 And so we'll well we want to represent those will often

67
00:04:38,470 --> 00:04:44,249
 Will sometimes refer to those numbers of that form as 1 minus epsilon and ePsilon just?

68
00:04:46,510 --> 00:04:51,779
 Depends on how many bits you have to the right of the binary point so ePsilon gets smaller the more?

69
00:04:53,020 --> 00:04:58,919
 The more of those bits you have there it gets closer to 1 and epsilon gets smaller the more of those fits you have

70
00:05:00,610 --> 00:05:02,610
 now there's a

71
00:05:03,100 --> 00:05:05,100
 There's limitations

72
00:05:05,380 --> 00:05:09,600
 In this kind of representation so first of all we can only represent

73
00:05:10,690 --> 00:05:13,950
 rational numbers of the Form X Divided by 2 2 to the K

74
00:05:13,950 --> 00:05:18,450
 we can only represent numbers of that's form exactly other numbers have to get

75
00:05:19,960 --> 00:05:23,579
 Have repeating bit representations that can't be represented

76
00:05:24,260 --> 00:05:27,499
 The finite number of debts that we have in a computer system

77
00:05:28,200 --> 00:05:33,890
 So for example things like a 1/3 is that is this repeating representation?

78
00:05:36,030 --> 00:05:38,330
 1/5 and 1/10 there are other examples of that

79
00:05:40,050 --> 00:05:43,339
 Now the other problem. We have is that we can only

80
00:05:45,150 --> 00:05:50,389
 There's only so many bits to the left and the right of the the binary point. So we're kind of

81
00:05:51,660 --> 00:05:55,160
 if we put if we move the binary point to the left

82
00:05:56,610 --> 00:05:59,960
 Then we don't have as many we can't represent as many

83
00:06:01,860 --> 00:06:07,009
 Large numbers we can only represent small numbers, but we have more precision to the right of the binary point

84
00:06:07,560 --> 00:06:13,400
 So we can represent more fractional values just the range of those values will be much smaller

85
00:06:14,580 --> 00:06:16,639
 similarly if we move the binary point to the right

86
00:06:17,640 --> 00:06:23,809
 We'll have a larger range of values, but we won't build a represent as many fractions, okay?

87
00:06:24,330 --> 00:06:27,080
 so there's this there's this kind of trade-off and

88
00:06:27,900 --> 00:06:29,900
 floating point is a

89
00:06:30,810 --> 00:06:32,810
 representation to

90
00:06:32,880 --> 00:06:35,749
 That to try that that enables us to move that

91
00:06:36,900 --> 00:06:42,049
 Basically to move that binary point to represent sort of as wide a range as possible

92
00:06:43,110 --> 00:06:44,940
 with as much precision

93
00:06:44,940 --> 00:06:49,730
 given the number of bits the finite number of bits that we have to work with so the

94
00:06:50,010 --> 00:06:56,809
 The float and floating point is this sort of shifting binary point right this floating this floating binary point?

95
00:06:58,890 --> 00:07:00,890
 now up until

96
00:07:01,110 --> 00:07:02,850
 1985

97
00:07:02,850 --> 00:07:04,850
 Floating point was just a disaster

98
00:07:05,370 --> 00:07:07,080
 and

99
00:07:07,080 --> 00:07:09,770
 every computer manufacturer had their own

100
00:07:10,410 --> 00:07:12,000
 representation

101
00:07:12,000 --> 00:07:16,040
 You couldn't and it was just terrible because you couldn't predict

102
00:07:16,980 --> 00:07:21,080
 What would happen what would happen if you moved your program from one machine to another?

103
00:07:21,660 --> 00:07:24,439
 The Behavior would be different the rounding would be different

104
00:07:25,410 --> 00:07:29,119
 It was a very difficult situation and people really

105
00:07:29,910 --> 00:07:31,910
 computer scientists in particular really

106
00:07:33,000 --> 00:07:35,000
 disliked floating point

107
00:07:35,110 --> 00:07:36,370
 in

108
00:07:36,370 --> 00:07:38,320
 in 18

109
00:07:38,320 --> 00:07:44,790
 1985 I triple E which is the professional association for electrical engineers?

110
00:07:45,880 --> 00:07:47,880
 Introduced a and it's also a very

111
00:07:49,600 --> 00:07:56,100
 Important standards body they introduced a standard floating-point representation called I triple e floating point

112
00:07:57,010 --> 00:08:00,420
 Which was then adopted by all computer manufacturers?

113
00:08:00,420 --> 00:08:05,219
 So now the situation is much better everybody everybody supports the same kind of floating point

114
00:08:06,220 --> 00:08:08,400
 Representation which is what we're going to learn about today

115
00:08:14,260 --> 00:08:16,260
 so the floating point

116
00:08:16,510 --> 00:08:18,510
 has the form

117
00:08:18,730 --> 00:08:26,159
 it represents numbers in a like a scientific notation it represents numbers of the form

118
00:08:26,890 --> 00:08:28,870
 minus 1 to the s

119
00:08:28,870 --> 00:08:30,870
 Where s is assigned it?

120
00:08:32,830 --> 00:08:34,830
 Times A

121
00:08:35,260 --> 00:08:37,260
 significant M

122
00:08:37,660 --> 00:08:39,660
 ok times

123
00:08:40,570 --> 00:08:47,910
 2 to some exponent e ok so all of the numbers that we can represent in floating point

124
00:08:49,600 --> 00:08:51,600
 Have to be represented in this form

125
00:08:52,660 --> 00:08:56,999
 So the sign bit s determines whether the number is negative or positive

126
00:08:58,270 --> 00:08:59,470
 obviously

127
00:08:59,470 --> 00:09:03,599
 the significant M and sometimes sometimes called the Mantissa

128
00:09:04,180 --> 00:09:10,979
 where the M comes from the significant m normally is a fractional value in the range between

129
00:09:11,260 --> 00:09:15,960
 between 1 & 2 and we'll see we'll see why that is in a second and

130
00:09:16,270 --> 00:09:19,559
 then the exponent E weights the value by some power of -

131
00:09:20,080 --> 00:09:22,080
 Okay, so this is encoded in

132
00:09:22,900 --> 00:09:30,299
 in either 32 bits or 64 bits in the following way the the sign bit s is the most significant bit and

133
00:09:31,000 --> 00:09:33,000
 then this is followed by some number of

134
00:09:34,300 --> 00:09:37,530
 By it by some number of bits called the Exp field

135
00:09:38,800 --> 00:09:40,450
 Which encodes?

136
00:09:40,450 --> 00:09:42,450
 the exponent e of

137
00:09:43,210 --> 00:09:48,420
 But it's not identical to e it encodes e, and we'll see how that works and then

138
00:09:49,089 --> 00:09:52,359
 the frack and then and then that's followed the remaining bits are the

139
00:09:53,029 --> 00:09:55,029
 the Frack Field

140
00:09:55,699 --> 00:09:59,019
 Which encodes them but isn't identical to em?

141
00:10:01,670 --> 00:10:03,670
 Now we I?

142
00:10:04,069 --> 00:10:07,419
 Triple E floating point has provides two different kinds

143
00:10:08,120 --> 00:10:14,289
 Of floating-point their single precision 32 bits and so-called double precision which is 64 bits

144
00:10:14,930 --> 00:10:16,930
 There's this funky

145
00:10:17,480 --> 00:10:19,430
 Intel

146
00:10:19,430 --> 00:10:22,509
 Extended precision which is non-standard and we won't talk about it anymore

147
00:10:24,620 --> 00:10:30,789
 And so in the single precision 32 bits you have one sign, bit. There's always a sign bit you have eight

148
00:10:31,790 --> 00:10:37,930
 Exp bits, and you have 23 frack bits in double precision you have 11 the XP bits and

149
00:10:39,019 --> 00:10:41,019
 52 Fragments

150
00:10:42,170 --> 00:10:48,339
 now there's a number of different kinds of floating-point representations, the

151
00:10:49,819 --> 00:10:53,979
 Sort of the default and sort of the common representation is called normalized

152
00:10:55,339 --> 00:10:57,339
 so called normalized values and

153
00:10:58,759 --> 00:11:05,109
 normalized values are all the values where the Exp field is not equal to 0

154
00:11:06,019 --> 00:11:12,428
 And not equal not equal to all zeros and not equal to all ones okay, so everything all

155
00:11:13,309 --> 00:11:17,319
 Zeros and all ones are special kinds of numbers. We'll look at a second

156
00:11:18,139 --> 00:11:19,399
 so

157
00:11:19,399 --> 00:11:21,399
 the exponent

158
00:11:21,559 --> 00:11:26,919
 this exponent e remember our numbers are minus 1 to the power s

159
00:11:27,620 --> 00:11:30,249
 Times M times 2 raised to the Power E

160
00:11:30,949 --> 00:11:32,949
 the exponent e is

161
00:11:34,069 --> 00:11:37,628
 Encoded as this biased value

162
00:11:39,439 --> 00:11:42,248
 Which is the called exp?

163
00:11:43,040 --> 00:11:45,429
 so the x the exponent e is

164
00:11:46,129 --> 00:11:48,129
 Exp minus some bias and

165
00:11:48,709 --> 00:11:50,709
 Exp is the value

166
00:11:50,870 --> 00:11:57,219
 Capital Exp is the value of the Exp bits the bits in the Exp field treat it as a positive number

167
00:11:57,649 --> 00:11:59,649
 Ok so capital exp

168
00:11:59,929 --> 00:12:02,949
 is just you just look at it as an unsigned and

169
00:12:05,750 --> 00:12:09,460
 seven bit in case of single Precision Seven bit number

170
00:12:11,120 --> 00:12:13,120
 Okay, now the bias is

171
00:12:14,840 --> 00:12:22,299
 2 to the Power K minus 1 minus 1 where K is the number of exponent bits okay? So for single precision?

172
00:12:24,890 --> 00:12:32,290
 We have 8 exponent bits so 2 to the 8th 2 to the 8 minus 1 is 7 so 2 to the seventh is?

173
00:12:35,210 --> 00:12:37,210
 128

174
00:12:37,220 --> 00:12:39,080
 minus 1 is

175
00:12:39,080 --> 00:12:43,270
 127 okay, so the bias for single precision is 127 and

176
00:12:44,000 --> 00:12:46,690
 Similarly for double precision it's a thousand 23

177
00:12:49,910 --> 00:12:51,680
 okay, so you just

178
00:12:51,680 --> 00:12:56,020
 you just have to memorize this this formula the exponent e is

179
00:12:56,750 --> 00:12:58,750
 the Exp field

180
00:12:59,720 --> 00:13:02,739
 Interpret it as an unsigned number minus the the bias

181
00:13:03,890 --> 00:13:05,630
 now this is a

182
00:13:05,630 --> 00:13:07,630
 This is kind of a strange thing

183
00:13:08,120 --> 00:13:13,720
 The first time you encounter floating-point it. It seems kind of odd right. So why not I?

184
00:13:14,600 --> 00:13:16,689
 Mean we've already learned about two's complement

185
00:13:16,690 --> 00:13:23,440
 That's a perfectly fine way to represent positive and negative numbers okay, and we have exponents that are negative

186
00:13:24,830 --> 00:13:28,569
 And positive right so why not just use the Exp field to represent?

187
00:13:29,930 --> 00:13:31,930
 Or why not just use?

188
00:13:32,240 --> 00:13:38,980
 Two's complement in the Exp field to represent those positive and negative exponents right so it turns out that

189
00:13:39,830 --> 00:13:41,889
 The reason that they do this

190
00:13:42,620 --> 00:13:44,600
 is

191
00:13:44,600 --> 00:13:48,489
 That and if you think if I think about this and we'll come back to it

192
00:13:49,340 --> 00:13:53,470
 but if we if we encode the the exponent e

193
00:13:54,710 --> 00:13:56,710
 using this bias representation

194
00:13:57,410 --> 00:14:02,170
 The smallest negative exponent is represented by all zeros

195
00:14:04,580 --> 00:14:07,660
 okay, and the largest exponent is represented by

196
00:14:10,640 --> 00:14:12,640
 0 1 1 1 1

197
00:14:14,709 --> 00:14:16,859
 so the the smallest

198
00:14:17,649 --> 00:14:20,099
 the swamp the number with the smallest exponent

199
00:14:20,889 --> 00:14:25,469
 If we were just to compare the bits using it just some kind of unsigned

200
00:14:26,589 --> 00:14:32,429
 Representation just comparing the bits treating it as an unsigned number by using. This is this biased

201
00:14:33,100 --> 00:14:35,909
 Representation we can just compare two floating point numbers

202
00:14:37,149 --> 00:14:43,859
 Just as unsigned we can treat the whole floating point number as an unsigned integer and compare two numbers and get

203
00:14:44,589 --> 00:14:46,589
 Get a true comparison

204
00:14:50,230 --> 00:14:57,779
 So the exponent uses this this sort of biasing encoding and then the significance is encoded

205
00:14:59,079 --> 00:15:03,568
 with an implied one so and this is where the

206
00:15:04,720 --> 00:15:09,810
 This is where the normalized in the normalized representation comes from that

207
00:15:09,810 --> 00:15:12,779
 We're always going to represent our numbers so m

208
00:15:14,709 --> 00:15:18,839
 We're always going to normalize m no matter what the number we want to represent?

209
00:15:18,839 --> 00:15:23,099
 we're always going to normalize m as one point something and

210
00:15:23,709 --> 00:15:29,369
 Then we adjust the exponent accordingly right, so if if the value we want to represent is

211
00:15:30,130 --> 00:15:32,130
 one zero zero point zero one

212
00:15:33,220 --> 00:15:37,079
 We're going to shift it over and it'll be one point zero zero

213
00:15:38,350 --> 00:15:40,350
 Okay

214
00:15:40,449 --> 00:15:44,729
 And then we'll adjust the exponent to represent that shift

215
00:15:46,899 --> 00:15:48,899
 okay, so the

216
00:15:48,970 --> 00:15:51,839
 V bits in the Frac field xxxxx

217
00:15:52,600 --> 00:15:54,310
 are

218
00:15:54,310 --> 00:15:59,819
 All of the numbers to the right of the binary point right so there's always this implied one

219
00:16:01,060 --> 00:16:05,010
 But we don't even encode it. We just throw it away because it's always there all right

220
00:16:05,010 --> 00:16:07,349
 So this is a little trick just to get one more bit

221
00:16:07,899 --> 00:16:09,759
 for free

222
00:16:09,759 --> 00:16:12,119
 Okay, so the the xxx bits

223
00:16:12,850 --> 00:16:14,850
 in the fraks field

224
00:16:15,220 --> 00:16:23,189
 are all all of all the bits to the right of the binary point after one point the one point and this is the

225
00:16:23,649 --> 00:16:28,609
 so this is the smallest fractal is all zero's which Corresponds to a

226
00:16:29,370 --> 00:16:31,370
 significant of 1.0

227
00:16:33,180 --> 00:16:35,989
 And a fractal of all ones

228
00:16:37,769 --> 00:16:42,799
 Corresponds to two minus Epsilon, so that's one swing one long-run 1 1 and so on

229
00:16:47,970 --> 00:16:50,000
 So let's look at let's look at an example

230
00:16:51,360 --> 00:16:53,360
 So let's look at how we would encode

231
00:16:54,690 --> 00:16:56,959
 15 to 13 our favorite number

232
00:16:58,110 --> 00:17:00,829
 In two's complement and floating-point

233
00:17:02,070 --> 00:17:04,819
 So the if we represent that so it's an integer

234
00:17:06,150 --> 00:17:08,150
 And we represent it using

235
00:17:09,630 --> 00:17:12,559
 these fifths take my word for it correspond to

236
00:17:13,500 --> 00:17:15,500
 the integer 213

237
00:17:15,720 --> 00:17:18,230
 So now we want to convert it. We want to normalize it

238
00:17:19,470 --> 00:17:20,939
 by

239
00:17:20,939 --> 00:17:28,249
 Expressing it as one point 1 1 0 and so on times 2 to the 13th ok saying the same number

240
00:17:28,250 --> 00:17:31,939
 We just normalized it so that there's there's always this leading 1

241
00:17:36,380 --> 00:17:38,589
 So the significant M

242
00:17:40,880 --> 00:17:42,560
 is

243
00:17:42,560 --> 00:17:45,279
 1 point 1 1 0 1 1 and So on

244
00:17:46,280 --> 00:17:48,819
 the Frack Field is everything to the right of

245
00:17:49,370 --> 00:17:55,449
 the binary point so we just we throw this we throw this one away, and we just take the

246
00:17:55,970 --> 00:18:03,040
 the values to the right of the binary point and then we pat it out with zeros to to get the 23 bits that we

247
00:18:03,040 --> 00:18:05,040
 need for single precision

248
00:18:07,010 --> 00:18:09,010
 Okay, so now we've got our frack sealed

249
00:18:10,820 --> 00:18:15,220
 The exponent so in this case a yz

250
00:18:16,670 --> 00:18:24,249
 We're multiplying by 2 to the 13 so e is 13 so we want to represent the value 13 using this biased

251
00:18:24,590 --> 00:18:26,590
 encoding

252
00:18:27,410 --> 00:18:29,439
 So the bias is 127

253
00:18:31,670 --> 00:18:38,319
 and so the exponent the value that the value of the Exp field

254
00:18:39,770 --> 00:18:44,530
 should be 140 because if we take if we take 140

255
00:18:45,440 --> 00:18:47,890
 minus 127 we get

256
00:18:48,590 --> 00:18:50,570
 13

257
00:18:50,570 --> 00:18:57,760
 Okay, so 140 is represented using these eight bits and that becomes our Exp field

258
00:18:59,600 --> 00:19:04,870
 Okay, so the resulting floating-point number and of course. It's a positive number, so the sign Bill is zero

259
00:19:06,530 --> 00:19:13,989
 So the resulting floating point number has these eight the eight bits and Exp field that we computed by subtracting

260
00:19:15,590 --> 00:19:19,270
 140 by subtracting 127 from 140 and then

261
00:19:19,850 --> 00:19:21,530
 the Frack Field

262
00:19:21,530 --> 00:19:27,339
 Are these bits that we that we got here by just taking everything to the right of the binary point?

263
00:19:31,700 --> 00:19:33,700
 so this

264
00:19:35,700 --> 00:19:41,489
 So let's look at this exponent. Just a little bit more because I think can be a little confusing

265
00:19:46,670 --> 00:19:48,879
 so so in our example

266
00:19:54,590 --> 00:19:57,340
 if we want to look at the range of exp

267
00:20:00,260 --> 00:20:02,560
 So what's the smallest value of exp?

268
00:20:06,920 --> 00:20:08,920
 What's the smallest value of the Xp?

269
00:20:10,370 --> 00:20:14,739
 The way no no don't don't confuse the encoding with the value of represents

270
00:20:15,260 --> 00:20:20,949
 Exp is is just the encoding. So what's what's the smallest value of the xp?

271
00:20:21,920 --> 00:20:23,920
 0 that's right

272
00:20:26,000 --> 00:20:30,040
 Okay, and the largest value is is what remember?

273
00:20:31,580 --> 00:20:35,170
 It's what's the largest value yep?

274
00:20:37,820 --> 00:20:43,510
 Well the largest value would be remember it can't be all ones

275
00:20:45,350 --> 00:20:49,060
 Right so the largest value would be 2 to the 8th minus 1 so

276
00:20:50,630 --> 00:20:56,829
 Okay, so the largest value would be 0 1 1 1 1 0 followed by 7 ones

277
00:20:58,220 --> 00:21:02,800
 Ok, so that's a 2 to the 8th minus 1 is

278
00:21:06,470 --> 00:21:08,470
 255 good

279
00:21:12,990 --> 00:21:19,430
 Okay, so then what's the range then of the of e which is the actual value that we want to encode

280
00:21:23,970 --> 00:21:26,449
 Okay, remember use this we have this definition

281
00:21:27,090 --> 00:21:31,220
 So we have the range of values for Exp. We have our bias

282
00:21:32,040 --> 00:21:37,369
 So what are the range of values for it for e? This is the actual exponents that we're we're encoding

283
00:21:38,280 --> 00:21:40,280
 So what's the smallest exponent?

284
00:21:41,760 --> 00:21:43,760
 minus 127 good

285
00:21:47,070 --> 00:21:49,070
 right because that's

286
00:21:49,200 --> 00:21:55,819
 Zero is our smallest Exp minus the bias which is 127 okay, so the smallest value of e is is

287
00:21:57,450 --> 00:22:01,700
 it's 127 and the the largest value of e is

288
00:22:08,250 --> 00:22:15,679
 So if we take the largest value of Exp, that's 255 minus 127

289
00:22:19,890 --> 00:22:21,890
 128

290
00:22:24,830 --> 00:22:26,830
 okay, so the the

291
00:22:27,020 --> 00:22:30,490
 numbers that we can represent using this bias notation

292
00:22:31,370 --> 00:22:35,319
 will have the smallest exponent will be 2 to the minus 127 and

293
00:22:35,930 --> 00:22:40,090
 The largest exponent will be 2 to the raised to the power 128

294
00:22:42,110 --> 00:22:44,110
 Okay, so do you see

295
00:22:44,660 --> 00:22:46,660
 You see what's going on here. So we have

296
00:22:47,480 --> 00:22:50,919
 We have a range of values for e. Here's the largest value

297
00:22:51,350 --> 00:22:58,419
 Here's the smallest value here's 0 right in the middle these are the values we want to represent this biasing is like a shift

298
00:22:58,730 --> 00:23:05,469
 We've just now we're shifting up by 127 so that now the smallest exponent is

299
00:23:06,080 --> 00:23:08,080
 represented by 0

300
00:23:09,830 --> 00:23:12,999
 Okay, any questions about that

301
00:23:22,870 --> 00:23:24,279
 now

302
00:23:24,279 --> 00:23:30,359
 These normalized these normalized values always have this this implied one

303
00:23:31,299 --> 00:23:32,860
 okay, which

304
00:23:32,860 --> 00:23:36,599
 Which when we get clipped when we want to represent numbers closer to zero?

305
00:23:37,720 --> 00:23:41,100
 that limits us right, so there's another type of

306
00:23:42,220 --> 00:23:44,970
 floating-Point number called the de norm de normalized

307
00:23:45,640 --> 00:23:46,840
 value

308
00:23:46,840 --> 00:23:51,179
 which which is characterized by an Exp field of all zeros and

309
00:23:52,630 --> 00:24:00,059
 in a normal in a denormalized number or D norm there's no implied one, okay, so the the

310
00:24:01,690 --> 00:24:03,690
 significant m is

311
00:24:04,090 --> 00:24:11,340
 represented exactly is encoded identically in the in the frac field so there's no implied one and

312
00:24:11,980 --> 00:24:14,669
 all of the numbers are the form zero point

313
00:24:16,029 --> 00:24:18,179
 Something something something after them

314
00:24:20,710 --> 00:24:22,710
 in the exponent value E

315
00:24:22,929 --> 00:24:25,829
 Instead of remember for de norms we subtracted

316
00:24:26,559 --> 00:24:31,408
 Bias from Exp for D. Norms we subtract the bias from one?

317
00:24:32,260 --> 00:24:35,369
 okay, now you would just use the

318
00:24:36,070 --> 00:24:40,500
 The definition we use for normalized numbers that would be the Exp would be zero

319
00:24:41,679 --> 00:24:43,679
 So we don't do that instead, we?

320
00:24:45,700 --> 00:24:47,700
 Yi is 1 minus the bias and

321
00:24:48,940 --> 00:24:54,659
 Then the significant is coded with an implied leading zero instead of a leading one like I like I mentioned

322
00:24:57,850 --> 00:24:59,850
 so

323
00:25:00,010 --> 00:25:03,059
 so when Exp is zero and also I mean we

324
00:25:04,029 --> 00:25:05,919
 think about it if

325
00:25:05,919 --> 00:25:12,388
 If we only had denormalized numbers, we wouldn't be able to represent zero right because there's there'd always be a 1 in there

326
00:25:13,269 --> 00:25:20,549
 So the d norms allow us to represent zero and they only allow us to represent values that are very close to zero

327
00:25:22,269 --> 00:25:24,269
 so when the exponent is zero and

328
00:25:24,909 --> 00:25:29,549
 The Exp field is zero and the Frac field is zero then this is the zero value

329
00:25:30,300 --> 00:25:37,019
 And so this is nice because all zeroes represents zero which is you know sort of what what you want?

330
00:25:38,200 --> 00:25:40,260
 Now there is a sort of weird thing though that

331
00:25:40,900 --> 00:25:43,889
 If you have a sign, bit is

332
00:25:45,550 --> 00:25:49,349
 one and then your your Frakkin and an

333
00:25:49,900 --> 00:25:55,259
 Exp or zero then you have negative zero so you have this kind of odd situation where there's a positive and negative zero

334
00:25:55,990 --> 00:25:57,990
 Okay

335
00:25:59,860 --> 00:26:04,979
 and other values if the xp is zero, and you have a non zero frack then those are the

336
00:26:05,800 --> 00:26:08,429
 equally spaced numbers that are closest to zero

337
00:26:12,040 --> 00:26:16,589
 Now there's a couple of other special values when Exp is is

338
00:26:17,260 --> 00:26:19,260
 all one and

339
00:26:19,540 --> 00:26:22,769
 Frack is all zeros this represents the value infinity

340
00:26:24,340 --> 00:26:27,569
 so this is a value that that we get when

341
00:26:28,420 --> 00:26:31,499
 Is some kind of addition or multiplication and we overflow?

342
00:26:32,110 --> 00:26:33,070
 so in

343
00:26:33,070 --> 00:26:40,800
 Floating point always overflows to the special value called infinity the positive or negative infinity so it's different from two's complement rightward

344
00:26:40,990 --> 00:26:43,530
 You sort of overflowed and in this modular way

345
00:26:45,550 --> 00:26:49,619
 Back just back it around into the range of numbers in in floating point

346
00:26:49,690 --> 00:26:54,630
 We just overflow to the sticky value called infinity, and then then everything we do on that

347
00:26:55,210 --> 00:26:57,210
 remains infinity

348
00:26:59,350 --> 00:27:01,350
 so for example if we did a

349
00:27:05,770 --> 00:27:09,780
 if we did 1 divided by 0 or

350
00:27:10,900 --> 00:27:15,269
 We or minus 1 divided by minus 0 we get positive infinity if we divide

351
00:27:15,700 --> 00:27:19,350
 One by a zero negative zero we get negative infinity

352
00:27:20,350 --> 00:27:24,209
 the fourth the fourth kind of special case special number

353
00:27:24,640 --> 00:27:30,150
 Is the case where the exponent again is all once but the frac is is Nonzero

354
00:27:30,850 --> 00:27:32,850
 in a non zero value

355
00:27:33,070 --> 00:27:36,059
 And this represents what's called not a number, so this is

356
00:27:36,790 --> 00:27:41,729
 This is this this lift handles cases with where there's no. There's no answer

357
00:27:41,760 --> 00:27:45,989
 There's no feasible answer for example if we you know try to take the square root of -1

358
00:27:46,480 --> 00:27:48,930
 What we'll get back is not a number

359
00:27:54,880 --> 00:27:59,459
 So 2 I think it's helpful to to visualize these

360
00:28:00,130 --> 00:28:02,130
 the number line now, so the

361
00:28:02,920 --> 00:28:07,829
 We have positive zero negative zero sort of right next to each other and then to

362
00:28:08,470 --> 00:28:11,190
 The right of that are the positive D norms?

363
00:28:12,040 --> 00:28:15,269
 and then those then those sort of

364
00:28:16,690 --> 00:28:18,280
 Transition into the

365
00:28:18,280 --> 00:28:20,050
 normalized numbers

366
00:28:20,050 --> 00:28:22,050
 And then you have infinity

367
00:28:22,360 --> 00:28:24,810
 Positive infinity they have a similar

368
00:28:26,140 --> 00:28:33,629
 similar situation on the for the negative numbers and then negative and positive nodded numbers

369
00:28:39,160 --> 00:28:42,749
 so I think the you know he's probably you've probably discovered now that a

370
00:28:43,330 --> 00:28:45,810
 Really good way to try to understand these

371
00:28:46,390 --> 00:28:53,189
 American coatings, it's just to do examples with only a few numbers bits. You know if you want to understand like for example in tooth

372
00:28:54,010 --> 00:29:00,420
 If you want to understand t min and t max and and how they relate to each other just do a three bit

373
00:29:02,230 --> 00:29:06,780
 Two's complement system. You know imagine just have a system with two's complement of three bits

374
00:29:06,780 --> 00:29:09,689
 and then you can just enumerate all those all the

375
00:29:10,210 --> 00:29:12,040
 possibilities, and you can see

376
00:29:12,040 --> 00:29:15,629
 And then you see where you know the t min is actually

377
00:29:16,180 --> 00:29:22,049
 One greater than t max you know so if you add one to t max it actually overflows into t min

378
00:29:22,570 --> 00:29:24,570
 maybe a

379
00:29:25,180 --> 00:29:32,399
 Similar thing for floating-point. It's I would really encourage you to do this just try some simple examples with a

380
00:29:33,040 --> 00:29:39,359
 sort of Tyent with a small number of Exp and frac bits so in this case, we're going to look at A

381
00:29:41,140 --> 00:29:47,160
 floating-point system based on I triple e that has for Exp bits and three fraC bits

382
00:29:48,310 --> 00:29:51,149
 As always the sign bit, it's the most significant bit

383
00:29:51,970 --> 00:29:53,970
 followed by Exp followed by Frac

384
00:29:55,370 --> 00:29:59,860
 Okay, so this is this is identical to I triple e floating point except for the size of that

385
00:30:01,550 --> 00:30:03,550
 Exp in fractions

386
00:30:03,860 --> 00:30:07,479
 So it's actually small enough that we can now just enumerate

387
00:30:08,660 --> 00:30:10,660
 these values and

388
00:30:11,000 --> 00:30:12,920
 And now you can I?

389
00:30:12,920 --> 00:30:15,159
 You can start to see why these weird

390
00:30:16,820 --> 00:30:24,730
 definitions for the exponent in donora and normalized numbers, so let's just look at

391
00:30:27,200 --> 00:30:32,080
 So what we've done here. We've just with a signed bit of zero. We've we've just enumerated

392
00:30:32,960 --> 00:30:34,960
 all of the two to the seventh

393
00:30:35,840 --> 00:30:37,580
 possibilities possible

394
00:30:37,580 --> 00:30:40,569
 combinations of Exp and Frac Fields starting with zero

395
00:30:42,050 --> 00:30:48,279
 okay, so when when exp is all zeros, that's a d norm right by definition and

396
00:30:49,310 --> 00:30:51,310
 then we have

397
00:30:51,980 --> 00:30:54,219
 the three FraC bits or all zero

398
00:30:59,240 --> 00:31:05,980
 okay, so remember the Exp is all zeros right so the four D norms the

399
00:31:07,580 --> 00:31:12,730
 The exponent value is 1 minus the bias our bias here is seven

400
00:31:13,640 --> 00:31:17,980
 Okay, so one minus seven gives us a value for the exponent of minus six

401
00:31:19,070 --> 00:31:21,070
 So we're going to take the frac

402
00:31:23,630 --> 00:31:26,050
 the bits in the in the in the frac field

403
00:31:27,770 --> 00:31:29,450
 times

404
00:31:29,450 --> 00:31:31,450
 so m is zero

405
00:31:31,520 --> 00:31:33,520
 So m in this case is zero

406
00:31:34,280 --> 00:31:35,420
 times

407
00:31:35,420 --> 00:31:38,529
 2 to the minus 6 gives us zero, okay?

408
00:31:38,530 --> 00:31:42,850
 So this this is our reference state representation of zero and like I said it's really

409
00:31:42,850 --> 00:31:46,629
 It's nice that it actually is if we just treated this as an unsigned

410
00:31:47,210 --> 00:31:48,860
 Integer we just it

411
00:31:48,860 --> 00:31:51,639
 Would be zero okay, so that's kind of pleasing

412
00:31:52,670 --> 00:31:57,970
 Now let's look at the very next number right the x exp is still zero and we've just bumped up

413
00:31:58,610 --> 00:32:00,610
 Track by one

414
00:32:00,920 --> 00:32:04,899
 Okay, so again it's it's a one minus the bias which is

415
00:32:05,570 --> 00:32:07,400
 minus six

416
00:32:07,400 --> 00:32:10,119
 And now this this frack

417
00:32:10,970 --> 00:32:12,970
 field represents

418
00:32:13,760 --> 00:32:15,760
 This is 1/2

419
00:32:16,160 --> 00:32:17,660
 1/4

420
00:32:17,660 --> 00:32:23,199
 1/8 so it represents, so this is a value of Amaz it is 1/8

421
00:32:24,260 --> 00:32:25,880
 So 1/8

422
00:32:25,880 --> 00:32:28,059
 Times 2 to the minus 6 which is 1

423
00:32:28,460 --> 00:32:35,530
 64th equals 1 over 512 so in this floating point system the smallest Nonzero number we can represent is the

424
00:32:35,990 --> 00:32:38,319
 denormalized representation of 1 over 512

425
00:32:38,840 --> 00:32:40,840
 the next smallest number is 0

426
00:32:44,240 --> 00:32:49,719
 okay, now let's look at so let's take let's bump this up by 1 so now we get a

427
00:32:51,380 --> 00:32:55,059
 We get a fraC sealed of 0 1 0 so this represents

428
00:32:57,050 --> 00:32:58,910
 1/4

429
00:32:58,910 --> 00:33:02,889
 So e/m is 1/4 that significant is 1/4 times

430
00:33:03,560 --> 00:33:05,710
 2 to the Minus 6 So 2 8

431
00:33:06,470 --> 00:33:09,789
 Times 1 64 is 2 to the 5 12?

432
00:33:10,610 --> 00:33:12,110
 okay, so

433
00:33:12,110 --> 00:33:14,110
 the the numbers were just

434
00:33:14,360 --> 00:33:17,260
 Invite by incrementing this by incrementing

435
00:33:17,960 --> 00:33:21,460
 Armored-Car significant, we're increasing the numbers by

436
00:33:22,160 --> 00:33:24,160
 1 over 512

437
00:33:25,910 --> 00:33:33,219
 now the largest d norm in this number system is the case where the frack field is all ones and

438
00:33:34,250 --> 00:33:36,250
 so this encodes

439
00:33:36,560 --> 00:33:37,700
 1/2

440
00:33:37,700 --> 00:33:40,809
 Plus 1/4 Plus 1/8

441
00:33:41,990 --> 00:33:43,990
 which is 7/8 and

442
00:33:44,330 --> 00:33:46,330
 then our value is

443
00:33:46,790 --> 00:33:48,440
 7/8 times

444
00:33:48,440 --> 00:33:52,630
 2 to the minus 6 or 1 over 64 and that equals 7 512

445
00:33:54,410 --> 00:33:55,790
 so this

446
00:33:55,790 --> 00:34:00,790
 7 over 512 is the largest denormalized number we can represent in this system

447
00:34:01,820 --> 00:34:04,630
 and now if we if we bump our number up by one

448
00:34:05,330 --> 00:34:06,560
 the

449
00:34:06,560 --> 00:34:13,120
 The Frac field resets to zero and now the Exp field goes from zero to one

450
00:34:16,520 --> 00:34:23,020
 Now because the Exp field is non-0 this this is no longer a denormalized number. It's a normalized number

451
00:34:24,560 --> 00:34:27,159
 okay, so now we're changing the

452
00:34:27,800 --> 00:34:33,099
 Definition of e from 1 minus the bias to Exp minus the bias

453
00:34:34,819 --> 00:34:37,629
 So what's what's Exp in this case?

454
00:34:40,040 --> 00:34:42,040
 1

455
00:34:42,260 --> 00:34:46,869
 Minus 7 the bias is minus 6 so Lo and Behold

456
00:34:48,139 --> 00:34:50,139
 it's the same it's the same it's

457
00:34:51,260 --> 00:34:53,260
 the same

458
00:34:53,329 --> 00:34:56,769
 exponent as the previous denormalized number

459
00:34:56,960 --> 00:35:00,429
 So this is this is actually very clever by the I triple e folks

460
00:35:00,859 --> 00:35:06,459
 because you get the spirit you get this nice smooth transition from de norms to norms to normalize, so

461
00:35:07,010 --> 00:35:09,010
 You can see that

462
00:35:09,710 --> 00:35:15,699
 Our our exponent. E is minus 6 still and now our

463
00:35:18,260 --> 00:35:24,129
 Because we're taking 1 minus the bias 7 and our signature

464
00:35:25,609 --> 00:35:32,289
 Significant now remember this is a normalized number because the Exp field is Nonzero

465
00:35:33,740 --> 00:35:40,750
 Just this the a fraction of all zeros represents a significant of one point zero zero zero

466
00:35:42,560 --> 00:35:47,679
 Okay, so this this normalized number this the smallest normalized number

467
00:35:49,099 --> 00:35:53,109
 Represents is one point zero zero zero which is 8 8 times

468
00:35:54,079 --> 00:35:56,709
 2 to the Minus 6 which is 1 over 64

469
00:35:57,440 --> 00:36:05,440
 Which gives us 8 over 512 so if we've made this nice smooth transition from 7 over 5 12 to 8 over 512?

470
00:36:06,740 --> 00:36:09,399
 And I'll do one more. I don't want to be

471
00:36:10,160 --> 00:36:12,050
 so if we bump if

472
00:36:12,050 --> 00:36:17,499
 We bump keeping the Exp field at 1 if we bump our fracks deals from 0 to 1

473
00:36:18,349 --> 00:36:20,349
 now this represents the the

474
00:36:21,619 --> 00:36:23,649
 significant of 1

475
00:36:25,490 --> 00:36:27,490
 point 0

476
00:36:28,680 --> 00:36:30,680
 one point zero zero one

477
00:36:32,430 --> 00:36:36,380
 Which is eight eight plus one eight?

478
00:36:37,860 --> 00:36:39,860
 So that's nine eight

479
00:36:40,140 --> 00:36:42,140
 times and then the value is

480
00:36:42,750 --> 00:36:48,590
 Nine eight times 2 to the minus six once 1 over 64 which is equal to 9 over 512 okay?

481
00:36:52,079 --> 00:36:54,079
 Any questions about that?

482
00:36:59,230 --> 00:37:01,230
 question back here

483
00:37:04,270 --> 00:37:10,349
 Okay, the question is why is why do you choose to bias that to be 2 to the K minus 1 minus 1 well go?

484
00:37:10,349 --> 00:37:16,949
 Back to my my singer diagram here, so this is the range of the Xp fields that you want to

485
00:37:18,339 --> 00:37:21,689
 This is the range of e that you want to represent with 0 in the middle

486
00:37:23,200 --> 00:37:31,139
 Okay, and so you want to bias it so that this is halfway 0 the smallest exponent

487
00:37:31,140 --> 00:37:33,140
 Is Halfway to 0?

488
00:37:33,730 --> 00:37:36,689
 So you want the bias to shift it up, so it's the smallest

489
00:37:37,839 --> 00:37:42,509
 The smallest encoded the smallest value of Exp Corresponds to the smallest exponent

490
00:37:43,030 --> 00:37:48,269
 Right so 2 to the K minus 1 minus 1 is just giving you it's giving you a value. That's halfway

491
00:37:48,520 --> 00:37:51,209
 between the smallest exponent and the largest exponent

492
00:37:52,930 --> 00:37:54,930
 Okay

493
00:37:56,270 --> 00:37:58,270
 That's good any other questions

494
00:38:04,910 --> 00:38:11,410
 okay, if we take a like a little smaller six bit format same thing as we did before just different numbers of

495
00:38:12,470 --> 00:38:19,179
 Bits and Exp and frac, and then we plot these on the number line you can see that

496
00:38:20,840 --> 00:38:27,309
 you can see that the values are very dense around zero, so they're very spaced very closely together and

497
00:38:27,740 --> 00:38:31,089
 Then every time you increase the exponent by one

498
00:38:33,410 --> 00:38:36,160
 the numbers are spaced twice

499
00:38:38,240 --> 00:38:41,559
 twice as far apart as the previous the number the numbers that

500
00:38:42,560 --> 00:38:44,860
 Are represented by the previous exponent?

501
00:38:45,710 --> 00:38:47,859
 So you can see like in this little example

502
00:38:50,300 --> 00:38:52,300
 You see these

503
00:38:53,180 --> 00:38:55,450
 These values here are all equally spaced

504
00:38:56,240 --> 00:38:58,719
 Now these these four values are equally spaced

505
00:38:58,720 --> 00:39:01,449
 And they're right next to each other and then you

506
00:39:01,940 --> 00:39:07,059
 See this jump in the spacing that represents an increase in the Exp field by one

507
00:39:09,350 --> 00:39:13,569
 And then it and then that spacing doubles as we go out

508
00:39:16,160 --> 00:39:20,649
 And you can see it. You can see it even better here. This if we if we zoom in

509
00:39:21,620 --> 00:39:24,279
 These blue values are the are

510
00:39:25,220 --> 00:39:27,279
 these blue values or D norms and

511
00:39:28,010 --> 00:39:29,600
 then we have

512
00:39:29,600 --> 00:39:35,650
 The the next set of normalized values where the frack field is one. They're spaced the same, right?

513
00:39:35,650 --> 00:39:38,920
 We saw this when we kept increasing by by one over 512

514
00:39:40,580 --> 00:39:45,100
 And then we increase the the exponent by one and the spacing doubles

515
00:39:50,960 --> 00:39:55,809
 okay, so this like I mentioned this this encoding has some some pretty nice properties the

516
00:39:56,840 --> 00:40:02,140
 The floating point zero zero zero is encoded as integers here. Which is nice

517
00:40:03,500 --> 00:40:05,770
 and with the exception of

518
00:40:08,120 --> 00:40:10,120
 Not a number

519
00:40:12,080 --> 00:40:16,690
 With the exception of not a number you can compare any floating-point numbers?

520
00:40:17,180 --> 00:40:20,799
 Including infinity by just treating it as doing an unsigned

521
00:40:21,680 --> 00:40:24,369
 Comparison so that's that's really nice, too

522
00:40:30,869 --> 00:40:37,999
 Now if you when you add and multiply floating point numbers right we're dealing with a limited set of bits here

523
00:40:38,579 --> 00:40:41,298
 so if we take if we take two numbers

524
00:40:42,750 --> 00:40:49,399
 Encoded as floating-point, and we add them together. There's there's no guarantee that we'll be able to fit all those bits in the bits

525
00:40:49,400 --> 00:40:51,400
 we have available to us the

526
00:40:52,349 --> 00:40:55,429
 There's no guarantee that we'll be able to fit the bits and the result

527
00:40:56,069 --> 00:40:57,780
 So what?

528
00:40:57,780 --> 00:41:00,589
 So what we do in this case is you can imagine?

529
00:41:02,430 --> 00:41:06,559
 The Model You want to have with floating point operations addition to multiplication is

530
00:41:07,140 --> 00:41:14,299
 That you you add or multiply you do the addition or multiplication and you compute the exact result you

531
00:41:14,299 --> 00:41:18,019
 just assume that you have an infinite amount of number of bits and

532
00:41:18,660 --> 00:41:23,180
 then you round use the technique called rounding to get it to fit into the of

533
00:41:23,730 --> 00:41:29,689
 The available bits okay, so the effect is like you're doing say x plus y is

534
00:41:30,569 --> 00:41:32,569
 getting the precise value

535
00:41:32,790 --> 00:41:36,109
 of x plus y at an infinite number of bits and then rounding into the

536
00:41:37,079 --> 00:41:39,079
 available bits

537
00:41:39,240 --> 00:41:47,000
 So let's look at this this idea of rounding it this can be confusing the first time you see it it requires

538
00:41:48,059 --> 00:41:50,059
 You need to think about it carefully

539
00:41:51,240 --> 00:41:55,339
 To get it right now in I triple e. There's four different kinds of rounding

540
00:41:55,339 --> 00:42:00,169
 There's round towards zero round down route or round to minus infinity

541
00:42:01,170 --> 00:42:03,170
 round up to

542
00:42:03,329 --> 00:42:10,639
 Which is rounding it to positive infinity and then the default case which is the only one really we're really going to consider which is

543
00:42:11,190 --> 00:42:13,190
 round to the nearest even

544
00:42:13,950 --> 00:42:16,790
 And this is what I triple e does by default

545
00:42:17,430 --> 00:42:24,349
 You can you can if you go into assembly language you can change the rounding, but we're not going to consider it any more

546
00:42:24,349 --> 00:42:26,349
 yes question

547
00:42:27,180 --> 00:42:29,180
 the

548
00:42:29,690 --> 00:42:31,690
 I'm sorry

549
00:42:33,110 --> 00:42:37,120
 There is right because there's one so the question is there a distinct

550
00:42:37,730 --> 00:42:40,030
 negative infinity and a distinct positive infinity

551
00:42:40,030 --> 00:42:47,110
 And there is they have the exact same bit representation except the most significant bit for negative infinity is one

552
00:42:47,810 --> 00:42:49,810
 And for positive infinity at zero

553
00:42:52,850 --> 00:42:54,850
 yes question

554
00:42:57,590 --> 00:43:03,789
 White is nearest even oh, I'll show you let me go over the others the question was about nearest even yes

555
00:43:06,410 --> 00:43:12,309
 Greater than big well. That was me that was the exception right today. That's right so so aside from

556
00:43:13,490 --> 00:43:15,490
 Infinity, you can't do that comparison

557
00:43:17,480 --> 00:43:19,480
 positive infinity works

558
00:43:19,640 --> 00:43:22,269
 Right, but not negative, so you're right. That's good point

559
00:43:23,420 --> 00:43:25,989
 All right, so let's look at these rounding modes, and I'll explain

560
00:43:27,110 --> 00:43:31,719
 Live at the Neuro Steven works, but let's look at so rounding towards zero what we're going to do

561
00:43:32,180 --> 00:43:34,899
 We'll use dollars so we want to round to the nearest dollar

562
00:43:37,340 --> 00:43:39,670
 Towards Zero just anything less than

563
00:43:40,130 --> 00:43:41,420
 You just around

564
00:43:41,420 --> 00:43:48,430
 You just round towards zero so dollar forty would go to one a dollar sixty would go down to one a dollar fifty to one

565
00:43:48,740 --> 00:43:50,740
 To fifty would go to two

566
00:43:50,870 --> 00:43:55,390
 Negative 150 you round toward zero so that would be negative negative one

567
00:43:56,600 --> 00:43:58,749
 round down Towards negative infinity

568
00:44:02,480 --> 00:44:05,980
 It's similar the only difference is that for negative one point?

569
00:44:06,650 --> 00:44:09,219
 Negative a dollar fifty you'd round towards negative

570
00:44:10,250 --> 00:44:12,250
 Infinity which would be minus two

571
00:44:12,830 --> 00:44:14,780
 rounding up is the

572
00:44:14,780 --> 00:44:16,340
 is

573
00:44:16,340 --> 00:44:19,840
 symmetric to round down the interesting case is

574
00:44:22,250 --> 00:44:24,250
 round to nearest even

575
00:44:25,340 --> 00:44:30,999
 Interesting because it's what I triple e floating point actually uses so the idea here

576
00:44:31,400 --> 00:44:35,199
 If you if you have a value that's less than half

577
00:44:35,870 --> 00:44:42,969
 Then you round down if you have a value that's more than halfway between two dollar amounts you round up

578
00:44:43,940 --> 00:44:47,409
 the route that nearest even part comes when you have

579
00:44:48,380 --> 00:44:50,380
 Something that's exactly halfway

580
00:44:50,930 --> 00:44:53,980
 Then what you do is you round towards the nearest even number

581
00:44:54,980 --> 00:45:02,620
 Okay, so in in this example a dollar forty because it's less than it's less than half

582
00:45:03,230 --> 00:45:08,740
 rounds down to one dollar a dollar sixty is greater than half so we round up to two dollars a

583
00:45:09,890 --> 00:45:11,890
 dollar Fifty right in the Middle

584
00:45:12,710 --> 00:45:14,240
 We round

585
00:45:14,240 --> 00:45:18,189
 Round up to the nearest even knock dollar amount. Which is two dollars

586
00:45:20,120 --> 00:45:22,120
 two dollars and fifty

587
00:45:22,430 --> 00:45:28,690
 Cents we round down to the nearest even right if we round it up. It would be three which is a oDd number and

588
00:45:29,690 --> 00:45:32,740
 - a dollar fifty we round - we

589
00:45:33,950 --> 00:45:36,189
 Round down to minus - two dollars

590
00:45:38,030 --> 00:45:41,110
 So the reason we do this the reason they chose. This is that

591
00:45:43,340 --> 00:45:45,260
 statistically if

592
00:45:45,260 --> 00:45:50,290
 You would imagine if you have a uniform distribution of sort of numbers

593
00:45:50,290 --> 00:45:55,029
 They're going to round up or down about 50 percent of the time, so there won't be a statistical bias

594
00:45:55,730 --> 00:46:00,340
 Rounding up or down one way or the other okay? So that's the that's the reason they did that

595
00:46:03,110 --> 00:46:05,090
 now

596
00:46:05,090 --> 00:46:07,840
 You can apply this you can do this rounding to any

597
00:46:08,480 --> 00:46:12,879
 to any any any value, so in the last example, we did it to

598
00:46:13,520 --> 00:46:19,540
 The nearest dollar but let's suppose. We wanted to round to the nearest hundredth using round two even

599
00:46:20,150 --> 00:46:22,150
 the default round - even mode

600
00:46:22,490 --> 00:46:24,490
 So we want to round

601
00:46:24,590 --> 00:46:26,590
 to the nearest

602
00:46:28,100 --> 00:46:33,370
 Hundredth is the second position this first do we have tenths and hundredths

603
00:46:34,730 --> 00:46:41,230
 So if we have a value seven point eight nine for $9.99 that's less than halfway

604
00:46:42,920 --> 00:46:44,920
 Halfway would be

605
00:46:45,830 --> 00:46:47,830
 Halfway would be

606
00:46:48,080 --> 00:46:51,340
 Any number that had a five followed by all zeros

607
00:46:52,400 --> 00:46:54,879
 So for 999 is less than that

608
00:46:55,880 --> 00:46:59,170
 So we would just round down to 7.89

609
00:47:01,190 --> 00:47:07,060
 Even though 9 is odd. The only the only time we're going to apply round 2 even is when we're exactly halfway

610
00:47:08,359 --> 00:47:14,409
 Okay, our next the next example seven point eight nine five zero zero one that's greater than halfway

611
00:47:16,250 --> 00:47:23,679
 Right if this if this was a zero it would be exactly halfway, so we round up to seven point nine

612
00:47:24,770 --> 00:47:29,020
 Okay, now here's the interesting case where we have seven point eight nine five

613
00:47:29,660 --> 00:47:35,710
 Followed by all zeroes that's exactly halfway. So now we now we apply the round to nearest even rule

614
00:47:39,530 --> 00:47:47,350
 Eight nine is the negative an odd number so that doesn't work so we round up and we do that basically by adding

615
00:47:48,290 --> 00:47:50,290
 adding a 5 here, so

616
00:47:50,960 --> 00:47:53,800
 5 + 5 is 10 and then that carries over

617
00:47:54,590 --> 00:47:55,820
 God

618
00:47:55,820 --> 00:47:58,600
 to the next position and 9 + 1 is 0

619
00:48:00,890 --> 00:48:07,840
 9 + 1 is 10 so that carries over and so 8 + 8 + 1 is 9 so the result is set of rounds

620
00:48:09,560 --> 00:48:11,560
 ero

621
00:48:11,930 --> 00:48:13,930
 Okay, is that clear you see?

622
00:48:15,770 --> 00:48:21,219
 It's a very mechanical way when you round up. It's always it's a very mechanical like that. You always just add

623
00:48:22,100 --> 00:48:24,609
 the half way number in this Case 5 and

624
00:48:25,280 --> 00:48:29,019
 Then just just propagate it out just do the addition and that will give you the nearest

625
00:48:30,230 --> 00:48:32,409
 The nearest that will round you up to the nearest

626
00:48:33,650 --> 00:48:35,480
 hundredth in this case

627
00:48:35,480 --> 00:48:38,530
 Okay, now the last case seven point eight eight five

628
00:48:39,410 --> 00:48:42,490
 Followed by all zeroes that's that's another number. That's halfway between

629
00:48:45,619 --> 00:48:47,619
 between two numbers

630
00:48:48,830 --> 00:48:52,179
 Rounded to the nearest hundredth so in this case

631
00:48:53,630 --> 00:48:55,100
 eight is

632
00:48:55,100 --> 00:48:59,949
 Even so we just we round down and to round down. We just truncate just throw these bits

633
00:49:00,470 --> 00:49:04,659
 These these digits away, and we get seven point eight eight

634
00:49:05,180 --> 00:49:07,180
 So there any questions about this

635
00:49:10,729 --> 00:49:12,729
 question back here yep

636
00:49:24,589 --> 00:49:26,589
 yep, that's the question was if

637
00:49:27,769 --> 00:49:29,769
 numbers that have the same

638
00:49:29,779 --> 00:49:31,779
 Exp field

639
00:49:31,849 --> 00:49:37,149
 Will will those numbers be equally spaced on the number line and the answer is yes?

640
00:49:40,190 --> 00:49:42,190
 yes question

641
00:49:45,709 --> 00:49:47,709
 all

642
00:49:47,779 --> 00:49:54,819
 Right and things done. Thank you in the last example Deltas. Why'd you run it would round up?

643
00:49:55,699 --> 00:49:57,650
 Yeah, the only

644
00:49:57,650 --> 00:50:00,849
 The half way values are always in this case because it's Base 10

645
00:50:01,910 --> 00:50:04,539
 the the half way number in Base 10 is 5 and

646
00:50:04,759 --> 00:50:08,498
 Then so it's always the half way number in this case 5 followed by all zeros

647
00:50:11,539 --> 00:50:18,429
 You always have that the half way if a value is halfway between like 200 it'll always have that that form

648
00:50:22,369 --> 00:50:27,098
 All right now. We can do the same thing with with binary fractional numbers as well

649
00:50:28,099 --> 00:50:34,028
 now a binary number is is even if it if the

650
00:50:34,609 --> 00:50:36,609
 least significant digit is 0

651
00:50:37,069 --> 00:50:41,048
 Ok we only have two digits right so odd is 1 and 0 is even

652
00:50:41,690 --> 00:50:44,499
 Ok and the halfway so the halfway

653
00:50:45,440 --> 00:50:47,440
 value is going to be a

654
00:50:48,589 --> 00:50:56,318
 1 followed by all zeros ok that represents exactly halfway ok so it's very it's analogous

655
00:50:57,680 --> 00:50:59,680
 analogous to the Base 10 example

656
00:51:00,019 --> 00:51:03,789
 Except where the halfway value is going to be 1 followed by all zeros

657
00:51:04,729 --> 00:51:07,539
 so let's look let's look at some examples, so

658
00:51:09,410 --> 00:51:12,219
 Suppose we have we want to represent two

659
00:51:13,219 --> 00:51:16,029
 and three thirty-seconds and

660
00:51:17,089 --> 00:51:19,538
 Suppose we only have four bits to do that in

661
00:51:20,660 --> 00:51:22,660
 Okay, well to represent that exactly

662
00:51:23,039 --> 00:51:25,039
 we need

663
00:51:26,490 --> 00:51:28,490
 seven bits

664
00:51:28,680 --> 00:51:32,030
 And so we have to round okay?

665
00:51:33,900 --> 00:51:35,900
 so let's look at

666
00:51:36,510 --> 00:51:38,510
 So we're going to round to

667
00:51:38,789 --> 00:51:41,899
 this two bits right at the binary point and

668
00:51:42,780 --> 00:51:45,139
 So let's look at all the bits that follow that

669
00:51:46,200 --> 00:51:48,439
 so since it starts with zero

670
00:51:49,770 --> 00:51:51,770
 This is going to be less than halfway

671
00:51:52,829 --> 00:51:58,699
 So since it's less than halfway we just truncate just chop those out and the result is

672
00:52:00,390 --> 00:52:02,390
 10.00

673
00:52:02,789 --> 00:52:08,689
 Now our next example is one zero point zero zero one one zero, so if we look at these

674
00:52:09,329 --> 00:52:11,329
 the bits to the right of these

675
00:52:12,059 --> 00:52:15,469
 to the right of the the bit we're rounding to

676
00:52:16,980 --> 00:52:23,689
 Since it starts with one, and it's not followed by all zeros that's greater than half okay

677
00:52:24,960 --> 00:52:26,819
 so

678
00:52:26,819 --> 00:52:30,379
 For the in this case we have to round up and so the way we do that is

679
00:52:31,589 --> 00:52:37,699
 we take we take one and we add it to this leftmost one right here and just

680
00:52:38,730 --> 00:52:42,799
 Do the addition and the result is one zero point zero one

681
00:52:44,819 --> 00:52:46,819
 Now let's look at two to the seven eight

682
00:52:48,630 --> 00:52:53,779
 This is represented as one zero point one one one zero zero

683
00:52:54,779 --> 00:52:58,429
 Now here's that here's that half way marker that we were looking for

684
00:53:00,420 --> 00:53:07,730
 it's a 1 followed by all zeros, so this is exactly half way, so now we have to round to the nearest even

685
00:53:09,270 --> 00:53:10,950
 number now

686
00:53:10,950 --> 00:53:16,220
 That if we can't just truncate because then it would be an odd number right we would end

687
00:53:17,460 --> 00:53:19,260
 10.11 is an oDd number

688
00:53:19,260 --> 00:53:21,260
 So we have to round up

689
00:53:21,720 --> 00:53:23,720
 And we do that by adding

690
00:53:25,260 --> 00:53:27,260
 we do that by adding a 1

691
00:53:27,900 --> 00:53:35,540
 Right here to this less leftmost red, bit. We add one to that and then just do the addition and we end up with

692
00:53:37,260 --> 00:53:39,030
 11.00

693
00:53:39,030 --> 00:53:41,120
 Which is three so the nearest?

694
00:53:42,510 --> 00:53:44,960
 The nearest value to two to the seventh eighth

695
00:53:46,890 --> 00:53:49,460
 The nearest rounded value is three

696
00:53:50,910 --> 00:53:53,089
 okay, our last example two to the five a's

697
00:53:54,500 --> 00:53:56,190
 We have the same

698
00:53:56,190 --> 00:53:58,489
 Halfway marker again one zero zero

699
00:53:59,610 --> 00:54:05,479
 But in this case the the hundreds bit are the one fourth bit is

700
00:54:06,360 --> 00:54:11,660
 Zero so that's even so we can just truncate we just throw those bits away, and the result is simply

701
00:54:12,510 --> 00:54:14,510
 10.10

702
00:54:15,330 --> 00:54:17,330
 That makes sense

703
00:54:18,240 --> 00:54:20,240
 so it's very mechanical and

704
00:54:21,240 --> 00:54:24,620
 mainly you just need to be able to recognize that halfway Marker and

705
00:54:25,230 --> 00:54:30,770
 Then figure out if you need to round up or down if you're going to round down just truncate you're going to round up add

706
00:54:30,770 --> 00:54:32,770
 A one and just propagate it

707
00:54:33,330 --> 00:54:35,330
 to get your result

708
00:54:36,930 --> 00:54:38,930
 Okay

709
00:54:40,170 --> 00:54:44,569
 Now we won't spend much time. I just want to mention a few things about multiplication in addition

710
00:54:47,790 --> 00:54:54,410
 so if we if we multiply two numbers, so we have different mantises significance and exponents and

711
00:54:55,050 --> 00:54:57,050
 suppose that the result is

712
00:54:59,580 --> 00:55:01,580
 M times two to the E

713
00:55:02,070 --> 00:55:08,090
 The sign bit will be the xor of the two sign bits of the two operands

714
00:55:09,540 --> 00:55:11,570
 the significant M will be

715
00:55:12,420 --> 00:55:17,389
 the multiplying M1 times M2 and the exponents are added right because

716
00:55:18,390 --> 00:55:20,390
 They're just by the rules of exponents

717
00:55:21,870 --> 00:55:23,870
 so if m is

718
00:55:24,330 --> 00:55:28,039
 If m is greater than 2 and this is a normalized number we have to

719
00:55:28,470 --> 00:55:31,310
 We have to we have to shift it and we have to

720
00:55:31,590 --> 00:55:36,259
 Put it in the range between 1 and 2 by shifting to the right and incrementing the exponent

721
00:55:36,900 --> 00:55:39,650
 if he's out of range, then we overflow 2

722
00:55:40,320 --> 00:55:42,320
 to infinity

723
00:55:42,390 --> 00:55:43,500
 and

724
00:55:43,500 --> 00:55:51,260
 Then if if m has too many bits, we have to use round 2 even to fit it into the available of fragments

725
00:55:54,000 --> 00:55:59,360
 Okay, addition. So suppose. We're trying to add two floating point numbers

726
00:56:01,140 --> 00:56:07,279
 Conceptually what you do is think of think of those numbers as fractional binary numbers you want to line up the binary points?

727
00:56:08,640 --> 00:56:11,869
 line up the Binary points then do the addition and then

728
00:56:13,470 --> 00:56:16,490
 a and then do the addition and that if

729
00:56:17,220 --> 00:56:23,150
 and then normalize the number so that the normalized the significance of it's between 1 & 2

730
00:56:26,760 --> 00:56:28,620
 and

731
00:56:28,620 --> 00:56:36,140
 either do that by shifting shifting right or left if he's too big then you overflow and then you round the

732
00:56:36,900 --> 00:56:40,039
 the bits and m to fit into the available for x field

733
00:56:42,120 --> 00:56:49,849
 now remember when we the first day of class we we talked about we call these great realities that Intz aren't really integers and

734
00:56:50,280 --> 00:56:52,280
 Floats aren't really reals

735
00:56:52,800 --> 00:56:56,180
 So the and just as just as just as we saw when we looked at

736
00:56:57,360 --> 00:57:01,370
 Two's complement representation of integers, it's not exactly

737
00:57:01,950 --> 00:57:07,069
 They're not exact exactly like real integers and operations on them aren't exactly like real integers

738
00:57:07,170 --> 00:57:11,809
 But they follow very predictable mathematical properties, okay that are similar to

739
00:57:12,750 --> 00:57:17,120
 Integers, but not quite so the same thing holds for floating-point numbers

740
00:57:18,240 --> 00:57:20,240
 They follow very

741
00:57:21,210 --> 00:57:22,670
 predictable

742
00:57:22,670 --> 00:57:25,279
 they have very predictable mathematical properties, but there's

743
00:57:26,040 --> 00:57:31,670
 somewhat different from the reals and the the big thing is

744
00:57:33,030 --> 00:57:38,540
 Is that the big big thing with addition is that it doesn't associate?

745
00:57:39,300 --> 00:57:43,610
 ok it's it's commutative, but it's not associative and

746
00:57:44,880 --> 00:57:50,150
 This usually happens when you have who you're dealing with numbers that have very large

747
00:57:50,700 --> 00:57:56,539
 dynamic ranges so a big if you're trying to add and subtract really big numbers with

748
00:57:57,080 --> 00:58:01,580
 It really little numbers you run into this this problem with non associativity

749
00:58:02,550 --> 00:58:06,140
 So the the example was if we take three point one four

750
00:58:06,930 --> 00:58:09,109
 plus two to the tenth

751
00:58:10,080 --> 00:58:14,150
 Two to the tensest so there's so much larger than three point one four

752
00:58:14,850 --> 00:58:16,680
 that when we

753
00:58:16,680 --> 00:58:22,519
 The bits that would be two to the tenth plus three the point one four the the bits that represent the three point one four

754
00:58:23,220 --> 00:58:25,459
 You know there's bits way out here that represent

755
00:58:25,890 --> 00:58:29,839
 There's one bit out here that represents two to the tenth, and then there's a few bits here they represent

756
00:58:30,570 --> 00:58:33,350
 Three point one four and there's just not enough

757
00:58:33,990 --> 00:58:40,370
 We don't have enough bits to represent all those so we have the three point one. Four goes goes away, so adding a

758
00:58:40,920 --> 00:58:42,920
 big number to a little number

759
00:58:43,620 --> 00:58:48,559
 Essentially gives the big number and then if you said you subtract that big number you get zero

760
00:58:49,140 --> 00:58:50,520
 now if

761
00:58:50,520 --> 00:58:53,390
 We change the the associate of the association

762
00:58:54,090 --> 00:58:58,670
 if we take this big number and subtract it from itself we get zero and then

763
00:58:59,010 --> 00:59:02,719
 So the result will be instead of zeros before we get three point one four

764
00:59:06,060 --> 00:59:10,459
 So other than that you you have all of the things that you would normally expect

765
00:59:11,400 --> 00:59:16,160
 Closed under addition. It's commutative. There's a additive identity of zero

766
00:59:18,000 --> 00:59:23,930
 Except for infinities, and nan's there's there's an additive inverse that you can take for any number

767
00:59:23,930 --> 00:59:27,169
 There's there's an inverse that will give you zero when you add it together

768
00:59:27,840 --> 00:59:29,840
 And you get monotonicity?

769
00:59:32,220 --> 00:59:38,450
 monotonicity between between values except of course for infinities and ends now multiplication has

770
00:59:39,810 --> 00:59:46,640
 Some it's similar you get it's closed generally under multiplication. It's commutative, but

771
00:59:47,340 --> 00:59:50,479
 It's not associative, and it doesn't distribute over addition

772
00:59:52,410 --> 00:59:58,759
 And it's the same so here you can see we're taking two to xx x - 2 xx

773
01:00:00,180 --> 01:00:02,869
 x - 2 xx and that gives infinity

774
01:00:06,069 --> 01:00:10,439
 But if we if we reassociate, and we take I'm sorry

775
01:00:11,530 --> 01:00:15,089
 To to the 20 times 2 to the 20th times 2 to the minus 20th

776
01:00:15,609 --> 01:00:21,149
 well this first multiplication is infinity and anything anything you do with infinity is just

777
01:00:21,700 --> 01:00:23,700
 Infinity, so the result is infinity

778
01:00:24,700 --> 01:00:26,700
 however if We associate and

779
01:00:27,520 --> 01:00:30,389
 multiply to xx times 2 to the minus 20th

780
01:00:31,660 --> 01:00:33,750
 that gives us 1 and then x

781
01:00:34,900 --> 01:00:40,289
 2 to the 20th until we get 2 to the 20th, so the big Takeaway point here is that?

782
01:00:41,049 --> 01:00:42,490
 A

783
01:00:42,490 --> 01:00:44,170
 floating point

784
01:00:44,170 --> 01:00:46,829
 floating point is an associative ok

785
01:00:48,309 --> 01:00:51,089
 Now is that a problem

786
01:00:53,799 --> 01:00:58,169
 It's something you have to be aware of and but generally I mean I

787
01:00:59,559 --> 01:01:02,369
 I've done a lot of scientific computing in particular

788
01:01:02,890 --> 01:01:03,970
 modeling

789
01:01:03,970 --> 01:01:05,829
 earthquake ground motion in Southern California

790
01:01:05,829 --> 01:01:12,568
 so basically we would we would build models of Southern California in the computer, and then we would shake them and

791
01:01:13,180 --> 01:01:16,349
 Then we would see how the ground moves in like Los Angeles

792
01:01:16,990 --> 01:01:20,789
 and those that that's shaking we used a

793
01:01:21,609 --> 01:01:27,659
 Numerical method called finite Elements, and it was all used all floating points single precision floating point numbers

794
01:01:28,180 --> 01:01:34,950
 And we never ran into a problem this with this associativity right? We would do we would do operations in different orders

795
01:01:35,079 --> 01:01:41,068
 we couldn't always guarantee that we would do the operations in the exact same order, but we never ran into a problem with this because

796
01:01:42,069 --> 01:01:45,298
 nature and generally in General is kind of smooth right that

797
01:01:46,029 --> 01:01:47,980
 if you look at the

798
01:01:47,980 --> 01:01:50,490
 You know if one part of the ground is shaking like this

799
01:01:50,490 --> 01:01:54,449
 And you look at the next part it might be shaking a little more or a little less

800
01:01:54,450 --> 01:01:57,179
 But you're not going to have like huge differences

801
01:01:58,210 --> 01:02:00,659
 And so we never ran into those kind of problems

802
01:02:00,660 --> 01:02:06,119
 but in some so if generally if you if you're simulating natural phenomena

803
01:02:06,119 --> 01:02:11,399
 You don't often see these kind of huge dynamic ranges, but other times. You know if it's not

804
01:02:12,339 --> 01:02:16,528
 Non natural financial maybe financial systems they use floating point

805
01:02:17,079 --> 01:02:21,299
 Then you might see this larger dynamic the numbers, and it might might become a problem

806
01:02:21,820 --> 01:02:26,580
 So as a programmer you just generally have to be aware of this you have to have a good

807
01:02:26,890 --> 01:02:32,009
 sense for the dynamic range of your numbers, and you have to keep in mind that if you if you reassociate

808
01:02:32,010 --> 01:02:34,010
 Or change the order of things

809
01:02:34,030 --> 01:02:36,030
 You may not get exactly the same

810
01:02:36,610 --> 01:02:38,610
 Exactly the same answer

811
01:02:42,010 --> 01:02:45,210
 okay, so C gives us two different kinds of

812
01:02:46,690 --> 01:02:53,700
 Floating points, so they the float is the I triple e single precision and double is the I triple e double precision?

813
01:02:54,340 --> 01:02:57,930
 now you remember when we did casting between

814
01:02:59,260 --> 01:03:05,850
 Intz and unsigned values back and Forth the cast never changed the bit representation it just changed the way that in

815
01:03:06,040 --> 01:03:08,070
 fact it never even changed the

816
01:03:08,620 --> 01:03:10,240
 the

817
01:03:10,240 --> 01:03:12,299
 the what the how the Alu

818
01:03:13,030 --> 01:03:20,700
 Manipulated those bits. It's really just a how we're interpreting and how we're viewing those those values however when you do cast between

819
01:03:21,400 --> 01:03:22,840
 floats and

820
01:03:22,840 --> 01:03:27,630
 Intz and doubles the bit representation changes right so a cast here has a

821
01:03:28,000 --> 01:03:35,250
 Dramatic effect on the actual bits themselves now if we go from a double or a float

822
01:03:35,830 --> 01:03:37,540
 to an int

823
01:03:37,540 --> 01:03:42,960
 it's going to it's just going to it's going to truncate the fractional part and give us the

824
01:03:46,990 --> 01:03:52,769
 Give us the the integer part and then and then round to fit oh

825
01:03:54,910 --> 01:03:56,910
 Actually, no there won't be

826
01:03:58,240 --> 01:04:02,639
 Okay, so think about this how many there were she said 23

827
01:04:05,420 --> 01:04:09,159
 23 Frack bits and float and I

828
01:04:11,930 --> 01:04:18,909
 Forget exactly how many in doubles anybody remember it doesn't matter it's um it's some number

829
01:04:22,040 --> 01:04:24,040
 Well, no, it doesn't matter looks

830
01:04:24,320 --> 01:04:27,729
 so for a float if we if we cast a float to an int

831
01:04:28,400 --> 01:04:31,540
 We're casting 23 something that we can represent

832
01:04:32,330 --> 01:04:34,330
 with 23

833
01:04:34,790 --> 01:04:36,790
 at most 23 frack bits

834
01:04:37,760 --> 01:04:39,760
 into A

835
01:04:39,890 --> 01:04:44,830
 32 bit int so we won't we'll never lose so we won't we'll never need to do any rounding

836
01:04:50,550 --> 01:04:52,550
 but double-Precision

837
01:04:57,210 --> 01:04:59,210
 has 52 bits

838
01:04:59,580 --> 01:05:02,989
 okay, so they're there we may not be able to fit the the

839
01:05:03,720 --> 01:05:07,280
 represented integer into the into the end so they'll

840
01:05:09,120 --> 01:05:11,120
 They'll have to be some rounding

841
01:05:39,859 --> 01:05:41,859
 sorry Powerpoint crashed

842
01:06:15,540 --> 01:06:17,540
 Okay

843
01:06:18,540 --> 01:06:23,090
 Right now if we cast if we cast from an int to a double

844
01:06:25,860 --> 01:06:29,599
 There's will have will have enough debt so we won't lose anything, right?

845
01:06:31,170 --> 01:06:33,170
 the 32 bits

846
01:06:33,240 --> 01:06:36,469
 will fit in the double precision Frac field and

847
01:06:37,440 --> 01:06:39,090
 but int to float

848
01:06:39,090 --> 01:06:44,179
 Has there's more there's more bits than an int that then there are in the frac field will float

849
01:06:44,180 --> 01:06:49,610
 So we'll have to do some rounding right so the so casting works the same way as any other operation

850
01:06:49,770 --> 01:06:51,770
 you can think of it as just taking the

851
01:06:53,220 --> 01:06:58,490
 Assume you have an infinite number of bits get the exact result and then round it to fit into the available disk

852
01:07:00,510 --> 01:07:04,610
 All right, so let's the final thing. I want to do today is

853
01:07:07,080 --> 01:07:09,080
 sort of test your understanding

854
01:07:09,870 --> 01:07:13,339
 Do solve some puzzles to test test to understanding of these?

855
01:07:14,190 --> 01:07:16,190
 properties of floating-Point numbers

856
01:07:16,710 --> 01:07:21,740
 So imagine that we have three values acts as an int f is a float and d is a double

857
01:07:22,350 --> 01:07:28,249
 and then we're evaluating the CC expressions so x

858
01:07:29,910 --> 01:07:35,330
 Is x equal to int float x yeah?

859
01:07:41,680 --> 01:07:45,119
 How you can edit out the you can edit out that other stuff?

860
01:07:52,670 --> 01:07:54,670
 All right, so what do you think if we?

861
01:07:58,370 --> 01:08:00,370
 So if we take x which is an int

862
01:08:02,060 --> 01:08:04,060
 cast it to a float and

863
01:08:04,250 --> 01:08:07,540
 then cast that back to an int will that always be equal to x

864
01:08:08,630 --> 01:08:13,659
 No, make as we lose some bits right? We don't have enough breakfast in float

865
01:08:14,420 --> 01:08:18,700
 what about if we take x cast it to a double and

866
01:08:19,549 --> 01:08:21,999
 Then cast it back to ant well. We always get

867
01:08:23,359 --> 01:08:25,419
 equivalent value, yeah

868
01:08:26,839 --> 01:08:29,589
 Because we have enough practice and in double

869
01:08:30,830 --> 01:08:32,830
 Now what if we take a float f?

870
01:08:32,839 --> 01:08:37,599
 Cast it to a double and then cast it back to a float well that always equal the original f

871
01:08:38,839 --> 01:08:40,839
 Yeah

872
01:08:40,880 --> 01:08:47,470
 What about the converse though? What if we take the double d cast it to a float can cast it back to a double no?

873
01:08:49,970 --> 01:08:51,970
 How about this how about if we take f?

874
01:08:52,580 --> 01:08:55,990
 Negate it and then negate that again will that always equal f?

875
01:08:56,960 --> 01:08:59,260
 Yeah, because we're just toggling a bit right soon

876
01:09:01,640 --> 01:09:03,620
 Okay, how about?

877
01:09:03,620 --> 01:09:06,490
 Two over three equal two over three point. Oh

878
01:09:07,580 --> 01:09:10,180
 no, because 2 over 3 is 0

879
01:09:11,270 --> 01:09:12,589
 and 2

880
01:09:12,589 --> 01:09:15,609
 Over 3.0 is a is a floating point value

881
01:09:17,089 --> 01:09:24,278
 2/3 the floating point representation of 2/3 okay. How about if if the double d is less than 0?

882
01:09:27,080 --> 01:09:31,149
 Does that imply that d times 2 is also less than 0?

883
01:09:32,180 --> 01:09:33,680
 Yeah

884
01:09:33,680 --> 01:09:38,740
 even if no matter what even if even if 2 times d overflows it will overflow to

885
01:09:39,980 --> 01:09:41,980
 negative infinity which is less than

886
01:09:45,140 --> 01:09:47,000
 Which is less than 0?

887
01:09:47,000 --> 01:09:53,740
 Okay, how about does the double d greater than f imply that minus f is greater than minus D?

888
01:09:54,980 --> 01:09:58,450
 Yeah, that's that monotonicity right and again. It's just yes

889
01:09:59,889 --> 01:10:03,129
 - with people euros and float that both are double

890
01:10:07,190 --> 01:10:09,320
 Oh, that's a good question. I think it'd be explode I

891
01:10:10,980 --> 01:10:18,709
 Think if we if you put there's an annotation in situ to give it a double, but actually I'd have to check that out. That's

892
01:10:20,550 --> 01:10:22,669
 Enough yeah, that's a good question. I don't know

893
01:10:24,000 --> 01:10:28,550
 We'd have to check off to go and look in the in the see guide

894
01:10:34,830 --> 01:10:39,860
 How about it is D squared the double D squared always greater than or equal to zero?

895
01:10:42,330 --> 01:10:44,250
 Yes

896
01:10:44,250 --> 01:10:51,290
 And how about the D plus f minus d always equal f now because of lack of associativity?

897
01:10:54,540 --> 01:10:55,710
 Okay

898
01:10:55,710 --> 01:11:00,169
 So that was that was that was fun right the floating points always fun

899
01:11:01,140 --> 01:11:04,399
 So anyway that the big thing is just to realize that

900
01:11:05,010 --> 01:11:08,179
 floats aren't exactly really reals, but they have very

901
01:11:08,700 --> 01:11:10,700
 predictable property and

902
01:11:10,800 --> 01:11:12,150
 that

903
01:11:12,150 --> 01:11:15,800
 They're not associative or commutative. They're not associative and

904
01:11:16,710 --> 01:11:18,710
 So you have to be careful about that?

905
01:11:18,870 --> 01:11:22,039
 All right, we'll have a good weekend. We'll see you on Tuesday

