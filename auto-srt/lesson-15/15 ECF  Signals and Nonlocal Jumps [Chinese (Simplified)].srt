1
00:00:00,003 --> 00:00:05,522
还有，大家下午好欢迎 

2
00:00:01,909 --> 00:00:07,620
很高兴见到你今天 我们要 

3
00:00:05,549 --> 00:00:10,583
继续我们的卓越研究 

4
00:00:07,062 --> 00:00:13,065
通过看一些上级控制流程

5
00:00:10,889 --> 00:00:17,912
称为 Linux信号 电平的机制 

6
00:00:13,092 --> 00:00:19,101
看看非本地的跳跃，现在我们要去 

7
00:00:18,119 --> 00:00:22,160
花大部分的我们这个时代最 

8
00:00:20,001 --> 00:00:25,068
看着 信号，因为他们 有一个 

9
00:00:22,529 --> 00:00:26,970
很多微妙的语义 可以 

10
00:00:25,068 --> 00:00:27,096
那种混乱，所以我们打算 

11
00:00:26,097 --> 00:00:31,098
我们将 花更多的时间 

12
00:00:27,096 --> 00:00:36,125
那里，我会提到的想法 

13
00:00:31,098 --> 00:00:37,185
非本地的跳跃，但对那些细节 

14
00:00:36,989 --> 00:00:41,190
你想在你的教科书的外观 和 

15
00:00:38,085 --> 00:00:45,111
在补充幻灯片幻灯片

16
00:00:41,019 --> 00:00:49,023
在此滑动台的现在到端 

17
00:00:46,011 --> 00:00:53,085
激励我要的信号概念

18
00:00:49,059 --> 00:00:56,618
想谈谈 外壳 一点点 

19
00:00:53,085 --> 00:00:58,564
现在的方案，因为我们上次 提到 的 

20
00:00:57,149 --> 00:01:01,920
只有一种创建方式 

21
00:00:59,329 --> 00:01:06,383
在Linux系统上的预言，这就是 

22
00:01:01,092 --> 00:01:07,158
使用用于实际上所有 的 呼叫 

23
00:01:06,869 --> 00:01:11,310
系统上的过程实际 

24
00:01:08,058 --> 00:01:12,111
形成了一个等级 ， 使得 第一个 

25
00:01:11,031 --> 00:01:16,160
当流程引导 系统创建

26
00:01:13,011 --> 00:01:19,017
向上是 ANIT方法，该方法具有 

27
00:01:16,439 --> 00:01:21,000
一个，然后将所有的的进程ID 

28
00:01:19,017 --> 00:01:23,078
该系统上的进程是后代 

29
00:01:21,000 --> 00:01:27,063
那是init进程的 

30
00:01:23,078 --> 00:01:29,157
现在它开始时的过程ANIT

31
00:01:27,063 --> 00:01:31,122
多达它创建魔所为 

32
00:01:30,057 --> 00:01:35,109
长时间运行的程序，提供 

33
00:01:32,022 --> 00:01:39,045
通常这样例如Web服务

34
00:01:36,009 --> 00:01:41,028
服务器和其他类型的服务， 这些 服务 

35
00:01:39,045 --> 00:01:44,070
你总是希望在系统上运行 

36
00:01:41,028 --> 00:01:46,104
然后最终它创建登录，这样 

37
00:01:44,007 --> 00:01:48,746
所谓的记录炮弹其提供 

38
00:01:47,004 --> 00:01:53,022
命令行界面给用户，以便 

39
00:01:49,439 --> 00:01:55,460
当您登录到Linux系统是什么 

40
00:01:53,022 --> 00:02:00,071
你最终得到一个登录shell 

41
00:01:55,649 --> 00:02:00,710
该公司预计，您可以键入命令

42
00:02:00,073 --> 00:02:09,095
现在登录登录货架 执行 

43
00:02:05,063 --> 00:02:12,125
代表你对你的程序，所以当我们 

44
00:02:09,095 --> 00:02:14,171
输入一些东西到外壳说，我们 

45
00:02:13,025 --> 00:02:17,081
输入ls命令我们要求 我们 

46
00:02:15,071 --> 00:02:22,169
问外壳运行可执行文件 

47
00:02:17,081 --> 00:02:24,176
程序调用LS还等什么壳 

48
00:02:23,069 --> 00:02:28,091
需要做的是它会创建一个孩子， 

49
00:02:25,076 --> 00:02:32,092
然后它会执行内 的 LS 

50
00:02:28,091 --> 00:02:34,190
孩子的过程，它可能是

51
00:02:32,092 --> 00:02:40,097
这个过程可能会产生其他其他 

52
00:02:35,009 --> 00:02:42,038
子流程，使一个shell就是一个 

53
00:02:41,042 --> 00:02:45,137
应用程序没有什么不同 

54
00:02:43,019 --> 00:02:49,106
任何其他程序 ，执行程序 

55
00:02:46,037 --> 00:02:51,128
对用户的名义行不行的 

56
00:02:50,006 --> 00:02:54,073
为Linux默认的shell被称为bash的 

57
00:02:52,028 --> 00:02:59,707
但有一个还有 其他炮弹 

58
00:02:54,073 --> 00:03:01,090
已创建与前面做

59
00:02:59,959 --> 00:03:04,910
早期版本的Unix 

60
00:03:01,009 --> 00:03:05,057
SH是原壳名为 

61
00:03:04,091 --> 00:03:07,187
Bourne shell的，因为它是由创建 

62
00:03:06,038 --> 00:03:10,109
史蒂芬出生在伯克利出来 

63
00:03:08,087 --> 00:03:15,181
与他们的UNIX，他们的分布

64
00:03:11,009 --> 00:03:20,128
创建了一个名为CSH现在壳 

65
00:03:16,081 --> 00:03:22,163
执行在一个壳的序列 

66
00:03:20,209 --> 00:03:26,390
读取和评估步骤，使第一壳 

67
00:03:23,063 --> 00:03:28,094
打印出一个提示，然后它等待 

68
00:03:26,039 --> 00:03:30,065
它等待你输入一些东西 

69
00:03:28,094 --> 00:03:32,147
在命令行和回车上

70
00:03:30,065 --> 00:03:37,067
没关系，通常 你是 什么 什么 

71
00:03:33,047 --> 00:03:39,104
你键入是一个命令， 

72
00:03:37,067 --> 00:03:40,160
只是这样你输入的第一件事 

73
00:03:40,004 --> 00:03:43,453
是一个命令，然后您按照

74
00:03:41,006 --> 00:03:47,012
与 由分离 的可选参数 

75
00:03:43,489 --> 00:03:49,489
空间好了，一旦你打你一次 

76
00:03:47,066 --> 00:03:52,675
键入一个命令和那些任选

77
00:03:49,489 --> 00:03:56,780
参数并回车 壳 

78
00:03:53,269 --> 00:04:00,860
检查文件字符的结束

79
00:03:56,078 --> 00:04:03,097
这是一种控制D钮 终端，并且如果 

80
00:04:00,086 --> 00:04:08,095
所以它退出，否则它是评估 

81
00:04:03,799 --> 00:04:08,950
命令行和评估包括 

82
00:04:09,028 --> 00:04:13,052
然后当它从返回

83
00:04:11,051 --> 00:04:13,112
评价它只是做同样的 事情 

84
00:04:13,052 --> 00:04:18,095
在它 

85
00:04:14,012 --> 00:04:23,012
现在评估包括的

86
00:04:18,095 --> 00:04:28,127
第一下列各种步骤它解析 

87
00:04:23,012 --> 00:04:30,089
在命令行，并通过和，并在

88
00:04:29,027 --> 00:04:33,029
过程因此需要在命令行

89
00:04:30,089 --> 00:04:35,144
在该示例中是在浅黄色和它 

90
00:04:33,029 --> 00:04:39,056
产生一个RV阵列没关系其中 弧V-0 

91
00:04:36,044 --> 00:04:43,052
是一个命令然后RV一个和两个与 

92
00:04:39,056 --> 00:04:45,131
等都是可选的参数和 

93
00:04:44,024 --> 00:04:49,079
公约中的外壳是 ，如果 

94
00:04:46,031 --> 00:04:51,035
命令行是通过一个终止 

95
00:04:49,079 --> 00:04:53,132
符号然后你 问壳 

96
00:04:51,071 --> 00:04:56,072
运行该作业在运行该命令 

97
00:04:54,032 --> 00:04:58,040
背景意味着外壳不会 

98
00:04:56,081 --> 00:05:01,085
等待工作之前它完成

99
00:04:59,012 --> 00:05:04,085
经过它的下一个读一步，如果你

100
00:05:02,021 --> 00:05:06,023
如果您键入的行 不 

101
00:05:04,085 --> 00:05:07,088
有一个连字符，然后你问 

102
00:05:06,041 --> 00:05:09,107
壳牌运行 在 该 作业 

103
00:05:08,015 --> 00:05:17,018
前景，这意味着罩体的意志

104
00:05:10,007 --> 00:05:19,606
等了这么所以首先我们分析这个 这个 

105
00:05:17,018 --> 00:05:21,077
命令行为艺术 V阵列和我们 

106
00:05:19,669 --> 00:05:25,360
返回它是否被终止 

107
00:05:21,077 --> 00:05:28,094
通过一个与符号乙所以 B GG背景 

108
00:05:25,036 --> 00:05:30,101
如果本领域V零是 空值，则这意味着我们 

109
00:05:28,094 --> 00:05:33,107
刚打我们只是打回右 从而 

110
00:05:31,001 --> 00:05:38,090
一个空行，所以我们只返回和 

111
00:05:34,007 --> 00:05:40,106
不理会那些现在还壳 

112
00:05:38,009 --> 00:05:45,010
实现了所谓的内置 

113
00:05:41,006 --> 00:05:49,058
命令使各种事物一样工作BG 

114
00:05:45,091 --> 00:05:50,138
FG是内置命令的例子 

115
00:05:49,058 --> 00:05:54,065
这是在刚刚壳实现 

116
00:05:51,038 --> 00:05:57,041
本身，所以如果你在输入时的第一件事

117
00:05:54,065 --> 00:06:00,164
您键入如果 您输入 的 命令 是 

118
00:05:57,068 --> 00:06:03,101
内置那么shell将它 

119
00:06:01,064 --> 00:06:06,086
检查 将 检查 精氨酸 为 0 

120
00:06:04,001 --> 00:06:09,077
看它是否是一个内置的命令，并且 

121
00:06:06,086 --> 00:06:13,091
这是它只会 执行它什么 

122
00:06:09,077 --> 00:06:15,125
无论是你要求它做的 好 

123
00:06:13,091 --> 00:06:17,153
否则，如果它不是一个内置的再 

124
00:06:16,025 --> 00:06:21,042
这意味着，你问了

125
00:06:18,053 --> 00:06:23,062
外壳运行一些程序好吗 

126
00:06:21,042 --> 00:06:27,079
所以在这种情况下，外壳将叉一个 

127
00:06:24,043 --> 00:06:32,131
孩子，那么孩子的将执行

128
00:06:27,079 --> 00:06:34,090
该程序 通过 调用 准确 传递已经 

129
00:06:33,031 --> 00:06:37,063
是第一个参数的名称 

130
00:06:34,009 --> 00:06:39,033
命令和作为第二和第三 

131
00:06:37,063 --> 00:06:40,132
参数是V和环境 

132
00:06:40,014 --> 00:06:43,108
分别 

133
00:06:41,032 --> 00:06:46,033
现在确切的e。如果从去年召回 

134
00:06:44,008 --> 00:06:48,094
时间永远不会返回，除非有一个 

135
00:06:46,042 --> 00:06:52,111
错误，因此会检查 ，所以我们检查了 

136
00:06:48,094 --> 00:06:53,101
对于x XE e 和如果 返回值 

137
00:06:53,011 --> 00:06:56,080
返回小于 零 

138
00:06:54,064 --> 00:06:59,136
事实上唯一的一次将 返回如果 

139
00:06:56,008 --> 00:07:02,065
它返回它总是返回 

140
00:07:00,036 --> 00:07:07,110
减人，但我们只是要小心 

141
00:07:03,037 --> 00:07:10,123
在这里，所以我们检查 了一个错误， 

142
00:07:08,001 --> 00:07:19,023
在印刷 和 错误信息，如果我们找到一个 

143
00:07:11,023 --> 00:07:22,081
错误，然后退出 所以一旦一次 

144
00:07:19,032 --> 00:07:24,061
一旦父母再次得到控制权，然后 

145
00:07:22,081 --> 00:07:26,137
它等待前台作业 

146
00:07:24,061 --> 00:07:29,113
终止没关系，所以如果它不是一个 

147
00:07:27,037 --> 00:07:34,069
后台作业然后等待其 

148
00:07:30,013 --> 00:07:36,052
通过调用湖底和等待终止

149
00:07:34,069 --> 00:07:38,130
对于孩子说前台作业 

150
00:07:36,052 --> 00:07:41,065
终止，然后和它收获

151
00:07:39,003 --> 00:07:44,056
否则，如果它是一个后台 作业它 

152
00:07:41,065 --> 00:07:45,130
只是打印 AA消息并继续如此 

153
00:07:44,083 --> 00:07:46,174
这真的很 有趣正确的 

154
00:07:46,003 --> 00:07:48,091
没什么，唯一的区别 

155
00:07:47,074 --> 00:07:50,082
前台工作和之间 

156
00:07:49,018 --> 00:07:53,104
后台作业 仅仅是外壳 

157
00:07:50,082 --> 00:07:54,141
并等待它的是工作或不对 的 

158
00:07:54,004 --> 00:08:00,097
所以否则真的 

159
00:07:55,041 --> 00:08:01,126
真的没有区别 ，现在什么 

160
00:08:00,097 --> 00:08:05,194
的概率有一个问题我们 

161
00:08:02,026 --> 00:08:08,065
例如壳 ，而这个问题是 

162
00:08:06,094 --> 00:08:10,102
我们正在我们正在做正确的事 

163
00:08:08,065 --> 00:08:14,140
对于前台 工作，我们总是要 

164
00:08:11,002 --> 00:08:19,093
获得这些孩子，让他们使 

165
00:08:15,004 --> 00:08:21,085
那里是他们的状态能够被释放，但 

166
00:08:19,093 --> 00:08:23,146
我们不是，我们没有做任何事情

167
00:08:22,021 --> 00:08:27,037
获得任何后台工作 的权利，如果当 

168
00:08:24,046 --> 00:08:28,048
后台工作，所以如果不是 BG我们 

169
00:08:27,037 --> 00:08:30,121
只是打印一条 消息， 然后我们 

170
00:08:28,066 --> 00:08:33,164
返回，然后我们在继续 

171
00:08:31,021 --> 00:08:36,104
这个阅读评估步骤，并且从来就不曾 

172
00:08:34,064 --> 00:08:40,082
回去和和采取的是照顾

173
00:08:37,004 --> 00:08:42,095
这样的 背景下工作 的 ，所以这 是一个 

174
00:08:40,082 --> 00:08:45,167
问题的原因 是 后台作业会 

175
00:08:42,095 --> 00:08:47,159
最终成为，如果我们有足够的 

176
00:08:46,067 --> 00:08:49,136
这些工作我们创建了一个内存泄漏 

177
00:08:48,059 --> 00:08:52,103
可能导致系统崩溃的权利 ，所以 这 是 

178
00:08:50,036 --> 00:08:54,131
错误那么，我们该怎么办 

179
00:08:53,003 --> 00:08:57,101
关于这口井事实证明 ， 

180
00:08:55,031 --> 00:09:02,084
异常控制流将帮助我们 

181
00:08:58,001 --> 00:09:05,057
解决这个问题 ， 什么情况是 

182
00:09:02,084 --> 00:09:06,167
内核将通知 壳 

183
00:09:05,057 --> 00:09:11,096
当，当其所有子 

184
00:09:07,067 --> 00:09:13,139
终止 还好然后壳 可 

185
00:09:11,096 --> 00:09:16,115
然后可以反应到并发出等待 

186
00:09:14,039 --> 00:09:19,097
坑没关系 ，这通知 

187
00:09:17,015 --> 00:09:26,021
该内核使用机制 

188
00:09:19,097 --> 00:09:30,154
一种叫做的信号，因此信号 

189
00:09:26,075 --> 00:09:34,076
一个小消息 ，内核提供 

190
00:09:31,054 --> 00:09:38,078
到进程通知它有

191
00:09:34,085 --> 00:09:40,157
有了一些事件在系统中现在这样 

192
00:09:38,078 --> 00:09:43,154
这是非常相似的例外 

193
00:09:41,057 --> 00:09:46,085
我们研究的最后一次正确的 

194
00:09:44,054 --> 00:09:51,110
除了它的它在所有实施 

195
00:09:46,085 --> 00:09:52,151
现在的软件内核信号总是

196
00:09:52,001 --> 00:09:55,067
从内核发送，但有时

197
00:09:53,051 --> 00:09:58,067
他们在别人 的请求而发送

198
00:09:55,076 --> 00:09:59,158
过程有时候也是对的内核 

199
00:09:58,067 --> 00:10:03,146
会发现，有一些事件 

200
00:10:00,058 --> 00:10:05,141
其他时间另一个进程会问 

201
00:10:04,046 --> 00:10:10,052
内核将消息发送给其他一些 

202
00:10:06,041 --> 00:10:12,128
现在的过程，我们说这是一个 

203
00:10:10,052 --> 00:10:14,123
小消息， 因为只有 

204
00:10:13,028 --> 00:10:19,094
即包含在一信号信息

205
00:10:15,023 --> 00:10:22,037
是它是一个独特的整数ID 和 

206
00:10:19,094 --> 00:10:24,098
事实上， 这是它是交付 

207
00:10:22,037 --> 00:10:27,038
好了 ，所以这是如此没有什么 别的 

208
00:10:25,034 --> 00:10:30,098
在一个信号，除了不同之处在于它 

209
00:10:27,038 --> 00:10:36,071
赶到， 它 具有一定的某些部分 

210
00:10:30,098 --> 00:10:38,102
唯一ID现在的这些实施例的 

211
00:10:36,071 --> 00:10:42,118
SIG诠释这样的信号有这种类似这样的

212
00:10:39,038 --> 00:10:42,046
唯一的ID，然后他们也有一个名字 

213
00:10:43,008 --> 00:10:50,547
所以持反对意见的CIG是什么，当你 

214
00:10:48,459 --> 00:10:55,420
在命令行上输入CTRLÇ 

215
00:10:51,339 --> 00:10:57,345
上校再次向我们 所有的任何 

216
00:10:55,042 --> 00:10:59,211
在前景和过程

217
00:10:57,399 --> 00:11:01,540
接收 信号情报 的默认动作是 

218
00:10:59,589 --> 00:11:02,676
终止权 ，所以这是 你 如何 是 

219
00:11:01,054 --> 00:11:05,101
运行 你打控制 一个前台作业 

220
00:11:03,459 --> 00:11:11,470
c您得到及时回来，因为它 

221
00:11:06,001 --> 00:11:15,082
杀死作业SIG杀 九位 数字 可以 

222
00:11:11,047 --> 00:11:18,036
被用来杀死终止任何程序 ，所以 

223
00:11:15,082 --> 00:11:20,170
这两个有SIG蚂蚁和SIG有杀 

224
00:11:18,459 --> 00:11:26,160
在节目我说同样的效果

225
00:11:21,007 --> 00:11:27,094
他们杀了该程序的独特 

226
00:11:26,016 --> 00:11:30,085
SIG杀的方面是，有没有

227
00:11:28,057 --> 00:11:33,088
办法忽略或覆盖它好了， 

228
00:11:30,085 --> 00:11:35,170
这就像故障保护 ，我们会看到 

229
00:11:33,088 --> 00:11:39,163
有没有办法 赶上和 

230
00:11:36,007 --> 00:11:42,516
忽略其它信号等信号情报之字形 

231
00:11:40,063 --> 00:11:44,137
v是我们 最喜欢 的 缘故故障 

232
00:11:43,209 --> 00:11:47,890
段违规所以如果你，如果你 

233
00:11:45,037 --> 00:11:52,081
访问的内存，这是一个区域 

234
00:11:47,089 --> 00:11:54,124
保护或是否合法，然后你 

235
00:11:52,081 --> 00:11:59,113
程序会上校将发送您的 

236
00:11:55,024 --> 00:12:04,060
SIG的鸡蛋V还好 信号的这一过程

237
00:12:00,013 --> 00:12:07,048
和默认的 缺省 有效 的 

238
00:12:04,006 --> 00:12:08,083
这是终止程序 的签名 

239
00:12:07,048 --> 00:12:10,117
报警是你的 程序 中的方式 ，你 

240
00:12:09,037 --> 00:12:14,496
可以安排一个信号被 发送 到 

241
00:12:11,017 --> 00:12:17,436
自己，这样你可以说你里面 

242
00:12:14,829 --> 00:12:21,610
程序给我一个 SIG报警信号 

243
00:12:17,589 --> 00:12:23,290
3秒 类似 的东西 ，所以 

244
00:12:21,061 --> 00:12:25,087
这 是一种方式 做这样的事情，你可以 

245
00:12:23,029 --> 00:12:28,051
设置定时器可以设置超时 

246
00:12:25,087 --> 00:12:29,092
就像如果你想退出，如果你 想 

247
00:12:28,051 --> 00:12:33,064
设置超时值和你正在做的

248
00:12:29,092 --> 00:12:34,138
一些一些一些工作，你想 

249
00:12:33,064 --> 00:12:36,070
针对这项工作回吐后卫

250
00:12:35,038 --> 00:12:39,057
你特别长的时间，你可以可以

251
00:12:37,024 --> 00:12:41,092
您可以使用 签名的报警设置超时 

252
00:12:39,399 --> 00:12:43,404
然后很重要的一条是 

253
00:12:41,092 --> 00:12:46,121
我们将看到，这将 是 非常重要的 

254
00:12:43,899 --> 00:12:49,980
我们的 shell是 SIG孩子信号 

255
00:12:46,949 --> 00:12:51,970
其中上校发送到父 

256
00:12:49,098 --> 00:12:54,098
每它的一个子时间

257
00:12:51,097 --> 00:12:56,162
终止或停止 

258
00:12:54,098 --> 00:12:58,151
好了，所以这就是我们现在会看到它 会 

259
00:12:57,062 --> 00:13:00,125
适合，我们会看到这 是我们要如何 

260
00:12:59,051 --> 00:13:03,089
这 是 我们的外壳， 如何去 

261
00:13:01,025 --> 00:13:06,080
实际上收割 这是其所有 

262
00:13:03,089 --> 00:13:09,170
儿童右它是通过利用 

263
00:13:06,008 --> 00:13:12,077
在CIG 孩子信号 ， 但之前，我可以 

264
00:13:10,007 --> 00:13:19,046
告诉你 ，我们 需要经过一个 

265
00:13:13,049 --> 00:13:23,111
概念数周围信号好吗 

266
00:13:20,009 --> 00:13:26,015
就像我说 的信号 的 语义 

267
00:13:24,011 --> 00:13:31,016
它可能是 最棘手的 一个 

268
00:13:26,015 --> 00:13:33,053
Linux的方面是它被开发 

269
00:13:31,016 --> 00:13:39,077
在 Linux 中的寿命很早就 

270
00:13:33,053 --> 00:13:41,105
当它也许不 干净，因为 它 

271
00:13:39,077 --> 00:13:42,158
可能是对的所以为了 得到 

272
00:13:42,005 --> 00:13:45,101
处理上我们会非常的信号 

273
00:13:43,058 --> 00:13:48,127
小心 定义术语 ，非常 

274
00:13:46,001 --> 00:13:53,003
小心我们谈论他们的方式

275
00:13:49,027 --> 00:13:56,033
所以我们说 ， 内核发送或 

276
00:13:53,021 --> 00:14:01,028
的信号传送到一些目的地

277
00:13:56,033 --> 00:14:04,034
的过程，它通过设置一些做这个 

278
00:14:01,091 --> 00:14:09,119
状态在目的地的上下文 

279
00:14:04,043 --> 00:14:12,080
流程现在什么也没有发生，除了 

280
00:14:10,019 --> 00:14:15,032
一些位都在改变 目的地 

281
00:14:12,008 --> 00:14:17,072
进程上下文还好有没有有 

282
00:14:15,032 --> 00:14:24,106
没有发送立杆见影的影响 

283
00:14:18,044 --> 00:14:27,101
一个信号，现在一个内核发送信号

284
00:14:25,006 --> 00:14:31,013
可能是因为它检测到某些事件 

285
00:14:28,001 --> 00:14:34,067
该系统像 像个孩子 

286
00:14:31,013 --> 00:14:37,016
过程终止例如或 

287
00:14:34,067 --> 00:14:40,067
另一个进程，已要求内核 

288
00:14:37,016 --> 00:14:43,109
要发送到的信号传递过程

289
00:14:40,067 --> 00:14:45,089
代表其 并有多项 

290
00:14:44,009 --> 00:14:49,031
如何 做到 这一点 他们 中的 一个 是与 

291
00:14:45,089 --> 00:14:51,158
杀死 系统调用它的种类的 

292
00:14:49,031 --> 00:14:54,038
不幸的比赛是我 的 意思 是 

293
00:14:52,058 --> 00:14:58,130
所以杀是发送信号的一般方法

294
00:14:55,001 --> 00:15:01,040
而影响不是它 

295
00:14:59,003 --> 00:15:03,026
有时不杀程序权 

296
00:15:01,004 --> 00:15:05,080
但出于某种原因，他们选择了到 

297
00:15:03,053 --> 00:15:05,116
把它杀

298
00:15:06,078 --> 00:15:14,103
现在目的地进程接收到一个

299
00:15:11,014 --> 00:15:18,091
当它的内核被迫信号

300
00:15:15,003 --> 00:15:22,054
以某种方式行动以某种方式作出反应

301
00:15:18,091 --> 00:15:23,125
该信号的 传送 好了，所以这些 

302
00:15:22,054 --> 00:15:26,136
是两个完全不同的东西发送 

303
00:15:24,025 --> 00:15:30,031
信号中的情况下 设置 状态 

304
00:15:27,036 --> 00:15:34,042
目的地处理接收信号 

305
00:15:30,085 --> 00:15:37,093
是发生在当目标是什么

306
00:15:34,042 --> 00:15:40,086
过程终于迫使内核

307
00:15:37,093 --> 00:15:43,141
以某种方式行事以某种方式作出反应

308
00:15:40,086 --> 00:15:48,094
现在一些可能的 方式 做出反应是 

309
00:15:44,041 --> 00:15:54,070
只是忽略信号好吗 终止 

310
00:15:49,066 --> 00:15:56,155
本方法或用捕捉信号

311
00:15:54,007 --> 00:15:59,011
执行用户级功能称为 

312
00:15:57,055 --> 00:16:01,141
信号处理程序 ，以便在这种情况下，当我们 

313
00:15:59,074 --> 00:16:05,149
当 我们捉的信号 是非常相似 

314
00:16:02,041 --> 00:16:08,046
到 的，并且执行信号处理 

315
00:16:06,049 --> 00:16:11,122
这是非常相似执行的 

316
00:16:08,091 --> 00:16:13,135
在回应一些异常处理程序

317
00:16:12,022 --> 00:16:16,063
样的系统事件的现 

318
00:16:14,035 --> 00:16:18,094
不同的是 ，异常处理程序 

319
00:16:16,063 --> 00:16:20,109
在内核信号处理程序

320
00:16:18,094 --> 00:16:25,095
实际上只是在你的C代码 还好吧 

321
00:16:21,009 --> 00:16:31,054
他们在你在你的进程中执行

322
00:16:25,095 --> 00:16:32,179
所以这样的方法 来思考 ，如果如果 

323
00:16:31,054 --> 00:16:36,088
我们通过执行信号搭上信号

324
00:16:33,079 --> 00:16:39,103
处理程序，我们有我们的流程执行 

325
00:16:36,088 --> 00:16:42,154
指令，然后该信号是 

326
00:16:40,003 --> 00:16:47,020
通过 这个 过程 获得 如此内核 

327
00:16:43,054 --> 00:16:49,117
控制传递到信号处理程序 ，其 

328
00:16:47,002 --> 00:16:51,067
也只有 在 这 代码 

329
00:16:50,017 --> 00:16:56,026
在目前的进程是执行

330
00:16:51,085 --> 00:16:57,091
只是在我们在我们的C代码功能 

331
00:16:56,026 --> 00:17:00,079
信号处理程序运行，当它返回 

332
00:16:57,091 --> 00:17:02,176
它最终返回到 下一个 

333
00:17:00,079 --> 00:17:05,167
指令，然后 ，我们将继续 

334
00:17:03,076 --> 00:17:07,102
好了，这就像 有点像 一个 

335
00:17:06,067 --> 00:17:11,104
中断的权利，我们只是暂时 

336
00:17:08,002 --> 00:17:14,065
暂停我们在做什么我们 

337
00:17:12,004 --> 00:17:17,097
代码之前 执行 该此处理程序 

338
00:17:14,065 --> 00:17:17,097
只是在继续 

339
00:17:18,011 --> 00:17:25,070
现在没事了，我们说的信号挂起 

340
00:17:21,014 --> 00:17:30,111
如果它已经被 上校，但不 发送 

341
00:17:25,169 --> 00:17:32,880
你已经收到 ， 所以 如果在任何给定 

342
00:17:31,011 --> 00:17:34,700
在时间点 只能是一个 

343
00:17:32,088 --> 00:17:37,247
任何特定类型的挂起信号

344
00:17:34,799 --> 00:17:40,811
好了，所以这 具有非常重要的 

345
00:17:38,039 --> 00:17:43,530
使用的信号，因为后果

346
00:17:40,919 --> 00:17:45,750
你不能在任何提示信号右上 

347
00:17:43,053 --> 00:17:47,812
在时间点有只能有 

348
00:17:45,075 --> 00:17:51,734
例如一个未决SIG子 信号 

349
00:17:48,289 --> 00:17:55,230
或 六对信号 ，并且如果 

350
00:17:52,409 --> 00:17:58,740
随后SIG孩子说信号发送 

351
00:17:55,023 --> 00:18:00,045
它只是在写得很好，你能想到的 

352
00:17:58,074 --> 00:18:01,173
它的，因为它没有任何影响 

353
00:18:00,045 --> 00:18:04,004
它只是丢弃的权利，如果有 

354
00:18:02,073 --> 00:18:05,076
已经挂起的信号，使他们不

355
00:18:04,409 --> 00:18:10,484
他们不以任何有意义的排队

356
00:18:06,003 --> 00:18:13,892
现在这样我们的工艺可以阻止 

357
00:18:11,159 --> 00:18:16,100
收到一定的信号现在没事了它 

358
00:18:13,919 --> 00:18:19,890
不能停止投放信号

359
00:18:16,001 --> 00:18:22,190
但它可以阻止它可以停止 进程 

360
00:18:19,089 --> 00:18:25,148
从具有向这些 到该反应

361
00:18:22,289 --> 00:18:26,480
当它接收到的 信号 好 

362
00:18:26,087 --> 00:18:32,099
所以块信号可以被递送但 

363
00:18:30,069 --> 00:18:35,072
他们将无法接收到的信号 

364
00:18:32,099 --> 00:18:35,099
畅通

365
00:18:38,036 --> 00:18:47,084
和待处理的信号在接收最 

366
00:18:40,085 --> 00:18:50,254
一旦现在上校跟踪的 

367
00:18:47,084 --> 00:18:53,173
未决且在比特阻塞信号

368
00:18:51,019 --> 00:18:57,082
将调用挂起的载体和 

369
00:18:53,929 --> 00:18:59,870
阻塞和未决代表所述一组 

370
00:18:57,649 --> 00:19:01,738
挂起信号右其中每个位 

371
00:18:59,087 --> 00:19:04,133
挂起的比特向量对应于 

372
00:19:02,539 --> 00:19:06,612
一些特定的信号好，所以这是 

373
00:19:05,033 --> 00:19:10,049
为什么他们不能正确的，因为线索 

374
00:19:07,269 --> 00:19:12,230
只有一个对任何信号 凯位

375
00:19:10,049 --> 00:19:14,488
只有一个在位 向量 位 

376
00:19:12,023 --> 00:19:16,034
如果我们，当我们提供一个信号

377
00:19:14,929 --> 00:19:18,710
我们只是设置，我们将设置该 位 

378
00:19:16,034 --> 00:19:20,087
上校将设置位我们提供 

379
00:19:18,071 --> 00:19:22,076
同类型的另一个信号， 它会 

380
00:19:20,087 --> 00:19:24,184
只需设置该位 再次它没有 作为 

381
00:19:22,076 --> 00:19:29,120
没有效果 

382
00:19:25,084 --> 00:19:31,100
现在上校设置该位 

383
00:19:30,002 --> 00:19:33,981
未决 当 信号传递和 

384
00:19:32,000 --> 00:19:38,045
它清除它接收到的信号时 

385
00:19:34,179 --> 00:19:41,690
和上校还提供机构 

386
00:19:38,045 --> 00:19:43,504
为用户阻止与此信号

387
00:19:41,069 --> 00:19:45,298
阻止比特向量所以块位 

388
00:19:43,909 --> 00:19:47,974
矢量的大小与待处理同

389
00:19:45,919 --> 00:19:52,966
位向量原来它只是一个32位

390
00:19:48,559 --> 00:19:55,250
诠释好，它可以设置和清除 

391
00:19:53,389 --> 00:19:58,468
该位， 可设置和清除 

392
00:19:55,025 --> 00:20:01,444
使用SIG PROC面罩系统调用 好吗 

393
00:19:59,179 --> 00:20:03,860
现在有阻塞在Linux 

394
00:20:01,669 --> 00:20:06,705
文献阻塞位向量是 

395
00:20:03,086 --> 00:20:06,255
也称为信号掩模 

396
00:20:09,035 --> 00:20:13,047
好吧，现在我们要在一点点看 

397
00:20:12,003 --> 00:20:15,072
有关发送和接收更详细 

398
00:20:13,047 --> 00:20:19,095
信号，从而让我们先开始发送 

399
00:20:15,072 --> 00:20:22,137
信号首先我们需要 了解 

400
00:20:19,095 --> 00:20:26,172
进程组所以每一个过程的想法

401
00:20:23,037 --> 00:20:30,060
属于一个进程组和 

402
00:20:27,072 --> 00:20:32,127
那些所以这里我展示一个shell这是 

403
00:20:30,006 --> 00:20:36,084
在过程中 它具有 10 的过程ID 

404
00:20:33,027 --> 00:20:41,049
和10 的外壳 的工序组ID 

405
00:20:37,038 --> 00:20:43,080
创建具有一个前台作业

406
00:20:41,049 --> 00:20:45,054
二十进程ID 和处理组 

407
00:20:43,008 --> 00:20:47,012
二十ID，然后所有的 

408
00:20:45,099 --> 00:20:50,100
孩子，这个前台作业 

409
00:20:47,084 --> 00:20:54,117
创建具有相同的处理组ID

410
00:20:51,009 --> 00:20:57,042
20个所以这些这些过程组

411
00:20:55,017 --> 00:21:01,113
可以通过一个名为系统调用集设置 

412
00:20:57,042 --> 00:21:04,056
一组进程组ID，并可以中和 

413
00:21:02,013 --> 00:21:07,074
您可以 通过获取该进程组 

414
00:21:04,056 --> 00:21:08,151
在获取进程组的系统调用，所以你 

415
00:21:07,074 --> 00:21:12,153
在这个例子中看到什么 

416
00:21:09,051 --> 00:21:16,073
外壳做的是它开创了前景 

417
00:21:13,053 --> 00:21:19,098
孩子所以它创造了这个孩子 ，并 

418
00:21:16,073 --> 00:21:23,124
改变进程组ID为等于 

419
00:21:19,098 --> 00:21:25,116
孩子的进程ID，然后 

420
00:21:24,024 --> 00:21:28,119
当这个孩子创建的其他子

421
00:21:26,016 --> 00:21:33,035
孩子们，他们只是继承了相同的 

422
00:21:29,019 --> 00:21:33,035
处理组ID 没关系 

423
00:21:34,025 --> 00:21:39,086
现在这个这个概念的过程组 

424
00:21:36,044 --> 00:21:42,053
是有用的，因为它 允许你 发送 

425
00:21:39,086 --> 00:21:43,178
信号，以在 所述 的处理组 

426
00:21:42,053 --> 00:21:47,078
同时，你可以做到这一点 与 

427
00:21:44,078 --> 00:21:48,083
称为杀程序，其典型地是 

428
00:21:47,078 --> 00:21:51,149
在/ bin目录

429
00:21:49,028 --> 00:21:54,074
而杀程序，你可以使用 

430
00:21:52,049 --> 00:21:56,102
杀程序发送任意 

431
00:21:54,074 --> 00:21:59,102
信号可以是个人过程 

432
00:21:57,002 --> 00:22:05,015
或全部在一个过程中的处理 

433
00:22:00,002 --> 00:22:09,074
组让我们来看一个例子 这 

434
00:22:05,015 --> 00:22:14,084
该方案计划福克斯创建两个 

435
00:22:09,074 --> 00:22:17,162
儿童和每 一个有 

436
00:22:14,084 --> 00:22:19,121
的 24八一七 处理组 和 

437
00:22:18,062 --> 00:22:22,981
当然，他们有不同的过程

438
00:22:20,021 --> 00:22:26,114
他们有不同的进程ID等 

439
00:22:23,539 --> 00:22:31,220
如果我们如果我们做一个PS，我们看到这两个我们 

440
00:22:27,014 --> 00:22:32,069
看到这两个进程运行，

441
00:22:31,022 --> 00:22:36,077
这些刚进入循环，这样他们就会 

442
00:22:32,069 --> 00:22:41,135
他们将刚才连续运行 好吗 

443
00:22:36,077 --> 00:22:44,096
我们可以来我们可以使用杀 来 杀去 的 

444
00:22:42,035 --> 00:22:48,040
例如个别过程，所以如果我们 

445
00:22:44,096 --> 00:22:49,190
把它的第一个 参数 

446
00:22:48,004 --> 00:22:52,076
指示信号要送什么 

447
00:22:50,009 --> 00:22:55,031
所以在这种情况下，它的信号9 

448
00:22:53,012 --> 00:23:00,301
这是CIG kill信号 所以杀 

449
00:22:56,012 --> 00:23:01,088
零下 九级是一个非常典型的，通常 

450
00:23:00,409 --> 00:23:04,730
如果你只想杀了你的过程

451
00:23:01,088 --> 00:23:08,132
杀零下九实际上我一个

452
00:23:04,073 --> 00:23:14,119
最喜欢的 奥托实验室Mik的名字 213 

453
00:23:09,032 --> 00:23:18,501
绰号被打死 - 915 - 1 3等等 

454
00:23:15,019 --> 00:23:23,060
但随后则第二个参数是 

455
00:23:18,789 --> 00:23:27,200
如果它是进程 ID，所以这是 

456
00:23:23,006 --> 00:23:30,065
问这是请求内核杀 

457
00:23:27,002 --> 00:23:34,079
进程ID  - 对于1 8通过发送一个

458
00:23:31,019 --> 00:23:40,028
CIG kill 信号，现在如果要是 

459
00:23:34,097 --> 00:23:42,286
进程ID是由前面-那么它 

460
00:23:41,009 --> 00:23:46,082
将信号发送到每一个过程 

461
00:23:43,159 --> 00:23:47,870
进程组 - 然后把这个

462
00:23:46,082 --> 00:23:50,087
参数作为一个过程 

463
00:23:47,087 --> 00:23:52,163
并将其发送 信号到每一个过程 

464
00:23:51,032 --> 00:23:57,035
在这一 过程中组，以便在这种情况下，它 

465
00:23:53,063 --> 00:24:00,142
将发出一个信号，这两个都 

466
00:23:57,035 --> 00:24:03,098
这些孩子的过程，然后 

467
00:24:01,042 --> 00:24:05,108
事后我们，如果我们做一个PS我们看到， 

468
00:24:03,098 --> 00:24:07,183
这些过程 都消失了 还好，它 

469
00:24:06,008 --> 00:24:12,041
确实工作方式 

470
00:24:08,083 --> 00:24:15,089
现在另一种方式来发送信号是 

471
00:24:12,041 --> 00:24:20,069
打字 或者控制C或控制 ž在 

472
00:24:15,089 --> 00:24:22,112
该命令行 控制C使 

473
00:24:20,069 --> 00:24:24,145
内核的信号发送到每一项工作 

474
00:24:23,012 --> 00:24:31,049
前台进程组 中 和 

475
00:24:25,045 --> 00:24:33,137
控制ž 导致它 发送一个信号 

476
00:24:31,049 --> 00:24:36,074
信号到每一项工作中的 

477
00:24:34,037 --> 00:24:38,072
前台进程组默认 

478
00:24:36,074 --> 00:24:40,088
对于 SIGINT行动是终止 

479
00:24:38,072 --> 00:24:43,079
处理该 CIG T 中的默认 操作 

480
00:24:40,088 --> 00:24:49,114
站暂停过程中停止 

481
00:24:43,079 --> 00:24:49,114
直到它接收到SIG CRT信号 

482
00:24:54,299 --> 00:25:01,325
所以你 可以 在这里 看到 这样的 一个例子 

483
00:24:57,033 --> 00:25:05,342
我们必须创建 一个父一个程序 

484
00:25:01,559 --> 00:25:06,625
和一个孩子在前台 运行 ，所以 

485
00:25:05,639 --> 00:25:09,644
在前台运行的父母 

486
00:25:07,219 --> 00:25:14,225
现在，当我们输入 控制Z到了 

487
00:25:10,139 --> 00:25:17,165
命令行 外壳通知我们 

488
00:25:14,279 --> 00:25:21,355
它暂停该进程，如果我们这样做 

489
00:25:17,399 --> 00:25:25,418
一个PS 我们可以看到父母和孩子 

490
00:25:22,039 --> 00:25:30,085
确实悬空，从而使PS指示

491
00:25:25,589 --> 00:25:29,680
，它的悬挂或使用 RT 停止 

492
00:25:32,119 --> 00:25:37,216
现在接下来我们在建的类型

493
00:25:34,829 --> 00:25:40,838
壳内置在其中 是F G和FG 

494
00:25:38,089 --> 00:25:46,097
恢复那些那些悬挂作业 

495
00:25:41,729 --> 00:25:48,734
前台所以 现在打字FG后 

496
00:25:46,889 --> 00:25:51,941
我们再次运行这个我们的程序 

497
00:25:49,229 --> 00:25:55,271
前台，然后 我们就可以杀死它 

498
00:25:52,409 --> 00:25:58,200
通过键入CTRLÇ其中哪一个引起 

499
00:25:55,649 --> 00:25:59,732
SIGINT其默认动作是 

500
00:25:58,002 --> 00:26:04,471
终止，那么当我们做一个PS我们 

501
00:26:00,479 --> 00:26:04,498
看到确实就是这样，他们已离开 

502
00:26:06,026 --> 00:26:12,109
现在，第三次的方式， 我们可以发送 

503
00:26:08,075 --> 00:26:12,109
信号是通过使用kill系统调用 

504
00:26:14,005 --> 00:26:18,092
所以这里的如何工作的一个例子

505
00:26:17,045 --> 00:26:23,060
所以在这个在这个例子中，我们 

506
00:26:19,037 --> 00:26:25,112
现在创建结束孩子 的每一个 

507
00:26:23,006 --> 00:26:28,075
进入一个无限循环和我们 

508
00:26:26,012 --> 00:26:32,075
每个记录的过程想法 

509
00:26:28,669 --> 00:26:34,720
我们创造的孩子，然后在其中我们 

510
00:26:32,075 --> 00:26:36,161
去另一个循环中，我们通过和我们走

511
00:26:35,179 --> 00:26:41,090
我们自相残杀的子进程 

512
00:26:37,061 --> 00:26:43,061
通过使用所述传递函数杀 

513
00:26:41,009 --> 00:26:48,020
它 的 进程ID和信号，我们 

514
00:26:43,061 --> 00:26:51,010
要发送给该进程没关系，然后 

515
00:26:48,002 --> 00:26:53,006
我们做我们的尽职调查 ，并获得各 

516
00:26:51,559 --> 00:26:54,610
那些我们所的一个孩子 

517
00:26:53,024 --> 00:26:56,953
终止 

518
00:26:54,061 --> 00:26:58,124
现在这不是 绝对必要 

519
00:26:57,169 --> 00:27:03,620
因为我们要尽快退出 

520
00:26:59,024 --> 00:27:06,052
我们要这412函数返回 

521
00:27:03,062 --> 00:27:09,083
退出码左右，但我们只是被 

522
00:27:06,052 --> 00:27:11,961
你知道这里小心，也许一点点 

523
00:27:09,083 --> 00:27:11,682
迂腐但 

524
00:27:15,013 --> 00:27:24,019
现在没事了我们现在让我们来看看我们 如何 

525
00:27:18,008 --> 00:27:28,052
处理接收到的信号现在假设 

526
00:27:24,073 --> 00:27:31,118
处理的沿执行运行其 

527
00:27:28,052 --> 00:27:33,059
用户代码，然后有一个控制 

528
00:27:32,018 --> 00:27:37,019
进入到 因为一些 内核 

529
00:27:34,022 --> 00:27:40,031
除了现在的例外可能 是 

530
00:27:37,028 --> 00:27:43,115
无论是定时去 关的可能 

531
00:27:41,012 --> 00:27:47,078
中断，也可以是一个陷阱用户通话 

532
00:27:44,015 --> 00:27:50,059
系统调用不错，但它总是 

533
00:27:47,078 --> 00:27:51,152
引起的陷阱初成 

534
00:27:50,059 --> 00:27:55,136
控制转移到内核 

535
00:27:52,052 --> 00:27:57,131
总是有些例外，这样在造成

536
00:27:56,036 --> 00:28:03,038
这一点上，内核调用它的 

537
00:27:58,031 --> 00:28:05,126
调度功能，它决定于

538
00:28:03,038 --> 00:28:10,073
从做一个先知上下文切换到 

539
00:28:06,026 --> 00:28:14,027
过程B和它被处理的是所有 

540
00:28:10,073 --> 00:28:16,076
建立和权利之前它返回 

541
00:28:14,036 --> 00:28:21,098
该异常，右 它的前 

542
00:28:17,003 --> 00:28:25,004
准备通过控制背靠背 

543
00:28:21,098 --> 00:28:27,176
信任乙它的用户代码和过程 

544
00:28:25,004 --> 00:28:33,068
检查任何未决的任何信号 

545
00:28:28,076 --> 00:28:36,152
信号很好，而且它通过执行此 

546
00:28:33,068 --> 00:28:40,091
计算比特向量 PMD 所以未决 

547
00:28:37,052 --> 00:28:43,061
非受阻这是逻辑和的 

548
00:28:40,091 --> 00:28:47,180
未决位向量和逆 

549
00:28:44,042 --> 00:28:50,138
被阻止的位向量的好了 ，所以 PMD是 

550
00:28:48,008 --> 00:28:53,033
所有等待信号的列表 

551
00:28:51,038 --> 00:28:56,137
未被阻止好了，这些都是 

552
00:28:54,005 --> 00:29:01,010
应该接收挂起信号

553
00:28:57,037 --> 00:29:03,128
如果现在为TND都是零则有 

554
00:29:01,055 --> 00:29:07,097
没有待处理的信号， 所以它只是返回它 

555
00:29:04,028 --> 00:29:09,104
将控制传递回它 通过控制 

556
00:29:07,097 --> 00:29:12,146
回到过程B，其可以继续 

557
00:29:10,004 --> 00:29:17,035
然而执行如果如果PN B是 非零 

558
00:29:13,046 --> 00:29:20,123
然后选择最小的非零位 

559
00:29:17,035 --> 00:29:23,087
在PN B和它迫使过程p来

560
00:29:21,023 --> 00:29:26,023
接收相应的该信号

561
00:29:23,087 --> 00:29:25,123
信号 

562
00:29:26,066 --> 00:29:35,145
收到信号的触发 一些 

563
00:29:29,309 --> 00:29:39,480
在过程，然后我们的行动

564
00:29:36,045 --> 00:29:42,132
重复所有非零 信号 

565
00:29:39,048 --> 00:29:45,497
K表是 在设置 不 为零的位 

566
00:29:43,032 --> 00:29:48,060
PMD 最后当我们已经走了所有 

567
00:29:45,929 --> 00:29:51,967
通过所有非零位，然后我们

568
00:29:48,006 --> 00:30:00,965
控制传递给下一个指令在 

569
00:29:52,309 --> 00:30:04,500
在过程p之间，这样的收据 

570
00:30:01,559 --> 00:30:07,583
信号始终 触发一些动作 ，其 

571
00:30:04,005 --> 00:30:09,063
或者是该过程终止 

572
00:30:07,799 --> 00:30:13,799
过程停止，直到它被重新启动

573
00:30:10,008 --> 00:30:16,029
SIG的CON信号的过程中忽略了 

574
00:30:13,799 --> 00:30:21,750
信号好了，这就是总有 

575
00:30:16,029 --> 00:30:25,035
一些预定义的默认操作，但我们 

576
00:30:21,075 --> 00:30:28,104
可以修改由默认动作 

577
00:30:25,035 --> 00:30:32,133
使用 所谓的系统调用的 函数 

578
00:30:29,004 --> 00:30:34,086
信号好了，所以我们现在可以信号是 

579
00:30:33,033 --> 00:30:36,057
小那是另一形式的误导

580
00:30:34,086 --> 00:30:37,149
一种长期形同杀权 

581
00:30:36,057 --> 00:30:39,656
因为当我们，当我们发出一个信号， 

582
00:30:38,049 --> 00:30:42,126
一个过程中，我们不要 总想 杀人 

583
00:30:40,169 --> 00:30:45,900
它和信号实际上并不 信号 

584
00:30:43,026 --> 00:30:48,051
任何东西，它只是它只是修改 

585
00:30:45,009 --> 00:30:51,012
默认操作 一些 相关 

586
00:30:48,051 --> 00:30:57,220
信号好了，所以信号的功能需要 

587
00:30:52,002 --> 00:31:00,731
我们的信号数，然后 

588
00:30:57,679 --> 00:31:04,679
指定默认操作的变化

589
00:31:00,929 --> 00:31:06,840
对于信号和这些默认 

590
00:31:04,679 --> 00:31:09,600
行动可以是 忽略 

591
00:31:06,084 --> 00:31:13,098
信号行无视类型的信号 

592
00:31:09,006 --> 00:31:18,042
信号还原为默认 行为 

593
00:31:13,098 --> 00:31:19,152
该信号，或者我们可以我们可以给它 

594
00:31:18,096 --> 00:31:22,122
或者它可能是 一个用户的地址 

595
00:31:20,052 --> 00:31:25,070
电平的信号处理程序 ，其是一个函数 

596
00:31:23,022 --> 00:31:28,098
我们在我们的C程序已经声明 

597
00:31:25,007 --> 00:31:30,021
还好这没有什么特别的是关于 

598
00:31:28,098 --> 00:31:32,190
该功能具有一定的原型 

599
00:31:30,084 --> 00:31:34,161
它具有它需要一个唯一参数 ， 

600
00:31:33,009 --> 00:31:37,068
是信号编号，以便当 

601
00:31:35,061 --> 00:31:41,070
函数被 调用 

602
00:31:38,049 --> 00:31:48,053
手至接收 信号 这样的 说法 

603
00:31:41,007 --> 00:31:51,021
将被设置为 所述 信号数量，以便 

604
00:31:48,053 --> 00:31:53,076
调用带有信号和指定

605
00:31:51,084 --> 00:31:56,100
信号处理程序被调用安装 

606
00:31:53,076 --> 00:31:58,745
处理程序， 然后执行处理程序 

607
00:31:57,000 --> 00:32:03,015
称为捕获或执行 

608
00:31:59,429 --> 00:32:05,490
他们正在处理的信号，并与 

609
00:32:03,015 --> 00:32:07,059
这种处理事件就像一个 

610
00:32:05,049 --> 00:32:10,071
异常处理程序，当它时，它 

611
00:32:07,059 --> 00:32:13,071
返回时，它的运行它，它会 

612
00:32:10,071 --> 00:32:15,126
将中断当前无论是 

613
00:32:13,071 --> 00:32:17,145
在 处理 执行 时，它返回 

614
00:32:16,026 --> 00:32:23,058
它会返回 到这 一点，并 

615
00:32:18,045 --> 00:32:28,080
继续执行好了，所以这里有一个简单的 

616
00:32:23,058 --> 00:32:30,063
例如所以这里安装一个处理程序 

617
00:32:28,008 --> 00:32:35,019
在缅因州我们要去的地方安装一个 

618
00:32:31,008 --> 00:32:38,025
这就是所谓的签名INT SIG INT处理器 

619
00:32:35,091 --> 00:32:40,170
强调其定义了处理程序

620
00:32:38,025 --> 00:32:44,031
这里的原型 这一 功能 

621
00:32:41,007 --> 00:32:45,986
是什么回报，它需要一个单一的 

622
00:32:44,085 --> 00:32:50,097
整数参数 是 信号 

623
00:32:46,679 --> 00:32:53,460
号，并且 没有 返回 OK后 

624
00:32:50,097 --> 00:32:55,185
我们安装的处理程序，然后我们要去 

625
00:32:53,046 --> 00:32:58,053
执行暂停该调用 哪个 

626
00:32:56,085 --> 00:32:59,169
只是等待一个信号处理程序 

627
00:32:58,053 --> 00:33:02,150
执行确定，所以暂停终止 

628
00:33:00,069 --> 00:33:05,151
电流或悬念当前 进程 

629
00:33:03,005 --> 00:33:08,013
直到的信号被接收和处理程序 

630
00:33:06,051 --> 00:33:13,059
执行该过程，然后暂停 

631
00:33:09,003 --> 00:33:16,086
然后暂停了回报，我们要 

632
00:33:13,059 --> 00:33:21,087
等到 SIGINT 发生如此SIG 

633
00:33:17,013 --> 00:33:23,055
入口调用是当我们输入控件C等等 

634
00:33:21,087 --> 00:33:24,135
当你在做 你的 炸弹并没有 

635
00:33:23,055 --> 00:33:28,056
你恐慌在某些时候和尝试打 

636
00:33:25,035 --> 00:33:32,040
按Ctrl C退出的就OK了， 这样 

637
00:33:28,065 --> 00:33:33,144
令人感到讽刺的消息，你有，这是我们做

638
00:33:32,004 --> 00:33:38,043
通过通过安装信号 房子 

639
00:33:34,044 --> 00:33:40,107
在您的炸弹确定，所以SIGINT处理程序 

640
00:33:38,079 --> 00:33:43,134
当，当你键入控件C 是 

641
00:33:41,007 --> 00:33:48,356
，诱发SIGINT时SIGINT是 

642
00:33:44,034 --> 00:33:49,115
接收我们印刷此消息，并 

643
00:33:48,419 --> 00:33:59,210
然后最终 

644
00:33:50,015 --> 00:34:01,112
让你现在退出信号机信号 

645
00:33:59,021 --> 00:34:05,470
现在并发的另一个例子

646
00:34:02,012 --> 00:34:10,099
我们前面在看到并发

647
00:34:05,659 --> 00:34:14,810
的过程右并发流形式

648
00:34:10,099 --> 00:34:17,107
在时间上重叠 没关系逻辑流 

649
00:34:14,081 --> 00:34:23,123
通过定义在时间重叠的

650
00:34:18,007 --> 00:34:25,082
与进程并发现在

651
00:34:24,023 --> 00:34:27,922
因为他们有不同的地址

652
00:34:25,082 --> 00:34:29,161
空间的并发流永远

653
00:34:28,129 --> 00:34:32,206
彼此右 所以在干扰

654
00:34:29,899 --> 00:34:35,000
从某种意义上说预言是很容易

655
00:34:32,899 --> 00:34:39,230
对付我们真的没有 来 

656
00:34:35,000 --> 00:34:43,007
担心与 被 干扰 

657
00:34:39,023 --> 00:34:45,098
其实你必须 去另一个进程

658
00:34:43,007 --> 00:34:48,786
以很大的篇幅来分享喜欢分享

659
00:34:45,098 --> 00:34:50,126
流程之间的事情，你必须使用 

660
00:34:48,849 --> 00:34:55,520
具体的系统调用，以说 

661
00:34:51,026 --> 00:34:57,625
现在两个进程之间共享内存 

662
00:34:55,052 --> 00:34:59,063
信号是 并发的另一种形式 

663
00:34:57,859 --> 00:35:03,310
这是第二次类 

664
00:34:59,063 --> 00:35:05,099
你所经历的并发性和 

665
00:35:03,031 --> 00:35:08,036
所以一个信号只是一个并流 

666
00:35:05,099 --> 00:35:10,142
它只是一个逻辑流程生病所以 

667
00:35:08,081 --> 00:35:13,090
处理器只不过是另一种逻辑流

668
00:35:11,042 --> 00:35:16,100
与程序同时运行

669
00:35:13,009 --> 00:35:19,091
右所以我们假设我们正在执行 

670
00:35:17,000 --> 00:35:23,054
while循环和处理好这 

671
00:35:20,072 --> 00:35:26,096
while循环正在执行，然后 

672
00:35:23,054 --> 00:35:30,079
处理的接收引起的信号

673
00:35:26,096 --> 00:35:33,235
控制转移 给该处理程序 

674
00:35:30,079 --> 00:35:36,107
这个处理程序执行，所以这是一个 

675
00:35:34,099 --> 00:35:39,470
在时间上重叠并流 

676
00:35:37,007 --> 00:35:44,072
在处理的 while 循环 

677
00:35:39,047 --> 00:35:47,051
最终这个处理器返回，我们 

678
00:35:44,072 --> 00:35:51,143
回到 反引号要回 

679
00:35:47,051 --> 00:35:55,118
处理现在的 原因信号 中的一个

680
00:35:52,043 --> 00:35:59,047
如此棘手的是因为 这个 这个 

681
00:35:56,018 --> 00:36:01,102
重叠并流

682
00:35:59,047 --> 00:36:04,114
此并发性，因为信号

683
00:36:02,002 --> 00:36:07,084
处理程序在同一个进程中运行 

684
00:36:05,014 --> 00:36:12,021
主要程序，使这股 所有全局 

685
00:36:07,084 --> 00:36:14,098
该方案的变量 好了，所以你 

686
00:36:12,021 --> 00:36:16,102
该信号处理程序是一个函数，它 

687
00:36:14,098 --> 00:36:19,174
你已经声明，它具有 所有访问 

688
00:36:17,002 --> 00:36:24,013
所有国家所有的全局状态 

689
00:36:20,074 --> 00:36:26,077
该方案很好，而且存在 

690
00:36:24,013 --> 00:36:28,080
这个共享的全局状态可以创造真正的 

691
00:36:26,077 --> 00:36:28,080
问题

692
00:36:36,309 --> 00:36:42,334
我们将进入更多 细节 

693
00:36:39,229 --> 00:36:44,307
其中的一些问题，所以另一种方式 

694
00:36:42,559 --> 00:36:47,623
看看 这些信号处理 为碟形 

695
00:36:45,009 --> 00:36:51,061
并发流使用该本

696
00:36:48,199 --> 00:36:54,286
上下文切换图所以假设我们 

697
00:36:51,529 --> 00:37:00,546
在一些过程中执行，现在 

698
00:36:55,069 --> 00:37:04,160
点的信号被 传递到处理 

699
00:37:00,699 --> 00:37:05,740
现在没有任何反应的权利只是刚刚 

700
00:37:04,016 --> 00:37:09,885
中断标志位， 获取过程中的设置

701
00:37:06,109 --> 00:37:12,168
这一点现在在某些 时候有一个 

702
00:37:10,029 --> 00:37:15,103
控制转移到 内核中， 

703
00:37:12,699 --> 00:37:19,130
内核决定做一个上下文

704
00:37:15,769 --> 00:37:20,800
从A切换到B和现在B获得运行 

705
00:37:19,013 --> 00:37:24,412
有一段时间的另一个转移 

706
00:37:21,079 --> 00:37:28,144
控制内核和内核 

707
00:37:24,529 --> 00:37:31,555
决定安排过程中，现在 

708
00:37:28,729 --> 00:37:34,753
权利之前返回控制 

709
00:37:31,789 --> 00:37:37,837
过程中也注意到了这取决于 

710
00:37:34,969 --> 00:37:40,984
该信号位，以便它会导致 

711
00:37:38,269 --> 00:37:43,315
处理以接收信号， 使得 

712
00:37:41,119 --> 00:37:46,162
执行处理程序代码时，

713
00:37:43,729 --> 00:37:47,776
处理程序返回返回短暂 

714
00:37:46,549 --> 00:37:50,551
简单的内核，然后

715
00:37:48,199 --> 00:37:52,282
控制转移回下一 

716
00:37:50,749 --> 00:37:57,808
该进程将 指令 

717
00:37:53,029 --> 00:37:59,107
现在执行的处理也非常棘手 

718
00:37:58,339 --> 00:38:02,386
因为他们可以 通过其他中断 

719
00:37:59,809 --> 00:38:07,828
的处理器，这样假设我们有我们的主要 

720
00:38:02,809 --> 00:38:09,847
程序映入信号S，其 

721
00:38:07,999 --> 00:38:12,097
导致控制 转移 到处理 

722
00:38:10,189 --> 00:38:15,650
或者我们，然后我们会处理了S做 

723
00:38:12,979 --> 00:38:23,034
你有一个问题好处理好或 

724
00:38:15,065 --> 00:38:22,944
其他人在被正在执行 

725
00:38:24,829 --> 00:38:32,875
该程序捕获 一个信号T 

726
00:38:29,068 --> 00:38:36,097
它使控制转移 给 

727
00:38:33,289 --> 00:38:38,317
该处理程序前 40，然后当当 

728
00:38:36,709 --> 00:38:42,715
该处理程序返回它返回到 

729
00:38:38,569 --> 00:38:44,930
指向的 -给指令 

730
00:38:43,309 --> 00:38:46,408
和处理，否则，这是它在哪里 

731
00:38:44,093 --> 00:38:49,372
中断，然后我们处理程序 

732
00:38:47,299 --> 00:38:52,700
继续执行并最终 

733
00:38:50,209 --> 00:38:54,211
它返回到 在该点 

734
00:38:52,007 --> 00:38:55,078
被中断的地方主程序

735
00:38:54,229 --> 00:38:56,410
现在

736
00:38:59,799 --> 00:39:04,880
信号，但核心 始终块 

737
00:39:02,499 --> 00:39:07,597
当前未决的类型的信号 

738
00:39:04,088 --> 00:39:12,757
被处理的权利这样一个处理一个 

739
00:39:08,479 --> 00:39:15,380
类型T的信号不能被中断

740
00:39:13,549 --> 00:39:17,554
在收到该另一信号的

741
00:39:15,038 --> 00:39:19,417
同类型的好可以为我 的 表现 

742
00:39:18,049 --> 00:39:21,124
一张 幻灯片可以通过中断 

743
00:39:19,759 --> 00:39:23,794
另一种类型的信号，但不是 由 

744
00:39:21,799 --> 00:39:28,873
相同类型的信号，所以这是排序 

745
00:39:24,109 --> 00:39:31,207
的阻塞的隐形式的，但 

746
00:39:29,539 --> 00:39:33,541
还有的内核还提供了 

747
00:39:32,089 --> 00:39:37,430
系统调用，允许你 

748
00:39:33,559 --> 00:39:39,562
明确地阻断和开启信号

749
00:39:37,043 --> 00:39:43,732
所述SIG PROC掩模函数的形式 

750
00:39:39,859 --> 00:39:46,908
然后有一个关联 ，以便本 

751
00:39:44,119 --> 00:39:50,167
允许您阻断和开启一组 

752
00:39:47,349 --> 00:39:53,365
信号，然后有一定的支撑

753
00:39:50,599 --> 00:39:57,650
功能，允许 您创建这些 

754
00:39:53,509 --> 00:40:00,880
集如此只是觉得这些是位 

755
00:39:57,065 --> 00:40:03,874
载体和这些 功能将设置和 

756
00:40:00,088 --> 00:40:07,437
置位和复位的位和那些那些 

757
00:40:04,459 --> 00:40:11,485
探测器让我们看看我们如何使用 

758
00:40:08,229 --> 00:40:13,234
SIG的 PROC掩模 暂时封闭和 

759
00:40:11,719 --> 00:40:14,755
解锁一个信号，这是怎么回事

760
00:40:13,729 --> 00:40:17,390
这会变成是 非常 

761
00:40:15,079 --> 00:40:20,083
对你很重要，当你工作 

762
00:40:17,039 --> 00:40:23,658
你的炮弹是你的下一个你 

763
00:40:20,119 --> 00:40:23,208
接下来的实验任务好吗 

764
00:40:24,085 --> 00:40:29,102
所以我们做什么，我们将使用 齐格空集来 

765
00:40:27,095 --> 00:40:31,160
创建一个空蒙版，所以这是一个面具 

766
00:40:30,002 --> 00:40:35,009
与所有零还好有没有 

767
00:40:32,006 --> 00:40:36,103
集合中的元素，然后我们要去 

768
00:40:35,009 --> 00:40:43,031
到一个单一的元素添加到该组 

769
00:40:37,057 --> 00:40:44,081
这是SIG的int和现在 我们临时，我们有 

770
00:40:43,031 --> 00:40:48,056
一些代码，我们不希望 

771
00:40:44,081 --> 00:40:50,126
通过接收SIG INT 没关系 的中断

772
00:40:48,056 --> 00:40:53,150
所以我们想 暂时阻止 

773
00:40:51,026 --> 00:40:57,101
收到SIGINT信号，我们做 

774
00:40:54,005 --> 00:40:59,066
通过调用与SIG PROC面具 

775
00:40:58,001 --> 00:41:03,083
命令说，我想阻止 

776
00:41:00,011 --> 00:41:06,100
我想阻止的信号 

777
00:41:03,083 --> 00:41:13,091
spected的 是在集 

778
00:41:07,000 --> 00:41:16,076
通过屏蔽指定，我将签署使 

779
00:41:14,063 --> 00:41:19,066
这将成为我的新的面具 ，让这 

780
00:41:16,076 --> 00:41:22,157
这成为新的阻塞位向量 

781
00:41:19,066 --> 00:41:25,073
好或者他们不是这个新 

782
00:41:23,057 --> 00:41:28,154
信号屏蔽 ，这让的副本 

783
00:41:25,073 --> 00:41:32,087
老并将其存储在该地址 

784
00:41:29,054 --> 00:41:34,079
在第三个参数，以便在指定的

785
00:41:32,087 --> 00:41:36,110
这点之后，我们从SIG返回 

786
00:41:34,079 --> 00:41:40,147
PROC掩模SIG和信号被阻断 

787
00:41:37,001 --> 00:41:44,018
他们不会接收，然后我们 

788
00:41:41,047 --> 00:41:45,134
所以我们可以执行该代码知道

789
00:41:44,027 --> 00:41:50,030
我们不会收据被中断 

790
00:41:46,034 --> 00:41:54,038
SIGINT 然后我们就可以恢复 

791
00:41:50,057 --> 00:41:58,058
前块通过使用CIG集设置 

792
00:41:54,038 --> 00:42:00,110
掩盖塞子通货膨胀和传入 

793
00:41:58,067 --> 00:42:02,072
以前的面具，我们， 我们得救了 

794
00:42:01,001 --> 00:42:05,005
在这里，当我们的时候，我们 最初块 

795
00:42:02,072 --> 00:42:04,114
再次

796
00:42:09,033 --> 00:42:15,087
好了，所以信号和信号处理是一个 

797
00:42:13,005 --> 00:42:19,005
真正棘手的业务，并有排序 

798
00:42:15,087 --> 00:42:22,152
三件事情，使他们如此棘手 

799
00:42:19,005 --> 00:42:24,087
和那种讨厌的真正 之一是，你 

800
00:42:23,052 --> 00:42:27,090
必须非常小心 地 写 

801
00:42:24,087 --> 00:42:29,118
处理程序 是安全的好了，所以有 

802
00:42:27,009 --> 00:42:31,041
你可以编写信号处理程序

803
00:42:30,018 --> 00:42:36,093
不安全的感觉，他们会创造 

804
00:42:32,022 --> 00:42:38,073
在你的程序死锁正确的，或者你

805
00:42:36,093 --> 00:42:39,189
可以或者你可以写信号处理

806
00:42:38,073 --> 00:42:44,139
那会他们就会产生破坏全局数据 

807
00:42:40,089 --> 00:42:47,100
多数民众赞成由修改结构

808
00:42:45,039 --> 00:42:50,135
主程序所以我的意思是想象想象 

809
00:42:48,000 --> 00:42:53,061
你的主要编程一些更新 

810
00:42:51,035 --> 00:42:56,037
一些数据结构就像一个链表 

811
00:42:53,061 --> 00:42:57,150
而就在更新中间的那个 

812
00:42:56,037 --> 00:43:01,101
当它的数据结构时，它的无 

813
00:42:58,005 --> 00:43:03,030
长一致的程序获取 

814
00:43:02,001 --> 00:43:07,065
通过接收的信号的中断 

815
00:43:03,075 --> 00:43:08,154
并且如果该信号 处理程序更新 

816
00:43:07,065 --> 00:43:12,069
相同的数据结构读数 

817
00:43:09,054 --> 00:43:13,110
结构或修改那么它的

818
00:43:12,069 --> 00:43:18,071
会遇到它不一致 

819
00:43:14,001 --> 00:43:18,062
状态，并且和你就麻烦了 

820
00:43:18,086 --> 00:43:26,088
所以这样一个事实， 这是事实， 

821
00:43:24,059 --> 00:43:29,154
它很容易 编写信号处理程序 

822
00:43:27,006 --> 00:43:32,079
是不安全的是 的 一个 方面 

823
00:43:30,054 --> 00:43:34,131
这让他们很难对付 另一个 

824
00:43:32,079 --> 00:43:37,128
一方面 是他们有这个有趣的语义 

825
00:43:35,031 --> 00:43:39,090
该信号不线索 ，因此，如果 

826
00:43:38,028 --> 00:43:43,035
你不是，如果你不小心真的 

827
00:43:39,009 --> 00:43:45,054
这个是非常 容易使用 

828
00:43:43,035 --> 00:43:47,046
收到的信号进行 计数和事件 

829
00:43:46,035 --> 00:43:49,110
你不能这样做

830
00:43:47,046 --> 00:43:51,060
如果信号是线索，你可以使用你 

831
00:43:50,001 --> 00:43:53,028
可以使用收到信号来 

832
00:43:51,006 --> 00:43:55,008
计数系统中的事件，但 你不能 

833
00:43:53,037 --> 00:43:58,098
这样做是因为 他们的信号不 线索 

834
00:43:55,008 --> 00:43:59,090
和 然后在第三第三方面 

835
00:43:58,098 --> 00:44:01,179
这使得他们强硬的信号是， 

836
00:44:00,062 --> 00:44:04,062
他们甚至 没有 他们甚至不 

837
00:44:02,079 --> 00:44:10,080
可跨不同 版本的 

838
00:44:04,062 --> 00:44:12,120
Linux的好了，所以如果你使用Solaris或一些 

839
00:44:10,008 --> 00:44:14,010
BSD的形式，它并不一定是

840
00:44:13,002 --> 00:44:15,099
信号处理语义不 

841
00:44:14,082 --> 00:44:18,108
不一定，因为它们是在同一 

842
00:44:16,017 --> 00:44:20,100
Linux的好那么 好，我们来看看所有 

843
00:44:19,008 --> 00:44:22,063
这三个在更详细一点 

844
00:44:21,000 --> 00:44:27,579
首先，我们将与启动

845
00:44:22,063 --> 00:44:31,066
编写安全的处理程序，所以让我给你

846
00:44:27,579 --> 00:44:34,420
对于如何编写 安全的一些准则 

847
00:44:31,066 --> 00:44:38,505
处理程序和这仅仅是一个 集合 

848
00:44:34,042 --> 00:44:41,991
乐趣，这只是一种 集合 

849
00:44:39,099 --> 00:44:47,200
收集的智慧来自不同 

850
00:44:42,369 --> 00:44:49,392
来源，但它涵盖 了 很多方面的 

851
00:44:47,002 --> 00:44:51,321
信号处理程序，以便第一 

852
00:44:49,599 --> 00:44:53,637
原则是， 让您的处理器为 

853
00:44:51,519 --> 00:44:55,551
简单越好例如 

854
00:44:53,979 --> 00:44:57,990
最简单可行的处理，我能想到 的 

855
00:44:55,839 --> 00:45:05,936
只是设置 一个全局 变量，然后将其 

856
00:44:58,089 --> 00:45:09,108
回报而事实上证书的CMU证书 

857
00:45:06,809 --> 00:45:12,970
提供了某种指引

858
00:45:09,279 --> 00:45:15,363
兼容的程序，这是唯一的 

859
00:45:12,097 --> 00:45:17,376
信号处理程序 ，他们允许这是 

860
00:45:16,119 --> 00:45:19,194
唯一兼容的信号处理 一个 

861
00:45:18,249 --> 00:45:23,252
只是设置一个全局变量， 

862
00:45:19,869 --> 00:45:22,937
然后返回好吗 

863
00:45:25,589 --> 00:45:30,606
指导头号只调用函数 

864
00:45:28,479 --> 00:45:33,564
在你的处理程序，它具有此 

865
00:45:30,759 --> 00:45:36,810
同步信号安全性能好 

866
00:45:34,329 --> 00:45:39,378
我们来看看这在第二，但 我 

867
00:45:37,269 --> 00:45:42,327
要 指出的是，打印的printf 

868
00:45:39,819 --> 00:45:44,868
马拉克退出功能 ，是非常 

869
00:45:42,849 --> 00:45:48,150
常见和常用 的使用 并不安全 

870
00:45:45,309 --> 00:45:48,150
好的

871
00:45:48,091 --> 00:45:53,167
指导号二是始终保存 

872
00:45:51,091 --> 00:45:56,910
和还原错误没有在进入和退出 

873
00:45:54,067 --> 00:45:58,656
所以你知道错误是没有一个全球性的全球 

874
00:45:57,729 --> 00:46:00,729
变量时有每当它的设置 

875
00:45:59,259 --> 00:46:03,342
有一个系统 级 的错误 

876
00:46:00,729 --> 00:46:05,950
功能，所以你需要保存你

877
00:46:04,089 --> 00:46:08,130
需要保存，并在进入恢复和 

878
00:46:05,095 --> 00:46:08,194
退出， 这样 它不会被覆盖 

879
00:46:08,499 --> 00:46:12,410
你正在被另一个中断 

880
00:46:09,094 --> 00:46:14,098
处理器 

881
00:46:12,041 --> 00:46:17,170
[音乐]

882
00:46:14,098 --> 00:46:19,987
没关系，如果你所访问的任何共享数据 

883
00:46:17,539 --> 00:46:24,571
一个信号 处理器 内部结构， 其 

884
00:46:20,869 --> 00:46:26,750
也是由主程序访问 

885
00:46:24,859 --> 00:46:28,460
那么你需要 暂时阻止 

886
00:46:26,075 --> 00:46:30,077
信号，同时您访问数据 

887
00:46:28,046 --> 00:46:32,875
结构既在主例程和 

888
00:46:30,095 --> 00:46:34,684
信号处理程序权利和理由 

889
00:46:33,289 --> 00:46:37,400
这 就是我在前面描述 是否 

890
00:46:35,539 --> 00:46:38,930
你的主要程序是更新

891
00:46:37,004 --> 00:46:40,088
全局数据结构，然后它会 

892
00:46:38,093 --> 00:46:41,165
中断，且信号处理程序是 

893
00:46:41,024 --> 00:46:44,120
读取数据结构这是怎么回事 

894
00:46:42,065 --> 00:46:50,734
找到它在不一致的状态和糟糕 

895
00:46:45,002 --> 00:46:52,100
事情发生好吗你想 成为 

896
00:46:51,319 --> 00:46:54,394
一定要声明你的任何 全局 

897
00:46:53,018 --> 00:46:56,090
被信号之间共享的变量

898
00:46:55,069 --> 00:46:59,480
处理程序和主程序为 

899
00:46:56,009 --> 00:47:01,016
挥发性好挥发性属性 

900
00:46:59,048 --> 00:47:07,357
将防止编译器把

901
00:47:01,097 --> 00:47:09,188
在寄存器该值 ，所以如果你 

902
00:47:07,789 --> 00:47:12,950
声明一个 全局变量挥发性它 

903
00:47:10,088 --> 00:47:15,092
永远是 读取和写入的意志 

904
00:47:12,095 --> 00:47:17,934
经常去，并从内存好了， 

905
00:47:15,092 --> 00:47:20,141
这是非常重要的权利，你可能 

906
00:47:18,789 --> 00:47:22,843
如果你不声明这些全球 

907
00:47:21,041 --> 00:47:25,750
在易失性和编译器变量

908
00:47:23,329 --> 00:47:31,160
选择摆放其中的一个在 

909
00:47:26,119 --> 00:47:33,440
在寄存器中，那么 你可能会错过 

910
00:47:31,016 --> 00:47:36,385
变量更新因此，假设 

911
00:47:33,044 --> 00:47:39,613
假设你的信号处理函数设置 

912
00:47:36,529 --> 00:47:42,890
一个全局变量，现在假设 你 

913
00:47:40,009 --> 00:47:46,066
主程序在旋转等待 

914
00:47:42,089 --> 00:47:47,165
全球变量获得定好了，如果

915
00:47:46,579 --> 00:47:51,580
它是在寄存器中写入到 

916
00:47:48,065 --> 00:47:54,034
变量只会 更新寄存器 

917
00:47:51,589 --> 00:47:57,140
右等你的主程序是 

918
00:47:54,619 --> 00:47:58,710
刚纺永远不会没有危险

919
00:47:57,014 --> 00:48:03,014
看到变化谢谢 

920
00:47:59,529 --> 00:48:05,611
好了，所以一直使用的波动，使 

921
00:48:03,014 --> 00:48:08,713
他们不存储在寄存器，然后

922
00:48:06,349 --> 00:48:11,750
如果你有乐趣，如果你有一个 特殊的 

923
00:48:08,839 --> 00:48:13,670
一种全球性的，称为标志，该标志由 

924
00:48:11,075 --> 00:48:16,624
定义 一个变量是只读的， 

925
00:48:13,067 --> 00:48:20,656
或书写不增加或更新 

926
00:48:17,299 --> 00:48:22,372
它只是读或写，如果你有，如果 

927
00:48:21,259 --> 00:48:24,680
你 有这个属性 变量 

928
00:48:23,029 --> 00:48:25,910
然后 你可以用这个SIG宣布它 

929
00:48:24,068 --> 00:48:29,162
原子

930
00:48:25,091 --> 00:48:31,097
牛逼的属性 ，如果你这样做，那么该 

931
00:48:30,062 --> 00:48:34,088
系统保证了读取和 写入 

932
00:48:32,051 --> 00:48:36,083
该变量 是原子的，所以你不要 

933
00:48:34,088 --> 00:48:38,177
有换句话说，你不必 

934
00:48:36,083 --> 00:48:42,083
保护访问到共享到 

935
00:48:39,077 --> 00:48:45,170
访问或到那些全局引用

936
00:48:42,083 --> 00:48:48,098
变量好，因此使用这种由原子 

937
00:48:46,007 --> 00:48:50,068
什么意思是读或写 

938
00:48:48,098 --> 00:48:54,121
该标志总是会发生 在一个 

939
00:48:51,031 --> 00:48:58,114
不间断一步 好一个 

940
00:48:55,021 --> 00:49:02,069
不间断负载或存储特定 

941
00:48:59,014 --> 00:49:07,028
现在在大多数系统中，这SIG做法

942
00:49:02,069 --> 00:49:08,141
原子t是一个 INT孩子，所以你可以在 你 

943
00:49:07,028 --> 00:49:12,059
可以读取或 一个一个 写一个 int 

944
00:49:09,041 --> 00:49:13,109
指令好吧，这是它的原子，但 

945
00:49:12,059 --> 00:49:16,067
如果你想成为便携式声明 

946
00:49:14,009 --> 00:49:20,033
它与 康原子 吨，然后 它会 

947
00:49:16,067 --> 00:49:25,085
它会在没有它的工作在所有工作

948
00:49:20,033 --> 00:49:29,039
还好我们提到的这个产权制度 

949
00:49:25,085 --> 00:49:31,103
异步信号安全的，现在的功能是

950
00:49:29,039 --> 00:49:36,056
是安全的信号的内 使用 

951
00:49:32,003 --> 00:49:38,015
处理程序如果它要么 折返 正确的，或者 

952
00:49:36,056 --> 00:49:40,094
如果它不能被信号中断 

953
00:49:38,015 --> 00:49:43,049
那叫一个折返功能，我们将 

954
00:49:40,094 --> 00:49:45,101
看到，当我们学习 线程是一个功能 

955
00:49:43,049 --> 00:49:50,087
所有数据的其所有它 

956
00:49:46,001 --> 00:49:53,006
访问是在其自己的堆栈好了，所以没有 

957
00:49:50,087 --> 00:49:53,159
全局变量没有指针指向全球 

958
00:49:53,006 --> 00:49:58,061
变量的一切都存储在 

959
00:49:54,059 --> 00:50:00,080
本地堆放好了，这意味着你可以 

960
00:49:58,061 --> 00:50:02,063
可这就是所谓的折返，因为你可以 

961
00:50:00,008 --> 00:50:03,041
写有 多个实例 

962
00:50:02,063 --> 00:50:06,119
功能，他们都有自己的 

963
00:50:04,013 --> 00:50:10,109
所有变量的单独副本

964
00:50:07,019 --> 00:50:14,033
他们是他们使用现在 POSIX 

965
00:50:11,009 --> 00:50:18,031
标准保证117不同 

966
00:50:14,033 --> 00:50:17,131
函数是一个同步信号安全 

967
00:50:18,082 --> 00:50:24,146
这包括强调出口权等待 

968
00:50:22,049 --> 00:50:26,114
等待 可以睡杀，但 

969
00:50:25,046 --> 00:50:28,087
不幸的是有一些很受欢迎 

970
00:50:27,014 --> 00:50:31,085
不在这个名单上的功能 

971
00:50:28,087 --> 00:50:34,094
的printf 的printf的东西，你真的 

972
00:50:31,085 --> 00:50:36,092
要使用，其实正确的是 

973
00:50:34,094 --> 00:50:38,149
只有输出 功能，这是一个同步 

974
00:50:36,092 --> 00:50:38,149
信号安全

975
00:50:39,999 --> 00:50:46,910
所以这是怎样的一个问题，因为 

976
00:50:43,329 --> 00:50:48,410
尤其是当你知道你的东西 

977
00:50:46,091 --> 00:50:51,640
你经常喜欢你的信号处理程序 

978
00:50:48,041 --> 00:50:53,830
输出信息，但你不能，如果你 

979
00:50:52,459 --> 00:50:56,557
想要真正成为迂腐和小心 

980
00:50:54,199 --> 00:51:00,920
你不能在实际上用printf 它的 

981
00:50:57,439 --> 00:51:02,530
可以编写一个程序，我会尽力 

982
00:51:00,092 --> 00:51:06,271
到我会尝试有可能 写 

983
00:51:03,349 --> 00:51:11,390
程序， 它的一个紧密循环 

984
00:51:07,099 --> 00:51:14,630
在主程序中，然后 打印输出 

985
00:51:11,039 --> 00:51:16,858
中断的稳定流，其

986
00:51:14,063 --> 00:51:25,702
执行的处理程序也做了 

987
00:51:17,209 --> 00:51:27,283
printf的还好现在的printf调用具有 

988
00:51:26,269 --> 00:51:30,313
获得了所谓的锁

989
00:51:27,949 --> 00:51:34,670
内部的终端没关系每个 printf的 

990
00:51:30,709 --> 00:51:36,766
该库函数它获得锁

991
00:51:34,067 --> 00:51:38,138
这意味着printf的只有一个实例 

992
00:51:37,279 --> 00:51:42,304
可以写入终端在一个点 

993
00:51:39,038 --> 00:51:43,987
时间如果另一个如果另一个功能

994
00:51:42,529 --> 00:51:48,577
尝试获取锁定它有 

995
00:51:44,329 --> 00:51:51,370
等到一切功能拥有

996
00:51:49,009 --> 00:51:55,027
锁定释放它好了，一个锁可防止 

997
00:51:51,739 --> 00:51:57,822
锁是得到相互的方式

998
00:51:55,189 --> 00:52:02,660
独家获得两个共享资源 

999
00:51:58,569 --> 00:52:05,608
所以，如果我们有我们的主要紧密循环

1000
00:52:02,066 --> 00:52:07,139
程序与执行printf的想象

1001
00:52:05,959 --> 00:52:09,985
会发生什么，如果这些打印的一个

1002
00:52:08,039 --> 00:52:14,968
获取终端上的锁定 和 

1003
00:52:10,219 --> 00:52:17,266
然后获取由收据不中断

1004
00:52:15,319 --> 00:52:22,160
信号中现在 的信号的 

1005
00:52:17,689 --> 00:52:24,748
处理它调用另一个printf和那 

1006
00:52:22,016 --> 00:52:27,595
printf的尝试获取锁，它 

1007
00:52:25,279 --> 00:52:29,362
块永远因为没有任何事情

1008
00:52:27,739 --> 00:52:30,814
以释放 锁，因为在 

1009
00:52:30,109 --> 00:52:35,203
主程序被中断

1010
00:52:31,489 --> 00:52:39,514
处理器让你拥有什么叫做 

1011
00:52:36,049 --> 00:52:42,049
古典称为经典条件

1012
00:52:39,739 --> 00:52:42,835
僵局是，我们有一个过程 

1013
00:52:42,049 --> 00:52:46,054
等待事件永远不会 

1014
00:52:43,699 --> 00:52:47,788
发生在这种情况下，printf 和 

1015
00:52:46,099 --> 00:52:49,910
信号处理程序正在等待锁

1016
00:52:48,589 --> 00:52:50,600
被释放，这将永远是 

1017
00:52:49,091 --> 00:52:54,144
发布

1018
00:52:50,006 --> 00:52:58,071
所以这很有趣，你可以试试 这个 

1019
00:52:55,044 --> 00:53:03,057
这是它不是太难创建此 

1020
00:52:59,025 --> 00:53:05,046
死锁情况如此处理这 

1021
00:53:03,057 --> 00:53:06,096
我真的不想告诉你们 

1022
00:53:05,046 --> 00:53:07,143
你不能有任何输出 

1023
00:53:06,096 --> 00:53:11,115
您的程序和写一个 很 

1024
00:53:08,043 --> 00:53:14,130
困难的事情处理这么让我 

1025
00:53:12,015 --> 00:53:19,071
创建了一个名为小小图书馆 

1026
00:53:15,003 --> 00:53:22,041
安全 I / O库包括三个 

1027
00:53:19,071 --> 00:53:25,730
例程和他们是提供给您 

1028
00:53:22,068 --> 00:53:28,095
这是 分布在 CSA PTC文件 

1029
00:53:26,369 --> 00:53:32,780
网站 

1030
00:53:28,095 --> 00:53:38,171
它包括三个折返程序 

1031
00:53:32,078 --> 00:53:45,174
二氧化硅 放王子/公主串把大号 

1032
00:53:39,071 --> 00:53:50,100
沿打印和 SiO错误 打印 

1033
00:53:46,074 --> 00:53:52,119
消息，然后退出 好了，你可以 

1034
00:53:51,000 --> 00:53:55,032
安全使用需要我的话 ，你可以 

1035
00:53:53,019 --> 00:53:57,066
安全在 你在你的信号 使用 

1036
00:53:55,032 --> 00:54:00,081
处理器，所以如果我们要改写 

1037
00:53:57,066 --> 00:54:03,078
我们从从SIGINT处理程序 

1038
00:54:00,081 --> 00:54:04,164
二进制炸弹，我们可以把 它像 

1039
00:54:03,078 --> 00:54:10,173
这一点， 现在我们有充分的功能 

1040
00:54:05,064 --> 00:54:12,071
是一个同步信号安全现在好了 

1041
00:54:11,073 --> 00:54:18,171
单打， 因为 这也强悍 

1042
00:54:13,034 --> 00:54:22,100
和这样 时髦的非 排队语义 

1043
00:54:19,071 --> 00:54:24,144
它真的很容易犯错误 

1044
00:54:23,000 --> 00:54:29,001
当你有一个隐含的假设 

1045
00:54:25,044 --> 00:54:32,046
该该收到信号就 

1046
00:54:29,001 --> 00:54:36,006
可以用于计数 的发生 

1047
00:54:32,046 --> 00:54:41,046
事件让我们 看看这个让我们 

1048
00:54:36,051 --> 00:54:43,107
看看我们安装这个示例程序 

1049
00:54:41,046 --> 00:54:46,068
一个生病的孩子处理好，这是 

1050
00:54:44,007 --> 00:54:48,078
其实 这个 先生，我想关闭 

1051
00:54:46,068 --> 00:54:50,070
环成员，我们谈到了我们的例子中 

1052
00:54:48,078 --> 00:54:52,095
外壳我们想知道我们如何去 

1053
00:54:50,088 --> 00:54:54,144
收获的那些背景的孩子 

1054
00:54:52,095 --> 00:54:56,120
以及我们通过安装一个生病的孩子做 

1055
00:54:55,044 --> 00:54:59,135
处理这样我们在这个例子中正在做 

1056
00:54:57,002 --> 00:55:03,391
所以这次我们在这里有一个程序， 

1057
00:55:00,035 --> 00:55:07,088
安装此 SIG 孩子处理程序 

1058
00:55:03,589 --> 00:55:10,630
然后它创建 N个不同的 子 

1059
00:55:07,088 --> 00:55:17,077
每个孩子睡觉的过程 

1060
00:55:10,999 --> 00:55:22,083
点点退出，然后将其旋转

1061
00:55:17,869 --> 00:55:25,160
，直至C计数变量变为零 

1062
00:55:22,839 --> 00:55:27,907
父对不起父 

1063
00:55:25,016 --> 00:55:35,063
旋转，直至C 计数变量变得 

1064
00:55:28,519 --> 00:55:37,561
现在零在我们的孩子 ，我们 的处理程序 

1065
00:55:35,063 --> 00:55:43,462
我们有一个全球性就是这样的 

1066
00:55:37,939 --> 00:55:45,025
初始化为零 见计数，然后 

1067
00:55:44,029 --> 00:55:47,098
我们等待我们要等到所以这 

1068
00:55:45,799 --> 00:55:48,874
孩子，当孩子处理程序被调用 

1069
00:55:47,719 --> 00:55:52,783
这意味着这就是所谓的，因为 我们 

1070
00:55:49,549 --> 00:55:55,630
收到一个生病的孩子信号好了，所以在 

1071
00:55:53,359 --> 00:55:59,368
我们在 我们的处理程序，我们要收获 

1072
00:55:56,359 --> 00:56:02,434
那个孩子 通过 调用 重量和我们 

1073
00:56:00,259 --> 00:56:06,410
要减速，然后将递减Ç 

1074
00:56:03,109 --> 00:56:09,175
算好了，一旦 所有的孩子 

1075
00:56:06,041 --> 00:56:11,250
在随后进行 已 收获 Ç 数 

1076
00:56:09,769 --> 00:56:14,866
将为零 ，然后家长可以 

1077
00:56:11,619 --> 00:56:19,693
还好现在退出此这个while循环

1078
00:56:15,739 --> 00:56:24,817
这个特定的 实例中，n为 5，但将 

1079
00:56:20,359 --> 00:56:30,382
运行这段代码 ，我们只能把手 或 

1080
00:56:25,519 --> 00:56:32,604
只有被调用两次还行，因此在 

1081
00:56:30,589 --> 00:56:35,593
消息句柄或每个孩子只 得到 

1082
00:56:33,369 --> 00:56:38,385
执行两次右 这 意味着 

1083
00:56:35,989 --> 00:56:41,071
处理程序只叫了两声 ，我们创建了 

1084
00:56:38,529 --> 00:56:46,606
五个孩子，我们终止5 

1085
00:56:41,809 --> 00:56:49,846
孩子，但我们只读过两年好了， 

1086
00:56:47,299 --> 00:56:52,880
这个问题 是，当我们 的 

1087
00:56:50,179 --> 00:56:57,244
问题是，我们假设 

1088
00:56:52,088 --> 00:56:58,987
收到了该执行 

1089
00:56:57,829 --> 00:57:03,140
孩子处理对应于

1090
00:56:59,779 --> 00:57:06,877
单接收到单个信号的信号 

1091
00:57:03,014 --> 00:57:12,343
好时，当在现实中这些信号 

1092
00:57:07,759 --> 00:57:13,792
没有线索的权利，我们在现实中有 

1093
00:57:12,469 --> 00:57:15,523
多生病的孩子信号是

1094
00:57:14,089 --> 00:57:17,117
传递到 孩子里面存放 

1095
00:57:16,009 --> 00:57:21,020
从而覆盖

1096
00:57:17,369 --> 00:57:23,390
出价挂起位部门和 

1097
00:57:21,119 --> 00:57:25,890
这些信号的传递没有没有 

1098
00:57:23,579 --> 00:57:27,647
有没有引起任何反应

1099
00:57:25,089 --> 00:57:29,948
过程，直到我进程只是 

1100
00:57:28,259 --> 00:57:32,320
有关准备改期，只 

1101
00:57:30,749 --> 00:57:34,847
然后在接收到的信号 

1102
00:57:32,869 --> 00:57:36,941
但是，尽管即使是像说的三个信号

1103
00:57:35,729 --> 00:57:42,390
交付只有一个接收 

1104
00:57:37,589 --> 00:57:44,612
好了，所以你不能使用这个事件 

1105
00:57:42,039 --> 00:57:47,498
情况下，我们使用的是我们使用事件

1106
00:57:44,819 --> 00:57:51,180
信号计算在这个事件

1107
00:57:47,849 --> 00:57:55,200
情况是孩子的终止好吗 

1108
00:57:51,018 --> 00:57:58,607
因此接收到的信号 在这种情况下 

1109
00:57:55,002 --> 00:58:02,921
它只是表明至少有一个 

1110
00:57:58,769 --> 00:58:05,846
孩子终止权不是没有一个孩子 

1111
00:58:03,119 --> 00:58:07,217
终止了所有我们可以从推断 

1112
00:58:06,539 --> 00:58:12,450
接收到该 信号的是，至少 

1113
00:58:08,099 --> 00:58:18,161
一个孩子好吗因此终止修复 

1114
00:58:12,045 --> 00:58:19,874
当我们收到一个生病的孩子 ，我们 

1115
00:58:18,719 --> 00:58:23,798
必须把我们必须把重量 

1116
00:58:20,279 --> 00:58:27,420
多数民众赞成在收获我们的孩子，我们有

1117
00:58:24,509 --> 00:58:28,544
把在 这一个循环，所以我们 有 

1118
00:58:27,042 --> 00:58:30,611
假设收到一个生病的 

1119
00:58:28,859 --> 00:58:34,901
孩子如果我们得到一个生病的孩子有可能 

1120
00:58:30,989 --> 00:58:38,880
有多个终止的孩子，我们 

1121
00:58:35,279 --> 00:58:41,303
有，我们有收获，所以我们 

1122
00:58:38,088 --> 00:58:42,165
把我们提出，在这个循环中， 我们 

1123
00:58:41,519 --> 00:58:46,410
执行这个循环，直到有没有更多的

1124
00:58:43,065 --> 00:58:49,754
终止儿童在这种情况下 等待 

1125
00:58:46,041 --> 00:58:52,880
将将将退出并返回错误代码 

1126
00:58:50,339 --> 00:58:55,346
减去一个和 孩子的 eronel这样的

1127
00:58:53,249 --> 00:58:57,450
这是不是 真的 ，它只是它 的一个错误 

1128
00:58:56,039 --> 00:58:59,108
只是意味着没有更多的终止 

1129
00:58:57,045 --> 00:59:02,144
孩子，所以我们只要检查是否我们

1130
00:58:59,729 --> 00:59:04,754
错误知道 淘气的孩子 则有 

1131
00:59:02,549 --> 00:59:08,190
一个错误，否则 我们终止 

1132
00:59:04,979 --> 00:59:12,660
通常，我们目前预计，如果我们运行 

1133
00:59:08,019 --> 00:59:17,042
此代码现在我们大家看到 ，我们所有的收获 

1134
00:59:12,066 --> 00:59:16,142
五个孩子是我们应该 

1135
00:59:17,088 --> 00:59:24,093
好了，所以看的 有 问题的一长串 

1136
00:59:22,033 --> 00:59:27,106
第一个信号， 它可以很容易编写 

1137
00:59:24,093 --> 00:59:30,129
处理程序并不安全第二它的 

1138
00:59:28,006 --> 00:59:33,082
容易 得到语义错误的 第三 

1139
00:59:31,029 --> 00:59:35,035
他们 往往 跨越 是 连便携式 

1140
00:59:33,082 --> 00:59:38,089
Unix的 不同版本Vernors 

1141
00:59:35,089 --> 00:59:40,123
所以有一些老的系统我不 

1142
00:59:38,089 --> 00:59:43,548
知道任何有一些早期

1143
00:59:41,023 --> 00:59:47,074
的Unix版本，你抓后 

1144
00:59:44,349 --> 00:59:50,080
信号恢复到默认操作 ，以便 

1145
00:59:47,074 --> 00:59:52,081
你必须每次重新安装处理程序 

1146
00:59:50,008 --> 00:59:54,043
每一个处理程序获取时间以及时间

1147
00:59:52,081 --> 00:59:55,860
叫你不得不重新安装 

1148
00:59:54,043 --> 00:59:58,114
通过调用内部信号处理程序

1149
00:59:56,589 --> 01:00:03,594
处理本身，我们没有做 

1150
00:59:59,014 --> 01:00:07,090
这适用于Linux 在某些 系统 上 

1151
01:00:04,089 --> 01:00:12,090
当你 所谓的慢 SIS 系统 

1152
01:00:07,009 --> 01:00:14,101
呼吁例如读取你知道，如果你 

1153
01:00:12,099 --> 01:00:18,400
做一个读系统调用内核不

1154
01:00:15,082 --> 01:00:21,181
在附近等 数据到达是 

1155
01:00:18,004 --> 01:00:24,213
它，你知道它发送一个请求 

1156
01:00:22,081 --> 01:00:26,140
磁盘控制器和 时间表 

1157
01:00:24,609 --> 01:00:29,658
另一个程序的权利等等的方式 ， 

1158
01:00:27,004 --> 01:00:32,008
读取调用进行排序，然后只有当 

1159
01:00:30,099 --> 01:00:35,140
数据到达和中断到来 

1160
01:00:32,044 --> 01:00:37,090
在宣布数据到达呢 

1161
01:00:35,014 --> 01:00:40,051
该读取通话结束后恢复 

1162
01:00:37,009 --> 01:00:41,086
并 返回 所以你可以把 读的是 

1163
01:00:40,051 --> 01:00:49,096
其实那种分为两个 

1164
01:00:42,067 --> 01:00:52,078
部分权没有和使功能 

1165
01:00:49,096 --> 01:00:54,190
喜欢读这几 样功能 

1166
01:00:52,078 --> 01:00:58,126
所谓慢SIS通话和一些

1167
01:00:55,009 --> 01:01:02,040
如果该过程接收的信号系统

1168
01:00:59,026 --> 01:01:05,098
前一个缓慢的 系统调用已完成 

1169
01:01:03,021 --> 01:01:08,026
内核将只会是中止 

1170
01:01:05,098 --> 01:01:10,189
系统调用 在 从该系统返回 

1171
01:01:08,026 --> 01:01:13,123
有错误好了，所以从 用户的呼叫

1172
01:01:11,089 --> 01:01:16,156
的角度来看，你正在做的读取调用 

1173
01:01:14,023 --> 01:01:20,029
并将其与此此电子邮件进入返回

1174
01:01:17,056 --> 01:01:21,585
这个信号e输入错误，您做了 

1175
01:01:20,083 --> 01:01:22,177
没有错，你恰好有 

1176
01:01:22,089 --> 01:01:26,140
由被打断的厄运 

1177
01:01:23,077 --> 01:01:28,163
在用户代码中的一些信号等你 

1178
01:01:26,014 --> 01:01:30,092
要检查 这一点 ，如果如果他们 

1179
01:01:29,063 --> 01:01:32,090
慢行系统调用，比如读是 

1180
01:01:30,092 --> 01:01:34,145
被信号中断，你必须重做 

1181
01:01:32,009 --> 01:01:35,938
它，就必须把这实在是一个 

1182
01:01:35,045 --> 01:01:39,116
疼痛正确的，因为你必须把这些 

1183
01:01:36,829 --> 01:01:42,880
这些阅读在一个循环调用，并保持保持 

1184
01:01:40,016 --> 01:01:45,041
循环，直到成功为止，最后 

1185
01:01:43,339 --> 01:01:49,366
有些系统不阻塞的信号

1186
01:01:45,041 --> 01:01:51,910
类型是正确的处理，这样 的解决方案 

1187
01:01:49,609 --> 01:01:53,650
因为这是对于信号的替代，以便 

1188
01:01:52,279 --> 01:01:56,332
问题是与该信号 siskel 

1189
01:01:54,019 --> 01:01:59,101
解决的办法是叫一个较新的SIS 

1190
01:01:56,809 --> 01:02:02,930
称为齐格作用，这提供了一种 

1191
01:01:59,839 --> 01:02:04,864
机构用于信号替换该 

1192
01:02:02,093 --> 01:02:07,012
提供了一种机制用于便携式和

1193
01:02:05,089 --> 01:02:11,450
可预见的信号处理等什么

1194
01:02:07,849 --> 01:02:14,947
我所做 的就是创建了一个 我做了 什么 

1195
01:02:11,045 --> 01:02:18,664
说唱歌手所谓的大写的信号 

1196
01:02:15,829 --> 01:02:22,880
采用相同的参数的信号

1197
01:02:19,069 --> 01:02:25,144
呼叫，但里面调用签名行动 

1198
01:02:22,088 --> 01:02:30,007
函数来获取便携式信号处理 

1199
01:02:25,819 --> 01:02:34,819
所以这是它 不是真的很重要 

1200
01:02:30,799 --> 01:02:36,822
进入详细 介绍这一点是 

1201
01:02:34,819 --> 01:02:40,430
在你的代码，你 总是想打电话 

1202
01:02:37,029 --> 01:02:43,105
使用说唱大写信号 

1203
01:02:40,043 --> 01:02:45,442
在 硅Si PP C点 提供 ，然后，如果 

1204
01:02:43,789 --> 01:02:47,150
你这样做，那么你将永远 阻止 

1205
01:02:45,829 --> 01:02:49,880
信号的打字 

1206
01:02:47,015 --> 01:02:52,094
自动处理系统将 

1207
01:02:49,088 --> 01:02:57,164
重新启动已经接近电话 

1208
01:02:52,094 --> 01:03:01,141
中断由信号 好了，所以 

1209
01:02:58,064 --> 01:03:01,141
幸好有一个简单的办法解决这个 

1210
01:03:03,046 --> 01:03:09,625
现在让我们，让我们完成了 他们 

1211
01:03:07,072 --> 01:03:11,131
有一些有趣的，我提到 

1212
01:03:10,039 --> 01:03:13,430
该信号是困难的，因为 

1213
01:03:11,779 --> 01:03:15,808
这些事实 ，他们是他们 

1214
01:03:13,043 --> 01:03:17,932
并发流，所以我想看看 

1215
01:03:16,069 --> 01:03:21,400
某种微妙的问题，你可以 

1216
01:03:18,319 --> 01:03:24,319
到因为这个并发运行 ， 

1217
01:03:21,004 --> 01:03:27,088
我想谈谈如何 识别 

1218
01:03:24,319 --> 01:03:28,240
这些错误以及 如何解决 这些 问题 

1219
01:03:30,052 --> 01:03:37,063
所以这里有一个程序， 这是一个像 

1220
01:03:34,003 --> 01:03:39,088
维护一个简单的shell程序

1221
01:03:37,063 --> 01:03:42,151
作业列表每一次正确因此 它创建 

1222
01:03:39,088 --> 01:03:45,145
一个新的孩子就其添加到任务列表中 

1223
01:03:43,051 --> 01:03:52,075
而每一次当孩子终止它 

1224
01:03:46,045 --> 01:03:55,123
删除它从作业列表好了，所以 

1225
01:03:52,075 --> 01:03:58,096
我们简单的外壳只是在一个循环中，它只是 

1226
01:03:56,023 --> 01:04:02,074
创建一个子，然后执行 

1227
01:03:58,096 --> 01:04:05,098
那个孩子中，然后在程序

1228
01:04:02,074 --> 01:04:07,138
父它正确地阻止所有的

1229
01:04:06,016 --> 01:04:12,079
暂时的信号，同时它增加了一个

1230
01:04:08,038 --> 01:04:15,055
作业添加到作业队列，然后将其

1231
01:04:12,079 --> 01:04:18,115
放开，然后解封 那些 

1232
01:04:15,055 --> 01:04:21,058
还好信号，所以这是正确的 ， 

1233
01:04:19,015 --> 01:04:27,043
它保护访问这个共享 

1234
01:04:21,085 --> 01:04:29,122
作业队列，因为这是该作业 

1235
01:04:27,043 --> 01:04:33,043
该作业队列也被操纵 

1236
01:04:30,022 --> 01:04:36,040
病儿 的处理程序，所以当一个时 

1237
01:04:33,043 --> 01:04:41,110
终止童和家长接受

1238
01:04:36,004 --> 01:04:43,069
该处理器运行信号，这 

1239
01:04:42,001 --> 01:04:46,024
处理经过，并收获所有的 

1240
01:04:44,005 --> 01:04:48,091
孩子们可能终止

1241
01:04:46,033 --> 01:04:51,118
孩子再为每 一个 它 

1242
01:04:48,091 --> 01:04:54,540
删除从作业队列作业 

1243
01:04:52,018 --> 01:04:56,089
好吧所以这里是一个 典型的情况下，我们 

1244
01:04:55,359 --> 01:05:00,780
有两个并发流我们的主要

1245
01:04:56,089 --> 01:05:02,113
常规和我们的我们的信号处理程序

1246
01:05:00,078 --> 01:05:05,163
他们每个访问共享数据 

1247
01:05:03,013 --> 01:05:12,078
结构在这种 情况下，作业队列 

1248
01:05:06,063 --> 01:05:14,116
好吧，他们是正确的有 

1249
01:05:12,078 --> 01:05:18,175
阻塞信号而他们更新这 

1250
01:05:15,016 --> 01:05:24,035
这个作业队列但这个 方案有一个 

1251
01:05:19,075 --> 01:05:29,156
真是微妙和它讨厌的错误 

1252
01:05:24,035 --> 01:05:33,038
你可以看到它是什么， 什么是

1253
01:05:30,056 --> 01:05:42,058
事件的顺序，将导致此 

1254
01:05:33,065 --> 01:05:42,076
程序失败是

1255
01:05:46,062 --> 01:05:51,120
正是这正是它如此是它 

1256
01:05:49,075 --> 01:05:53,170
可能是因为子进程 

1257
01:05:52,002 --> 01:05:56,050
可以终止家长有一个前 

1258
01:05:54,007 --> 01:05:59,008
机会是作业添加到队列中 ， 

1259
01:05:56,068 --> 01:06:01,087
答案是肯定正确的 ，我们就可以不 

1260
01:05:59,008 --> 01:06:03,016
做出关于执行任何假设 

1261
01:06:01,087 --> 01:06:06,111
在这个过程中孩子的顺序或 

1262
01:06:04,006 --> 01:06:10,039
关于他们的权利所以它的运行多久 

1263
01:06:07,011 --> 01:06:13,096
它 很可能 是孩子能 

1264
01:06:10,093 --> 01:06:14,152
四个控制后连接后

1265
01:06:13,096 --> 01:06:16,165
返回到孩子，而不是 

1266
01:06:15,052 --> 01:06:19,084
父母，然后孩子终止 

1267
01:06:17,065 --> 01:06:22,072
之前父曾经有机会 

1268
01:06:19,084 --> 01:06:28,087
该作业添加到作业队列所以现在 

1269
01:06:23,035 --> 01:06:32,068
发生了什么事是 ，孩子 

1270
01:06:29,014 --> 01:06:35,017
删除删除具有不工作

1271
01:06:32,068 --> 01:06:36,115
被 添加到 作业队列权 

1272
01:06:35,017 --> 01:06:39,061
现在当父母终于得到周围 

1273
01:06:37,015 --> 01:06:42,021
要运行它补充说，工作就是工作 

1274
01:06:39,061 --> 01:06:46,122
排队和作业将永远不会 被删除 

1275
01:06:42,075 --> 01:06:49,093
所以这是那种微妙讨厌的 

1276
01:06:47,022 --> 01:06:51,099
可怕的一种错误， 你碰上 

1277
01:06:49,093 --> 01:06:53,125
当你处理并发 

1278
01:06:51,099 --> 01:06:55,198
试图让所有的 这些 轨道 

1279
01:06:54,025 --> 01:07:00,040
事件的交织可以只让

1280
01:06:56,098 --> 01:07:02,143
你的头 ，现在突然 爆炸 ，它 

1281
01:07:00,004 --> 01:07:05,005
发生和Sigma与任何情况 

1282
01:07:03,043 --> 01:07:06,088
一种并发的，你必须 

1283
01:07:05,041 --> 01:07:08,107
并发流访问共享 

1284
01:07:06,088 --> 01:07:10,147
资源和信号处理程序是没有 

1285
01:07:09,007 --> 01:07:13,009
现在不同了，我们来看看原则 

1286
01:07:11,047 --> 01:07:15,054
方式，我们可以应付这种 

1287
01:07:13,009 --> 01:07:18,097
当我们后来研究线程共享

1288
01:07:16,017 --> 01:07:23,041
但我只是想指出 这一点你 

1289
01:07:18,097 --> 01:07:26,134
和吓唬你一点点没事 如此 

1290
01:07:23,041 --> 01:07:30,139
这里就是我们将如何解决这个问题正是我们 

1291
01:07:27,034 --> 01:07:34,126
需要做的就是以某种方式避免避免

1292
01:07:31,039 --> 01:07:38,121
该避免的可能性 

1293
01:07:35,026 --> 01:07:42,037
孩子处理程序之前执行

1294
01:07:39,021 --> 01:07:44,074
家长可以相应的作业添加到 

1295
01:07:42,037 --> 01:07:46,102
作业队列现在我们无法控制

1296
01:07:44,074 --> 01:07:49,081
孩子是否执行第一或 

1297
01:07:47,002 --> 01:07:52,048
父执行第一 ，我们不能 

1298
01:07:49,081 --> 01:07:55,117
孩子的运行控制多久，但我们 

1299
01:07:52,048 --> 01:07:57,142
可以控制当 大孩子处理程序 

1300
01:07:56,017 --> 01:08:02,946
运行，因为我们可以 阻止信号 

1301
01:07:58,042 --> 01:08:08,065
好了，所以我们要做的，我们要修改我们的 

1302
01:08:03,099 --> 01:08:12,010
节目你会SIG的 PROC 面具 

1303
01:08:08,065 --> 01:08:14,116
块SIG 平铺信号 ，我们 之前 创建 

1304
01:08:12,001 --> 01:08:17,940
孩子好了，所以在这一点后， 

1305
01:08:15,016 --> 01:08:22,033
这个调用SIG PROC SIG的孩子 

1306
01:08:17,949 --> 01:08:26,790
信号好阻止后来我们创造 

1307
01:08:22,033 --> 01:08:29,062
孩子和我们做我们的鸡蛋XEE前 

1308
01:08:26,079 --> 01:08:31,117
因为我们不知道，孩子可能将在5 

1309
01:08:29,062 --> 01:08:36,088
需要获得其子女的权利，我们不 

1310
01:08:32,017 --> 01:08:39,115
知道，如果它在默认情况下 继承的孩子 

1311
01:08:36,088 --> 01:08:43,141
的阻塞的位向量其

1312
01:08:40,015 --> 01:08:46,704
父母好，所以当这个 孩子运行F- 

1313
01:08:44,041 --> 01:08:48,660
后从叉子在这一点上返回 

1314
01:08:46,839 --> 01:08:51,873
右后 叉 SIG孩子 

1315
01:08:49,029 --> 01:08:53,100
挡在了孩子，以及正确的，所以如果 

1316
01:08:52,179 --> 01:08:58,060
我们没有做任何事情，如果孩子 

1317
01:08:53,739 --> 01:08:59,560
创建儿童和尝试种瓜得 

1318
01:08:58,006 --> 01:09:00,915
知道有一个生病的孩子 把手他们收获

1319
01:08:59,056 --> 01:09:02,152
那生病的孩子处理程序将无法运行

1320
01:09:00,969 --> 01:09:05,040
右所以这将是一个问题，所以在 

1321
01:09:03,052 --> 01:09:07,110
孩子之前，我们 执行的是 

1322
01:09:05,679 --> 01:09:10,480
程序本身我们 疏通 生病的孩子和 

1323
01:09:08,001 --> 01:09:12,450
这是我被 暗指 的示例 

1324
01:09:10,048 --> 01:09:15,867
于它是如何有用的最后一次

1325
01:09:12,549 --> 01:09:20,620
有时 以分离创建进程 

1326
01:09:16,299 --> 01:09:23,140
有好的执行程序，以便本 

1327
01:09:20,062 --> 01:09:24,681
使我们 能够 得到我们的我们的信号 掩码 集合 

1328
01:09:23,014 --> 01:09:31,060
向上的方式，我们希望 我们运行 之前 我们 

1329
01:09:25,239 --> 01:09:36,285
程序在孩子所以现在即使 

1330
01:09:31,006 --> 01:09:39,037
孩子早期终止的 SIG孩子 

1331
01:09:36,699 --> 01:09:42,774
处理程序将无法运行，直到我们经过 

1332
01:09:39,091 --> 01:09:45,163
添加作业到作业队列 

1333
01:09:43,449 --> 01:09:52,484
因为我们不解除SIG的孩子，直到 

1334
01:09:46,063 --> 01:09:52,232
之后，直到后我们所说的工作好吗 

1335
01:09:56,063 --> 01:10:02,064
还好现在有另一个所以这本 

1336
01:09:59,064 --> 01:10:04,373
那种情景将 是非常 相关的 

1337
01:10:02,064 --> 01:10:06,069
你当你做你的shell实验室好吗 

1338
01:10:04,949 --> 01:10:12,900
所以你要小心， 不要 不要 

1339
01:10:06,069 --> 01:10:14,082
犯 这种错误的另一个另一件事 

1340
01:10:12,009 --> 01:10:16,050
你你 将需要做的 

1341
01:10:14,082 --> 01:10:18,090
你的shell实验室现在你 还记得 我们 

1342
01:10:17,031 --> 01:10:21,108
简单简单的shell例子，我们做了

1343
01:10:19,062 --> 01:10:23,138
重量主程序，所以我们内部 

1344
01:10:22,008 --> 01:10:26,897
等待使用重量就业前景 

1345
01:10:24,038 --> 01:10:28,077
但是现在真正的外壳，我们要 

1346
01:10:26,969 --> 01:10:31,830
有我们生病的孩子处理程序做 所有这些 

1347
01:10:28,077 --> 01:10:33,144
所有的方式调用所有的权重和 

1348
01:10:31,083 --> 01:10:35,151
it.we所以我们不能把重量有 

1349
01:10:34,044 --> 01:10:42,123
走在CIG 孩子处理程序不能进去 

1350
01:10:36,051 --> 01:10:44,240
主程序好了，所以这么高，如果 

1351
01:10:43,023 --> 01:10:47,088
我们不能把重量在主 

1352
01:10:44,699 --> 01:10:50,100
日常我们怎么怎么的我们 

1353
01:10:47,088 --> 01:10:51,152
去检测， 我们的前台作业 

1354
01:10:50,001 --> 01:10:52,043
结束了

1355
01:10:55,969 --> 01:11:02,971
所以在某种程度上所以我们能做什么，我们能 

1356
01:10:59,021 --> 01:11:06,092
定义在 CIG孩子处理程序时，我们 

1357
01:11:02,989 --> 01:11:08,840
阅读我们已在前台工作的权利 

1358
01:11:06,092 --> 01:11:11,153
创建当我们读到一个前台作业

1359
01:11:08,084 --> 01:11:16,103
是前台作业 ，我们可以设置 这个 

1360
01:11:12,053 --> 01:11:20,075
全局标志，我们可以申报过程

1361
01:11:17,003 --> 01:11:23,006
这个过程ID 的变量PID 作为 

1362
01:11:20,075 --> 01:11:26,111
全局标志，然后就分配

1363
01:11:23,033 --> 01:11:30,038
的前景的过程想法

1364
01:11:27,011 --> 01:11:32,078
工作好了，所以这个是一个例子 

1365
01:11:30,083 --> 01:11:38,132
处理程序，它只是所做的只是设置一个

1366
01:11:32,078 --> 01:11:42,107
标志， 然后退出，然后在我们的主 

1367
01:11:39,032 --> 01:11:45,101
常规没关系 ， 我们要 ，我们要阻止 

1368
01:11:43,007 --> 01:11:48,026
齐格 卡尔只是 但 就像之前没关系 

1369
01:11:46,001 --> 01:11:53,057
为了避免那场比赛状态 

1370
01:11:48,026 --> 01:11:57,062
家长和孩子之间 

1371
01:11:53,057 --> 01:11:59,102
然后我们创建了孩子 ，然后和 

1372
01:11:57,062 --> 01:12:04,091
然后在再父我们设置

1373
01:12:00,002 --> 01:12:08,221
PID到好 零 ，则我们解除齐格 

1374
01:12:04,091 --> 01:12:10,094
孩子，然后我们等待生病 

1375
01:12:08,239 --> 01:12:16,264
孩子处理程序运行，并令T ID非 

1376
01:12:10,094 --> 01:12:18,853
零还好还好大家看到 我的意思 

1377
01:12:16,489 --> 01:12:23,260
这所以这是 正确的 权利，但它是 

1378
01:12:19,699 --> 01:12:27,751
极其浪费的权利，我们正在纺 

1379
01:12:23,026 --> 01:12:29,102
我们用宝贵的处理器周期中

1380
01:12:28,219 --> 01:12:31,520
这在这种紧密的自旋循环刚 

1381
01:12:30,002 --> 01:12:32,971
执行一遍又一遍又一遍，并 

1382
01:12:31,052 --> 01:12:35,093
一遍 又一遍又一遍 对谁知道如何 

1383
01:12:32,989 --> 01:12:38,840
长好了，这 不是一个好这 

1384
01:12:35,093 --> 01:12:39,140
没有一个很好的解决方案没事让我们 

1385
01:12:38,084 --> 01:12:42,086
看看其他几件事情 ，我们可能 

1386
01:12:40,004 --> 01:12:44,803
可以考虑与已 

1387
01:12:43,004 --> 01:12:50,203
通过213世代考虑

1388
01:12:45,199 --> 01:12:53,630
学生这么一件事，你可能会认为 

1389
01:12:50,239 --> 01:12:58,730
嗯，我会只是 ，而不是仅仅把一个 

1390
01:12:53,063 --> 01:13:01,072
分号在这里，我会停下来，然后我会 

1391
01:12:58,073 --> 01:13:04,312
等待着生病的孩子处理程序运行

1392
01:13:02,053 --> 01:13:07,382
然后我就回去了 ，我会检查 

1393
01:13:04,969 --> 01:13:09,986
我会再次检查ID 

1394
01:13:07,859 --> 01:13:13,530
现在你必须把这个循环它 

1395
01:13:10,139 --> 01:13:14,222
仍然是在 ，因为我们 一环 

1396
01:13:13,053 --> 01:13:17,252
在其他信号处理程序我们

1397
01:13:14,969 --> 01:13:18,995
节目中，我们有一个印处理程序，以便它 

1398
01:13:17,729 --> 01:13:20,804
如果我们在这里做的暂停可能是和 

1399
01:13:19,229 --> 01:13:24,323
这再次进来， 说 去获得 

1400
01:13:21,479 --> 01:13:26,558
处理运行时，会导致我们退出 

1401
01:13:25,169 --> 01:13:28,247
暂停功能和涨回去 ，所以我们 

1402
01:13:27,269 --> 01:13:31,260
必须继续检查PID因为我们 

1403
01:13:28,949 --> 01:13:34,050
不知道我们要不断检查 

1404
01:13:31,026 --> 01:13:36,425
具体 的 信号处理程序 见孩子 

1405
01:13:34,005 --> 01:13:40,124
处理程序运行，而不是其他处理 

1406
01:13:36,659 --> 01:13:45,737
可能运行 ，但其实这是 

1407
01:13:40,169 --> 01:13:49,174
错误的，因为 它有一个比赛，你可以看到 

1408
01:13:46,439 --> 01:13:48,517
什么种族 

1409
01:13:53,085 --> 01:13:56,172
有什么不对这个有一个很好的 

1410
01:13:55,005 --> 01:14:05,006
的机会，这件事情 将阻止 

1411
01:13:57,072 --> 01:14:04,151
永远是

1412
01:14:14,098 --> 01:14:20,737
是啊，这使该问题 

1413
01:14:18,949 --> 01:14:24,260
这个问题是像 这样，如果 

1414
01:14:21,619 --> 01:14:27,650
如果之后接收到的信号的信号

1415
01:14:24,026 --> 01:14:31,755
PID检查，但在暂停之前 

1416
01:14:27,065 --> 01:14:37,054
执行好这是可能的 权 

1417
01:14:31,989 --> 01:14:42,052
这是不可能的，但它可能如果 

1418
01:14:37,639 --> 01:14:44,685
如果信号在这里到达，则 

1419
01:14:42,619 --> 01:14:48,980
处理程序将组T ID为非零 和 

1420
01:14:45,099 --> 01:14:50,840
然后我们会执行 暂停和 

1421
01:14:48,098 --> 01:14:51,125
暂停将永远阻塞等待 

1422
01:14:50,084 --> 01:14:53,653
对于将 永远不会到来 的信号 

1423
01:14:52,025 --> 01:14:58,914
就是 因为这个SIG 头的信号 

1424
01:14:54,409 --> 01:15:02,150
已经来到了已经非常微妙权 

1425
01:14:59,139 --> 01:15:06,172
所以这段代码看起来 不错，它看起来 良性 

1426
01:15:02,015 --> 01:15:09,754
但它是错误的，并和你的程序 

1427
01:15:06,469 --> 01:15:12,770
就只是挂永远所以 我们说好 

1428
01:15:09,889 --> 01:15:14,510
还好这不是什么好，我们可以更换 

1429
01:15:12,077 --> 01:15:18,080
与睡眠暂停，所以我们可以说，让我们

1430
01:15:14,051 --> 01:15:20,057
让我们来检验T ID，然后睡了一段 

1431
01:15:19,007 --> 01:15:25,426
预定在该时间 量 

1432
01:15:21,011 --> 01:15:28,810
案例一秒钟，然后回去起来 

1433
01:15:25,489 --> 01:15:30,710
再次检查PID所以这同时这也是 

1434
01:15:28,909 --> 01:15:31,990
纠正它的通行权太慢我们

1435
01:15:30,071 --> 01:15:34,148
要求系统等待第二 

1436
01:15:32,719 --> 01:15:37,610
这是一个永恒的 和有有 

1437
01:15:35,048 --> 01:15:39,083
睡眠或 纳秒，你的形式

1438
01:15:37,061 --> 01:15:41,050
可以等待，而不是单位为秒你 

1439
01:15:39,083 --> 01:15:44,156
可以纳秒为单位，但等待

1440
01:15:41,599 --> 01:15:47,570
什么珍惜 你使用权它是 

1441
01:15:45,056 --> 01:15:49,735
所以这就是，如果你选择的值 是 

1442
01:15:47,057 --> 01:15:51,916
过大，那么你有这个问题的 

1443
01:15:50,239 --> 01:15:55,580
如果你选择了睡眠缓慢问题

1444
01:15:52,429 --> 01:15:58,483
时间太小，那么你 有 

1445
01:15:55,058 --> 01:16:01,407
另一个问题是它的效率低下等等

1446
01:15:58,969 --> 01:16:04,670
该解决方案是使用睡眠暂停 

1447
01:16:01,929 --> 01:16:08,780
这是我们要过去的最后一件事

1448
01:16:04,067 --> 01:16:11,556
看今天这么 SIG的暂停是 

1449
01:16:08,078 --> 01:16:14,150
函数，它接受一个信号掩模和 

1450
01:16:12,159 --> 01:16:19,130
它相当于一个不间断 

1451
01:16:15,005 --> 01:16:21,062
这三个语句，所以我们的版本

1452
01:16:19,013 --> 01:16:23,292
块被指定的信号

1453
01:16:22,007 --> 01:16:28,596
信号掩码 

1454
01:16:23,409 --> 01:16:28,434
然后它在这个意义上是原子

1455
01:16:29,005 --> 01:16:34,028
这 之后， 这两个 声明 

1456
01:16:33,029 --> 01:16:38,042
不能被 打断他们总是 

1457
01:16:34,073 --> 01:16:41,082
所以我们阻止这些 执行起来 好吗 

1458
01:16:38,042 --> 01:16:46,551
信号，然后我们执行暂停 

1459
01:16:41,739 --> 01:16:49,580
好了， 没有 信号的机会 

1460
01:16:46,929 --> 01:16:54,650
在之间的干扰这个计划 

1461
01:16:49,058 --> 01:16:57,367
SIG的PROC面具和暂停很好，而且 

1462
01:16:54,065 --> 01:17:00,634
然后，然后，当信号不进来 

1463
01:16:57,889 --> 01:17:03,889
和手柄的执行或 

1464
01:17:01,219 --> 01:17:07,228
原因暂停退出然后我们设置

1465
01:17:03,889 --> 01:17:10,280
面具回到它以前好了， 

1466
01:17:08,119 --> 01:17:13,190
那么正确的方式来等待一个信号

1467
01:17:10,028 --> 01:17:15,367
是使用SIG下面暂停 

1468
01:17:13,019 --> 01:17:19,031
方式，使这里是我们这里的我们的计划 

1469
01:17:15,619 --> 01:17:22,250
我们 再次 之前，我们创建了 我们 的孩子 

1470
01:17:19,031 --> 01:17:24,104
阻止SIG孩子那么我们创建子 

1471
01:17:22,025 --> 01:17:28,028
现在我们要 等待生病 

1472
01:17:25,004 --> 01:17:32,030
要接收的孩子现在病儿

1473
01:17:28,028 --> 01:17:35,030
还堵好，所以没有危险 

1474
01:17:32,003 --> 01:17:37,025
病儿处理好运行 

1475
01:17:35,003 --> 01:17:41,057
所以我们设置全局变量为零 

1476
01:17:37,052 --> 01:17:45,128
然后，而它，而它的 非零 

1477
01:17:41,084 --> 01:17:48,086
我们多次拨打 生病暂停和生病 

1478
01:17:46,028 --> 01:17:50,102
暂停使用以前的掩码 

1479
01:17:48,086 --> 01:17:53,128
成立了这里，所以 生病暂停使用 

1480
01:17:51,002 --> 01:17:57,010
在那里生病的孩子是畅通的面具

1481
01:17:54,028 --> 01:18:02,887
好吧，当我们，当我们进入这个第一 

1482
01:17:57,001 --> 01:18:07,120
CIG PROC面具 SIG孩子 这么 畅通 

1483
01:18:03,139 --> 01:18:10,610
这使得SIG内暂停SIG的 

1484
01:18:07,219 --> 01:18:14,270
瓷砖畅通 好了，所以它允许 

1485
01:18:10,061 --> 01:18:18,820
在处理程序，现在要接收或 

1486
01:18:14,027 --> 01:18:22,034
没事的执行，从而赢得它，它 

1487
01:18:19,369 --> 01:18:24,170
它安全， 因为 呃原子 的 

1488
01:18:22,034 --> 01:18:26,433
那些那些前两个性质 

1489
01:18:24,017 --> 01:18:30,070
说明

1490
01:18:26,739 --> 01:18:33,070
所以一旦所以它可能是 

1491
01:18:30,007 --> 01:18:35,032
一个生病的孩子里面隐含的中断，就可能

1492
01:18:33,007 --> 01:18:39,025
通过说另一个信号中断

1493
01:18:35,095 --> 01:18:40,177
像SIGINT还好在这种情况下，我们就不断循环， 

1494
01:18:39,025 --> 01:18:43,123
备份，我们会发现 ，PID仍然 

1495
01:18:41,077 --> 01:18:47,082
零 和我们回去到 生病暂停 

1496
01:18:44,023 --> 01:18:49,111
与生病的孩子 好吗 畅通 

1497
01:18:47,082 --> 01:18:51,100
这样才有意义给大家，现在 

1498
01:18:50,011 --> 01:18:53,107
所以这正是 我们想要的行为 

1499
01:18:52,000 --> 01:18:59,071
这里我们 不浪费资源，而且 

1500
01:18:54,007 --> 01:19:01,048
我们已经消除了比赛 好了，这就是 

1501
01:18:59,071 --> 01:19:02,152
好了，今天 如果你有兴趣的非 

1502
01:19:01,048 --> 01:19:06,085
非本地的跳跃是 这个奇怪的事情和 

1503
01:19:03,052 --> 01:19:09,057
看到允许函数返回 

1504
01:19:06,085 --> 01:19:11,164
这并不能称之为一些其他的功能 

1505
01:19:10,002 --> 01:19:14,029
但它在你的 课本定律描述和 

1506
01:19:12,064 --> 01:19:16,068
也正是在这里一些额外的幻灯片 

1507
01:19:14,029 --> 01:19:16,104
在这里如果你有兴趣 

