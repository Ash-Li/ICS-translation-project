1
00:00:00,003 --> 00:00:05,522
well good afternoon everybody welcome

2
00:00:01,909 --> 00:00:07,620
good to see you today we're going to

3
00:00:05,549 --> 00:00:10,583
continue our study of exceptional

4
00:00:07,062 --> 00:00:13,065
control flow by looking at some higher

5
00:00:10,889 --> 00:00:17,912
level mechanisms known as Linux signals

6
00:00:13,092 --> 00:00:19,101
and see non-local jumps now we're going

7
00:00:18,119 --> 00:00:22,160
to spend most of our most of our time

8
00:00:20,001 --> 00:00:25,068
looking at signals because they have a

9
00:00:22,529 --> 00:00:26,970
lot of subtleties the semantics can be

10
00:00:25,068 --> 00:00:27,096
kind of confusing so we're going to

11
00:00:26,097 --> 00:00:31,098
we're going to spend most of our time

12
00:00:27,096 --> 00:00:36,125
there and I'll mention the idea of

13
00:00:31,098 --> 00:00:37,185
non-local jumps but for details on those

14
00:00:36,989 --> 00:00:41,190
you'll want to look in your textbook and

15
00:00:38,085 --> 00:00:45,111
in the slides at the Supplemental slides

16
00:00:41,019 --> 00:00:49,023
at the end of this the slide deck now to

17
00:00:46,011 --> 00:00:53,085
motivate the notion of signals I want to

18
00:00:49,059 --> 00:00:56,618
want to talk a little bit about shell

19
00:00:53,085 --> 00:00:58,564
programs now as we mentioned last time

20
00:00:57,149 --> 00:01:01,920
there's only one way to create

21
00:00:59,329 --> 00:01:06,383
prophecies on a Linux system and that's

22
00:01:01,092 --> 00:01:07,158
using the for call in fact the all of

23
00:01:06,869 --> 00:01:11,310
the processes on the system actually

24
00:01:08,058 --> 00:01:12,111
form a hierarchy so that the very first

25
00:01:11,031 --> 00:01:16,160
process created when you boot the system

26
00:01:13,011 --> 00:01:19,017
up is the anit process which has the

27
00:01:16,439 --> 00:01:21,000
process ID of one and then all of the

28
00:01:19,017 --> 00:01:23,078
processes on the system are descendants

29
00:01:21,000 --> 00:01:27,063
of that of that init process

30
00:01:23,078 --> 00:01:29,157
now the anit process of when it starts

31
00:01:27,063 --> 00:01:31,122
up it creates demons which are

32
00:01:30,057 --> 00:01:35,109
long-running programs that provide

33
00:01:32,022 --> 00:01:39,045
services typically so for example a web

34
00:01:36,009 --> 00:01:41,028
server and other kinds of services that

35
00:01:39,045 --> 00:01:44,070
you always want running on the system

36
00:01:41,028 --> 00:01:46,104
and then eventually it creates login so

37
00:01:44,007 --> 00:01:48,746
called logging shells which provide the

38
00:01:47,004 --> 00:01:53,022
command line interface to to users so

39
00:01:49,439 --> 00:01:55,460
when you log in to a Linux system what

40
00:01:53,022 --> 00:02:00,071
you eventually get to is a login shell

41
00:01:55,649 --> 00:02:00,710
that's expecting you to type commands

42
00:02:00,073 --> 00:02:09,095
now the login login shelves execute

43
00:02:05,063 --> 00:02:12,125
programs on your your behalf so when we

44
00:02:09,095 --> 00:02:14,171
type something into the shell say we

45
00:02:13,025 --> 00:02:17,081
type the LS command we're asking we're

46
00:02:15,071 --> 00:02:22,169
asking the shell to run the executable

47
00:02:17,081 --> 00:02:24,176
program called LS and so what the shell

48
00:02:23,069 --> 00:02:28,091
will do is it will create a child and

49
00:02:25,076 --> 00:02:32,092
then it will execute LS within that

50
00:02:28,091 --> 00:02:34,190
child process and it's possible that

51
00:02:32,092 --> 00:02:40,097
that process may create other other

52
00:02:35,009 --> 00:02:42,038
child processes so a shell is an

53
00:02:41,042 --> 00:02:45,137
application program no different from

54
00:02:43,019 --> 00:02:49,106
any other program that executes programs

55
00:02:46,037 --> 00:02:51,128
on the behalf of users okay the the

56
00:02:50,006 --> 00:02:54,073
default shell for Linux is called bash

57
00:02:52,028 --> 00:02:59,707
but there's a there's other shells that

58
00:02:54,073 --> 00:03:01,090
that were created done earlier with

59
00:02:59,959 --> 00:03:04,910
earlier versions of Unix

60
00:03:01,009 --> 00:03:05,057
SH was the original shell called the

61
00:03:04,091 --> 00:03:07,187
bourne shell because it was created by

62
00:03:06,038 --> 00:03:10,109
steven born and when berkeley came out

63
00:03:08,087 --> 00:03:15,181
with their distribution of unix they

64
00:03:11,009 --> 00:03:20,128
created a shell called CSH now the the

65
00:03:16,081 --> 00:03:22,163
execution in a shell is a sequence of

66
00:03:20,209 --> 00:03:26,390
read and evaluate steps so first a shell

67
00:03:23,063 --> 00:03:28,094
prints out a prompt and then it waits

68
00:03:26,039 --> 00:03:30,065
for it waits for you to type something

69
00:03:28,094 --> 00:03:32,147
in on the command line and hit return

70
00:03:30,065 --> 00:03:37,067
okay and typically what you're what

71
00:03:33,047 --> 00:03:39,104
you're typing in is a is a command which

72
00:03:37,067 --> 00:03:40,160
is just the so the first thing you type

73
00:03:40,004 --> 00:03:43,453
is a command and then you follow that

74
00:03:41,006 --> 00:03:47,012
with optional arguments separated by

75
00:03:43,489 --> 00:03:49,489
spaces okay so once you hit once you

76
00:03:47,066 --> 00:03:52,675
type in a command and those optional

77
00:03:49,489 --> 00:03:56,780
arguments and hit return the shell

78
00:03:53,269 --> 00:04:00,860
checks for the end of file character

79
00:03:56,078 --> 00:04:03,097
which is a control D to terminal and if

80
00:04:00,086 --> 00:04:08,095
so it exits otherwise it evaluates that

81
00:04:03,799 --> 00:04:08,950
command line and the evaluation consists

82
00:04:09,028 --> 00:04:13,052
and then when it returns from the

83
00:04:11,051 --> 00:04:13,112
evaluation it just does the same thing

84
00:04:13,052 --> 00:04:18,095
over it

85
00:04:14,012 --> 00:04:23,012
now the evaluation consists of the

86
00:04:18,095 --> 00:04:28,127
following kinds of steps first it parses

87
00:04:23,012 --> 00:04:30,089
the command line and by and and in the

88
00:04:29,027 --> 00:04:33,029
process so it takes the command line

89
00:04:30,089 --> 00:04:35,144
which in this example is in buff and it

90
00:04:33,029 --> 00:04:39,056
produces an RV array okay where arc v-0

91
00:04:36,044 --> 00:04:43,052
is a command and then RV one and two and

92
00:04:39,056 --> 00:04:45,131
so on are the optional arguments and the

93
00:04:44,024 --> 00:04:49,079
convention in the shell is that if the

94
00:04:46,031 --> 00:04:51,035
command line is terminated by an

95
00:04:49,079 --> 00:04:53,132
ampersand then you're asking the shell

96
00:04:51,071 --> 00:04:56,072
to run that job to run that command in

97
00:04:54,032 --> 00:04:58,040
the background meaning the shell won't

98
00:04:56,081 --> 00:05:01,085
wait for that job to finish before it

99
00:04:59,012 --> 00:05:04,085
goes through its next read step if you

100
00:05:02,021 --> 00:05:06,023
if the the line that you type doesn't

101
00:05:04,085 --> 00:05:07,088
have an ampersand then you're asking the

102
00:05:06,041 --> 00:05:09,107
shell to to run that job in the

103
00:05:08,015 --> 00:05:17,018
foreground which means the shell will

104
00:05:10,007 --> 00:05:19,606
wait so so first we parse this this

105
00:05:17,018 --> 00:05:21,077
command line into an art V array and we

106
00:05:19,669 --> 00:05:25,360
return whether or not it was terminated

107
00:05:21,077 --> 00:05:28,094
by an ampersand B so B GG for background

108
00:05:25,036 --> 00:05:30,101
if art V zero is null then that means we

109
00:05:28,094 --> 00:05:33,107
just hit we just hit return right so as

110
00:05:31,001 --> 00:05:38,090
an empty line so we'll just return and

111
00:05:34,007 --> 00:05:40,106
just ignore those now a shell also

112
00:05:38,009 --> 00:05:45,010
implements the what are called built-in

113
00:05:41,006 --> 00:05:49,058
commands so various things like jobs b g

114
00:05:45,091 --> 00:05:50,138
FG are examples of built-in commands

115
00:05:49,058 --> 00:05:54,065
which are just implemented in the shell

116
00:05:51,038 --> 00:05:57,041
itself so if you type if the first thing

117
00:05:54,065 --> 00:06:00,164
you type if the command you enter is a

118
00:05:57,068 --> 00:06:03,101
built-in then the shell will it will

119
00:06:01,064 --> 00:06:06,086
check that it will check Arg be 0 for a

120
00:06:04,001 --> 00:06:09,077
to see if it's a built-in command and if

121
00:06:06,086 --> 00:06:13,091
it is it'll just execute it whatever

122
00:06:09,077 --> 00:06:15,125
whatever it is you asked it to do okay

123
00:06:13,091 --> 00:06:17,153
otherwise if it's not a built-in then

124
00:06:16,025 --> 00:06:21,042
that means that that you're asking the

125
00:06:18,053 --> 00:06:23,062
shell to run some program okay

126
00:06:21,042 --> 00:06:27,079
so in that case the shell will fork a

127
00:06:24,043 --> 00:06:32,131
child and then the child's will execute

128
00:06:27,079 --> 00:06:34,090
that program by calling exact ve passing

129
00:06:33,031 --> 00:06:37,063
is the first argument the name of the

130
00:06:34,009 --> 00:06:39,033
command and as the second and third

131
00:06:37,063 --> 00:06:40,132
arguments are V and the environment

132
00:06:40,014 --> 00:06:43,108
respectively

133
00:06:41,032 --> 00:06:46,033
now exact the e if you recall from last

134
00:06:44,008 --> 00:06:48,094
time never returns unless there's an

135
00:06:46,042 --> 00:06:52,111
error so it checks so we check it the

136
00:06:48,094 --> 00:06:53,101
return value for x XE e and if it

137
00:06:53,011 --> 00:06:56,080
returns less than zero

138
00:06:54,064 --> 00:06:59,136
in fact the only time it will return if

139
00:06:56,008 --> 00:07:02,065
it does return it will always return

140
00:07:00,036 --> 00:07:07,110
minus one but we're just being careful

141
00:07:03,037 --> 00:07:10,123
here so we check that for a an error and

142
00:07:08,001 --> 00:07:19,023
in print and error message if we find an

143
00:07:11,023 --> 00:07:22,081
error and then exit so once the once the

144
00:07:19,032 --> 00:07:24,061
once the parent gets control again then

145
00:07:22,081 --> 00:07:26,137
it waits for that foreground job to

146
00:07:24,061 --> 00:07:29,113
terminate okay so if it's not a

147
00:07:27,037 --> 00:07:34,069
background job then it waits for it to

148
00:07:30,013 --> 00:07:36,052
terminate by calling lakebed and waiting

149
00:07:34,069 --> 00:07:38,130
for that child that foreground job to

150
00:07:36,052 --> 00:07:41,065
terminate and then and reaping it

151
00:07:39,003 --> 00:07:44,056
otherwise if it's a background job it

152
00:07:41,065 --> 00:07:45,130
just prints a a message and goes on so

153
00:07:44,083 --> 00:07:46,174
this is really interesting right that

154
00:07:46,003 --> 00:07:48,091
there's really the only difference

155
00:07:47,074 --> 00:07:50,082
between a foreground job and a

156
00:07:49,018 --> 00:07:53,104
background job is just that the shell

157
00:07:50,082 --> 00:07:54,141
does await it on that job or not right

158
00:07:54,004 --> 00:08:00,097
so there otherwise there's really

159
00:07:55,041 --> 00:08:01,126
there's really no difference now what's

160
00:08:00,097 --> 00:08:05,194
the prob there's a problem with our

161
00:08:02,026 --> 00:08:08,065
example shell and that the problem is

162
00:08:06,094 --> 00:08:10,102
that we're we're doing the right thing

163
00:08:08,065 --> 00:08:14,140
for the foreground job we always have to

164
00:08:11,002 --> 00:08:19,093
reap these children so they so that

165
00:08:15,004 --> 00:08:21,085
there's their state can be released but

166
00:08:19,093 --> 00:08:23,146
we're not we're not doing anything to

167
00:08:22,021 --> 00:08:27,037
reap any background jobs right when if

168
00:08:24,046 --> 00:08:28,048
the background job so if not BG we're

169
00:08:27,037 --> 00:08:30,121
just printing a message and then we're

170
00:08:28,066 --> 00:08:33,164
returning and then we're continuing with

171
00:08:31,021 --> 00:08:36,104
this read evaluate step and never never

172
00:08:34,064 --> 00:08:40,082
going back and and taking care of that

173
00:08:37,004 --> 00:08:42,095
of that background job so this is a

174
00:08:40,082 --> 00:08:45,167
problem because that background job will

175
00:08:42,095 --> 00:08:47,159
eventually become if we have enough of

176
00:08:46,067 --> 00:08:49,136
those jobs we create a memory leak that

177
00:08:48,059 --> 00:08:52,103
could crash the system right so this is

178
00:08:50,036 --> 00:08:54,131
an error so what are we going to do

179
00:08:53,003 --> 00:08:57,101
about this well it turns out that

180
00:08:55,031 --> 00:09:02,084
exceptional control flow will help us

181
00:08:58,001 --> 00:09:05,057
solve this problem and what happens is

182
00:09:02,084 --> 00:09:06,167
that the kernel will notify the shell

183
00:09:05,057 --> 00:09:11,096
when when a any of its children

184
00:09:07,067 --> 00:09:13,139
terminate okay and then the shell can

185
00:09:11,096 --> 00:09:16,115
can then react to that and issue a wait

186
00:09:14,039 --> 00:09:19,097
pit okay and this notification that

187
00:09:17,015 --> 00:09:26,021
mechanism that the the kernel uses is

188
00:09:19,097 --> 00:09:30,154
something called a signal so a signal is

189
00:09:26,075 --> 00:09:34,076
a small message that the kernel delivers

190
00:09:31,054 --> 00:09:38,078
to a process to notify it that there's

191
00:09:34,085 --> 00:09:40,157
been some event in the system now so

192
00:09:38,078 --> 00:09:43,154
this is very similar to the exceptions

193
00:09:41,057 --> 00:09:46,085
that we studied the last time right

194
00:09:44,054 --> 00:09:51,110
except it's it's all implemented in

195
00:09:46,085 --> 00:09:52,151
software now kernel signals are always

196
00:09:52,001 --> 00:09:55,067
sent from the kernel but sometimes

197
00:09:53,051 --> 00:09:58,067
they're sent at the request of another

198
00:09:55,076 --> 00:09:59,158
process right sometimes the the kernel

199
00:09:58,067 --> 00:10:03,146
will notice that there's some event

200
00:10:00,058 --> 00:10:05,141
other times another process will ask the

201
00:10:04,046 --> 00:10:10,052
kernel to send a message to some other

202
00:10:06,041 --> 00:10:12,128
process now that we say that it's a

203
00:10:10,052 --> 00:10:14,123
small message because the only

204
00:10:13,028 --> 00:10:19,094
information that's contained in a signal

205
00:10:15,023 --> 00:10:22,037
is it it's a unique integer ID and the

206
00:10:19,094 --> 00:10:24,098
fact that it was it was it was delivery

207
00:10:22,037 --> 00:10:27,038
okay so that's so there's nothing else

208
00:10:25,034 --> 00:10:30,098
in a signal except except that it

209
00:10:27,038 --> 00:10:36,071
arrived and that it has some some some

210
00:10:30,098 --> 00:10:38,102
unique ID now examples of these are the

211
00:10:36,071 --> 00:10:42,118
sig int so signals have this like this

212
00:10:39,038 --> 00:10:42,046
unique ID and then they also have a name

213
00:10:43,008 --> 00:10:50,547
so the cig antis is what the when you

214
00:10:48,459 --> 00:10:55,420
type ctrl C at on the command line

215
00:10:51,339 --> 00:10:57,345
the colonel sends us again to every any

216
00:10:55,042 --> 00:10:59,211
processes in the foreground and the

217
00:10:57,399 --> 00:11:01,540
default action of receiving a SIGINT is

218
00:10:59,589 --> 00:11:02,676
to terminate right so this is how you're

219
00:11:01,054 --> 00:11:05,101
running a foreground job you hit control

220
00:11:03,459 --> 00:11:11,470
C you get the prompt back because it

221
00:11:06,001 --> 00:11:15,082
kills that job sig kill number nine can

222
00:11:11,047 --> 00:11:18,036
be used to kill terminate any program so

223
00:11:15,082 --> 00:11:20,170
these two have sig ant and sig kill have

224
00:11:18,459 --> 00:11:26,160
the same effect on the programs me that

225
00:11:21,007 --> 00:11:27,094
they kill the program the the unique

226
00:11:26,016 --> 00:11:30,085
aspect of sig kill is that there's no

227
00:11:28,057 --> 00:11:33,088
way to ignore it or override it okay so

228
00:11:30,085 --> 00:11:35,170
this is like the failsafe as we'll see

229
00:11:33,088 --> 00:11:39,163
there are there are ways to to catch and

230
00:11:36,007 --> 00:11:42,516
ignore other signals like SIGINT zigzag

231
00:11:40,063 --> 00:11:44,137
v is the our favorite sake fault

232
00:11:43,209 --> 00:11:47,890
segmentation violation so if you if you

233
00:11:45,037 --> 00:11:52,081
access a region of memory that's

234
00:11:47,089 --> 00:11:54,124
protected or or not legal then your

235
00:11:52,081 --> 00:11:59,113
program will the colonel will send your

236
00:11:55,024 --> 00:12:04,060
that process of SIG's egg V okay signal

237
00:12:00,013 --> 00:12:07,048
and the default the default effective of

238
00:12:04,006 --> 00:12:08,083
that is to terminate the program a sig

239
00:12:07,048 --> 00:12:10,117
alarm is a way within your program you

240
00:12:09,037 --> 00:12:14,496
can arrange for a signal to be sent to

241
00:12:11,017 --> 00:12:17,436
yourself so you can say inside your

242
00:12:14,829 --> 00:12:21,610
program send me a sig alarm signal in

243
00:12:17,589 --> 00:12:23,290
three seconds something like that so

244
00:12:21,061 --> 00:12:25,087
this is a way to do things like you can

245
00:12:23,029 --> 00:12:28,051
set up timers you can set up timeouts

246
00:12:25,087 --> 00:12:29,092
like if you want to exit if you want to

247
00:12:28,051 --> 00:12:33,064
set a timeout value and you're doing

248
00:12:29,092 --> 00:12:34,138
some some some work and you want to

249
00:12:33,064 --> 00:12:36,070
guard against that that work taking

250
00:12:35,038 --> 00:12:39,057
exceptionally long time you can you can

251
00:12:37,024 --> 00:12:41,092
you can use sig alarm to set a timeout

252
00:12:39,399 --> 00:12:43,404
and then a very important one is as

253
00:12:41,092 --> 00:12:46,121
we'll see that will be very important

254
00:12:43,899 --> 00:12:49,980
for our shell is the sig child signal

255
00:12:46,949 --> 00:12:51,970
which the colonel sends to a parent

256
00:12:49,098 --> 00:12:54,098
every time one of its children

257
00:12:51,097 --> 00:12:56,162
terminates or stops

258
00:12:54,098 --> 00:12:58,151
okay so this is we'll see now it will

259
00:12:57,062 --> 00:13:00,125
fit we'll see this is how we're going

260
00:12:59,051 --> 00:13:03,089
this is how our shell that is going to

261
00:13:01,025 --> 00:13:06,080
actually reap it it's all of its

262
00:13:03,089 --> 00:13:09,170
children right it's by taking advantage

263
00:13:06,008 --> 00:13:12,077
of the cig child signal but before I can

264
00:13:10,007 --> 00:13:19,046
show you that we need to go through a

265
00:13:13,049 --> 00:13:23,111
number of concepts around signals okay

266
00:13:20,009 --> 00:13:26,015
like I said the the semantics of signals

267
00:13:24,011 --> 00:13:31,016
it's probably one of the thorniest

268
00:13:26,015 --> 00:13:33,053
aspects of Linux it was it was developed

269
00:13:31,016 --> 00:13:39,077
very early in the the lifespan of Linux

270
00:13:33,053 --> 00:13:41,105
when and it maybe wasn't as clean as it

271
00:13:39,077 --> 00:13:42,158
could be right so in order to get a

272
00:13:42,005 --> 00:13:45,101
handle on signals we're going to be very

273
00:13:43,058 --> 00:13:48,127
careful about defining terms and very

274
00:13:46,001 --> 00:13:53,003
careful about the way we talk about them

275
00:13:49,027 --> 00:13:56,033
so we say that the kernel sends or

276
00:13:53,021 --> 00:14:01,028
delivers a signal to some destination

277
00:13:56,033 --> 00:14:04,034
process and it does this by setting some

278
00:14:01,091 --> 00:14:09,119
state in the context of the destination

279
00:14:04,043 --> 00:14:12,080
process now nothing happens except that

280
00:14:10,019 --> 00:14:15,032
some bits get changed in the destination

281
00:14:12,008 --> 00:14:17,072
process context okay there's no there's

282
00:14:15,032 --> 00:14:24,106
no impact of immediate impact of sending

283
00:14:18,044 --> 00:14:27,101
a signal now a kernel sends a signal

284
00:14:25,006 --> 00:14:31,013
either because it detected some event in

285
00:14:28,001 --> 00:14:34,067
the system like that like a child

286
00:14:31,013 --> 00:14:37,016
process is terminated for example or

287
00:14:34,067 --> 00:14:40,067
another process it has asked the kernel

288
00:14:37,016 --> 00:14:43,109
to send to deliver a process on a signal

289
00:14:40,067 --> 00:14:45,089
on its behalf and there's a number of

290
00:14:44,009 --> 00:14:49,031
ways to do that one of them is with the

291
00:14:45,089 --> 00:14:51,158
kill system call it's kind of an

292
00:14:49,031 --> 00:14:54,038
unfortunate tournament it's I mean the

293
00:14:52,058 --> 00:14:58,130
so kill is a general way to send signals

294
00:14:55,001 --> 00:15:01,040
and the the impact is not it is

295
00:14:59,003 --> 00:15:03,026
sometimes not to kill the program right

296
00:15:01,004 --> 00:15:05,080
but for some reason they chose to to

297
00:15:03,053 --> 00:15:05,116
call it kill

298
00:15:06,078 --> 00:15:14,103
now the destination process receives a

299
00:15:11,014 --> 00:15:18,091
signal when it's forced by the kernel to

300
00:15:15,003 --> 00:15:22,054
act in some way to react in some way to

301
00:15:18,091 --> 00:15:23,125
the delivery of the signal okay so these

302
00:15:22,054 --> 00:15:26,136
are two very different things sending a

303
00:15:24,025 --> 00:15:30,031
signal sets state in the context of the

304
00:15:27,036 --> 00:15:34,042
destination process receiving a signal

305
00:15:30,085 --> 00:15:37,093
is what happens when the destination

306
00:15:34,042 --> 00:15:40,086
process is finally forced by the kernel

307
00:15:37,093 --> 00:15:43,141
to act in some way to react in some way

308
00:15:40,086 --> 00:15:48,094
now some possible ways to react are to

309
00:15:44,041 --> 00:15:54,070
just ignore the signal okay to terminate

310
00:15:49,066 --> 00:15:56,155
the process or to catch the signal by

311
00:15:54,007 --> 00:15:59,011
executing a user level function called a

312
00:15:57,055 --> 00:16:01,141
signal handler so in this case when we

313
00:15:59,074 --> 00:16:05,149
when we catch signals it's very similar

314
00:16:02,041 --> 00:16:08,046
to the the and executes a signal handle

315
00:16:06,049 --> 00:16:11,122
it's very similar to executing a an

316
00:16:08,091 --> 00:16:13,135
exception handler in response to some

317
00:16:12,022 --> 00:16:16,063
kind of event in the system now the

318
00:16:14,035 --> 00:16:18,094
difference is that exception handlers

319
00:16:16,063 --> 00:16:20,109
are in the kernel signal handlers are

320
00:16:18,094 --> 00:16:25,095
actually just in your C code okay there

321
00:16:21,009 --> 00:16:31,054
and they execute in your in your process

322
00:16:25,095 --> 00:16:32,179
so the so the way to think about if if

323
00:16:31,054 --> 00:16:36,088
we catch a signal by executing a signal

324
00:16:33,079 --> 00:16:39,103
handler we have our process executing

325
00:16:36,088 --> 00:16:42,154
instructions and then the signal is

326
00:16:40,003 --> 00:16:47,020
received by that process so the kernel

327
00:16:43,054 --> 00:16:49,117
passes control to a signal handler which

328
00:16:47,002 --> 00:16:51,067
is also just in the code that's

329
00:16:50,017 --> 00:16:56,026
executing in the current process it's

330
00:16:51,085 --> 00:16:57,091
just a function in our in our C code the

331
00:16:56,026 --> 00:17:00,079
signal handler runs and when it returns

332
00:16:57,091 --> 00:17:02,176
it eventually returns back to the next

333
00:17:00,079 --> 00:17:05,167
instruction and then and we continue

334
00:17:03,076 --> 00:17:07,102
okay so it's just like kind of like an

335
00:17:06,067 --> 00:17:11,104
interrupt right we just temporarily

336
00:17:08,002 --> 00:17:14,065
pause what we're doing in the in our

337
00:17:12,004 --> 00:17:17,097
code to execute this this handler before

338
00:17:14,065 --> 00:17:17,097
just continuing on

339
00:17:18,011 --> 00:17:25,070
okay now we say that a signal is pending

340
00:17:21,014 --> 00:17:30,111
if it's been sent by the colonel but not

341
00:17:25,169 --> 00:17:32,880
you have received so if at any given

342
00:17:31,011 --> 00:17:34,700
point in time that can only be one

343
00:17:32,088 --> 00:17:37,247
pending signal of any particular type

344
00:17:34,799 --> 00:17:40,811
okay so this has very important

345
00:17:38,039 --> 00:17:43,530
consequences for using signals because

346
00:17:40,919 --> 00:17:45,750
you can't cue signals up right at any

347
00:17:43,053 --> 00:17:47,812
point in time there's there can only be

348
00:17:45,075 --> 00:17:51,734
one pending sig child signal for example

349
00:17:48,289 --> 00:17:55,230
or six against signal and if a

350
00:17:52,409 --> 00:17:58,740
subsequent sig child signals say is sent

351
00:17:55,023 --> 00:18:00,045
it just over writes well you can think

352
00:17:58,074 --> 00:18:01,173
of it as it has no impact

353
00:18:00,045 --> 00:18:04,004
it's just discarded right if there's

354
00:18:02,073 --> 00:18:05,076
already a pending signal so they don't

355
00:18:04,409 --> 00:18:10,484
they don't queue up in any meaningful

356
00:18:06,003 --> 00:18:13,892
way now our process can block the

357
00:18:11,159 --> 00:18:16,100
receipt of certain signals okay now it

358
00:18:13,919 --> 00:18:19,890
can't stop signals from being delivered

359
00:18:16,001 --> 00:18:22,190
but it can stop it can stop the process

360
00:18:19,089 --> 00:18:25,148
from having to react to those to that

361
00:18:22,289 --> 00:18:26,480
signal when it's received okay

362
00:18:26,087 --> 00:18:32,099
so block signals can be delivered but

363
00:18:30,069 --> 00:18:35,072
they won't be received until the signals

364
00:18:32,099 --> 00:18:35,099
unblocked

365
00:18:38,036 --> 00:18:47,084
and pending signals are received at most

366
00:18:40,085 --> 00:18:50,254
once now the colonel keeps track of the

367
00:18:47,084 --> 00:18:53,173
pending and blocked signals in bit

368
00:18:51,019 --> 00:18:57,082
vectors that will call pending and

369
00:18:53,929 --> 00:18:59,870
blocked and pending represent the set of

370
00:18:57,649 --> 00:19:01,738
pending signals right where each bit in

371
00:18:59,087 --> 00:19:04,133
the pending bits vector corresponds to

372
00:19:02,539 --> 00:19:06,612
some particular signal okay so this is

373
00:19:05,033 --> 00:19:10,049
why they can't be cued right because

374
00:19:07,269 --> 00:19:12,230
there's only one bit for any signal Kay

375
00:19:10,049 --> 00:19:14,488
there's only one bit in the bit vector

376
00:19:12,023 --> 00:19:16,034
and if we and when we deliver a signal

377
00:19:14,929 --> 00:19:18,710
we're just setting we'll set that bit

378
00:19:16,034 --> 00:19:20,087
the colonel will set that bit we deliver

379
00:19:18,071 --> 00:19:22,076
another signal of the same type it'll

380
00:19:20,087 --> 00:19:24,184
just set that bit again which has no as

381
00:19:22,076 --> 00:19:29,120
no effect

382
00:19:25,084 --> 00:19:31,100
now the colonel sets that the bit in

383
00:19:30,002 --> 00:19:33,981
pending when the signals delivered and

384
00:19:32,000 --> 00:19:38,045
it clears it when the signals received

385
00:19:34,179 --> 00:19:41,690
and the colonel also provides mechanism

386
00:19:38,045 --> 00:19:43,504
for users to block signals with this

387
00:19:41,069 --> 00:19:45,298
blocked bit vector so the block bit

388
00:19:43,909 --> 00:19:47,974
vector is the same size as the pending

389
00:19:45,919 --> 00:19:52,966
bit vector turns out it's just a 32 bit

390
00:19:48,559 --> 00:19:55,250
int okay and it can be set and cleared

391
00:19:53,389 --> 00:19:58,468
the bits and that can be set and cleared

392
00:19:55,025 --> 00:20:01,444
using the sig proc mask system call okay

393
00:19:59,179 --> 00:20:03,860
now there's the blocked in the Linux

394
00:20:01,669 --> 00:20:06,705
literature the blocked bit vector is

395
00:20:03,086 --> 00:20:06,255
also called the signal mask

396
00:20:09,035 --> 00:20:13,047
okay now we're going to look in a little

397
00:20:12,003 --> 00:20:15,072
more detail about sending and receiving

398
00:20:13,047 --> 00:20:19,095
signal so let's start first with sending

399
00:20:15,072 --> 00:20:22,137
signals first we need to understand the

400
00:20:19,095 --> 00:20:26,172
idea of a process group so every process

401
00:20:23,037 --> 00:20:30,060
belongs to exactly one process group and

402
00:20:27,072 --> 00:20:32,127
those so here I'm showing a shell that's

403
00:20:30,006 --> 00:20:36,084
in process it has a process ID of ten

404
00:20:33,027 --> 00:20:41,049
and a process group ID of ten the shell

405
00:20:37,038 --> 00:20:43,080
created a foreground job which has a

406
00:20:41,049 --> 00:20:45,054
process ID of twenty and a process group

407
00:20:43,008 --> 00:20:47,012
ID of twenty and then all of the

408
00:20:45,099 --> 00:20:50,100
children that this foreground job

409
00:20:47,084 --> 00:20:54,117
created have the same process group ID

410
00:20:51,009 --> 00:20:57,042
of twenty so these these process groups

411
00:20:55,017 --> 00:21:01,113
can be set by a system call set called

412
00:20:57,042 --> 00:21:04,056
the set process group ID and you can and

413
00:21:02,013 --> 00:21:07,074
you can fetch that process group using

414
00:21:04,056 --> 00:21:08,151
the get process group system call so you

415
00:21:07,074 --> 00:21:12,153
can see in this example what what the

416
00:21:09,051 --> 00:21:16,073
shell is done is it created a foreground

417
00:21:13,053 --> 00:21:19,098
child so it created this child and it

418
00:21:16,073 --> 00:21:23,124
changed the process group ID to be equal

419
00:21:19,098 --> 00:21:25,116
to the process ID of the child and then

420
00:21:24,024 --> 00:21:28,119
when this child created other child

421
00:21:26,016 --> 00:21:33,035
children they just inherited the same

422
00:21:29,019 --> 00:21:33,035
process group ID okay

423
00:21:34,025 --> 00:21:39,086
now this this notion of a process group

424
00:21:36,044 --> 00:21:42,053
is useful because it allows you to send

425
00:21:39,086 --> 00:21:43,178
signals to groups of processes at the

426
00:21:42,053 --> 00:21:47,078
same time and you can do that with a

427
00:21:44,078 --> 00:21:48,083
program called kill which is typically

428
00:21:47,078 --> 00:21:51,149
in /bin directory

429
00:21:49,028 --> 00:21:54,074
and that the kill program you can use

430
00:21:52,049 --> 00:21:56,102
the kill program to send an arbitrary

431
00:21:54,074 --> 00:21:59,102
signal to either an individual process

432
00:21:57,002 --> 00:22:05,015
or all the processes in one process

433
00:22:00,002 --> 00:22:09,074
group so let's look at an example this

434
00:22:05,015 --> 00:22:14,084
program this Forks program creates two

435
00:22:09,074 --> 00:22:17,162
children and with each of which has the

436
00:22:14,084 --> 00:22:19,121
process group of 24 eight one seven and

437
00:22:18,062 --> 00:22:22,981
of course they have different process

438
00:22:20,021 --> 00:22:26,114
they have different process IDs and so

439
00:22:23,539 --> 00:22:31,220
if we if we do a PS we see these two we

440
00:22:27,014 --> 00:22:32,069
see these two processes running and

441
00:22:31,022 --> 00:22:36,077
these just go into loop so they'll just

442
00:22:32,069 --> 00:22:41,135
they'll just run continuously okay now

443
00:22:36,077 --> 00:22:44,096
we can come we can use kill to kill an

444
00:22:42,035 --> 00:22:48,040
individual process for example so if we

445
00:22:44,096 --> 00:22:49,190
call it that the first argument

446
00:22:48,004 --> 00:22:52,076
indicates what signal you want to send

447
00:22:50,009 --> 00:22:55,031
so in this case it's its signal nine

448
00:22:53,012 --> 00:23:00,301
which is the cig kill signal so kill

449
00:22:56,012 --> 00:23:01,088
minus nine is is a very typical usually

450
00:23:00,409 --> 00:23:04,730
if you want to kill processes you just

451
00:23:01,088 --> 00:23:08,132
kill minus nine and actually one of my

452
00:23:04,073 --> 00:23:14,119
favorite otto lab Mik names for 213 was

453
00:23:09,032 --> 00:23:18,501
the nickname was killed - 915 - 1 3 so

454
00:23:15,019 --> 00:23:23,060
but then then the second argument is the

455
00:23:18,789 --> 00:23:27,200
if it's is the the process ID so this is

456
00:23:23,006 --> 00:23:30,065
asking this is asking the kernel to kill

457
00:23:27,002 --> 00:23:34,079
process ID - for a 1 8 by sending it a

458
00:23:31,019 --> 00:23:40,028
cig kill signal now if the if the

459
00:23:34,097 --> 00:23:42,286
process ID is is preceded by a - then it

460
00:23:41,009 --> 00:23:46,082
sends a signal to every process in

461
00:23:43,159 --> 00:23:47,870
process group - then it treats this

462
00:23:46,082 --> 00:23:50,087
argument as a process

463
00:23:47,087 --> 00:23:52,163
and it sends a signal to every process

464
00:23:51,032 --> 00:23:57,035
in that process group so in this case it

465
00:23:53,063 --> 00:24:00,142
will send a signal to both of these both

466
00:23:57,035 --> 00:24:03,098
of these children processes and then

467
00:24:01,042 --> 00:24:05,108
afterwards we if we do a PS we see that

468
00:24:03,098 --> 00:24:07,183
those processes are gone okay that it

469
00:24:06,008 --> 00:24:12,041
really did work that way

470
00:24:08,083 --> 00:24:15,089
now another way to send signals is by

471
00:24:12,041 --> 00:24:20,069
typing either control C or control Z at

472
00:24:15,089 --> 00:24:22,112
the to the command line control C causes

473
00:24:20,069 --> 00:24:24,145
the kernel to send a signal to every job

474
00:24:23,012 --> 00:24:31,049
in the foreground process group and

475
00:24:25,045 --> 00:24:33,137
control Z causes it to send a signal

476
00:24:31,049 --> 00:24:36,074
signal to every job in the in the

477
00:24:34,037 --> 00:24:38,072
foreground process group the default

478
00:24:36,074 --> 00:24:40,088
action for SIGINT is to terminate the

479
00:24:38,072 --> 00:24:43,079
process the default action for the cig T

480
00:24:40,088 --> 00:24:49,114
stop is to suspend the process stop it

481
00:24:43,079 --> 00:24:49,114
until it receives a sig CRT signal

482
00:24:54,299 --> 00:25:01,325
so you could see an example of this here

483
00:24:57,033 --> 00:25:05,342
we have a program that creates a parent

484
00:25:01,559 --> 00:25:06,625
and a child running in the foreground so

485
00:25:05,639 --> 00:25:09,644
the parents running in the foreground

486
00:25:07,219 --> 00:25:14,225
now when we type control Z to the

487
00:25:10,139 --> 00:25:17,165
command line the shell notifies us that

488
00:25:14,279 --> 00:25:21,355
it's suspended that process and if we do

489
00:25:17,399 --> 00:25:25,418
a PS we can see the parent and the child

490
00:25:22,039 --> 00:25:30,085
indeed are suspended so the PS indicates

491
00:25:25,589 --> 00:25:29,680
that it's suspended or stopped using RT

492
00:25:32,119 --> 00:25:37,216
now next we type in the built in the

493
00:25:34,829 --> 00:25:40,838
shell built in which is F G and F G

494
00:25:38,089 --> 00:25:46,097
restores those those suspended jobs to

495
00:25:41,729 --> 00:25:48,734
the foreground so after typing F G now

496
00:25:46,889 --> 00:25:51,941
we're running this our program again in

497
00:25:49,229 --> 00:25:55,271
the foreground and then we can kill it

498
00:25:52,409 --> 00:25:58,200
by typing ctrl C which which elicits a

499
00:25:55,649 --> 00:25:59,732
SIGINT whose default action is to

500
00:25:58,002 --> 00:26:04,471
terminate and then when we do a PS we

501
00:26:00,479 --> 00:26:04,498
see that indeed that's that they're gone

502
00:26:06,026 --> 00:26:12,109
now that a third way that we can send

503
00:26:08,075 --> 00:26:12,109
signals is by using the kill system call

504
00:26:14,005 --> 00:26:18,092
so here's an example of how that works

505
00:26:17,045 --> 00:26:23,060
so in this in this example we're

506
00:26:19,037 --> 00:26:25,112
creating end children now each of which

507
00:26:23,006 --> 00:26:28,075
goes into an infinite loop and we're

508
00:26:26,012 --> 00:26:32,075
recording this process idea of each

509
00:26:28,669 --> 00:26:34,720
child that we create and then in it we

510
00:26:32,075 --> 00:26:36,161
go in another loop we go through and we

511
00:26:35,179 --> 00:26:41,090
we kill each of those child processes

512
00:26:37,061 --> 00:26:43,061
with by using the kill function passing

513
00:26:41,009 --> 00:26:48,020
it the process ID and the signal that we

514
00:26:43,061 --> 00:26:51,010
want sent to that process okay and then

515
00:26:48,002 --> 00:26:53,006
we do our due diligence and reap each

516
00:26:51,559 --> 00:26:54,610
one of those children that we've

517
00:26:53,024 --> 00:26:56,953
terminated

518
00:26:54,061 --> 00:26:58,124
now this isn't strictly necessary

519
00:26:57,169 --> 00:27:03,620
because we're going to exit as soon as

520
00:26:59,024 --> 00:27:06,052
this 412 function returns we're going to

521
00:27:03,062 --> 00:27:09,083
exit the code so but we're just being

522
00:27:06,052 --> 00:27:11,961
you know careful here and maybe a little

523
00:27:09,083 --> 00:27:11,682
pedantic but

524
00:27:15,013 --> 00:27:24,019
okay now we're now let's look at how we

525
00:27:18,008 --> 00:27:28,052
process received signals now suppose

526
00:27:24,073 --> 00:27:31,118
process a is running along executing its

527
00:27:28,052 --> 00:27:33,059
user code and then there's a control

528
00:27:32,018 --> 00:27:37,019
passes into the kernel because of some

529
00:27:34,022 --> 00:27:40,031
exception now that exception can be

530
00:27:37,028 --> 00:27:43,115
either a timer going off maybe an

531
00:27:41,012 --> 00:27:47,078
interrupt or it can be a trap user calls

532
00:27:44,015 --> 00:27:50,059
a system call okay but it's always

533
00:27:47,078 --> 00:27:51,152
caused that the trap into the early

534
00:27:50,059 --> 00:27:55,136
transferring control into the kernel is

535
00:27:52,052 --> 00:27:57,131
always caused by some exception so at

536
00:27:56,036 --> 00:28:03,038
this point the kernel calls its

537
00:27:58,031 --> 00:28:05,126
scheduler function and it decides to to

538
00:28:03,038 --> 00:28:10,073
do a context switch from prophet a to

539
00:28:06,026 --> 00:28:14,027
process B and it gets processed be all

540
00:28:10,073 --> 00:28:16,076
set up and right before it returns from

541
00:28:14,036 --> 00:28:21,098
that exception and right before it's

542
00:28:17,003 --> 00:28:25,004
ready to pass control back to back to

543
00:28:21,098 --> 00:28:27,176
trust the user code and process B it

544
00:28:25,004 --> 00:28:33,068
checks for any signals that any pending

545
00:28:28,076 --> 00:28:36,152
signals okay and it does this by

546
00:28:33,068 --> 00:28:40,091
computing a bit vector PMD so pending

547
00:28:37,052 --> 00:28:43,061
non blocked which is the logical and of

548
00:28:40,091 --> 00:28:47,180
the pending bit vector and the inverse

549
00:28:44,042 --> 00:28:50,138
of the blocked bit vector okay so PMD is

550
00:28:48,008 --> 00:28:53,033
a list of all the pending signals that

551
00:28:51,038 --> 00:28:56,137
aren't blocked okay so these are all the

552
00:28:54,005 --> 00:29:01,010
pending signals that should be received

553
00:28:57,037 --> 00:29:03,128
if now as tnd is all zeros then there's

554
00:29:01,055 --> 00:29:07,097
no pending signals so it just returns it

555
00:29:04,028 --> 00:29:09,104
passes control back it passes control

556
00:29:07,097 --> 00:29:12,146
back to process B which can continue

557
00:29:10,004 --> 00:29:17,035
executing however if if PN B is nonzero

558
00:29:13,046 --> 00:29:20,123
then it chooses the smallest nonzero bit

559
00:29:17,035 --> 00:29:23,087
in PN B and it forces process P to

560
00:29:21,023 --> 00:29:26,023
receive that signal the corresponding

561
00:29:23,087 --> 00:29:25,123
signal

562
00:29:26,066 --> 00:29:35,145
the receipt of the signal triggers some

563
00:29:29,309 --> 00:29:39,480
action in in the process and then we

564
00:29:36,045 --> 00:29:42,132
repeat that for all the nonzero signals

565
00:29:39,048 --> 00:29:45,497
K that are not zero bits that are set in

566
00:29:43,032 --> 00:29:48,060
PMD and finally when we've gone all

567
00:29:45,929 --> 00:29:51,967
through all the non zero bits then we

568
00:29:48,006 --> 00:30:00,965
pass control to the next instruction in

569
00:29:52,309 --> 00:30:04,500
in the in process P so the receipt of a

570
00:30:01,559 --> 00:30:07,583
signal always triggers some action which

571
00:30:04,005 --> 00:30:09,063
is either the process terminates the

572
00:30:07,799 --> 00:30:13,799
process stops until it's restarted by a

573
00:30:10,008 --> 00:30:16,029
sig con signal the process ignores the

574
00:30:13,799 --> 00:30:21,750
signal okay so that's there's always

575
00:30:16,029 --> 00:30:25,035
some predefined default action but we

576
00:30:21,075 --> 00:30:28,104
can modify that that default action by

577
00:30:25,035 --> 00:30:32,133
using a function of system call called

578
00:30:29,004 --> 00:30:34,086
signal okay so we can now signal is a

579
00:30:33,033 --> 00:30:36,057
little that's another sort of misleading

580
00:30:34,086 --> 00:30:37,149
kind of term just like killed right

581
00:30:36,057 --> 00:30:39,656
because when we when we send a signal to

582
00:30:38,049 --> 00:30:42,126
a process we don't always want to kill

583
00:30:40,169 --> 00:30:45,900
it and signal doesn't actually signal

584
00:30:43,026 --> 00:30:48,051
anything it just it just modifies the

585
00:30:45,009 --> 00:30:51,012
default action associated with some

586
00:30:48,051 --> 00:30:57,220
signal okay so the signal function takes

587
00:30:52,002 --> 00:31:00,731
us a signal number and and then

588
00:30:57,679 --> 00:31:04,679
specifies a change in the default action

589
00:31:00,929 --> 00:31:06,840
for that signal and those default

590
00:31:04,679 --> 00:31:09,600
actions can be either to ignore the

591
00:31:06,084 --> 00:31:13,098
signal okay ignore signals of type

592
00:31:09,006 --> 00:31:18,042
signal revert to the default behavior

593
00:31:13,098 --> 00:31:19,152
for that signal or we can we can give it

594
00:31:18,096 --> 00:31:22,122
or it could be the address of a user

595
00:31:20,052 --> 00:31:25,070
level signal handler which is a function

596
00:31:23,022 --> 00:31:28,098
that we've declared in our C program

597
00:31:25,007 --> 00:31:30,021
okay it's there's nothing special about

598
00:31:28,098 --> 00:31:32,190
the function it has a certain prototype

599
00:31:30,084 --> 00:31:34,161
it has it takes a single argument which

600
00:31:33,009 --> 00:31:37,068
is the signal number so when that

601
00:31:35,061 --> 00:31:41,070
function gets called in

602
00:31:38,049 --> 00:31:48,053
lots to receiving a signal that argument

603
00:31:41,007 --> 00:31:51,021
will be set to the signal number so

604
00:31:48,053 --> 00:31:53,076
calling signal with a and specifying a

605
00:31:51,084 --> 00:31:56,100
signal handler is called installing a

606
00:31:53,076 --> 00:31:58,745
handler and then executing the handlers

607
00:31:57,000 --> 00:32:03,015
referred to as catching or executing

608
00:31:59,429 --> 00:32:05,490
they are handling the signal and and

609
00:32:03,015 --> 00:32:07,059
this handle event is just like an

610
00:32:05,049 --> 00:32:10,071
exception handler when it when it

611
00:32:07,059 --> 00:32:13,071
returns it will be when it's executed it

612
00:32:10,071 --> 00:32:15,126
will interrupt the whatever is currently

613
00:32:13,071 --> 00:32:17,145
executing in the process when it returns

614
00:32:16,026 --> 00:32:23,058
it will return back to that point and

615
00:32:18,045 --> 00:32:28,080
continue executing ok so here's a simple

616
00:32:23,058 --> 00:32:30,063
example of installing a handler so here

617
00:32:28,008 --> 00:32:35,019
in Maine where we're going to install a

618
00:32:31,008 --> 00:32:38,025
sig int handler which is called sig int

619
00:32:35,091 --> 00:32:40,170
underscore handler which is defined up

620
00:32:38,025 --> 00:32:44,031
here and the prototype for this function

621
00:32:41,007 --> 00:32:45,986
is returns nothing and it takes a single

622
00:32:44,085 --> 00:32:50,097
integer argument which is the signal

623
00:32:46,679 --> 00:32:53,460
number and returns nothing ok and after

624
00:32:50,097 --> 00:32:55,185
we install that handler then we're going

625
00:32:53,046 --> 00:32:58,053
to execute the pause this call which

626
00:32:56,085 --> 00:32:59,169
just waits for a signal handler to

627
00:32:58,053 --> 00:33:02,150
execute ok so pause terminates the

628
00:33:00,069 --> 00:33:05,151
current or suspense the current process

629
00:33:03,005 --> 00:33:08,013
until a signal is received and a handler

630
00:33:06,051 --> 00:33:13,059
executes in that process and then pause

631
00:33:09,003 --> 00:33:16,086
then pause returns so we're going to

632
00:33:13,059 --> 00:33:21,087
wait until the SIGINT happens so sig

633
00:33:17,013 --> 00:33:23,055
entry call is when we type control C so

634
00:33:21,087 --> 00:33:24,135
when you were doing your bombs did did

635
00:33:23,055 --> 00:33:28,056
you panic at some point and try to hit

636
00:33:25,035 --> 00:33:32,040
ctrl C to get out of it ok so that

637
00:33:28,065 --> 00:33:33,144
snarky message you got that was we did

638
00:33:32,004 --> 00:33:38,043
that by by installing a signal house

639
00:33:34,044 --> 00:33:40,107
SIGINT handler in in your bomb ok so

640
00:33:38,079 --> 00:33:43,134
when when you type control C that

641
00:33:41,007 --> 00:33:48,356
elicits a SIGINT when that SIGINT is

642
00:33:44,034 --> 00:33:49,115
received we printed this message and

643
00:33:48,419 --> 00:33:59,210
then eventually

644
00:33:50,015 --> 00:34:01,112
let you exit now signaler signals are

645
00:33:59,021 --> 00:34:05,470
another examples of concurrency now

646
00:34:02,012 --> 00:34:10,099
we've seen concurrency earlier in the

647
00:34:05,659 --> 00:34:14,810
form of processes right concurrent flows

648
00:34:10,099 --> 00:34:17,107
overlapping in time okay logical flows

649
00:34:14,081 --> 00:34:23,123
overlapping in time by definition are

650
00:34:18,007 --> 00:34:25,082
concurrent now with with processes the

651
00:34:24,023 --> 00:34:27,922
because they have separate address

652
00:34:25,082 --> 00:34:29,161
spaces those concurrent flows never

653
00:34:28,129 --> 00:34:32,206
interfere with each other right so in

654
00:34:29,899 --> 00:34:35,000
some sense prophecies are very easy to

655
00:34:32,899 --> 00:34:39,230
deal with and we don't really have to

656
00:34:35,000 --> 00:34:43,007
worry about being interfered with by

657
00:34:39,023 --> 00:34:45,098
another process in fact you have to go

658
00:34:43,007 --> 00:34:48,786
to great lengths to share like to share

659
00:34:45,098 --> 00:34:50,126
things between processes you have to use

660
00:34:48,849 --> 00:34:55,520
specific system calls in order to say

661
00:34:51,026 --> 00:34:57,625
share memories between two processes now

662
00:34:55,052 --> 00:34:59,063
signals are another form of concurrency

663
00:34:57,859 --> 00:35:03,310
this is the second time this class that

664
00:34:59,063 --> 00:35:05,099
that you've experienced concurrency and

665
00:35:03,031 --> 00:35:08,036
so a signal is just a concurrent flow

666
00:35:05,099 --> 00:35:10,142
it's just a logical flow a sick so a

667
00:35:08,081 --> 00:35:13,090
handler is just another logical flow

668
00:35:11,042 --> 00:35:16,100
that runs concurrently with your program

669
00:35:13,009 --> 00:35:19,091
right so we're let's say we're executing

670
00:35:17,000 --> 00:35:23,054
a while loop and process a okay that

671
00:35:20,072 --> 00:35:26,096
while loop is is executing and then

672
00:35:23,054 --> 00:35:30,079
process a receives a signal which causes

673
00:35:26,096 --> 00:35:33,235
a transfer of control to this handler

674
00:35:30,079 --> 00:35:36,107
this handler executes so this is a

675
00:35:34,099 --> 00:35:39,470
concurrent flow that overlaps in time

676
00:35:37,007 --> 00:35:44,072
with the while loop in process a

677
00:35:39,047 --> 00:35:47,051
eventually this handler returns and we

678
00:35:44,072 --> 00:35:51,143
return to the backtick to back to

679
00:35:47,051 --> 00:35:55,118
process a now one of the reasons signals

680
00:35:52,043 --> 00:35:59,047
are so tricky is because of this this

681
00:35:56,018 --> 00:36:01,102
overlapping concurrent flow

682
00:35:59,047 --> 00:36:04,114
this concurrency because the signal

683
00:36:02,002 --> 00:36:07,084
handler runs in the same process as the

684
00:36:05,014 --> 00:36:12,021
main program so it shares all the global

685
00:36:07,084 --> 00:36:14,098
variables of that program okay so you're

686
00:36:12,021 --> 00:36:16,102
that signal handler is a function that

687
00:36:14,098 --> 00:36:19,174
you've declared and it has access to all

688
00:36:17,002 --> 00:36:24,013
all the state all the global state in

689
00:36:20,074 --> 00:36:26,077
the program okay and the existence of

690
00:36:24,013 --> 00:36:28,080
this shared global state can create real

691
00:36:26,077 --> 00:36:28,080
problems

692
00:36:36,309 --> 00:36:42,334
and we'll get into more details about

693
00:36:39,229 --> 00:36:44,307
some of those problems so another way to

694
00:36:42,559 --> 00:36:47,623
look at these signal handlers disking as

695
00:36:45,009 --> 00:36:51,061
concurrent flows is using this this

696
00:36:48,199 --> 00:36:54,286
context switch diagram so suppose we're

697
00:36:51,529 --> 00:37:00,546
executing in process a and now at some

698
00:36:55,069 --> 00:37:04,160
point a signal is delivered to process a

699
00:37:00,699 --> 00:37:05,740
now nothing happens right just just the

700
00:37:04,016 --> 00:37:09,885
pending bit gets set in process a at

701
00:37:06,109 --> 00:37:12,168
this point now at some point there's a

702
00:37:10,029 --> 00:37:15,103
transfer of control into the kernel and

703
00:37:12,699 --> 00:37:19,130
the kernel decides to do a context

704
00:37:15,769 --> 00:37:20,800
switch from A to B and now B gets to run

705
00:37:19,013 --> 00:37:24,412
for a while there's another transfer of

706
00:37:21,079 --> 00:37:28,144
control to the kernel and the kernel

707
00:37:24,529 --> 00:37:31,555
decides to schedule process a and now

708
00:37:28,729 --> 00:37:34,753
right before it returns control to

709
00:37:31,789 --> 00:37:37,837
process a it notices that the depending

710
00:37:34,969 --> 00:37:40,984
bit for this signal is set so it causes

711
00:37:38,269 --> 00:37:43,315
process a to receive that signal so that

712
00:37:41,119 --> 00:37:46,162
executes the handler code when the

713
00:37:43,729 --> 00:37:47,776
handler returns it returns for brief

714
00:37:46,549 --> 00:37:50,551
briefly to the kernel which then

715
00:37:48,199 --> 00:37:52,282
transfers control back to the the next

716
00:37:50,749 --> 00:37:57,808
instruction that the process is going to

717
00:37:53,029 --> 00:37:59,107
execute now handlers are also tricky

718
00:37:58,339 --> 00:38:02,386
because they can be interrupted by other

719
00:37:59,809 --> 00:38:07,828
handlers so suppose we have our main

720
00:38:02,809 --> 00:38:09,847
program that catches the signal S which

721
00:38:07,999 --> 00:38:12,097
causes the transfer of control to handle

722
00:38:10,189 --> 00:38:15,650
or us and then we'll handle our s did

723
00:38:12,979 --> 00:38:23,034
you have a question okay well handle or

724
00:38:15,065 --> 00:38:22,944
else is is is executing the

725
00:38:24,829 --> 00:38:32,875
that the program catches a signal T

726
00:38:29,068 --> 00:38:36,097
which causes a transfer of control to

727
00:38:33,289 --> 00:38:38,317
the handler first 40 and when then when

728
00:38:36,709 --> 00:38:42,715
that handler returns it returns to the

729
00:38:38,569 --> 00:38:44,930
point to the to the - to the instruction

730
00:38:43,309 --> 00:38:46,408
and handle or else that was where it was

731
00:38:44,093 --> 00:38:49,372
interrupted and then handler us

732
00:38:47,299 --> 00:38:52,700
continues its execution and eventually

733
00:38:50,209 --> 00:38:54,211
it returns back to the the point in the

734
00:38:52,007 --> 00:38:55,078
main program where it was interrupted

735
00:38:54,229 --> 00:38:56,410
now

736
00:38:59,799 --> 00:39:04,880
signals but the kernel always blocks

737
00:39:02,499 --> 00:39:07,597
pending signals of the type currently

738
00:39:04,088 --> 00:39:12,757
being handled right so a handler for a

739
00:39:08,479 --> 00:39:15,380
signal of type T can't be interrupted by

740
00:39:13,549 --> 00:39:17,554
the receipt of another signal of that

741
00:39:15,038 --> 00:39:19,417
same type okay can be as I showed in the

742
00:39:18,049 --> 00:39:21,124
previous slide it can be interrupted by

743
00:39:19,759 --> 00:39:23,794
a signal of another type but not by a

744
00:39:21,799 --> 00:39:28,873
signal of the same type so that's sort

745
00:39:24,109 --> 00:39:31,207
of an implicit form of of blocking but

746
00:39:29,539 --> 00:39:33,541
there's the kernel also provides a

747
00:39:32,089 --> 00:39:37,430
system call that allows you to

748
00:39:33,559 --> 00:39:39,562
explicitly block and unblock signals in

749
00:39:37,043 --> 00:39:43,732
the form of the sig proc mask function

750
00:39:39,859 --> 00:39:46,908
and then there's an Associated so this

751
00:39:44,119 --> 00:39:50,167
allows you to block and unblock a set of

752
00:39:47,349 --> 00:39:53,365
signals and then there's some support

753
00:39:50,599 --> 00:39:57,650
functions that allow you to create those

754
00:39:53,509 --> 00:40:00,880
sets so just think of these as bit

755
00:39:57,065 --> 00:40:03,874
vectors and these functions will set and

756
00:40:00,088 --> 00:40:07,437
set and reset the bits and those those

757
00:40:04,459 --> 00:40:11,485
detectors so let's see how we can use

758
00:40:08,229 --> 00:40:13,234
sig proc mask to temporarily block and

759
00:40:11,719 --> 00:40:14,755
unblock a signal so this is going to

760
00:40:13,729 --> 00:40:17,390
this is going to turn out to be very

761
00:40:15,079 --> 00:40:20,083
important for you when you working on

762
00:40:17,039 --> 00:40:23,658
your shells that which is your next your

763
00:40:20,119 --> 00:40:23,208
next lab assignment okay

764
00:40:24,085 --> 00:40:29,102
so what we do we'll use Zig empty set to

765
00:40:27,095 --> 00:40:31,160
create an empty mask so this is a mask

766
00:40:30,002 --> 00:40:35,009
with all zeros okay with with no

767
00:40:32,006 --> 00:40:36,103
elements in the set and then we're going

768
00:40:35,009 --> 00:40:43,031
to add a single element to this set

769
00:40:37,057 --> 00:40:44,081
which is sig int and now we temp we have

770
00:40:43,031 --> 00:40:48,056
some code that we don't want to be

771
00:40:44,081 --> 00:40:50,126
interrupted by receipt of sig int okay

772
00:40:48,056 --> 00:40:53,150
so we want to temporarily block the

773
00:40:51,026 --> 00:40:57,101
receipt of SIGINT signals and we do it

774
00:40:54,005 --> 00:40:59,066
by calling sig proc mask with the

775
00:40:58,001 --> 00:41:03,083
command say I want to block

776
00:41:00,011 --> 00:41:06,100
I want to block the signals that are

777
00:41:03,083 --> 00:41:13,091
spected the that are in the set

778
00:41:07,000 --> 00:41:16,076
specified by mask and I will sign the so

779
00:41:14,063 --> 00:41:19,066
this will become my new mask so this

780
00:41:16,076 --> 00:41:22,157
this becomes the new blocked bit vector

781
00:41:19,066 --> 00:41:25,073
okay or they're not the this the new

782
00:41:23,057 --> 00:41:28,154
signal mask and it makes a copy of the

783
00:41:25,073 --> 00:41:32,087
old one and stores it at at the address

784
00:41:29,054 --> 00:41:34,079
specified in the third argument so at

785
00:41:32,087 --> 00:41:36,110
this point after we returned from sig

786
00:41:34,079 --> 00:41:40,147
proc mask sig and signals are blocked

787
00:41:37,001 --> 00:41:44,018
and they won't be received and then we

788
00:41:41,047 --> 00:41:45,134
so we can execute this code knowing that

789
00:41:44,027 --> 00:41:50,030
we won't be interrupted by receipt of a

790
00:41:46,034 --> 00:41:54,038
SIGINT and then we can restore the

791
00:41:50,057 --> 00:41:58,058
previous block set by using the cig set

792
00:41:54,038 --> 00:42:00,110
mask in stopper ation and passing in the

793
00:41:58,067 --> 00:42:02,072
previous mask that we that we saved up

794
00:42:01,001 --> 00:42:05,005
here when we when we initially blocks

795
00:42:02,072 --> 00:42:04,114
again

796
00:42:09,033 --> 00:42:15,087
okay so signals and signal handling is a

797
00:42:13,005 --> 00:42:19,005
really tricky business and there's sort

798
00:42:15,087 --> 00:42:22,152
of three things that make them so tricky

799
00:42:19,005 --> 00:42:24,087
and kind of nasty really one is that you

800
00:42:23,052 --> 00:42:27,090
have to be very careful to write

801
00:42:24,087 --> 00:42:29,118
handlers that are safe okay so there's

802
00:42:27,009 --> 00:42:31,041
you can write signal handlers that are

803
00:42:30,018 --> 00:42:36,093
unsafe in the sense that they'll create

804
00:42:32,022 --> 00:42:38,073
a deadlock in your program okay or you

805
00:42:36,093 --> 00:42:39,189
can or you can write signal handlers

806
00:42:38,073 --> 00:42:44,139
that will they'll corrupt a global data

807
00:42:40,089 --> 00:42:47,100
structure that's being modified by the

808
00:42:45,039 --> 00:42:50,135
main program so I mean imagine imagine

809
00:42:48,000 --> 00:42:53,061
your main programming is updating some

810
00:42:51,035 --> 00:42:56,037
some data structure like a linked list

811
00:42:53,061 --> 00:42:57,150
and right in the middle of updating that

812
00:42:56,037 --> 00:43:01,101
data structure when it's when it's no

813
00:42:58,005 --> 00:43:03,030
longer consistent the program gets

814
00:43:02,001 --> 00:43:07,065
interrupted by the receipt of a signal

815
00:43:03,075 --> 00:43:08,154
and if that signal handler is updating

816
00:43:07,065 --> 00:43:12,069
that same data structure reading that

817
00:43:09,054 --> 00:43:13,110
structure or modifying it then it's

818
00:43:12,069 --> 00:43:18,071
going to encounter it in an inconsistent

819
00:43:14,001 --> 00:43:18,062
state and and and you're in trouble

820
00:43:18,086 --> 00:43:26,088
so this the fact that it's the fact that

821
00:43:24,059 --> 00:43:29,154
it's easy to write signal handlers that

822
00:43:27,006 --> 00:43:32,079
are that are unsafe is is one aspect of

823
00:43:30,054 --> 00:43:34,131
it makes them tough to deal with another

824
00:43:32,079 --> 00:43:37,128
aspect is they have this funny semantics

825
00:43:35,031 --> 00:43:39,090
that signals aren't cued and so if

826
00:43:38,028 --> 00:43:43,035
you're not if you're not really careful

827
00:43:39,009 --> 00:43:45,054
about this it's very easy to use the

828
00:43:43,035 --> 00:43:47,046
receipt of signals to count events and

829
00:43:46,035 --> 00:43:49,110
you can't do that

830
00:43:47,046 --> 00:43:51,060
if signals were cued you could use you

831
00:43:50,001 --> 00:43:53,028
could use the receipt of a signal to

832
00:43:51,006 --> 00:43:55,008
count events in the system but you can't

833
00:43:53,037 --> 00:43:58,098
do it because their signals aren't cued

834
00:43:55,008 --> 00:43:59,090
and then the third a third aspect of

835
00:43:58,098 --> 00:44:01,179
signals which makes them tough is that

836
00:44:00,062 --> 00:44:04,062
they're not even they're not even

837
00:44:02,079 --> 00:44:10,080
portable across different versions of

838
00:44:04,062 --> 00:44:12,120
Linux okay so if you use Solaris or some

839
00:44:10,008 --> 00:44:14,010
form of BSD it's not necessarily the

840
00:44:13,002 --> 00:44:15,099
signal handling semantics aren't

841
00:44:14,082 --> 00:44:18,108
necessarily the same as they are in

842
00:44:16,017 --> 00:44:20,100
Linux okay so well we'll look at all

843
00:44:19,008 --> 00:44:22,063
three of these in a little more detail

844
00:44:21,000 --> 00:44:27,579
first we'll start with

845
00:44:22,063 --> 00:44:31,066
writing safe handlers so let me give you

846
00:44:27,579 --> 00:44:34,420
some guidelines for how to write safe

847
00:44:31,066 --> 00:44:38,505
handlers and this is just a collection

848
00:44:34,042 --> 00:44:41,991
of fun this is just a collection of sort

849
00:44:39,099 --> 00:44:47,200
of collected wisdom from from various

850
00:44:42,369 --> 00:44:49,392
sources but it covers a lot of aspects

851
00:44:47,002 --> 00:44:51,321
of signal handlers so the first

852
00:44:49,599 --> 00:44:53,637
guideline is to keep your handlers as

853
00:44:51,519 --> 00:44:55,551
simple as possible for example the

854
00:44:53,979 --> 00:44:57,990
simplest possible handle I can think of

855
00:44:55,839 --> 00:45:05,936
just sets a global variable and then it

856
00:44:58,089 --> 00:45:09,108
returns and in fact cert the CMU cert

857
00:45:06,809 --> 00:45:12,970
provides guidelines for sort of

858
00:45:09,279 --> 00:45:15,363
compliant programs and this is the only

859
00:45:12,097 --> 00:45:17,376
signal handler that they allow this is

860
00:45:16,119 --> 00:45:19,194
the only compliant signal handler one

861
00:45:18,249 --> 00:45:23,252
that just sets a global variable and

862
00:45:19,869 --> 00:45:22,937
then returns okay

863
00:45:25,589 --> 00:45:30,606
guideline number one call only functions

864
00:45:28,479 --> 00:45:33,564
in your handlers that are that have this

865
00:45:30,759 --> 00:45:36,810
property of a sync signal safety okay

866
00:45:34,329 --> 00:45:39,378
and we'll look at this in a second but I

867
00:45:37,269 --> 00:45:42,327
want to point out that printout s printf

868
00:45:39,819 --> 00:45:44,868
Malak exit functions that are very

869
00:45:42,849 --> 00:45:48,150
common and commonly use are not safe

870
00:45:45,309 --> 00:45:48,150
okay

871
00:45:48,091 --> 00:45:53,167
guideline number two is to always save

872
00:45:51,091 --> 00:45:56,910
and restore error no on entry and exit

873
00:45:54,067 --> 00:45:58,656
so you know error no is a global global

874
00:45:57,729 --> 00:46:00,729
variable it's set when there's whenever

875
00:45:59,259 --> 00:46:03,342
there's an error in a system level

876
00:46:00,729 --> 00:46:05,950
function so you need to save and you

877
00:46:04,089 --> 00:46:08,130
need to save and restore it on entry and

878
00:46:05,095 --> 00:46:08,194
exit so that it doesn't get overwritten

879
00:46:08,499 --> 00:46:12,410
that you're interrupted by another

880
00:46:09,094 --> 00:46:14,098
handler

881
00:46:12,041 --> 00:46:17,170
[Music]

882
00:46:14,098 --> 00:46:19,987
okay if you're accessing any shared data

883
00:46:17,539 --> 00:46:24,571
structures inside a signal handler that

884
00:46:20,869 --> 00:46:26,750
are also accessed by your main routine

885
00:46:24,859 --> 00:46:28,460
then you need to temporarily block

886
00:46:26,075 --> 00:46:30,077
signals while you access that data

887
00:46:28,046 --> 00:46:32,875
structure both in the main routine and

888
00:46:30,095 --> 00:46:34,684
your signal handler right and the reason

889
00:46:33,289 --> 00:46:37,400
for this is what I described earlier if

890
00:46:35,539 --> 00:46:38,930
your main routine is updating that

891
00:46:37,004 --> 00:46:40,088
global data structure and then it gets

892
00:46:38,093 --> 00:46:41,165
interrupted and the signal handler is

893
00:46:41,024 --> 00:46:44,120
reading that data structure it's going

894
00:46:42,065 --> 00:46:50,734
to find it in inconsistent state and bad

895
00:46:45,002 --> 00:46:52,100
things will happen okay you want to be

896
00:46:51,319 --> 00:46:54,394
sure to declare your any global

897
00:46:53,018 --> 00:46:56,090
variables that are shared between signal

898
00:46:55,069 --> 00:46:59,480
handlers and the main routine as

899
00:46:56,009 --> 00:47:01,016
volatile okay the volatile attribute

900
00:46:59,048 --> 00:47:07,357
will prevent the compiler from putting

901
00:47:01,097 --> 00:47:09,188
that that value in a register so if you

902
00:47:07,789 --> 00:47:12,950
declare a global variable as volatile it

903
00:47:10,088 --> 00:47:15,092
will always be reads and writes will

904
00:47:12,095 --> 00:47:17,934
always go to and from memory okay so

905
00:47:15,092 --> 00:47:20,141
this is very important right you might

906
00:47:18,789 --> 00:47:22,843
if you don't declare these global

907
00:47:21,041 --> 00:47:25,750
variables in volatile and the compiler

908
00:47:23,329 --> 00:47:31,160
chooses to put to put one of those in a

909
00:47:26,119 --> 00:47:33,440
in a register then you may miss that

910
00:47:31,016 --> 00:47:36,385
variable being updated so suppose

911
00:47:33,044 --> 00:47:39,613
suppose your signal handlers is setting

912
00:47:36,529 --> 00:47:42,890
a global variable and now suppose your

913
00:47:40,009 --> 00:47:46,066
main routine is spinning waiting for

914
00:47:42,089 --> 00:47:47,165
that global variable to get set well if

915
00:47:46,579 --> 00:47:51,580
it's in a register the write to that

916
00:47:48,065 --> 00:47:54,034
variable will just update the register

917
00:47:51,589 --> 00:47:57,140
right and so your main routine is in

918
00:47:54,619 --> 00:47:58,710
danger of just spinning forever not not

919
00:47:57,014 --> 00:48:03,014
seeing the change thank you

920
00:47:59,529 --> 00:48:05,611
okay so always use volatility so that

921
00:48:03,014 --> 00:48:08,713
they're not stored in registers and then

922
00:48:06,349 --> 00:48:11,750
if you have fun if you have a special

923
00:48:08,839 --> 00:48:13,670
kind of global called a flag which by

924
00:48:11,075 --> 00:48:16,624
definition is a variable it's only read

925
00:48:13,067 --> 00:48:20,656
or written not incremented or updated

926
00:48:17,299 --> 00:48:22,372
it's just read or written if you have if

927
00:48:21,259 --> 00:48:24,680
you have a variable with that property

928
00:48:23,029 --> 00:48:25,910
then you can declare it with this SIG

929
00:48:24,068 --> 00:48:29,162
atomic

930
00:48:25,091 --> 00:48:31,097
t attribute and if you do that then the

931
00:48:30,062 --> 00:48:34,088
system guarantees that reads and writes

932
00:48:32,051 --> 00:48:36,083
to that variable be atomic so you don't

933
00:48:34,088 --> 00:48:38,177
have to in other words you don't have to

934
00:48:36,083 --> 00:48:42,083
protect accesses to the shared to

935
00:48:39,077 --> 00:48:45,170
accesses or references to those global

936
00:48:42,083 --> 00:48:48,098
variables okay and so by this by atomic

937
00:48:46,007 --> 00:48:50,068
what means that the the read or write of

938
00:48:48,098 --> 00:48:54,121
that flag will always happen in one

939
00:48:51,031 --> 00:48:58,114
uninterruptible step okay one

940
00:48:55,021 --> 00:49:02,069
uninterruptible load or store particular

941
00:48:59,014 --> 00:49:07,028
now in practice on most systems this SIG

942
00:49:02,069 --> 00:49:08,141
atomic t is an INT kids so you can you

943
00:49:07,028 --> 00:49:12,059
can read or write an int with one one

944
00:49:09,041 --> 00:49:13,109
instruction okay so it's it's atomic but

945
00:49:12,059 --> 00:49:16,067
if you want to be portable you declare

946
00:49:14,009 --> 00:49:20,033
it with sig atomic t and then it will

947
00:49:16,067 --> 00:49:25,085
it'll work on none it will work on all

948
00:49:20,033 --> 00:49:29,039
systems okay we mentioned this property

949
00:49:25,085 --> 00:49:31,103
of async signal safety now a function is

950
00:49:29,039 --> 00:49:36,056
is safe to be used inside of a signal

951
00:49:32,003 --> 00:49:38,015
handler if it's either reentrant okay or

952
00:49:36,056 --> 00:49:40,094
if it can't be interrupted by signals

953
00:49:38,015 --> 00:49:43,049
and what a reentrant function is we'll

954
00:49:40,094 --> 00:49:45,101
see when we study threads is a function

955
00:49:43,049 --> 00:49:50,087
where all of its all of the data that it

956
00:49:46,001 --> 00:49:53,006
accesses is on its own stack okay so no

957
00:49:50,087 --> 00:49:53,159
global variables no pointers to global

958
00:49:53,006 --> 00:49:58,061
variables everything's stored on the

959
00:49:54,059 --> 00:50:00,080
stack locally okay so that means you can

960
00:49:58,061 --> 00:50:02,063
be it's called reentrant because you can

961
00:50:00,008 --> 00:50:03,041
write have multiple instances of that

962
00:50:02,063 --> 00:50:06,119
function and they all have their own

963
00:50:04,013 --> 00:50:10,109
separate copies of all of the variables

964
00:50:07,019 --> 00:50:14,033
that they're they're using now the POSIX

965
00:50:11,009 --> 00:50:18,031
standard guarantees 117 different

966
00:50:14,033 --> 00:50:17,131
functions to be a sync signal safe

967
00:50:18,082 --> 00:50:24,146
these include underscore exit right wait

968
00:50:22,049 --> 00:50:26,114
wait could sleep killed but

969
00:50:25,046 --> 00:50:28,087
unfortunately there's some very popular

970
00:50:27,014 --> 00:50:31,085
functions that aren't on this list

971
00:50:28,087 --> 00:50:34,094
printf s printf things that you really

972
00:50:31,085 --> 00:50:36,092
want to use and in fact right is the

973
00:50:34,094 --> 00:50:38,149
only output function that's a sync

974
00:50:36,092 --> 00:50:38,149
signal safe

975
00:50:39,999 --> 00:50:46,910
so this is kind of a problem because

976
00:50:43,329 --> 00:50:48,410
especially when you know you something

977
00:50:46,091 --> 00:50:51,640
you'd often like your signal handlers to

978
00:50:48,041 --> 00:50:53,830
output information but you can't if you

979
00:50:52,459 --> 00:50:56,557
want to really be pedantic and careful

980
00:50:54,199 --> 00:51:00,920
you can't use printf in fact it's

981
00:50:57,439 --> 00:51:02,530
possible to write a program and I'll try

982
00:51:00,092 --> 00:51:06,271
to I'll try to it's possible to write a

983
00:51:03,349 --> 00:51:11,390
program that does a tight loop of

984
00:51:07,099 --> 00:51:14,630
printouts in the main routine and then a

985
00:51:11,039 --> 00:51:16,858
steady stream of interrupts which

986
00:51:14,063 --> 00:51:25,702
executes a handler which also does a

987
00:51:17,209 --> 00:51:27,283
printf okay now the printf call has to

988
00:51:26,269 --> 00:51:30,313
acquire what's called a lock on the

989
00:51:27,949 --> 00:51:34,670
terminal okay each printf inside that

990
00:51:30,709 --> 00:51:36,766
that library function it acquires a lock

991
00:51:34,067 --> 00:51:38,138
which means only one instance of printf

992
00:51:37,279 --> 00:51:42,304
can write to the terminal in a point in

993
00:51:39,038 --> 00:51:43,987
time if another if another function

994
00:51:42,529 --> 00:51:48,577
tries to acquire that lock it has to

995
00:51:44,329 --> 00:51:51,370
wait until whatever function owns the

996
00:51:49,009 --> 00:51:55,027
lock releases it okay so a lock prevents

997
00:51:51,739 --> 00:51:57,822
a lock is a way for to get mutually

998
00:51:55,189 --> 00:52:02,660
exclusive access to two shared resources

999
00:51:58,569 --> 00:52:05,608
so if we have a tight loop in our main

1000
00:52:02,066 --> 00:52:07,139
routine with executing printf imagine

1001
00:52:05,959 --> 00:52:09,985
what happens if one of those printouts

1002
00:52:08,039 --> 00:52:14,968
acquires the lock on the terminal and

1003
00:52:10,219 --> 00:52:17,266
then gets interrupted not by the receipt

1004
00:52:15,319 --> 00:52:22,160
of a signal now within the signal

1005
00:52:17,689 --> 00:52:24,748
handler it calls another printf and that

1006
00:52:22,016 --> 00:52:27,595
printf tries to acquire that lock and it

1007
00:52:25,279 --> 00:52:29,362
blocks forever because nothing is going

1008
00:52:27,739 --> 00:52:30,814
to release that lock because the the

1009
00:52:30,109 --> 00:52:35,203
main routine was interrupted by the

1010
00:52:31,489 --> 00:52:39,514
handler so you have what's called a

1011
00:52:36,049 --> 00:52:42,049
classical a classical condition called

1012
00:52:39,739 --> 00:52:42,835
deadlock which is we have a process

1013
00:52:42,049 --> 00:52:46,054
waiting for an event that will never

1014
00:52:43,699 --> 00:52:47,788
occur in this case the the printf and

1015
00:52:46,099 --> 00:52:49,910
the signal handler is waiting for a lock

1016
00:52:48,589 --> 00:52:50,600
to be released that will never be

1017
00:52:49,091 --> 00:52:54,144
released

1018
00:52:50,006 --> 00:52:58,071
so it's interesting you can try this

1019
00:52:55,044 --> 00:53:03,057
it's it's not too hard to to create this

1020
00:52:59,025 --> 00:53:05,046
deadlock situation so to deal with this

1021
00:53:03,057 --> 00:53:06,096
I really didn't want to tell you guys

1022
00:53:05,046 --> 00:53:07,143
that you couldn't have any output in

1023
00:53:06,096 --> 00:53:11,115
your programs and writes a very

1024
00:53:08,043 --> 00:53:14,130
difficult thing to deal with so so I

1025
00:53:12,015 --> 00:53:19,071
created a small little library called

1026
00:53:15,003 --> 00:53:22,041
the safe i/o library consists of three

1027
00:53:19,071 --> 00:53:25,730
routines and they're available to you in

1028
00:53:22,068 --> 00:53:28,095
the CSA PTC file which is distributed on

1029
00:53:26,369 --> 00:53:32,780
the website

1030
00:53:28,095 --> 00:53:38,171
it consists of three reentrant routines

1031
00:53:32,078 --> 00:53:45,174
SiO put s prince/princess string put L

1032
00:53:39,071 --> 00:53:50,100
prints along and SiO error prints a

1033
00:53:46,074 --> 00:53:52,119
message and then exits okay so you can

1034
00:53:51,000 --> 00:53:55,032
safely use take my word for it you can

1035
00:53:53,019 --> 00:53:57,066
safely use this in your in your signal

1036
00:53:55,032 --> 00:54:00,081
handlers so if we were going to rewrite

1037
00:53:57,066 --> 00:54:03,078
our SIGINT handler from the from the

1038
00:54:00,081 --> 00:54:04,164
binary bomb we could rewrite it like

1039
00:54:03,078 --> 00:54:10,173
this and now we have every function is

1040
00:54:05,064 --> 00:54:12,071
is a sync signal safe all right now

1041
00:54:11,073 --> 00:54:18,171
singles are also tough because of this

1042
00:54:13,034 --> 00:54:22,100
funky non queuing semantics of and so

1043
00:54:19,071 --> 00:54:24,144
it's really easy to make mistakes

1044
00:54:23,000 --> 00:54:29,001
when you have an implicit assumption

1045
00:54:25,044 --> 00:54:32,046
that the that the receipt of a signal it

1046
00:54:29,001 --> 00:54:36,006
can be used to count the occurrence of

1047
00:54:32,046 --> 00:54:41,046
an event so let's look at this let's

1048
00:54:36,051 --> 00:54:43,107
look at this example program we install

1049
00:54:41,046 --> 00:54:46,068
a sick child handler okay and this is

1050
00:54:44,007 --> 00:54:48,078
actually this sir I want to close the

1051
00:54:46,068 --> 00:54:50,070
loop member we talked about our example

1052
00:54:48,078 --> 00:54:52,095
shell we're wondering how are we going

1053
00:54:50,088 --> 00:54:54,144
to reap those those background children

1054
00:54:52,095 --> 00:54:56,120
well we do it by installing a sick child

1055
00:54:55,044 --> 00:54:59,135
handle like we're doing in this example

1056
00:54:57,002 --> 00:55:03,391
so this here we have a program that

1057
00:55:00,035 --> 00:55:07,088
installs this SIG child handler

1058
00:55:03,589 --> 00:55:10,630
and then it creates n different child

1059
00:55:07,088 --> 00:55:17,077
processes where each child sleeps for a

1060
00:55:10,999 --> 00:55:22,083
little bit and exits and then it spins

1061
00:55:17,869 --> 00:55:25,160
until the C count variable becomes zero

1062
00:55:22,839 --> 00:55:27,907
that the parent I'm sorry the parent

1063
00:55:25,016 --> 00:55:35,063
spins until the C count variable becomes

1064
00:55:28,519 --> 00:55:37,561
zero now in the in our child handler we

1065
00:55:35,063 --> 00:55:43,462
we have a global that's that's

1066
00:55:37,939 --> 00:55:45,025
initialized to zero see count and then

1067
00:55:44,029 --> 00:55:47,098
we wait we're going to wait so this

1068
00:55:45,799 --> 00:55:48,874
child when the child handler gets called

1069
00:55:47,719 --> 00:55:52,783
that means it's called because we

1070
00:55:49,549 --> 00:55:55,630
received a sick child signal okay so in

1071
00:55:53,359 --> 00:55:59,368
our in our handler we're going to reap

1072
00:55:56,359 --> 00:56:02,434
that child by calling weight and we're

1073
00:56:00,259 --> 00:56:06,410
going to Dec and then will decrement C

1074
00:56:03,109 --> 00:56:09,175
count okay so once all of the children

1075
00:56:06,041 --> 00:56:11,250
at then done have been reaped C count

1076
00:56:09,769 --> 00:56:14,866
will be zero and then the parent can

1077
00:56:11,619 --> 00:56:19,693
exit this this while loop okay now in

1078
00:56:15,739 --> 00:56:24,817
this particular example n was 5 but will

1079
00:56:20,359 --> 00:56:30,382
you run this code we only the handle or

1080
00:56:25,519 --> 00:56:32,604
only gets called twice okay so the the

1081
00:56:30,589 --> 00:56:35,593
message handle or each child only gets

1082
00:56:33,369 --> 00:56:38,385
executed twice right which means the

1083
00:56:35,989 --> 00:56:41,071
handler was only called twice we created

1084
00:56:38,529 --> 00:56:46,606
five children we terminated five

1085
00:56:41,809 --> 00:56:49,846
children but we only read two okay so

1086
00:56:47,299 --> 00:56:52,880
that the problem is that when we the

1087
00:56:50,179 --> 00:56:57,244
problem is that we assumed that the

1088
00:56:52,088 --> 00:56:58,987
receipt that the that the execution of

1089
00:56:57,829 --> 00:57:03,140
the child handler corresponded to the

1090
00:56:59,779 --> 00:57:06,877
single receipt of a single signal signal

1091
00:57:03,014 --> 00:57:12,343
okay when when in reality these signals

1092
00:57:07,759 --> 00:57:13,792
aren't cued right we had in reality

1093
00:57:12,469 --> 00:57:15,523
multiple sick child signals were

1094
00:57:14,089 --> 00:57:17,117
delivered to that child which kept

1095
00:57:16,009 --> 00:57:21,020
overriding that

1096
00:57:17,369 --> 00:57:23,390
bid in the pending bit sector and the

1097
00:57:21,119 --> 00:57:25,890
delivery of those signals didn't didn't

1098
00:57:23,579 --> 00:57:27,647
have didn't cause any reaction in the

1099
00:57:25,089 --> 00:57:29,948
process until I process was was just

1100
00:57:28,259 --> 00:57:32,320
about ready to be rescheduled and only

1101
00:57:30,749 --> 00:57:34,847
then was was the signal received

1102
00:57:32,869 --> 00:57:36,941
but even though like say three signals

1103
00:57:35,729 --> 00:57:42,390
were delivered only one was received

1104
00:57:37,589 --> 00:57:44,612
okay so you can't use events in this

1105
00:57:42,039 --> 00:57:47,498
case we're using event we're using

1106
00:57:44,819 --> 00:57:51,180
signals to count events which in this

1107
00:57:47,849 --> 00:57:55,200
case is the termination of a child okay

1108
00:57:51,018 --> 00:57:58,607
so the receipt of a signal in this case

1109
00:57:55,002 --> 00:58:02,921
it only indicates that at least one

1110
00:57:58,769 --> 00:58:05,846
child terminated right not not one child

1111
00:58:03,119 --> 00:58:07,217
terminated all we can infer from the

1112
00:58:06,539 --> 00:58:12,450
receipt of that signal is that at least

1113
00:58:08,099 --> 00:58:18,161
one child is terminated okay so to fix

1114
00:58:12,045 --> 00:58:19,874
that when we receive a sick child we

1115
00:58:18,719 --> 00:58:23,798
have to put we have to put the weight

1116
00:58:20,279 --> 00:58:27,420
that's reaping on our children we have

1117
00:58:24,509 --> 00:58:28,544
to put that in this in a loop so we have

1118
00:58:27,042 --> 00:58:30,611
to assume that the receipt of a sick

1119
00:58:28,859 --> 00:58:34,901
child if we get a sick child there could

1120
00:58:30,989 --> 00:58:38,880
be multiple terminated children that we

1121
00:58:35,279 --> 00:58:41,303
have to that we have to reap and so we

1122
00:58:38,088 --> 00:58:42,165
put we put that in this loop and we

1123
00:58:41,519 --> 00:58:46,410
execute this loop until there's no more

1124
00:58:43,065 --> 00:58:49,754
terminated children in which case wait

1125
00:58:46,041 --> 00:58:52,880
will will will exit with an error code

1126
00:58:50,339 --> 00:58:55,346
of minus one and a eronel of a child so

1127
00:58:53,249 --> 00:58:57,450
this isn't really an error it's just it

1128
00:58:56,039 --> 00:58:59,108
just means there's no more terminated

1129
00:58:57,045 --> 00:59:02,144
children so we check as long as if our

1130
00:58:59,729 --> 00:59:04,754
error knows naughty child then we have

1131
00:59:02,549 --> 00:59:08,190
an error otherwise we terminated

1132
00:59:04,979 --> 00:59:12,660
normally as we expected now if we run

1133
00:59:08,019 --> 00:59:17,042
this code now we we see that we reap all

1134
00:59:12,066 --> 00:59:16,142
five children is as we should

1135
00:59:17,088 --> 00:59:24,093
okay so look the litany of problems with

1136
00:59:22,033 --> 00:59:27,106
signals first it's easy to write

1137
00:59:24,093 --> 00:59:30,129
handlers that aren't safe second it's

1138
00:59:28,006 --> 00:59:33,082
easy to get the semantics wrong third

1139
00:59:31,029 --> 00:59:35,035
they're often not even portable across

1140
00:59:33,082 --> 00:59:38,089
different Vernors versions of Unix

1141
00:59:35,089 --> 00:59:40,123
so there's some older systems I don't

1142
00:59:38,089 --> 00:59:43,548
know if any there's some earlier

1143
00:59:41,023 --> 00:59:47,074
versions of Unix that after you catch a

1144
00:59:44,349 --> 00:59:50,080
signal it restores the default action so

1145
00:59:47,074 --> 00:59:52,081
you have to reinstall the handler every

1146
00:59:50,008 --> 00:59:54,043
time well every time a handler gets

1147
00:59:52,081 --> 00:59:55,860
called you have to re-install the

1148
00:59:54,043 --> 00:59:58,114
handler by calling signal inside the

1149
00:59:56,589 --> 01:00:03,594
handle itself and we don't have to do

1150
00:59:59,014 --> 01:00:07,090
that for for Linux systems on on some

1151
01:00:04,089 --> 01:00:12,090
systems when you have so-called slow sis

1152
01:00:07,009 --> 01:00:14,101
calls for example read you know if you

1153
01:00:12,099 --> 01:00:18,400
do a read system call the kernel doesn't

1154
01:00:15,082 --> 01:00:21,181
wait around for that data to arrive is

1155
01:00:18,004 --> 01:00:24,213
it you know it sends a request to the

1156
01:00:22,081 --> 01:00:26,140
disk controller and that schedules

1157
01:00:24,609 --> 01:00:29,658
another process right so in a way that

1158
01:00:27,004 --> 01:00:32,008
the read call is sort and then only when

1159
01:00:30,099 --> 01:00:35,140
the data arrives and the interrupt comes

1160
01:00:32,044 --> 01:00:37,090
in announcing that the data arrives does

1161
01:00:35,014 --> 01:00:40,051
that read call finish and then restores

1162
01:00:37,009 --> 01:00:41,086
and returned so you can think of read is

1163
01:00:40,051 --> 01:00:49,096
actually kind of broken up into two

1164
01:00:42,067 --> 01:00:52,078
parts right did and so that functions

1165
01:00:49,096 --> 01:00:54,190
like read these kind of functions are

1166
01:00:52,078 --> 01:00:58,126
called slow sis calls and on some

1167
01:00:55,009 --> 01:01:02,040
systems if the process receives a signal

1168
01:00:59,026 --> 01:01:05,098
before a slow system calls has finished

1169
01:01:03,021 --> 01:01:08,026
the kernel will will just abort that

1170
01:01:05,098 --> 01:01:10,189
system call in return from that system

1171
01:01:08,026 --> 01:01:13,123
call with an error okay so from user's

1172
01:01:11,089 --> 01:01:16,156
point of view you're doing a read call

1173
01:01:14,023 --> 01:01:20,029
and it returns with this this e enter

1174
01:01:17,056 --> 01:01:21,585
signal this e enter error you did

1175
01:01:20,083 --> 01:01:22,177
nothing wrong you just happen to have

1176
01:01:22,089 --> 01:01:26,140
the bad luck of being interrupted by

1177
01:01:23,077 --> 01:01:28,163
some signal and so in your user code you

1178
01:01:26,014 --> 01:01:30,092
have to check for that and if if they

1179
01:01:29,063 --> 01:01:32,090
slow system call like read is

1180
01:01:30,092 --> 01:01:34,145
interrupted by signal you have to redo

1181
01:01:32,009 --> 01:01:35,938
it so you have to put which is really a

1182
01:01:35,045 --> 01:01:39,116
pain right because you have to put these

1183
01:01:36,829 --> 01:01:42,880
these read calls in a loop and keep keep

1184
01:01:40,016 --> 01:01:45,041
looping until it succeeds and finally

1185
01:01:43,339 --> 01:01:49,366
some systems don't block signals of the

1186
01:01:45,041 --> 01:01:51,910
type being handled right so the solution

1187
01:01:49,609 --> 01:01:53,650
for this is a replacement for signal so

1188
01:01:52,279 --> 01:01:56,332
the problem is with this signal siskel

1189
01:01:54,019 --> 01:01:59,101
and the solution is a newer sis called

1190
01:01:56,809 --> 01:02:02,930
called Zig action which provides a

1191
01:01:59,839 --> 01:02:04,864
mechanism a replacement for signal that

1192
01:02:02,093 --> 01:02:07,012
provides a mechanism for portable and

1193
01:02:05,089 --> 01:02:11,450
predictable signal handling and so what

1194
01:02:07,849 --> 01:02:14,947
I've done what I've done is created a

1195
01:02:11,045 --> 01:02:18,664
rapper called uppercase signal that

1196
01:02:15,829 --> 01:02:22,880
takes the same arguments as the signal

1197
01:02:19,069 --> 01:02:25,144
call but inside it calls the sig action

1198
01:02:22,088 --> 01:02:30,007
function to get portable signal handling

1199
01:02:25,819 --> 01:02:34,819
and so it's it's not really important to

1200
01:02:30,799 --> 01:02:36,822
go into detail about this the point is

1201
01:02:34,819 --> 01:02:40,430
in your code you always want to call

1202
01:02:37,029 --> 01:02:43,105
uppercase signal using the rapper that

1203
01:02:40,043 --> 01:02:45,442
provided in si si PP dot C and then if

1204
01:02:43,789 --> 01:02:47,150
you do that then you'll always block

1205
01:02:45,829 --> 01:02:49,880
signal to the typing

1206
01:02:47,015 --> 01:02:52,094
handle the system will automatically

1207
01:02:49,088 --> 01:02:57,164
restart closest calls that have been

1208
01:02:52,094 --> 01:03:01,141
interrupted by by signals okay so

1209
01:02:58,064 --> 01:03:01,141
fortunately there's an easy fix for this

1210
01:03:03,046 --> 01:03:09,625
now let's let's finish up with them

1211
01:03:07,072 --> 01:03:11,131
there's some interesting I mentioned

1212
01:03:10,039 --> 01:03:13,430
that signals are difficult because of

1213
01:03:11,779 --> 01:03:15,808
these the fact that they're they're

1214
01:03:13,043 --> 01:03:17,932
concurrent flows so I want to look at

1215
01:03:16,069 --> 01:03:21,400
some sort of subtle issues that you can

1216
01:03:18,319 --> 01:03:24,319
run into because of this concurrency and

1217
01:03:21,004 --> 01:03:27,088
and I want to talk about how to identify

1218
01:03:24,319 --> 01:03:28,240
those errors and how to fix them

1219
01:03:30,052 --> 01:03:37,063
so here's a program that this is like a

1220
01:03:34,003 --> 01:03:39,088
simple shell program that maintains a

1221
01:03:37,063 --> 01:03:42,151
jobs list right so every time it creates

1222
01:03:39,088 --> 01:03:45,145
a new child it adds it to the jobs list

1223
01:03:43,051 --> 01:03:52,075
and every time that child terminates it

1224
01:03:46,045 --> 01:03:55,123
removes it from the jobs list okay so so

1225
01:03:52,075 --> 01:03:58,096
our simple shell just in a loop it just

1226
01:03:56,023 --> 01:04:02,074
creates a child and then executes the

1227
01:03:58,096 --> 01:04:05,098
program within that child and then in

1228
01:04:02,074 --> 01:04:07,138
the parent it correctly blocks all of

1229
01:04:06,016 --> 01:04:12,079
the signals temporarily while it adds a

1230
01:04:08,038 --> 01:04:15,055
job to the job queue and then it

1231
01:04:12,079 --> 01:04:18,115
unblocks and then it unblocked those

1232
01:04:15,055 --> 01:04:21,058
signals okay so this is correct and that

1233
01:04:19,015 --> 01:04:27,043
it's protecting access to this shared

1234
01:04:21,085 --> 01:04:29,122
job queue because that that that job

1235
01:04:27,043 --> 01:04:33,043
that job queue is also manipulated by

1236
01:04:30,022 --> 01:04:36,040
the sick child handler so when when a

1237
01:04:33,043 --> 01:04:41,110
child terminates and the parent receives

1238
01:04:36,004 --> 01:04:43,069
the signal this handler runs and this

1239
01:04:42,001 --> 01:04:46,024
handler goes through and it reaps all of

1240
01:04:44,005 --> 01:04:48,091
the children potentially terminated

1241
01:04:46,033 --> 01:04:51,118
children and then for each one it

1242
01:04:48,091 --> 01:04:54,540
deletes that that job from the job queue

1243
01:04:52,018 --> 01:04:56,089
all right so here's a classic case we

1244
01:04:55,359 --> 01:05:00,780
have two concurrent flows our main

1245
01:04:56,089 --> 01:05:02,113
routine and our our signal handler

1246
01:05:00,078 --> 01:05:05,163
they're each accessing a shared data

1247
01:05:03,013 --> 01:05:12,078
structure in this case the the job queue

1248
01:05:06,063 --> 01:05:14,116
okay and they're there correctly

1249
01:05:12,078 --> 01:05:18,175
blocking signals while they update this

1250
01:05:15,016 --> 01:05:24,035
this job queue but this program has a

1251
01:05:19,075 --> 01:05:29,156
really subtle and nasty bug in it

1252
01:05:24,035 --> 01:05:33,038
can you see what it is what's the

1253
01:05:30,056 --> 01:05:42,058
sequence of events that would cause this

1254
01:05:33,065 --> 01:05:42,076
program to to fail yes

1255
01:05:46,062 --> 01:05:51,120
exactly that's exactly it so is it

1256
01:05:49,075 --> 01:05:53,170
possible that the the child process

1257
01:05:52,002 --> 01:05:56,050
could terminate before the parent has a

1258
01:05:54,007 --> 01:05:59,008
chance to add that job to the queue and

1259
01:05:56,068 --> 01:06:01,087
the answer is yes right we you cannot

1260
01:05:59,008 --> 01:06:03,016
make any assumptions about the execution

1261
01:06:01,087 --> 01:06:06,111
ordering of the child in the process or

1262
01:06:04,006 --> 01:06:10,039
about how long they run right so it's

1263
01:06:07,011 --> 01:06:13,096
it's very possible that the child can

1264
01:06:10,093 --> 01:06:14,152
connect after after the four control

1265
01:06:13,096 --> 01:06:16,165
returns to the child instead of the

1266
01:06:15,052 --> 01:06:19,084
parent and then the child terminates

1267
01:06:17,065 --> 01:06:22,072
before the parent ever has a chance to

1268
01:06:19,084 --> 01:06:28,087
to add that job to the job queue so now

1269
01:06:23,035 --> 01:06:32,068
what's happened is that the the child is

1270
01:06:29,014 --> 01:06:35,017
deleting a deleting a job that hasn't

1271
01:06:32,068 --> 01:06:36,115
been added to the job queue right and

1272
01:06:35,017 --> 01:06:39,061
now when the parent finally gets around

1273
01:06:37,015 --> 01:06:42,021
to running it adds that job to the job

1274
01:06:39,061 --> 01:06:46,122
queue and that job will never be deleted

1275
01:06:42,075 --> 01:06:49,093
so this is the kind of subtle nasty

1276
01:06:47,022 --> 01:06:51,099
horrible kind of bug that you run into

1277
01:06:49,093 --> 01:06:53,125
when you're dealing with concurrency

1278
01:06:51,099 --> 01:06:55,198
trying to keep track of all of these

1279
01:06:54,025 --> 01:07:00,040
interleaving of events can just make

1280
01:06:56,098 --> 01:07:02,143
your head explode all right now and it

1281
01:07:00,004 --> 01:07:05,005
happens and Sigma it happens with any

1282
01:07:03,043 --> 01:07:06,088
kind of concurrency where you have

1283
01:07:05,041 --> 01:07:08,107
concurrent flows accessing shared

1284
01:07:06,088 --> 01:07:10,147
resources and signal handlers are no

1285
01:07:09,007 --> 01:07:13,009
different now we'll look at principles

1286
01:07:11,047 --> 01:07:15,054
ways where we can deal with this kind of

1287
01:07:13,009 --> 01:07:18,097
sharing when we study threads later on

1288
01:07:16,017 --> 01:07:23,041
but I just want to point this out to you

1289
01:07:18,097 --> 01:07:26,134
and scare you a little bit all right so

1290
01:07:23,041 --> 01:07:30,139
here's how we would fix that what we

1291
01:07:27,034 --> 01:07:34,126
have to do is somehow avoid that avoid

1292
01:07:31,039 --> 01:07:38,121
the to avoid the possibility of the

1293
01:07:35,026 --> 01:07:42,037
child handler executing before the

1294
01:07:39,021 --> 01:07:44,074
parent can add the corresponding job to

1295
01:07:42,037 --> 01:07:46,102
the job queue now we can't control

1296
01:07:44,074 --> 01:07:49,081
whether the child executes first or the

1297
01:07:47,002 --> 01:07:52,048
parent execute first and we can't

1298
01:07:49,081 --> 01:07:55,117
control how long the child runs but we

1299
01:07:52,048 --> 01:07:57,142
can control when the big child handler

1300
01:07:56,017 --> 01:08:02,946
runs because we can block signals

1301
01:07:58,042 --> 01:08:08,065
okay so what we'll do we'll modify our

1302
01:08:03,099 --> 01:08:12,010
program to will you sig proc mask to

1303
01:08:08,065 --> 01:08:14,116
block sig tiled signals before we create

1304
01:08:12,001 --> 01:08:17,940
the child okay so at this point after

1305
01:08:15,016 --> 01:08:22,033
this invocation of sig proc sig child

1306
01:08:17,949 --> 01:08:26,790
signals are blocked okay then we create

1307
01:08:22,033 --> 01:08:29,062
the child and before we do our eggs xee

1308
01:08:26,079 --> 01:08:31,117
since we don't know that child may may

1309
01:08:29,062 --> 01:08:36,088
need to reap its children right we don't

1310
01:08:32,017 --> 01:08:39,115
know if it by default children inherit

1311
01:08:36,088 --> 01:08:43,141
the the blocked bit vector of their

1312
01:08:40,015 --> 01:08:46,704
parents okay so when this child run F

1313
01:08:44,041 --> 01:08:48,660
after it returns from fork at this point

1314
01:08:46,839 --> 01:08:51,873
right after the fork sig child is

1315
01:08:49,029 --> 01:08:53,100
blocked in the child as well right so if

1316
01:08:52,179 --> 01:08:58,060
we didn't do anything if the child

1317
01:08:53,739 --> 01:08:59,560
created children and try to reap you

1318
01:08:58,006 --> 01:09:00,915
know reap them with a sick child handle

1319
01:08:59,056 --> 01:09:02,152
that sick child handler wouldn't run

1320
01:09:00,969 --> 01:09:05,040
right so that would be a problem so in

1321
01:09:03,052 --> 01:09:07,110
the child before we execute that the

1322
01:09:05,679 --> 01:09:10,480
program itself we unblock sick child and

1323
01:09:08,001 --> 01:09:12,450
this is an example that I was alluding

1324
01:09:10,048 --> 01:09:15,867
to last time of how it's useful

1325
01:09:12,549 --> 01:09:20,620
sometimes to separate creating processes

1326
01:09:16,299 --> 01:09:23,140
with executing programs okay so this

1327
01:09:20,062 --> 01:09:24,681
allows us to get our our signal mask set

1328
01:09:23,014 --> 01:09:31,060
up the way we want it before we run our

1329
01:09:25,239 --> 01:09:36,285
program in the child so now even if the

1330
01:09:31,006 --> 01:09:39,037
child terminates early the sig child

1331
01:09:36,699 --> 01:09:42,774
handler won't run until after we've

1332
01:09:39,091 --> 01:09:45,163
added the job to the to the job queue

1333
01:09:43,449 --> 01:09:52,484
because we don't unblock sig child until

1334
01:09:46,063 --> 01:09:52,232
after the until after we call a job okay

1335
01:09:56,063 --> 01:10:02,064
okay now there's another so this this

1336
01:09:59,064 --> 01:10:04,373
sort of scenario will be very relevant

1337
01:10:02,064 --> 01:10:06,069
to you when you do your shell lab okay

1338
01:10:04,949 --> 01:10:12,900
so you want to be careful not to not to

1339
01:10:06,069 --> 01:10:14,082
make that mistake another another thing

1340
01:10:12,009 --> 01:10:16,050
that you you're going to need to do in

1341
01:10:14,082 --> 01:10:18,090
your shell lab now you remember in our

1342
01:10:17,031 --> 01:10:21,108
simple simple shell example we did the

1343
01:10:19,062 --> 01:10:23,138
weight inside the main routine so we

1344
01:10:22,008 --> 01:10:26,897
waited for foreground jobs using weight

1345
01:10:24,038 --> 01:10:28,077
but now in a real shell we're going to

1346
01:10:26,969 --> 01:10:31,830
have our sick child handler do all those

1347
01:10:28,077 --> 01:10:33,144
all the ways call all the weights and

1348
01:10:31,083 --> 01:10:35,151
it.we so we can't put the weight has to

1349
01:10:34,044 --> 01:10:42,123
go in the cig child handler can't go in

1350
01:10:36,051 --> 01:10:44,240
the main routine okay so it so high if

1351
01:10:43,023 --> 01:10:47,088
we can't put a weight in the main

1352
01:10:44,699 --> 01:10:50,100
routine how are we going to how are we

1353
01:10:47,088 --> 01:10:51,152
going to detect that our foreground job

1354
01:10:50,001 --> 01:10:52,043
is finished

1355
01:10:55,969 --> 01:11:02,971
so somehow so what we could do we could

1356
01:10:59,021 --> 01:11:06,092
define in the cig child handler when we

1357
01:11:02,989 --> 01:11:08,840
read the foreground job right we've

1358
01:11:06,092 --> 01:11:11,153
created a foreground job when we read

1359
01:11:08,084 --> 01:11:16,103
that foreground job we could set this

1360
01:11:12,053 --> 01:11:20,075
global flag we could declare the process

1361
01:11:17,003 --> 01:11:23,006
this process ID a variable PID as a

1362
01:11:20,075 --> 01:11:26,111
global flag and then just assign the

1363
01:11:23,033 --> 01:11:30,038
process idea of the of the foreground

1364
01:11:27,011 --> 01:11:32,078
job okay so in this is an example of a

1365
01:11:30,083 --> 01:11:38,132
handler it just all it does it sets a

1366
01:11:32,078 --> 01:11:42,107
flag and then exits and then in our main

1367
01:11:39,032 --> 01:11:45,101
routine okay we want to we want to block

1368
01:11:43,007 --> 01:11:48,026
Zig Cal just but just like before okay

1369
01:11:46,001 --> 01:11:53,057
to avoid that that race condition

1370
01:11:48,026 --> 01:11:57,062
between the parent and the child and

1371
01:11:53,057 --> 01:11:59,102
then we create the child and then and

1372
01:11:57,062 --> 01:12:04,091
then in the and then the parent we set

1373
01:12:00,002 --> 01:12:08,221
PID to zero okay then we unblock Zig

1374
01:12:04,091 --> 01:12:10,094
child and then we wait for the sick

1375
01:12:08,239 --> 01:12:16,264
child handler to run and set T ID to non

1376
01:12:10,094 --> 01:12:18,853
zero okay okay everybody see that I mean

1377
01:12:16,489 --> 01:12:23,260
this so this is correct right but it's

1378
01:12:19,699 --> 01:12:27,751
extremely wasteful right we're spinning

1379
01:12:23,026 --> 01:12:29,102
we're using valuable processor cycles in

1380
01:12:28,219 --> 01:12:31,520
this in this tight spin loop just

1381
01:12:30,002 --> 01:12:32,971
executing over and over and over and

1382
01:12:31,052 --> 01:12:35,093
over and over and over for who knows how

1383
01:12:32,989 --> 01:12:38,840
long okay so that's not a good that's

1384
01:12:35,093 --> 01:12:39,140
not a good solution all right so let's

1385
01:12:38,084 --> 01:12:42,086
look at a couple other things we might

1386
01:12:40,004 --> 01:12:44,803
might consider and that have been

1387
01:12:43,004 --> 01:12:50,203
considered by generations of 213

1388
01:12:45,199 --> 01:12:53,630
students so one thing you might think

1389
01:12:50,239 --> 01:12:58,730
well I'll just instead of just putting a

1390
01:12:53,063 --> 01:13:01,072
semicolon here I'll pause and then I'll

1391
01:12:58,073 --> 01:13:04,312
wait for the sick child handler to run

1392
01:13:02,053 --> 01:13:07,382
and then I'll go back up and I'll check

1393
01:13:04,969 --> 01:13:09,986
I'll check the ID again

1394
01:13:07,859 --> 01:13:13,530
now you have to put this in a loop it

1395
01:13:10,139 --> 01:13:14,222
still has to be in a loop because we

1396
01:13:13,053 --> 01:13:17,252
have other signal handlers in our

1397
01:13:14,969 --> 01:13:18,995
program we have a signet handler so it

1398
01:13:17,729 --> 01:13:20,804
might be if we do the pause here and

1399
01:13:19,229 --> 01:13:24,323
this again comes in and say get to get

1400
01:13:21,479 --> 01:13:26,558
handler runs that would cause us to exit

1401
01:13:25,169 --> 01:13:28,247
the pause function and go back up so we

1402
01:13:27,269 --> 01:13:31,260
have to keep checking PID because we're

1403
01:13:28,949 --> 01:13:34,050
not sure we have to keep checking for

1404
01:13:31,026 --> 01:13:36,425
the specific signal handler see child

1405
01:13:34,005 --> 01:13:40,124
handler to run instead of other handlers

1406
01:13:36,659 --> 01:13:45,737
that might run but this is actually

1407
01:13:40,169 --> 01:13:49,174
wrong because it has a race can you see

1408
01:13:46,439 --> 01:13:48,517
what the race is

1409
01:13:53,085 --> 01:13:56,172
what's wrong with this there's a good

1410
01:13:55,005 --> 01:14:05,006
chance that this thing will block

1411
01:13:57,072 --> 01:14:04,151
forever yes

1412
01:14:14,098 --> 01:14:20,737
yeah that's so the the problem the

1413
01:14:18,949 --> 01:14:24,260
problem with this is like so if the

1414
01:14:21,619 --> 01:14:27,650
signal if the signal is received after

1415
01:14:24,026 --> 01:14:31,755
PID is checked but before the pause

1416
01:14:27,065 --> 01:14:37,054
executes okay which is possible right

1417
01:14:31,989 --> 01:14:42,052
it's unlikely but it's possible if that

1418
01:14:37,639 --> 01:14:44,685
if that signal is arrives here then the

1419
01:14:42,619 --> 01:14:48,980
handler will set T ID to non zero and

1420
01:14:45,099 --> 01:14:50,840
then we'll execute the pause and the

1421
01:14:48,098 --> 01:14:51,125
pause will be blocked forever waiting

1422
01:14:50,084 --> 01:14:53,653
for a signal that will never arrive

1423
01:14:52,025 --> 01:14:58,914
right because the sig Tau's signal

1424
01:14:54,409 --> 01:15:02,150
already already came very subtle right

1425
01:14:59,139 --> 01:15:06,172
so this code looks okay it looks benign

1426
01:15:02,015 --> 01:15:09,754
but it's wrong and and and your program

1427
01:15:06,469 --> 01:15:12,770
would just hang forever so we say well

1428
01:15:09,889 --> 01:15:14,510
okay that's no good we could replace the

1429
01:15:12,077 --> 01:15:18,080
pause with a sleep so we could say let's

1430
01:15:14,051 --> 01:15:20,057
let's check T ID and then sleep for some

1431
01:15:19,007 --> 01:15:25,426
predetermined amount of time in this

1432
01:15:21,011 --> 01:15:28,810
case one second and then go back up and

1433
01:15:25,489 --> 01:15:30,710
check PID again so this while this is

1434
01:15:28,909 --> 01:15:31,990
correct it's way too slow right we're

1435
01:15:30,071 --> 01:15:34,148
asking the system to wait for a second

1436
01:15:32,719 --> 01:15:37,610
which is an eternity and there's there's

1437
01:15:35,048 --> 01:15:39,083
forms of sleep or nanosecond where you

1438
01:15:37,061 --> 01:15:41,050
can wait instead of units of seconds you

1439
01:15:39,083 --> 01:15:44,156
can wait in units of nanoseconds but

1440
01:15:41,599 --> 01:15:47,570
that what value you use right it's that

1441
01:15:45,056 --> 01:15:49,735
so that's if you choose a value that's

1442
01:15:47,057 --> 01:15:51,916
too large then you have this problem the

1443
01:15:50,239 --> 01:15:55,580
slowness problem if you choose a sleep

1444
01:15:52,429 --> 01:15:58,483
time that's too small then you have the

1445
01:15:55,058 --> 01:16:01,407
other problem it's it's inefficient so

1446
01:15:58,969 --> 01:16:04,670
the solution is to use sleep suspend

1447
01:16:01,929 --> 01:16:08,780
which is the last last thing we're going

1448
01:16:04,067 --> 01:16:11,556
to look at today so SIG's suspend is a

1449
01:16:08,078 --> 01:16:14,150
function that takes a signal mask and

1450
01:16:12,159 --> 01:16:19,130
it's equivalent to an uninterruptible

1451
01:16:15,005 --> 01:16:21,062
version of these three statements so we

1452
01:16:19,013 --> 01:16:23,292
block the signals that are specified in

1453
01:16:22,007 --> 01:16:28,596
the signal mask

1454
01:16:23,409 --> 01:16:28,434
and then it's atomic in the sense that

1455
01:16:29,005 --> 01:16:34,028
after this this these two statements

1456
01:16:33,029 --> 01:16:38,042
can't be interrupted they're always

1457
01:16:34,073 --> 01:16:41,082
executed together okay so we block these

1458
01:16:38,042 --> 01:16:46,551
signals and then we execute the pause

1459
01:16:41,739 --> 01:16:49,580
okay so there's no chance of a signal

1460
01:16:46,929 --> 01:16:54,650
interrupting this program in between the

1461
01:16:49,058 --> 01:16:57,367
sig proc mask and the pause okay and

1462
01:16:54,065 --> 01:17:00,634
then and then when a signal does come in

1463
01:16:57,889 --> 01:17:03,889
and the execution of the handle or

1464
01:17:01,219 --> 01:17:07,228
causes pause to exit then we set the

1465
01:17:03,889 --> 01:17:10,280
mask back to what it was before okay so

1466
01:17:08,119 --> 01:17:13,190
the proper way then to wait for a signal

1467
01:17:10,028 --> 01:17:15,367
is to use sig suspend in the following

1468
01:17:13,019 --> 01:17:19,031
way so here's our here's our program

1469
01:17:15,619 --> 01:17:22,250
again we before we create the child we

1470
01:17:19,031 --> 01:17:24,104
block sig child then we create the child

1471
01:17:22,025 --> 01:17:28,028
and now we're going to wait for the sick

1472
01:17:25,004 --> 01:17:32,030
child to be received now sick child is

1473
01:17:28,028 --> 01:17:35,030
still blocked okay so there's no danger

1474
01:17:32,003 --> 01:17:37,025
of the sick child handler running okay

1475
01:17:35,003 --> 01:17:41,057
so we set that global variable to zero

1476
01:17:37,052 --> 01:17:45,128
and then while it's while it's non zero

1477
01:17:41,084 --> 01:17:48,086
we repeatedly call sick suspend and sick

1478
01:17:46,028 --> 01:17:50,102
suspend is using the previous mask that

1479
01:17:48,086 --> 01:17:53,128
was set up here so sick suspend is using

1480
01:17:51,002 --> 01:17:57,010
the mask where sick child is unblocked

1481
01:17:54,028 --> 01:18:02,887
okay when we when we entered this first

1482
01:17:57,001 --> 01:18:07,120
cig proc mask sig child was unblocked so

1483
01:18:03,139 --> 01:18:10,610
this allows inside the sig suspend sig

1484
01:18:07,219 --> 01:18:14,270
tiles is unblocked okay so it allows for

1485
01:18:10,061 --> 01:18:18,820
the the handler now to be received or to

1486
01:18:14,027 --> 01:18:22,034
be executed okay so win it and it does

1487
01:18:19,369 --> 01:18:24,170
it safely because of the uh the atomic

1488
01:18:22,034 --> 01:18:26,433
nature of those those first two

1489
01:18:24,017 --> 01:18:30,070
instructions

1490
01:18:26,739 --> 01:18:33,070
so once the so it's possible that the

1491
01:18:30,007 --> 01:18:35,032
implicit pause inside a sick child could

1492
01:18:33,007 --> 01:18:39,025
be interrupted by say another signal

1493
01:18:35,095 --> 01:18:40,177
like SIGINT okay in which case we'd loop

1494
01:18:39,025 --> 01:18:43,123
back up we'd notice that PID was still

1495
01:18:41,077 --> 01:18:47,082
zero and we go back into sick suspend

1496
01:18:44,023 --> 01:18:49,111
with with sick child unblocked okay

1497
01:18:47,082 --> 01:18:51,100
so that makes sense to everybody and now

1498
01:18:50,011 --> 01:18:53,107
so this is exactly the behavior we want

1499
01:18:52,000 --> 01:18:59,071
where we're not wasting resources but

1500
01:18:54,007 --> 01:19:01,048
we've eliminated the race okay so that's

1501
01:18:59,071 --> 01:19:02,152
it for today if you're interested non

1502
01:19:01,048 --> 01:19:06,085
non-local jumps are this weird thing and

1503
01:19:03,052 --> 01:19:09,057
see that allows a function to return to

1504
01:19:06,085 --> 01:19:11,164
some other function that didn't call it

1505
01:19:10,002 --> 01:19:14,029
but it's described in your textbook and

1506
01:19:12,064 --> 01:19:16,068
also in some additional slides here up

1507
01:19:14,029 --> 01:19:16,104
here if you're interested

