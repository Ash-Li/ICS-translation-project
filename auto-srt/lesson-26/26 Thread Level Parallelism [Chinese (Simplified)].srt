1
00:00:00,003 --> 00:00:07,047
以及大家感兴趣的是如何我们 

2
00:00:05,027 --> 00:00:10,526
座位少填充比在 

3
00:00:07,047 --> 00:00:13,256
课程 的开始，使中 

4
00:00:10,769 --> 00:00:16,080
当然我们是在最后阶段 

5
00:00:13,679 --> 00:00:20,430
这当然你在最后的工作 

6
00:00:16,008 --> 00:00:22,047
实验室， 我们正在 覆盖材料

7
00:00:20,043 --> 00:00:23,124
双方本次讲座和下一讲是 

8
00:00:22,047 --> 00:00:25,053
不是在考试， 你不需要他们 

9
00:00:24,024 --> 00:00:28,047
为您的 网站，从而在一定 程度 上 你 可以 

10
00:00:26,007 --> 00:00:29,091
只是调出并跳过 这一切，如果 

11
00:00:28,047 --> 00:00:34,053
您只有在参加此课程的目的 

12
00:00:29,091 --> 00:00:37,146
是通过它或得到一些年级它 

13
00:00:35,007 --> 00:00:39,105
这就是它也继续 调 出来，但 

14
00:00:38,046 --> 00:00:43,050
另一方面 ， 我们的材料 

15
00:00:40,005 --> 00:00:45,021
讲的是到 非常相关 

16
00:00:43,005 --> 00:00:47,016
电脑是今天，他们是 

17
00:00:45,021 --> 00:00:49,080
打算在未来 ，所以，如果你认为 

18
00:00:47,061 --> 00:00:51,150
大约 从长远来看 无论你的 

19
00:00:49,008 --> 00:00:54,497
投资是在计算机行业 

20
00:00:52,005 --> 00:00:57,078
与计算机技术是那么我认为 

21
00:00:55,289 --> 00:01:01,020
你会发现这些非常值得的，但这样 

22
00:00:58,023 --> 00:01:02,372
认为这更多的是在结冰 

23
00:01:01,002 --> 00:01:05,351
蛋糕，你学过的硬的东西 

24
00:01:02,579 --> 00:01:08,340
你，你所做的破碎部和 

25
00:01:05,369 --> 00:01:10,530
现在你要感谢 超越的那种 

26
00:01:08,034 --> 00:01:13,047
过程中材料的狭窄范围

27
00:01:10,053 --> 00:01:14,082
并且，认为大但真的

28
00:01:13,047 --> 00:01:16,736
你应该 查看此 方式 

29
00:01:14,082 --> 00:01:18,881
在讲座上一讲这将 

30
00:01:17,159 --> 00:01:23,130
所以今天我们是什么星期四 

31
00:01:19,619 --> 00:01:30,170
谈的是并行和 

32
00:01:23,013 --> 00:01:30,017
问题是，那哇

33
00:01:32,005 --> 00:01:38,018
PowerPoint将 是由制造的产品 

34
00:01:35,042 --> 00:01:41,108
某公司在 西雅图， 它不 

35
00:01:38,018 --> 00:01:44,066
总是可靠的 ，但问题是 ，你 

36
00:01:42,008 --> 00:01:48,047
现在知道 ，当 你买电脑 

37
00:01:44,066 --> 00:01:50,114
你 没有得到的只是一个CPU 

38
00:01:48,047 --> 00:01:55,112
处理器芯片，你至少有两个上 

39
00:01:51,014 --> 00:01:59,018
一个典型的笔记本电脑 ，甚至我的手机有两个 

40
00:01:56,012 --> 00:02:04,034
在其核心，以及四个 图形 

41
00:01:59,054 --> 00:02:06,059
处理单元和一个典型的中 

42
00:02:04,034 --> 00:02:09,083
下一代iPad将是 六 

43
00:02:06,059 --> 00:02:11,144
核处理器， 所以这些都 成为不 

44
00:02:09,083 --> 00:02:17,087
只是那种专业领域的 

45
00:02:12,044 --> 00:02:19,091
高端机器，但实际上有 

46
00:02:17,087 --> 00:02:23,105
所有的时间， 实际上我们将讨论 

47
00:02:19,091 --> 00:02:25,100
一些下一次那为什么不是 

48
00:02:24,005 --> 00:02:29,033
有一个快速的电脑，你得到一个

49
00:02:26,081 --> 00:02:30,134
中等大小中等性能

50
00:02:29,033 --> 00:02:32,084
一个或多个片上，并且处理器

51
00:02:31,034 --> 00:02:34,079
这 实际上是一个非常有趣的 

52
00:02:32,084 --> 00:02:37,097
技术 问题，我要谈谈 

53
00:02:34,079 --> 00:02:38,138
接下来的时间，但它是 如此你 的方式 

54
00:02:37,097 --> 00:02:43,151
可以把 它当你写一个程序 

55
00:02:39,038 --> 00:02:47,045
并且它会作为一个单独的线程则 

56
00:02:44,051 --> 00:02:48,113
你基本上没有利用的 

57
00:02:47,045 --> 00:02:51,113
你必须计算资源 

58
00:02:49,013 --> 00:02:53,090
提供给你 这样的东西自然 

59
00:02:52,013 --> 00:02:57,062
好，我们可以让我们的程序运行 

60
00:02:53,009 --> 00:02:59,098
通过做多线程，以便更快

61
00:02:57,062 --> 00:03:02,116
你已经学会或者你在 

62
00:02:59,989 --> 00:03:10,780
将多线程 的过程 

63
00:03:03,016 --> 00:03:14,018
编程的方式来对付 

64
00:03:10,078 --> 00:03:16,091
外部 事件 的并发有 

65
00:03:14,018 --> 00:03:19,079
谁想要使用多台客户端 

66
00:03:16,091 --> 00:03:20,147
和 一个 服务 而不是服务器和 

67
00:03:19,079 --> 00:03:22,166
然后又接着 又如果你能 

68
00:03:21,047 --> 00:03:26,138
处理它们所有它是一个排序的一个 

69
00:03:23,066 --> 00:03:28,705
外用并发但什么 

70
00:03:27,038 --> 00:03:31,927
我们将谈论今天 是更多的 内部 

71
00:03:29,299 --> 00:03:34,730
使用我可以利用多线程

72
00:03:32,269 --> 00:03:37,310
在 多个内核 上运行，以使 

73
00:03:34,073 --> 00:03:40,100
程序运行单个程序的运行速度

74
00:03:37,031 --> 00:03:43,118
而背后的消息是肯定的，但

75
00:03:41,000 --> 00:03:44,045
和我的意思是它 是真正 有可能 

76
00:03:44,018 --> 00:03:46,061
和

77
00:03:44,045 --> 00:03:49,046
人们花了很多 时间做 

78
00:03:46,061 --> 00:03:52,064
程序使用多个跑得更快

79
00:03:49,055 --> 00:03:54,140
线程，但 比你想象 它很难 

80
00:03:52,064 --> 00:03:56,093
它应该 是和它充满了如 

81
00:03:55,004 --> 00:03:58,070
你可能已经经历 

82
00:03:56,093 --> 00:04:00,167
编程错误，但 它也只是 

83
00:03:59,006 --> 00:04:03,295
真是混账很难得到的那种 

84
00:04:01,067 --> 00:04:04,139
表现出来 的多核心 

85
00:04:03,349 --> 00:04:07,400
你 应该会觉得处理器

86
00:04:05,039 --> 00:04:10,070
这将会是可用的，所以我们将谈论 

87
00:04:07,004 --> 00:04:15,005
一些 这一点，那么我们将完成它 

88
00:04:10,007 --> 00:04:16,052
如何如何一点点的理解 

89
00:04:15,005 --> 00:04:19,144
当你写并发程序 

90
00:04:17,015 --> 00:04:22,037
你要想想 的状态 

91
00:04:19,639 --> 00:04:25,100
内存以及如何这对面临的挑战 

92
00:04:22,037 --> 00:04:32,045
多核处理器或任何事实

93
00:04:25,001 --> 00:04:35,069
同时并发系统，以便有 

94
00:04:32,045 --> 00:04:37,124
并发 上实际上有两个来源

95
00:04:35,078 --> 00:04:41,132
现代处理器的多个核是

96
00:04:38,024 --> 00:04:44,033
你有一个实际多个CPU 

97
00:04:42,032 --> 00:04:46,118
单芯片但也有一些 

98
00:04:44,033 --> 00:04:49,034
所谓超线程这 是我的 

99
00:04:47,018 --> 00:04:51,107
经验少有用的，但让我走 

100
00:04:49,043 --> 00:04:55,097
通过这个所以这是一个典型的 

101
00:04:52,007 --> 00:04:58,007
现代处理器看起来像处理器 

102
00:04:55,097 --> 00:05:00,103
芯片是实际上有 一个上 

103
00:04:58,007 --> 00:05:06,053
单芯片有多个 

104
00:05:01,003 --> 00:05:10,052
独立的CPU 和他们每个人都有 

105
00:05:06,053 --> 00:05:14,135
缓存层次结构的某些部分，其 

106
00:05:10,052 --> 00:05:17,081
是专用于 特定的核心， 

107
00:05:15,035 --> 00:05:19,043
再有就是缓存的另一部分 

108
00:05:17,081 --> 00:05:22,097
导致用户在内核和共享层次

109
00:05:20,015 --> 00:05:26,021
然后，他们都有一个共同的接口 

110
00:05:22,097 --> 00:05:27,101
主内存中，因此如果这些内核是 

111
00:05:26,021 --> 00:05:29,045
运行，这是发生了什么 

112
00:05:28,001 --> 00:05:31,022
审计他们正在运行的程序是 

113
00:05:29,045 --> 00:05:32,126
完全独立的没有什么 

114
00:05:31,022 --> 00:05:35,030
与对方那么他们更多或 

115
00:05:33,026 --> 00:05:38,084
少只是 存在和运行，他们是 

116
00:05:35,003 --> 00:05:42,005
高兴，因为可以为他们缓存部件 

117
00:05:38,084 --> 00:05:44,138
自己的状态，你知道 

118
00:05:42,032 --> 00:05:48,059
有时这种高速缓存将获得污染 

119
00:05:45,038 --> 00:05:50,090
通过从其他方面计划垃圾

120
00:05:48,059 --> 00:05:52,130
性能，但它会与物质 

121
00:05:50,009 --> 00:05:54,038
功能，当你的伎俩 

122
00:05:53,003 --> 00:05:56,060
尝试 做多核心编程的 

123
00:05:55,019 --> 00:05:58,048
并行计算的东西越来越莫名其妙 

124
00:05:56,087 --> 00:06:02,162
所有 这些内核 

125
00:05:58,048 --> 00:06:06,116
工作的不同部分 的零件 

126
00:06:03,062 --> 00:06:08,108
在某种程度上 ，使得它如此单一的问题 

127
00:06:07,016 --> 00:06:09,113
你得到的表现 出 它 

128
00:06:09,008 --> 00:06:11,105
他们不会把所有的时间 

129
00:06:10,013 --> 00:06:15,062
基本上彼此 谈论争论

130
00:06:12,005 --> 00:06:17,018
谁访问 了 什么，也即 

131
00:06:15,062 --> 00:06:22,078
他们没有踏过 对方， 

132
00:06:17,018 --> 00:06:25,022
搞乱对方的状态， 

133
00:06:22,078 --> 00:06:27,083
超线程是多一点点 

134
00:06:25,022 --> 00:06:30,068
成怎样的处理器深工程

135
00:06:28,028 --> 00:06:34,046
进行操作，你会 从这次讲座中 回顾 

136
00:06:30,068 --> 00:06:36,089
性能或什么的第5章 

137
00:06:34,046 --> 00:06:40,070
书上 说一个现代微处理器 

138
00:06:36,089 --> 00:06:41,186
看起来完全 不像模型 

139
00:06:40,007 --> 00:06:44,048
你通过看汇编 代码得到

140
00:06:42,086 --> 00:06:47,087
指令的汇编代码的模型 

141
00:06:45,011 --> 00:06:49,076
是你执行一条指令，那么你 

142
00:06:47,096 --> 00:06:51,119
执行下一个，那么你执行 

143
00:06:49,076 --> 00:06:54,094
下 一个现代的 处理器不做 

144
00:06:52,019 --> 00:06:56,116
，在所有他们没有 这样做它 

145
00:06:54,094 --> 00:07:02,159
那么，他们还没有做到这样 的 

146
00:06:57,016 --> 00:07:05,084
30 年，自1995年以来使20 

147
00:07:03,059 --> 00:07:07,142
多年来，他们做这个完全 

148
00:07:05,084 --> 00:07:09,131
不同的方式，其是有时 

149
00:07:08,042 --> 00:07:13,085
被称为 乱 序处理的 

150
00:07:10,031 --> 00:07:16,052
所以只是真正的快速 的 基本 

151
00:07:13,085 --> 00:07:17,123
想法是处理器芯片有上 

152
00:07:16,052 --> 00:07:19,091
是多个功能单元

153
00:07:18,023 --> 00:07:22,028
能够做不同类型的 

154
00:07:19,091 --> 00:07:23,096
操作这些的整数 

155
00:07:22,028 --> 00:07:27,056
算术这些的浮点

156
00:07:24,041 --> 00:07:30,080
算术来回左右，然后有 

157
00:07:27,056 --> 00:07:32,060
分离的块该接口到

158
00:07:30,008 --> 00:07:35,021
记忆里却到高速缓存存储器 

159
00:07:32,006 --> 00:07:37,013
他们俩都加载意义阅读

160
00:07:35,093 --> 00:07:40,120
从 内存和 存储写出 

161
00:07:38,003 --> 00:07:44,003
到内存中，但这些单位有几分 

162
00:07:41,002 --> 00:07:46,010
独立运作，会发生什么 

163
00:07:44,003 --> 00:07:48,062
是还有的逻辑块，其是 

164
00:07:46,028 --> 00:07:51,044
实际上是一个巨大的 具有巨大的块 

165
00:07:48,089 --> 00:07:52,121
在接下来的86处理器的逻辑

166
00:07:51,044 --> 00:07:55,091
读取指令出的 

167
00:07:53,021 --> 00:07:58,088
指令流撕裂它们分开成

168
00:07:55,091 --> 00:08:00,098
小件 跟踪 数据 

169
00:07:58,088 --> 00:08:02,180
依赖和控制依赖

170
00:08:00,098 --> 00:08:05,287
然后安排所有不同 

171
00:08:03,008 --> 00:08:07,627
在您对这些程序操作 

172
00:08:06,169 --> 00:08:11,210
不同的功能单元，所以我们聊 

173
00:08:08,419 --> 00:08:11,434
一些关于 在怎样的背景下 

174
00:08:11,021 --> 00:08:13,260
能够

175
00:08:11,569 --> 00:08:18,490
编写一个程序， 将整理的 

176
00:08:13,449 --> 00:08:21,451
最大限度地提高多少是怎么回事这儿 

177
00:08:18,049 --> 00:08:25,468
通过一种特殊的方式编写代码 

178
00:08:21,469 --> 00:08:27,556
所以这一切都是介绍说， 

179
00:08:25,909 --> 00:08:31,630
这是你怎么也得 明白 

180
00:08:28,339 --> 00:08:33,382
超线程是这样在单一

181
00:08:31,063 --> 00:08:37,094
执行模式有一个基本 

182
00:08:33,769 --> 00:08:39,793
指令解码器，它有它自己的 

183
00:08:37,094 --> 00:08:43,097
集邦这里了自己的方案 

184
00:08:40,009 --> 00:08:45,103
应对其自身业务的队列 

185
00:08:44,024 --> 00:08:48,103
它已经解码，并没有 

186
00:08:45,949 --> 00:08:49,036
完成但它有它自己的一套

187
00:08:48,319 --> 00:08:51,346
登记他们其实并没有 

188
00:08:49,819 --> 00:08:54,560
注册像你期望他们 

189
00:08:51,589 --> 00:08:57,676
他们是高度虚拟化的寄存器， 但 

190
00:08:54,056 --> 00:09:00,098
这一切的状态是有帮助 到 

191
00:08:58,459 --> 00:09:04,310
服务的 一个线程的执行

192
00:09:00,098 --> 00:09:06,447
执行与超线程基本上 

193
00:09:04,031 --> 00:09:10,118
你要做的就是就是说想法 

194
00:09:07,329 --> 00:09:12,500
90％ 的所有程序都不能很好的 

195
00:09:11,018 --> 00:09:16,055
利用所有这些功能单元的

196
00:09:12,005 --> 00:09:19,043
特别是 如果你阻止的负载 

197
00:09:16,055 --> 00:09:21,086
因为有在缓存中的缺失则 

198
00:09:19,088 --> 00:09:24,104
所有这些计算单元都坐在 

199
00:09:21,086 --> 00:09:28,093
有没有任何有用的工作要做好 

200
00:09:25,004 --> 00:09:33,913
所以我们为什么不只是加倍或 

201
00:09:28,093 --> 00:09:37,112
四倍上 K次向上的状态 

202
00:09:33,949 --> 00:09:40,610
与解码和控制相关联的

203
00:09:38,012 --> 00:09:43,831
该计划的一部分，这样就 可以 

204
00:09:40,061 --> 00:09:45,092
在运行 多线程 和 

205
00:09:43,939 --> 00:09:49,370
之间共享这些功能单元 

206
00:09:45,092 --> 00:09:50,129
对方所以他们真的工作 

207
00:09:49,037 --> 00:09:53,806
独立的状态不是 

208
00:09:51,029 --> 00:09:58,138
交织在一起，但他们那种使 

209
00:09:54,139 --> 00:09:59,221
更多地利用 现有硬件的 

210
00:09:58,399 --> 00:10:01,880
执行功能，所以这是 

211
00:09:59,959 --> 00:10:05,000
所谓超线程这是英特尔

212
00:10:01,088 --> 00:10:07,091
学期，你也有时会 听到叫SMT 

213
00:10:05,000 --> 00:10:10,939
同时多线程和我 

214
00:10:08,018 --> 00:10:12,026
经验，我们会看到这里的 

215
00:10:10,939 --> 00:10:16,550
数它并没有真正做出 大 

216
00:10:12,098 --> 00:10:18,937
有差别 ，但它原来是 在 

217
00:10:16,055 --> 00:10:21,814
那种大画面的东西 

218
00:10:19,819 --> 00:10:24,170
对他们来说相对便宜的功能

219
00:10:22,309 --> 00:10:25,040
扔在处理器和让他们做

220
00:10:24,017 --> 00:10:28,546
它

221
00:10:25,004 --> 00:10:31,019
所以现在至少有86 

222
00:10:28,699 --> 00:10:35,120
处理器通常必须权衡 

223
00:10:31,019 --> 00:10:37,108
在他们超线程所以考虑到，如果 

224
00:10:35,012 --> 00:10:39,017
你看看我们的鲨鱼机有哪些 

225
00:10:37,279 --> 00:10:42,620
有点老有那种2010 

226
00:10:39,062 --> 00:10:44,075
时代的机器，但他们是 高端 

227
00:10:42,062 --> 00:10:47,281
每天在他们的机器，所以他们仍然 

228
00:10:44,075 --> 00:10:49,118
实际上比更强大的 是什么 

229
00:10:47,839 --> 00:10:53,060
你会买是说一个桌面和方式更多

230
00:10:50,018 --> 00:10:54,056
不是作为一台笔记本电脑，你会得到强大 

231
00:10:53,006 --> 00:10:56,081
所以今天它们实际上是相当不错的 

232
00:10:54,056 --> 00:10:59,117
机其实我们接下来会说话

233
00:10:56,081 --> 00:11:00,173
时间为什么电脑还不是很多 

234
00:11:00,017 --> 00:11:02,686
比 五年前更快

235
00:11:01,073 --> 00:11:08,144
这实际上有趣 

236
00:11:02,839 --> 00:11:10,888
技术的事情，所以他们 他们是服务器 

237
00:11:09,044 --> 00:11:13,091
一流的设备， 使 他们有多个 

238
00:11:11,329 --> 00:11:19,660
内核，他们有他们的其中八个 

239
00:11:13,091 --> 00:11:22,172
是很多 ，你 可以买 十个核机 

240
00:11:19,066 --> 00:11:25,093
一个单一的芯片，但我在x86机器上

241
00:11:23,072 --> 00:11:27,167
不要以为你可以得到更多的却又 如此 

242
00:11:25,093 --> 00:11:29,156
这些人的比较先进的机 

243
00:11:28,067 --> 00:11:36,466
他们的一天，他们也有 双向 

244
00:11:30,056 --> 00:11:38,147
超线程所以理论上你应该 

245
00:11:37,069 --> 00:11:42,430
能够获得 16个独立 线程 

246
00:11:39,047 --> 00:11:44,129
运行排序 16 路并行 的 

247
00:11:42,043 --> 00:11:47,048
可能出程序的 ，如果你能 

248
00:11:45,029 --> 00:11:51,106
让一切工作，并保持不错 

249
00:11:47,093 --> 00:11:51,106
从发生的事情

250
00:11:54,199 --> 00:11:59,288
所以让我们给一个真是小巫见大巫

251
00:11:57,049 --> 00:12:02,146
应用一个应该 是很 

252
00:12:00,089 --> 00:12:05,135
简单的 并行，使跑，说 

253
00:12:03,019 --> 00:12:08,042
想象我们要总结的数字 

254
00:12:05,549 --> 00:12:09,578
介于0和n 减 1，其由 

255
00:12:08,249 --> 00:12:11,220
方式真正 愚蠢的事情，因为 

256
00:12:09,839 --> 00:12:13,856
有一个很简单的封闭形式 

257
00:12:11,022 --> 00:12:15,251
式为它是在良好 

258
00:12:14,009 --> 00:12:18,046
感觉这将让我们检查我们的工作 

259
00:12:15,449 --> 00:12:21,497
但它是一个 完全愚蠢的程序 

260
00:12:18,379 --> 00:12:23,435
但它只是说明 你这个想法 等 

261
00:12:21,929 --> 00:12:26,993
我们只是要做的是就是块 

262
00:12:23,939 --> 00:12:29,941
关闭，如果我们有N 路并行我们 

263
00:12:27,569 --> 00:12:35,582
只是要分裂 我们的数字范围 

264
00:12:29,959 --> 00:12:38,030
n路，只是有一个线程 总和 

265
00:12:35,699 --> 00:12:40,790
了一个n的数字，然后他们会 

266
00:12:38,669 --> 00:12:43,676
合加在一起的 结果 

267
00:12:41,609 --> 00:12:45,653
一些这样或那样所以这大约是 

268
00:12:44,369 --> 00:12:46,414
易并行程序 ，你可能 

269
00:12:46,049 --> 00:12:50,090
想像

270
00:12:46,819 --> 00:12:52,825
所以让我们做了一个版本，据说这是 

271
00:12:50,459 --> 00:12:55,505
以及哎呀我知道如何使用线程 

272
00:12:53,419 --> 00:12:59,423
P个线程，我知道这些事情 

273
00:12:55,919 --> 00:13:01,925
所谓的信号灯或互斥如此 

274
00:12:59,459 --> 00:13:05,730
我要做的只是一切的一切都爱 

275
00:13:02,519 --> 00:13:09,545
在内存中的一个地方，我收集 

276
00:13:05,073 --> 00:13:11,672
在所有n值和一个 总和 

277
00:13:09,779 --> 00:13:14,970
线程能够 ，如果将其 添加 到 

278
00:13:12,329 --> 00:13:17,402
它会锁定它，它会得到一个相互 

279
00:13:14,097 --> 00:13:19,122
它独占访问 增加它和 

280
00:13:18,059 --> 00:13:23,730
然后打开它，我们就会让所有的 

281
00:13:20,022 --> 00:13:26,141
线程去仓惶 锁定 

282
00:13:23,073 --> 00:13:29,912
和解锁这使该代码

283
00:13:26,339 --> 00:13:33,341
很容易 把它写它在这里是 

284
00:13:30,569 --> 00:13:35,576
该代码，当然所有螺纹 

285
00:13:33,359 --> 00:13:38,160
代码看上去混乱比你想象 

286
00:13:35,639 --> 00:13:41,674
它应该但最终这是一个相当 

287
00:13:38,016 --> 00:13:47,675
简单的代码，以便在特定

288
00:13:41,989 --> 00:13:49,007
这 是线程程序传递 

289
00:13:47,819 --> 00:13:52,918
通过这个奇怪的 bargue 

290
00:13:49,169 --> 00:13:56,174
豌豆结构，你用做 

291
00:13:53,809 --> 00:13:59,220
线程的方式传递参数给 

292
00:13:56,669 --> 00:14:01,470
线程程序，但基本上它是

293
00:13:59,022 --> 00:14:05,031
搞清楚在哪里开始和结束 

294
00:14:01,047 --> 00:14:08,073
数的范围内再加入

295
00:14:06,012 --> 00:14:13,074
对于所有的开始 之间 还没等我 

296
00:14:08,073 --> 00:14:16,074
最后，我会锁定该 获得 

297
00:14:13,074 --> 00:14:18,173
旗语锁我就会增加 一次 

298
00:14:16,074 --> 00:14:21,165
全球总和，然后我就会解除 

299
00:14:18,839 --> 00:14:24,350
锁定好了，所以相当多的风格 

300
00:14:22,065 --> 00:14:26,088
你一直使用 的代码 和 

301
00:14:24,035 --> 00:14:29,126
你发现了什么是其实 这 是 真的 

302
00:14:26,088 --> 00:14:32,121
一个坏主意 ， 所以运行作为单线程 

303
00:14:30,026 --> 00:14:35,028
它需要51秒做到这一点它会 

304
00:14:33,021 --> 00:14:36,027
是的方式，如果你没有锁定和 

305
00:14:35,046 --> 00:14:38,675
解锁，因为它只有一个线程 

306
00:14:36,081 --> 00:14:41,100
你吹这个客场将采取只 

307
00:14:39,089 --> 00:14:43,094
几秒钟左右，然后你看到的 

308
00:14:42,000 --> 00:14:46,005
你添加更多的线程，它实际上得到 

309
00:14:43,589 --> 00:14:50,370
糟糕， 特别是如果你从跳 

310
00:14:46,005 --> 00:14:52,101
一到两个你的一个因素9增加 

311
00:14:50,037 --> 00:14:55,256
它是如何花费的时间也只有它 

312
00:14:53,046 --> 00:14:57,048
开始得到更好的为你成 

313
00:14:55,589 --> 00:15:03,480
八个线程，然后将它变得更糟 

314
00:14:57,048 --> 00:15:05,657
再这样的原因是锁定和 

315
00:15:03,048 --> 00:15:08,082
解锁是一个非常耗时的任务 

316
00:15:06,089 --> 00:15:11,108
基本上你能想到的是 ， 

317
00:15:08,082 --> 00:15:12,129
你如果有地图 

318
00:15:11,279 --> 00:15:16,230
与所有多核处理器的

319
00:15:13,029 --> 00:15:17,115
在一个共享的缓存私有的高速缓存这些 

320
00:15:16,023 --> 00:15:21,060
螺纹基本上每个战斗

321
00:15:18,015 --> 00:15:24,074
另一个用于为一个存储器控制 

322
00:15:21,006 --> 00:15:26,091
解决他们，他们是 

323
00:15:24,074 --> 00:15:29,148
递增和它抢

324
00:15:27,045 --> 00:15:34,050
从一个核心 的控制 远 

325
00:15:30,048 --> 00:15:36,135
核心多数民众赞成访问它做锁 

326
00:15:34,005 --> 00:15:38,070
解锁， 然后它被抓住回来 

327
00:15:37,035 --> 00:15:41,082
它所以这是一个悲惨的性能或 

328
00:15:39,015 --> 00:15:44,070
信号量缓存巨大的开销 

329
00:15:41,082 --> 00:15:46,145
活动，只是 真的坏事 

330
00:15:44,007 --> 00:15:47,094
各地，这样的教训之一是 

331
00:15:47,045 --> 00:15:52,056
信号灯

332
00:15:48,057 --> 00:15:53,082
或互斥是非常昂贵的，如果 

333
00:15:52,056 --> 00:15:55,775
你正在试图做的低水平 

334
00:15:53,082 --> 00:15:58,113
并行你不想细粒度 

335
00:15:56,279 --> 00:16:02,100
在该级别锁定否则你 

336
00:15:59,013 --> 00:16:04,089
只是完全沉没 ，因此这不是 

337
00:16:02,001 --> 00:16:06,036
要做到这一点，我会进入，但 

338
00:16:04,089 --> 00:16:07,095
有大约相当多的 文献 

339
00:16:06,045 --> 00:16:11,049
他们所谓的无锁同步 

340
00:16:08,049 --> 00:16:13,056
这是为了避免信号量的方式，但 

341
00:16:11,049 --> 00:16:15,126
得到的效果，他们不会在工作 

342
00:16:13,056 --> 00:16:17,064
这种情况下无论是那些刚刚如果你已经 

343
00:16:16,026 --> 00:16:19,077
听说过这个词的一般 

344
00:16:18,036 --> 00:16:22,104
设计

345
00:16:19,077 --> 00:16:24,896
你想到哪里比较实例

346
00:16:23,004 --> 00:16:27,069
线程之间的竞争不大 

347
00:16:25,589 --> 00:16:31,070
所以你尽量 保持乐观的态度 

348
00:16:27,069 --> 00:16:33,111
然后回滚如果有什么不好的事情发生 

349
00:16:31,007 --> 00:16:35,061
这是一个情况下 都能跟得上所有这些 

350
00:16:34,011 --> 00:16:37,035
线程将要 冲击的是 

351
00:16:35,061 --> 00:16:39,063
一个内存位置 ，他们真的很 

352
00:16:37,035 --> 00:16:43,119
争取它，所以 没有什么好 

353
00:16:39,081 --> 00:16:45,165
解决这一问题 的另一件事 

354
00:16:44,019 --> 00:16:49,074
我要指出的是这一跳在这里 表演 

355
00:16:46,065 --> 00:16:53,094
你超线程是不是真的 

356
00:16:49,074 --> 00:16:55,101
帮助我们在这里从一个事实，即去 

357
00:16:53,094 --> 00:16:56,169
我们从 8至16个手段 减缓 

358
00:16:56,001 --> 00:16:59,010
我们真的不能使用十六 

359
00:16:57,069 --> 00:17:01,140
在这种应用 八线程

360
00:16:59,091 --> 00:17:03,138
线程是超过四个更好，但 

361
00:17:02,004 --> 00:17:05,049
显然一切有点浪费 

362
00:17:04,038 --> 00:17:10,053
时间，因为这 仅仅 是 一个真正的坏 

363
00:17:05,085 --> 00:17:12,137
想法各地 让我们做一些事情 

364
00:17:10,053 --> 00:17:15,602
不同让我们每个人 

365
00:17:13,037 --> 00:17:19,125
积累自己的总和为自己 

366
00:17:16,079 --> 00:17:24,650
子范围，我们就会放弃，所以我们会 

367
00:17:20,025 --> 00:17:27,974
有蓄能器，其中的阵列

368
00:17:24,065 --> 00:17:30,123
每个线程被递增只有一个 

369
00:17:28,199 --> 00:17:33,300
这个数组的元素，以便他们不 

370
00:17:31,023 --> 00:17:35,972
直接相互争抢它 

371
00:17:33,003 --> 00:17:39,084
但他们都在争取 ，如果你认为 

372
00:17:36,179 --> 00:17:42,600
它为同一高速缓存行，因为 

373
00:17:40,011 --> 00:17:47,022
阵列通常被存储，因此它的 

374
00:17:42,006 --> 00:17:49,029
没有完全好，但 它给你一个 

375
00:17:47,022 --> 00:17:53,025
指针指向这个想法，如果我们可以 排序 的 

376
00:17:49,083 --> 00:17:55,100
进入私人 状态的东西 ， 

377
00:17:53,052 --> 00:17:59,067
我们正在 以 最直接 的 访问 

378
00:17:56,000 --> 00:18:02,064
然后我们会得到更好的性能 等等 

379
00:17:59,067 --> 00:18:03,075
这是常规线 和点 

380
00:18:02,064 --> 00:18:07,103
是 ， 有一些所谓的全局数组 

381
00:18:04,047 --> 00:18:09,066
P一些，但它只是递增 

382
00:18:07,679 --> 00:18:13,470
它的部分之类的分配 

383
00:18:09,066 --> 00:18:14,163
这个特殊的线程，在这里你做 

384
00:18:13,047 --> 00:18:18,048
看到性能改进权利，使 

385
00:18:15,063 --> 00:18:20,094
一个线程需要五秒的时间记 

386
00:18:18,048 --> 00:18:24,077
这是 58前，使显示 的只是 

387
00:18:20,094 --> 00:18:26,190
信号灯的成本优势

388
00:18:24,077 --> 00:18:28,122
在那里为10个 ，你的一个因素

389
00:18:27,009 --> 00:18:30,038
看到你实际得到 的 

390
00:18:29,022 --> 00:18:32,091
改善所有跨线 

391
00:18:30,929 --> 00:18:35,190
包括高达16 3 

392
00:18:32,091 --> 00:18:36,108
-仍然得到改善 ，将 

393
00:18:35,019 --> 00:18:39,036
拉平我应该所示 

394
00:18:37,008 --> 00:18:41,076
号432，但它会在变平 

395
00:18:39,036 --> 00:18:43,041
这一点，但它实际上是越来越 

396
00:18:41,076 --> 00:18:46,134
一些优势了超线程作为 

397
00:18:43,041 --> 00:18:50,106
舒服，所以这是很好的它不是 一个惊人 

398
00:18:47,034 --> 00:18:52,116
加快使你能想到的他们 

399
00:18:51,006 --> 00:18:55,014
调用速度提高了性能 

400
00:18:53,016 --> 00:18:58,029
它在单核与运行 

401
00:18:55,086 --> 00:19:00,135
n个内核，并在理想的性能

402
00:18:58,029 --> 00:19:05,124
情况下它会快N倍，我们很 

403
00:19:01,035 --> 00:19:07,089
不太击中所有，但这里的 

404
00:19:06,024 --> 00:19:10,122
你已经了解到， 这是 

405
00:19:07,089 --> 00:19:13,140
普遍不好被累积成 

406
00:19:11,022 --> 00:19:16,095
内存为什么不能做的事情，我们 

407
00:19:14,004 --> 00:19:18,069
这是你积累以前学过

408
00:19:16,095 --> 00:19:20,136
在寄存器中，你只更新 

409
00:19:19,005 --> 00:19:23,016
当你与这样做内存

410
00:19:21,036 --> 00:19:26,049
让我们只是做到这一点 ，我会打电话给那 

411
00:19:23,016 --> 00:19:29,049
本地版本我就递增 

412
00:19:26,049 --> 00:19:33,086
总和，其是一个局部变量和唯一 

413
00:19:29,049 --> 00:19:38,055
当我做我就会把它存储在 

414
00:19:33,086 --> 00:19:39,123
全局数组好了，所以它在功能上 

415
00:19:38,055 --> 00:19:41,127
相当于一个我们刚刚出现

416
00:19:40,023 --> 00:19:44,034
我们准备搬家，而不是 

417
00:19:42,027 --> 00:19:47,031
积累在全球阵列我们

418
00:19:44,034 --> 00:19:49,121
累积在寄存器中，在这里你 

419
00:19:47,067 --> 00:19:53,085
看到一个相当大的性能提升 

420
00:19:50,021 --> 00:19:57,033
那么蓝就是我们显示出与该 

421
00:19:53,085 --> 00:20:00,171
全球阵 红色或橙色是什么 

422
00:19:57,033 --> 00:20:02,112
这个局部变量，所以你看到它的 

423
00:20:01,071 --> 00:20:07,157
实际上有趣我们得到一个 

424
00:20:03,012 --> 00:20:11,091
性能改进以及虽然 

425
00:20:08,057 --> 00:20:14,085
它在8见底，它实际上 得到 

426
00:20:11,091 --> 00:20:15,132
更糟糕 ，当你到16，这 是 

427
00:20:14,085 --> 00:20:17,139
示出 超线程不 

428
00:20:16,032 --> 00:20:20,078
真正帮助这里，因为基本上

429
00:20:18,039 --> 00:20:23,103
在单线程只是 

430
00:20:20,078 --> 00:20:27,132
积累尽可能快，因为它可以和 

431
00:20:24,003 --> 00:20:30,039
增加寄存器，因此它 使 

432
00:20:28,032 --> 00:20:32,048
相当不错的使用什么功能单元 

433
00:20:30,039 --> 00:20:34,122
它使用并把多线程 

434
00:20:32,048 --> 00:20:40,062
分享它不是真正帮助至少 

435
00:20:35,022 --> 00:20:42,089
没有鲨鱼机这实际上 

436
00:20:40,062 --> 00:20:44,120
可能是在 不同的机器 不同 

437
00:20:42,089 --> 00:20:46,121
实际上，如果你从召回 

438
00:20:45,002 --> 00:20:48,451
性能优化，我们发现，

439
00:20:47,021 --> 00:20:50,710
如果你只是做了一堆 

440
00:20:48,649 --> 00:20:52,690
添加你可以利用的 

441
00:20:50,899 --> 00:20:55,220
肖夏tivity并获得更多的

442
00:20:53,059 --> 00:20:57,440
积累并行，所以你可以 

443
00:20:55,022 --> 00:20:58,094
实际上加快了这一计划 只是 

444
00:20:57,044 --> 00:21:01,003
这个程序的单线程版本 

445
00:20:58,094 --> 00:21:04,423
非常好，但不管怎么说它表明， 

446
00:21:01,399 --> 00:21:07,477
好吧，这是开始 看起来 像你的 

447
00:21:05,269 --> 00:21:10,321
你的一个你的单线程性能 

448
00:21:08,179 --> 00:21:14,215
是相当不错的和B你得到一些 

449
00:21:10,789 --> 00:21:15,814
有用加快了并行， 但 

450
00:21:14,539 --> 00:21:17,545
正如我所说，这是像 最简单 的 

451
00:21:16,039 --> 00:21:21,950
例如，在世界 平行的生活如此 

452
00:21:18,139 --> 00:21:23,166
如果你不能做到这一点这里，那么当时的生活 

453
00:21:21,095 --> 00:21:27,101
很绝望，只要 

454
00:21:23,409 --> 00:21:30,740
多线程所以让我们来谈谈，因为我 

455
00:21:28,001 --> 00:21:33,026
提到这个想法的 加速使 

456
00:21:30,074 --> 00:21:35,135
加速只是定义为时间 

457
00:21:33,026 --> 00:21:41,045
对于一个单线程程序 除以 

458
00:21:36,035 --> 00:21:44,057
为4个P线程时运行 或 

459
00:21:41,045 --> 00:21:53,126
居然会用它P 芯代替 

460
00:21:44,057 --> 00:21:56,266
P个线程问题是一般 

461
00:21:54,026 --> 00:21:59,935
调度有某种 去 跳舞 的 

462
00:21:56,779 --> 00:22:02,570
内置到它，它会倾向于 

463
00:22:00,169 --> 00:22:05,260
尤其是在这样的情况 下 

464
00:22:02,057 --> 00:22:08,150
线程排序的抓取和运行 

465
00:22:05,026 --> 00:22:12,083
使得他们通常会 得到传播 

466
00:22:09,005 --> 00:22:14,006
在整个过程中所以 这是一个相当的 

467
00:22:12,083 --> 00:22:16,094
Linux调度是 在那个 不错 

468
00:22:14,006 --> 00:22:23,695
当你有比有更多的线程 

469
00:22:16,094 --> 00:22:26,159
是核心，然后再就基本开始

470
00:22:24,289 --> 00:22:32,720
在一些循环顺序安排他们和 

471
00:22:27,059 --> 00:22:34,124
你不会，你会在最好的，你不会 

472
00:22:32,072 --> 00:22:36,107
获得任何优势，在最坏的情况下， 

473
00:22:35,024 --> 00:22:39,122
你真正开始从放缓 

474
00:22:37,007 --> 00:22:42,032
具有比多线程有很好的 

475
00:22:40,022 --> 00:22:44,087
问题所以没什么两个版本 

476
00:22:42,032 --> 00:22:46,121
的加速一个是，如果我把我的 

477
00:22:44,087 --> 00:22:49,109
多线程的程序，并运行它

478
00:22:47,021 --> 00:22:52,097
一个线程，然后我遇到了这样做的P 

479
00:22:50,009 --> 00:22:54,958
线程或内核 ，我可以得到一个 加速 

480
00:22:52,097 --> 00:22:55,126
但实际上更真实的 事情是，如果我 

481
00:22:55,039 --> 00:22:58,690
拿最知名的 

482
00:22:56,026 --> 00:23:01,075
递推算法 执行此 

483
00:22:58,069 --> 00:23:03,097
任务与最佳实施 

484
00:23:01,075 --> 00:23:05,083
这一点 ，然后我对我的比较 

485
00:23:03,097 --> 00:23:08,146
并联的一个所以这被称为 

486
00:23:05,083 --> 00:23:11,089
绝对加速这是最好的 

487
00:23:09,046 --> 00:23:13,132
测量你知道你给双方 

488
00:23:11,089 --> 00:23:15,145
机会做最好 

489
00:23:14,032 --> 00:23:18,037
实施，他们可以再 

490
00:23:16,045 --> 00:23:21,112
你比较一下，然后什么简称 

491
00:23:18,082 --> 00:23:23,131
为效率是如何接近 

492
00:23:22,012 --> 00:23:25,108
加速 获得理想的加速，其 

493
00:23:24,031 --> 00:23:28,102
是，如果我P上内核上运行 

494
00:23:26,008 --> 00:23:31,057
我应该为P倍的速度，你会

495
00:23:29,002 --> 00:23:33,073
看到我们，你 知道的问题 

496
00:23:31,057 --> 00:23:36,082
超线程与没有 我们那种 

497
00:23:33,073 --> 00:23:39,130
这里我们要说不，你不我们不 

498
00:23:36,082 --> 00:23:41,113
试图从获得超线程 你 

499
00:23:40,003 --> 00:23:44,080
可以玩这个游戏的各种方式和你 

500
00:23:42,013 --> 00:23:47,062
可以说来回是否 

501
00:23:45,007 --> 00:23:50,059
超线程应该算作所以P 是 

502
00:23:47,062 --> 00:23:52,099
P可能的线程的总数

503
00:23:50,059 --> 00:23:57,088
或 核心的总数是 

504
00:23:52,099 --> 00:24:01,102
真的东西 扯皮 

505
00:23:57,088 --> 00:24:04,111
关于这样的点是效率 

506
00:24:02,002 --> 00:24:09,061
虽然是衡量有多少，我们做 

507
00:24:05,011 --> 00:24:12,028
相对于理想的，因此这是什么 

508
00:24:09,061 --> 00:24:14,110
你得到这个代码的本地版本 

509
00:24:12,028 --> 00:24:17,107
P的部分，你会看到我们的效率

510
00:24:15,001 --> 00:24:21,076
数字是在 高某处

511
00:24:18,007 --> 00:24:24,022
这是很好的，但不会有人范围

512
00:24:21,085 --> 00:24:26,116
大这是相当不错实际上，如果你 

513
00:24:24,022 --> 00:24:28,027
可以得到 75％ 的效率，你正在做的 

514
00:24:27,016 --> 00:24:29,095
最 要好 ，但再次这 

515
00:24:28,072 --> 00:24:32,103
因为这本来应该是 

516
00:24:29,095 --> 00:24:37,102
世界上最简单的程序并行 

517
00:24:33,003 --> 00:24:40,060
所以，最好的加速我们得到

518
00:24:38,002 --> 00:24:43,060
是六出于八个 核心的因素等等 

519
00:24:40,006 --> 00:24:47,020
再次就不错了，但是这真的 

520
00:24:43,006 --> 00:24:50,020
应该是你可以 做的这么好 

521
00:24:47,074 --> 00:24:53,152
只是给你一个什么样的味道 

522
00:24:50,074 --> 00:24:56,089
并行计算可以是这样，现在是 

523
00:24:54,052 --> 00:25:00,094
有点背过，聊一些一般 

524
00:24:56,089 --> 00:25:01,135
原理就像加速有 

525
00:25:00,094 --> 00:25:03,100
基因组 达尔 的每吨 谁 

526
00:25:02,035 --> 00:25:06,073
巧合的是刚刚去世几个星期前 

527
00:25:04,054 --> 00:25:09,076
你 可能会在 新闻 中已经看到了 他 

528
00:25:06,073 --> 00:25:09,522
在IBM原有的先驱者之一 

529
00:25:09,076 --> 00:25:12,105
在

530
00:25:10,179 --> 00:25:17,217
他们的大型计算机，然后再在 

531
00:25:12,789 --> 00:25:18,873
某些时候，他在60年代，他开始了他 

532
00:25:17,559 --> 00:25:21,606
自己的公司称为庵 DAL电脑 

533
00:25:19,629 --> 00:25:24,940
他们就像他们是凉爽 

534
00:25:22,029 --> 00:25:27,720
公司在大型计算机如果 

535
00:25:24,094 --> 00:25:30,693
能否 被认为是凉爽 的权利 和 

536
00:25:27,072 --> 00:25:32,631
他 建立了一个 竞争对手对 IBM说 

537
00:25:31,539 --> 00:25:35,562
绝对驱使他们疯狂，因为他们

538
00:25:33,279 --> 00:25:38,376
有一个虚拟的垄断，他们实际上 

539
00:25:35,769 --> 00:25:41,868
是受到反垄断诉讼所以， 嗯 

540
00:25:39,249 --> 00:25:44,590
达尔 是反叛的西装谁 

541
00:25:42,759 --> 00:25:47,847
从母公司打破了并且 

542
00:25:44,059 --> 00:25:49,878
开始一个竞争对手，他做出这个 

543
00:25:48,639 --> 00:25:54,940
很简单的观察这就是所谓的 

544
00:25:50,409 --> 00:25:57,070
Amdahl定律基本上是初中 

545
00:25:54,094 --> 00:25:58,146
高水平代数想到这一点 ，但 

546
00:25:57,007 --> 00:26:02,316
它实际上是一个相当敏锐的点 

547
00:25:59,046 --> 00:26:04,069
关于什么是可能的好处

548
00:26:02,379 --> 00:26:06,384
加快东西，这 是 

549
00:26:04,069 --> 00:26:07,111
你知道这 本书讨论

550
00:26:06,429 --> 00:26:09,940
不仅仅是电脑它的任何 

551
00:26:08,011 --> 00:26:12,420
要加快进程， 

552
00:26:09,094 --> 00:26:15,153
这是非常简单的 观察是 

553
00:26:12,519 --> 00:26:18,534
据说在 系统的 某些部分 

554
00:26:15,999 --> 00:26:21,054
我可以走得更快， 我会打电话给 

555
00:26:18,669 --> 00:26:25,674
那部分是PP 之间的 一些数 

556
00:26:21,549 --> 00:26:29,320
零和一点 零权 100％ 的零 

557
00:26:26,169 --> 00:26:31,240
％，而假设我们采取 

558
00:26:29,032 --> 00:26:33,070
我们打算让运行速度更快的一部分

559
00:26:31,024 --> 00:26:38,107
并能由因子提高其性能 

560
00:26:33,007 --> 00:26:41,020
好吧，那么我们就可以非常 简单谈 

561
00:26:39,007 --> 00:26:44,011
什么将成为该利益 

562
00:26:41,083 --> 00:26:47,892
性能，所以我们就叫它 透射次K和 

563
00:26:44,011 --> 00:26:53,400
它说什么是对的p部分 

564
00:26:48,639 --> 00:26:56,710
时间会被K，但可以减少 

565
00:26:53,499 --> 00:27:00,100
分数，你不能改变 一个 

566
00:26:56,071 --> 00:27:02,370
减去P将保留其旧时代和 

567
00:27:00,001 --> 00:27:04,090
我是娃娃 的法律就是这样这就是 

568
00:27:03,009 --> 00:27:08,350
整个事情，一个有趣的措施 

569
00:27:04,099 --> 00:27:09,648
是什么，如果K含量无穷大，如果我们什么 

570
00:27:08,035 --> 00:27:15,109
有无限的资源，以提高办事效率

571
00:27:10,539 --> 00:27:19,470
起来，什么观察是最好的 

572
00:27:16,009 --> 00:27:22,060
加快你将得到的是1个减去P 和 

573
00:27:19,047 --> 00:27:23,098
所以才觉得它这样，如果你有 

574
00:27:22,006 --> 00:27:27,455
它的百分之十是 

575
00:27:23,098 --> 00:27:31,126
无法改变对方90％你做 

576
00:27:28,049 --> 00:27:33,640
无限快那么你的表现 

577
00:27:32,026 --> 00:27:35,122
改善将是10倍 

578
00:27:33,064 --> 00:27:38,733
这真的这是一个非常 

579
00:27:36,022 --> 00:27:42,048
简单的想法所以这有几分 

580
00:27:39,309 --> 00:27:45,309
在这样的例子是有直接影响

581
00:27:42,048 --> 00:27:47,867
假设我们可以提高 

582
00:27:45,309 --> 00:27:51,130
的是 90％ 的人受到系统的性能 

583
00:27:48,299 --> 00:27:52,540
我们可以通过因子9和加快

584
00:27:51,013 --> 00:27:55,018
选择号码 进行号码 

585
00:27:52,054 --> 00:27:57,693
工作了，然后我们会 在2个 最好把它 

586
00:27:55,063 --> 00:27:59,104
性能的提高基本上是什么 

587
00:27:58,179 --> 00:28:02,080
它说的 是 系统 的一部分 

588
00:28:00,004 --> 00:28:06,004
你不能加快将成为你的 

589
00:28:02,008 --> 00:28:07,096
瓶颈，这只是事情是这样的

590
00:28:06,004 --> 00:28:09,079
所以蕴涵这个维修而 

591
00:28:07,096 --> 00:28:11,173
编程是相当明显 ，如果 

592
00:28:09,079 --> 00:28:14,137
我们可以把我们的应用程序，并砍掉 

593
00:28:12,073 --> 00:28:18,078
它的某些部分，使 之一连串k 

594
00:28:15,037 --> 00:28:19,119
倍的速度由日K内核上运行它

595
00:28:18,078 --> 00:28:22,102
然后

596
00:28:20,019 --> 00:28:26,026
它的一部分 仍在运行 

597
00:28:23,002 --> 00:28:30,019
依次将前来将限制 

598
00:28:26,026 --> 00:28:31,077
极致的性能，我们可以得到这样 

599
00:28:30,019 --> 00:28:34,027
这不是真正为 这个 问题 

600
00:28:31,077 --> 00:28:36,175
求和问题，因为它确实

601
00:28:34,027 --> 00:28:41,059
分成许多独立的任务 

602
00:28:37,075 --> 00:28:42,504
你有一个数字，正如你可以 看到你 

603
00:28:41,059 --> 00:28:44,101
可以让他们运行，但许多其他

604
00:28:43,179 --> 00:28:51,100
应用程序做它的某些部分，我 

605
00:28:45,001 --> 00:28:53,044
真的不能没有平行，就像 

606
00:28:51,001 --> 00:28:55,060
一个例子，只是为了这个缘故 

607
00:28:53,044 --> 00:28:57,109
类，你知道 一点的例子 

608
00:28:55,069 --> 00:28:59,110
位更 涉及并行 的 问题 

609
00:28:58,009 --> 00:29:02,023
编程和多线程咱们 

610
00:29:00,001 --> 00:29:05,020
想想分拣一堆数字 

611
00:29:02,023 --> 00:29:13,027
所以我们有n个数，我们想排序 

612
00:29:05,029 --> 00:29:15,037
他们和我们有线程的一些数 

613
00:29:13,027 --> 00:29:17,035
我们能做到这与有没有办法，我们 

614
00:29:15,037 --> 00:29:19,132
可以加快这和你想想看 

615
00:29:18,007 --> 00:29:22,012
不说清楚，你是怎么做到的有 

616
00:29:20,032 --> 00:29:24,891
实际上是一个大量文献中并行 

617
00:29:22,057 --> 00:29:27,145
排序和那些你已经采取 或将 

618
00:29:25,179 --> 00:29:30,640
走班 镇将被暴露 

619
00:29:28,045 --> 00:29:32,113
所有这一切，但 我 只是 打算 做 

620
00:29:30,064 --> 00:29:40,072
一个很简单的版本，这是快速排序 

621
00:29:33,013 --> 00:29:43,072
这么快SART是例如 与 c 

622
00:29:40,072 --> 00:29:47,080
库程序 ●排序是快速排序 它 

623
00:29:43,072 --> 00:29:51,091
在 20世纪60年代初50年代或者被发明

624
00:29:48,052 --> 00:29:53,137
由一位名叫托尼·霍雷谁也家伙 

625
00:29:51,091 --> 00:29:55,147
创立了很多 基本 的 逻辑 

626
00:29:54,037 --> 00:29:59,044
程序 ， 所以他就像一个 惊人 

627
00:29:56,047 --> 00:30:03,061
人还活着，今天 生活在 

628
00:30:00,007 --> 00:30:06,019
剑桥英格兰，但如果你曾经有一个 

629
00:30:03,061 --> 00:30:08,077
机会去 由他 来 谈谈 这样做的他 

630
00:30:06,019 --> 00:30:11,023
一个了不起的人，反正这个想法 

631
00:30:08,077 --> 00:30:12,163
快速排序是非常简单的，这 是 

632
00:30:11,023 --> 00:30:16,102
排序的基本排序算法的你

633
00:30:13,063 --> 00:30:18,100
抓住从所述阵列的一些元件，其

634
00:30:17,002 --> 00:30:21,094
你想 进行排序和这就是所谓的 

635
00:30:19,000 --> 00:30:23,559
枢轴 ， 然后拆分数据，以便 

636
00:30:21,094 --> 00:30:26,125
你看看那些元素 

637
00:30:23,559 --> 00:30:29,590
比枢轴或者更大或更小

638
00:30:27,025 --> 00:30:31,078
并有可能也等于让我们只 

639
00:30:29,059 --> 00:30:33,148
假设所有的元素是唯一在这里

640
00:30:31,078 --> 00:30:36,717
所以你只要 把它分成两堆 

641
00:30:34,048 --> 00:30:39,103
一个是曾经的教训更大的现在你 

642
00:30:37,419 --> 00:30:43,750
创造性你递归 您 排序 

643
00:30:40,003 --> 00:30:45,025
这两个桩通过相同的方法 和 

644
00:30:43,075 --> 00:30:46,081
当这一切都 完成你结束了 

645
00:30:45,025 --> 00:30:49,063
一切都整理 约 一个很好的 事 

646
00:30:47,035 --> 00:30:51,064
这是它 可 代替的意思，如果完成 

647
00:30:49,063 --> 00:30:52,162
你有你可以做一组数据 

648
00:30:51,064 --> 00:30:56,065
这一切只需通过交换元素 

649
00:30:53,062 --> 00:30:58,101
围而不需要使用任何额外的 

650
00:30:56,065 --> 00:31:02,094
空间， 你会例如 用 

651
00:30:58,659 --> 00:31:04,697
归并排序，所以这是一个相当简单的 

652
00:31:02,679 --> 00:31:08,710
算法，只是对其进行可视化，然后 

653
00:31:05,039 --> 00:31:10,360
你有数据X阵列的一些块 

654
00:31:08,071 --> 00:31:11,098
要排序，所以你挑 

655
00:31:10,036 --> 00:31:13,845
元素被称为支点 和有 

656
00:31:11,098 --> 00:31:17,185
做这件事的各种策略和 

657
00:31:14,169 --> 00:31:22,210
现在你只细分X为三 

658
00:31:18,085 --> 00:31:24,414
份L- 左手 R是右手 

659
00:31:22,021 --> 00:31:28,024
这意味着比P，然后更少和更大的 

660
00:31:25,179 --> 00:31:31,330
你所P在中间，然后你

661
00:31:28,024 --> 00:31:33,843
递归当你这样做的 

662
00:31:31,033 --> 00:31:36,058
在连续的代码，你会挑一个 

663
00:31:34,059 --> 00:31:38,890
这两种通常最左侧或最 

664
00:31:36,058 --> 00:31:41,121
什么其实并不重要，并 

665
00:31:38,089 --> 00:31:46,098
你会递归地应用相同 

666
00:31:42,021 --> 00:31:48,990
方法向左侧 

667
00:31:46,899 --> 00:31:50,910
最终经过足够递归的 

668
00:31:49,179 --> 00:31:53,220
得到的地方 ，EL已经 点 

669
00:31:51,009 --> 00:31:56,043
排序，这是一个 在这种 所示 

670
00:31:53,589 --> 00:31:59,678
一个swishy色彩的事情，并呼吁使L 

671
00:31:56,349 --> 00:32:00,362
总理与同 

672
00:32:03,012 --> 00:32:07,107
你现在会做同样的事情与 

673
00:32:06,000 --> 00:32:10,062
右手边，当你完成

674
00:32:08,007 --> 00:32:14,043
这 通常是在地方这样做 你 

675
00:32:10,062 --> 00:32:15,087
只是将L部分工作在一个 阵列 上 

676
00:32:14,043 --> 00:32:17,064
该阵列的一部分，我们 的卡 

677
00:32:15,087 --> 00:32:20,094
另外，当你完成他们在 

678
00:32:17,064 --> 00:32:23,151
有序所以很简单的排序和 

679
00:32:21,057 --> 00:32:26,082
一般具有 很好的性能 ，以便 

680
00:32:24,051 --> 00:32:29,085
这就是它的代码看起来像 

681
00:32:26,082 --> 00:32:30,180
这通常是你必须是一个特殊的 

682
00:32:29,085 --> 00:32:34,128
情况下，如果只有一个或两个 元素 

683
00:32:31,008 --> 00:32:37,026
然后你做这种划分使 

684
00:32:35,028 --> 00:32:39,069
之间拆分它的 这个程序 

685
00:32:37,098 --> 00:32:41,103
左， 右侧部分被处理 

686
00:32:39,069 --> 00:32:44,133
由函数调用分区，然后 

687
00:32:42,048 --> 00:32:48,114
如果有一个以上的 元素是在 

688
00:32:45,033 --> 00:32:50,076
左侧你那种，如果有 

689
00:32:49,014 --> 00:32:55,080
在右手 多于 一个的元件 

690
00:32:50,076 --> 00:32:57,105
侧你那种，然后当所有

691
00:32:55,008 --> 00:33:00,012
这些递归完成则数组

692
00:32:58,005 --> 00:33:03,039
排序所以非常典型的代码，我们 

693
00:33:00,084 --> 00:33:03,803
不会在最棘手的部分写入走

694
00:33:03,039 --> 00:33:08,061
代码是你如何使这个 

695
00:33:04,559 --> 00:33:12,690
分区走 的快，但我不会去 

696
00:33:08,061 --> 00:33:13,152
只是 想象它发生所以这 

697
00:33:12,069 --> 00:33:17,091
实际的算法具有天然的版本 

698
00:33:14,052 --> 00:33:19,116
并行这是在我的顺序 

699
00:33:17,091 --> 00:33:21,117
版本我第一次排序都 

700
00:33:20,016 --> 00:33:23,285
左边，然后在左侧的左侧和 

701
00:33:22,017 --> 00:33:25,116
左边 的 左边的左边和 

702
00:33:23,429 --> 00:33:28,470
样 的工作我的方式，直到我得到 的 

703
00:33:26,016 --> 00:33:30,030
整个数组排序，然后我来了 

704
00:33:28,047 --> 00:33:31,050
背部和我工作的权利， 

705
00:33:30,003 --> 00:33:32,088
然后右侧 和 左侧 部分 

706
00:33:31,077 --> 00:33:34,083
左向左向右 和嗒嗒 

707
00:33:33,015 --> 00:33:40,017
等等等等，做这些递归 

708
00:33:35,037 --> 00:33:43,038
因为这样的代码编写权 

709
00:33:40,017 --> 00:33:46,020
我做了充分的排序的 

710
00:33:43,038 --> 00:33:48,039
左手部分后，才 为 

711
00:33:46,002 --> 00:33:51,015
排序然后我做的完全排序 

712
00:33:48,048 --> 00:33:54,051
右手部分的故点 

713
00:33:51,033 --> 00:33:56,105
这是它在那里我工作的算法 

714
00:33:54,078 --> 00:33:58,170
只是在时间的阵列中的一个部分 

715
00:33:57,005 --> 00:34:02,013
但有一个 很自然的递归 

716
00:33:59,007 --> 00:34:04,095
并行这里 ，说好吧，我已经有了 

717
00:34:02,085 --> 00:34:08,133
两个部分 每个节拍需要 进行排序 

718
00:34:05,058 --> 00:34:13,095
让我火了两个线程，让 

719
00:34:09,033 --> 00:34:15,057
他们处理这个，这就是所谓 

720
00:34:13,095 --> 00:34:15,180
这是你所说的分而治之 

721
00:34:15,057 --> 00:34:18,141
它的并行

722
00:34:16,008 --> 00:34:24,033
一个自然的一种并行它显示 

723
00:34:19,041 --> 00:34:27,048
在这片代码所以基本上我会做 

724
00:34:25,005 --> 00:34:29,019
同样的事情，之前的所有顶部 

725
00:34:27,048 --> 00:34:34,110
水平将 是一个纯粹的顺序 

726
00:34:29,019 --> 00:34:36,096
分区和，但过程则 

727
00:34:35,001 --> 00:34:39,036
假设磁盘分区来了 

728
00:34:36,096 --> 00:34:42,195
一些不平凡的拆分，然后我会

729
00:34:39,045 --> 00:34:45,144
递归开始叉关闭以螺纹 

730
00:34:43,095 --> 00:34:47,121
其中 的每 一个将负责 

731
00:34:46,044 --> 00:34:50,052
其他以此类推，我们会有点像 

732
00:34:48,021 --> 00:34:54,048
我工作 的两个部分并行 

733
00:34:51,024 --> 00:34:56,112
最终双方将结束 

734
00:34:54,048 --> 00:34:58,065
现在这幅画是不是真的完全正确 

735
00:34:57,012 --> 00:35:00,060
并且，它期待使它看起来像 

736
00:34:58,065 --> 00:35:02,124
他们都是那种同步 

737
00:35:00,006 --> 00:35:05,073
一起和我做的，你知道 

738
00:35:03,024 --> 00:35:07,107
KABOOOM下来这样一个严格的方法 

739
00:35:06,027 --> 00:35:10,116
但其实他们不是 很 

740
00:35:08,007 --> 00:35:13,092
异步的左侧部分是一个螺纹 

741
00:35:11,016 --> 00:35:16,029
右边是另一个他们只是在去 

742
00:35:13,092 --> 00:35:19,092
自己的节奏，并在年底，我只是 

743
00:35:16,029 --> 00:35:22,053
要 等到这 一切 完成，但 

744
00:35:19,092 --> 00:35:24,146
没有严格的时间顺序上 

745
00:35:22,053 --> 00:35:24,146
怎么说都发生 

746
00:35:27,021 --> 00:35:33,058
这样的方式，我会在代码中写

747
00:35:30,088 --> 00:35:34,090
可在 法院网站我 在 

748
00:35:33,058 --> 00:35:36,067
只是要告诉 你它的一瞥 

749
00:35:35,008 --> 00:35:39,055
它的代码不平凡的量就

750
00:35:37,048 --> 00:35:42,061
需要做， 但我基本上什么 

751
00:35:39,055 --> 00:35:45,076
要做的是有一堆池 

752
00:35:42,061 --> 00:35:47,062
线程准备工作， 

753
00:35:45,076 --> 00:35:50,175
这就是你写一个非常典型的方式 

754
00:35:47,071 --> 00:35:53,077
线程代码，因为实际上的

755
00:35:51,075 --> 00:35:56,143
一个线程的启动是一个不平凡

756
00:35:54,031 --> 00:36:00,037
计算量所以 平时什么 

757
00:35:57,043 --> 00:36:04,078
你要做的就是你说我有这么多 

758
00:36:00,037 --> 00:36:08,073
核心我要创建 一组 

759
00:36:04,078 --> 00:36:13,111
许多线程，他们将分别由工作

760
00:36:08,073 --> 00:36:16,080
共享任务队列所以有些剂

761
00:36:14,011 --> 00:36:20,032
是分叉关闭工作，为不同 

762
00:36:17,043 --> 00:36:21,124
线程做自己会做的工作

763
00:36:20,032 --> 00:36:23,119
分配给他们当完成 

764
00:36:22,024 --> 00:36:25,033
我们会回来 ，说好吧，我已经准备好了 

765
00:36:24,019 --> 00:36:28,060
新的东西，它会给他们 

766
00:36:26,014 --> 00:36:31,063
新的东西，所以我有一点点 

767
00:36:28,006 --> 00:36:33,025
代码非常基本的 代码存在的 

768
00:36:31,063 --> 00:36:36,067
创建该任务模型和任务 

769
00:36:33,079 --> 00:36:39,124
伴随 这样的基本规则会有什么 

770
00:36:37,003 --> 00:36:42,031
给定的任务任何给定的线程，然后在任何 

771
00:36:40,024 --> 00:36:46,069
给定的时间已分配子子 

772
00:36:42,031 --> 00:36:50,053
此数组的范围是 一个排序和 

773
00:36:46,069 --> 00:36:53,130
它将由基 含义来指定 

774
00:36:50,053 --> 00:36:57,055
这个特殊的出发点

775
00:36:54,003 --> 00:37:04,024
范围，然后将元件的数 

776
00:36:57,055 --> 00:37:08,080
， 它的告诉它的排序和另一 

777
00:37:04,051 --> 00:37:10,132
我会做的事情是，一旦我得到了这个 

778
00:37:08,008 --> 00:37:14,089
阵列足够小我就排序 

779
00:37:11,032 --> 00:37:17,038
它依次，我们将看到如何

780
00:37:15,061 --> 00:37:19,063
大该块是与否实际上是 

781
00:37:17,092 --> 00:37:21,097
您可以使用性能参数 

782
00:37:19,081 --> 00:37:23,134
用于调谐程序，以便点是

783
00:37:22,042 --> 00:37:27,076
你不想 借此下来 

784
00:37:24,034 --> 00:37:30,034
太远，因为那种 开销 

785
00:37:27,076 --> 00:37:30,169
线程是足够的，当你 到 

786
00:37:30,034 --> 00:37:34,052
细粒度你居然要去 

787
00:37:31,069 --> 00:37:36,104
开始失去性能 

788
00:37:34,052 --> 00:37:39,104
因此认为它比这更大 

789
00:37:37,004 --> 00:37:43,025
我一直在考虑一些块有什么 

790
00:37:40,004 --> 00:37:45,038
我会做的就是，我会运行分区 

791
00:37:43,025 --> 00:37:47,117
这一步线程将运行它 

792
00:37:45,038 --> 00:37:50,107
只是用精确分割步

793
00:37:48,017 --> 00:37:55,105
功能我发现你还是没有告诉你 

794
00:37:51,007 --> 00:37:59,036
然后只要然后我会为我们 

795
00:37:56,005 --> 00:38:03,077
创建并添加到任务队列 两个新 

796
00:37:59,036 --> 00:38:06,059
任务 一个 dhis的左半部分和 

797
00:38:03,077 --> 00:38:10,129
一个正确的部分，然后 

798
00:38:06,059 --> 00:38:13,106
调度程序将分配两个线程 

799
00:38:11,029 --> 00:38:15,074
处理这些两个 部分，使 

800
00:38:14,006 --> 00:38:19,025
代码会 是这样的代码究竟如何是 

801
00:38:15,074 --> 00:38:22,085
上班这将继续重用 

802
00:38:19,025 --> 00:38:25,052
一遍又一遍的过同一主题

803
00:38:22,085 --> 00:38:27,161
但在任何给定的时间，他们会 得到一个 

804
00:38:25,052 --> 00:38:29,129
地方范围是什么一般 

805
00:38:28,061 --> 00:38:34,082
发生在他们会运行他们的分区

806
00:38:30,029 --> 00:38:37,076
步骤，然后说，好吧，我已经做了 我的工作 

807
00:38:34,082 --> 00:38:38,153
现在分配到新的新的线程做 

808
00:38:37,076 --> 00:38:41,084
这一点，这是它的总体方案 

809
00:38:39,053 --> 00:38:43,118
或者他们会说这 是足够小 

810
00:38:41,084 --> 00:38:45,158
块我只是要 排序 的混账 

811
00:38:44,018 --> 00:38:49,076
好了，这样的事情真的所有的代码 

812
00:38:46,058 --> 00:38:51,146
确实是在网上，如果你有兴趣 

813
00:38:49,076 --> 00:38:53,135
这种东西是 我认为这是 

814
00:38:52,046 --> 00:38:56,050
不错编写的代码，因为我写的 

815
00:38:54,035 --> 00:38:56,050
它 

816
00:38:57,001 --> 00:39:05,001
所以这是那种有点 

817
00:39:02,109 --> 00:39:08,530
代码的简化版本说

818
00:39:05,001 --> 00:39:13,026
初始化我的任务队列调度 

819
00:39:08,053 --> 00:39:15,058
系统创建的全局变量 

820
00:39:13,026 --> 00:39:19,033
描述此开始和结束

821
00:39:16,003 --> 00:39:21,097
要排序的数组创建新任务 

822
00:39:19,033 --> 00:39:25,096
队列，然后这是主要的功能 

823
00:39:21,097 --> 00:39:29,131
该TQ排序助手给出一些

824
00:39:25,096 --> 00:39:33,109
的地址范围的指针和指向 

825
00:39:30,031 --> 00:39:40,129
该 融合管理这些任务队列

826
00:39:34,009 --> 00:39:42,100
任务，然后当这一切都做到了

827
00:39:41,029 --> 00:39:45,103
只会等到所有的任务都有

828
00:39:43,000 --> 00:39:48,013
完成这 是顶层这 

829
00:39:46,003 --> 00:39:50,011
没有任何递归的一部分，这是

830
00:39:48,013 --> 00:39:55,027
顶级的代码，然后它会释放 

831
00:39:50,083 --> 00:39:56,158
的数据结构，然后，这 是 

832
00:39:55,027 --> 00:40:02,098
它的一部分，实际上 确实实 

833
00:39:57,058 --> 00:40:06,109
工作会这么说，现在的TQ排序 

834
00:40:02,098 --> 00:40:13,102
助手是已分配给该部分

835
00:40:07,009 --> 00:40:16,051
从开始的一些细节进行排序

836
00:40:14,002 --> 00:40:21,007
解决碱和一定数目的

837
00:40:16,051 --> 00:40:24,058
元素和所以这是每个任务 

838
00:40:21,007 --> 00:40:27,031
会做，它说 好 ，如果这是一个 

839
00:40:24,058 --> 00:40:29,104
元素足够小的块我只是 

840
00:40:27,031 --> 00:40:35,082
要叫我的串行快速排序做

841
00:40:30,004 --> 00:40:35,082
它否则我要去 

842
00:40:42,094 --> 00:40:50,155
哦，这是一个 有点 混乱比 这 

843
00:40:46,599 --> 00:40:55,630
现在没事了，否则它会酿出 

844
00:40:51,055 --> 00:40:57,354
任务做排序，让我们看看我是 一个 

845
00:40:55,063 --> 00:40:59,119
有点混了，这是一个很高的水平，从而 

846
00:40:57,849 --> 00:41:06,910
实际的分裂发生在这个

847
00:41:00,019 --> 00:41:10,072
这就是事情的地方是如此，这 是 

848
00:41:06,091 --> 00:41:13,155
实际线程程序以及它的

849
00:41:10,072 --> 00:41:17,170
说是这里运行分区和 

850
00:41:14,055 --> 00:41:20,364
然后把这个TQ排序帮助您 

851
00:41:18,007 --> 00:41:26,103
刚才看到的左边和右边部分 

852
00:41:20,859 --> 00:41:29,883
它所以只是审查则实际 

853
00:41:27,066 --> 00:41:34,075
任务的产卵被 这个 工作 

854
00:41:30,099 --> 00:41:38,380
辅助函数，但是那么是什么

855
00:41:34,075 --> 00:41:39,124
调用是线程程序是什么 

856
00:41:38,038 --> 00:41:41,047
这里做的工作以及它会做 

857
00:41:40,024 --> 00:41:44,050
是它会做内部的分区 

858
00:41:42,028 --> 00:41:50,065
该线程然后它会随便扔 

859
00:41:44,005 --> 00:41:54,097
背部和添加到任务 你 两个电话 

860
00:41:50,065 --> 00:41:56,514
这个帮手，但作为一种如此 

861
00:41:55,042 --> 00:41:58,114
这两个程序之间可以看到

862
00:41:57,099 --> 00:42:02,124
它做的这个想法鸿沟和 

863
00:41:59,014 --> 00:42:05,733
征服并行 所以这 是一个 

864
00:42:02,349 --> 00:42:11,470
鲨鱼机上运行的性能

865
00:42:05,859 --> 00:42:16,480
这是一个相当简单的我 

866
00:42:11,047 --> 00:42:19,104
只是把随机值的一定数目

867
00:42:16,048 --> 00:42:19,104
两本37 

868
00:42:21,087 --> 00:42:28,104
这不可能是正确的 ，这是 不是 数字 

869
00:42:27,009 --> 00:42:34,047
你同意 第三十七权 

870
00:42:29,004 --> 00:42:36,078
我237是128个十亿大致如此 

871
00:42:34,047 --> 00:42:43,125
这个数字是不正确的，我会要 

872
00:42:36,078 --> 00:42:45,120
检查出来，现在这是什么x轴 这样 

873
00:42:44,025 --> 00:42:48,081
y轴表示只是需要多长时间 

874
00:42:46,002 --> 00:42:50,016
采取的方式有一两件事，如果完成

875
00:42:48,081 --> 00:42:53,082
你已经习惯了 性能 测试 

876
00:42:50,034 --> 00:42:55,038
基于CPU的时间，这不是有用的时 

877
00:42:53,082 --> 00:42:56,133
你说一个并行计算你 

878
00:42:55,074 --> 00:42:58,155
真的想谈一个经过的时间 

879
00:42:57,033 --> 00:43:02,052
时间， 你 从寻找一个 获得 

880
00:42:59,055 --> 00:43:04,086
时钟和测量，并处理 

881
00:43:02,052 --> 00:43:06,117
无论出现效率低下，从而有 

882
00:43:04,086 --> 00:43:10,158
这些实际上的最后运行时间 

883
00:43:07,017 --> 00:43:13,074
整个程序，你会看到， 

884
00:43:11,058 --> 00:43:15,066
它根据这个东西叫做变化 

885
00:43:13,074 --> 00:43:18,129
串行分数串行分数 

886
00:43:16,038 --> 00:43:24,072
只是在我 之间滑动 点什么 

887
00:43:19,029 --> 00:43:26,115
串行快速排序或保持分裂等等 

888
00:43:24,072 --> 00:43:28,128
有多大请问阵列需要像一个 

889
00:43:27,015 --> 00:43:34,023
分数表示为的一小部分

890
00:43:29,028 --> 00:43:36,114
原来前阵II将进入 

891
00:43:34,095 --> 00:43:37,194
递归如果我确实 写 

892
00:43:37,014 --> 00:43:41,016
这个实际应用中，我不会做 

893
00:43:38,094 --> 00:43:43,167
根据分数我会做它基于一个 

894
00:43:41,016 --> 00:43:46,050
块大小说什么小于 

895
00:43:44,067 --> 00:43:49,092
一千元素或一些数字， 如 

896
00:43:46,005 --> 00:43:51,066
该但是这个代码恰好是 

897
00:43:49,092 --> 00:43:53,097
这种方式表达，但事 

898
00:43:52,011 --> 00:43:58,050
请注意，有趣的是，你会看到

899
00:43:53,097 --> 00:43:59,160
此处若分数为1 

900
00:43:58,005 --> 00:44:02,070
它基本上是说我不会在这个分裂

901
00:44:00,006 --> 00:44:05,043
所有我只是要调用顺序 

902
00:44:03,015 --> 00:44:08,079
快速排序，所以这是一个纯粹的顺序 

903
00:44:05,097 --> 00:44:11,166
它的版本，它显示 的是，如果 我 

904
00:44:08,079 --> 00:44:14,127
一旦我开始-我会愿意排序 

905
00:44:12,066 --> 00:44:17,067
分裂的这件事，做我的并行

906
00:44:15,027 --> 00:44:21,030
开始使它越跑越快 

907
00:44:17,076 --> 00:44:24,105
和更快的我会，然后我进入这个 

908
00:44:21,057 --> 00:44:26,100
触底 ，现在如果我开始去细 

909
00:44:25,005 --> 00:44:29,096
和细粒度然后我运行到 

910
00:44:27,000 --> 00:44:32,067
当线程开销问题

911
00:44:29,096 --> 00:44:33,135
以上优势，我通过获取

912
00:44:32,067 --> 00:44:36,162
做并行

913
00:44:34,035 --> 00:44:40,041
而且我更快地运行 大 买 

914
00:44:37,062 --> 00:44:43,143
配全只是使用顺序算法 

915
00:44:40,041 --> 00:44:46,080
而不是平行的，但好 消息 

916
00:44:44,043 --> 00:44:48,117
这里，这是一个相当长的槽 

917
00:44:46,008 --> 00:44:51,096
这里，所以这意味着，如果你 想 

918
00:44:49,017 --> 00:44:54,045
调整这一计划也并不难 

919
00:44:52,068 --> 00:44:57,096
你不打算 支付巨额罚款 

920
00:44:54,045 --> 00:44:59,061
如果你不知道确切的参数等等 

921
00:44:57,096 --> 00:45:03,192
只要是因为这是 一个巨大的 范围 

922
00:44:59,061 --> 00:45:11,096
从32到4096右30 这是一个因素 

923
00:45:04,092 --> 00:45:13,095
的很多的第五和因 

924
00:45:11,096 --> 00:45:17,127
由于 两个 12世纪 到第七分区 

925
00:45:14,022 --> 00:45:21,029
128看我怎么做我的算术权力 

926
00:45:18,027 --> 00:45:24,054
两个 反正它大致在你知道 

927
00:45:21,092 --> 00:45:26,100
128个这样几个订单 

928
00:45:24,054 --> 00:45:28,143
幅度的十进制订单超过其 

929
00:45:27,000 --> 00:45:31,041
你得到相当相当的性能，所以 

930
00:45:29,043 --> 00:45:33,060
从一个性能调整装置 

931
00:45:31,041 --> 00:45:35,073
的角度来看，这并不难做到 

932
00:45:33,006 --> 00:45:39,018
你会经常看到我们得到 一个 

933
00:45:35,073 --> 00:45:41,082
我们的八大核心相当不错的加速 

934
00:45:39,072 --> 00:45:45,143
到超线程机器我们 

935
00:45:41,082 --> 00:45:47,139
越来越基本上是7倍的性能和 

936
00:45:46,043 --> 00:45:50,139
超线程真的不帮助 我们 

937
00:45:48,039 --> 00:45:52,107
在所有为 课程 的一部分， 在这里，但如果 

938
00:45:51,039 --> 00:45:55,055
你只是把它作为一门课程和 

939
00:45:53,007 --> 00:45:55,055
就不错了 

940
00:45:58,047 --> 00:46:04,140
所以有一个明显的地方在这儿， 

941
00:46:02,019 --> 00:46:06,102
那里将 在 南 娃娃法律问题 

942
00:46:05,004 --> 00:46:10,059
如果你想的 第一个 顶级 

943
00:46:07,002 --> 00:46:13,091
分割所述 第一呼叫到 分区是 

944
00:46:10,095 --> 00:46:16,098
通过整个阵列上正在做

945
00:46:13,109 --> 00:46:19,740
串行顺序处理的权利 因此在 

946
00:46:17,025 --> 00:46:21,102
最起码 是不会 

947
00:46:19,074 --> 00:46:22,083
并行在所有那里将 准确 

948
00:46:22,002 --> 00:46:27,045
一个线程是做初始 

949
00:46:23,064 --> 00:46:28,140
分区，然后该分裂成两个 

950
00:46:27,045 --> 00:46:31,424
所以最多有两个线程，其中 

951
00:46:29,004 --> 00:46:33,473
这是一个并行 再下 

952
00:46:31,829 --> 00:46:35,670
级下调最多四等你 

953
00:46:33,869 --> 00:46:38,430
真的没有，你必须得到几个 

954
00:46:35,067 --> 00:46:39,138
递归级别 下跌你之前 

955
00:46:38,043 --> 00:46:42,117
所有课程真正运行 

956
00:46:40,038 --> 00:46:45,017
你们有 那么你会认为 

957
00:46:43,017 --> 00:46:46,101
是的限制条件，加快 并 

958
00:46:45,359 --> 00:46:51,420
的确， 这就是的原因部分 

959
00:46:47,001 --> 00:46:54,065
我们最好的表现 是一个因素 

960
00:46:51,042 --> 00:47:00,141
七不是8倍以上 

961
00:46:54,065 --> 00:47:05,150
所以有相当多的工作，因为我 

962
00:47:01,041 --> 00:47:08,076
就如何加快性能提到

963
00:47:06,005 --> 00:47:13,056
包括如何使快速排序去 

964
00:47:08,076 --> 00:47:16,148
快所以有一个庞大的机构 

965
00:47:14,001 --> 00:47:17,048
文献上平行的故事 

966
00:47:19,001 --> 00:47:25,075
这么一两件事我想是 说 好了 

967
00:47:22,055 --> 00:47:28,139
那么让我们来尝试做这种划分 

968
00:47:25,075 --> 00:47:31,127
步骤当周最热门的几个 级别 

969
00:47:29,039 --> 00:47:34,100
让我们尝试做的并行 版本 

970
00:47:32,027 --> 00:47:37,055
这一点，这样的想法是你一个挑 

971
00:47:35,000 --> 00:47:40,088
主元，但现在你在这个火 

972
00:47:37,055 --> 00:47:44,113
例如用于螺纹和各那些的 

973
00:47:40,088 --> 00:47:48,122
四个线程运行的分区步骤对 

974
00:47:45,013 --> 00:47:51,040
该范围的1/4，它会 产生 

975
00:47:49,022 --> 00:47:55,109
自己的左侧和右侧版本和 

976
00:47:51,004 --> 00:48:00,223
那么全球弄清楚有多少 

977
00:47:56,009 --> 00:48:03,011
在每个这些子范围，然后的 

978
00:48:00,619 --> 00:48:05,780
你告诉每个线程现在没事了，你复制 

979
00:48:03,029 --> 00:48:09,125
你的一部分移交给相关 

980
00:48:05,078 --> 00:48:10,085
该阵列的部分，但好消息 

981
00:48:10,025 --> 00:48:14,048
所以有一定量

982
00:48:11,048 --> 00:48:17,054
同步是继续存在，但 

983
00:48:14,048 --> 00:48:19,067
你能想象 ，这个分区 

984
00:48:17,054 --> 00:48:22,067
当你运行 它是 一次一步 

985
00:48:19,067 --> 00:48:23,153
完全独立于整个的 

986
00:48:22,067 --> 00:48:27,128
不同的 线程所以它才获得了 

987
00:48:24,053 --> 00:48:29,138
近乎理想的 速度， 所以我实现 

988
00:48:28,028 --> 00:48:33,077
这一点，并试图和我不能 使它 

989
00:48:30,038 --> 00:48:36,071
运行比原来的代码，我快 

990
00:48:33,077 --> 00:48:42,109
认为这个 问题 是 

991
00:48:36,071 --> 00:48:45,970
这里复制的复制数据的成本 

992
00:48:43,009 --> 00:48:48,017
是，即使它被完成 

993
00:48:46,609 --> 00:48:50,660
多线程 并获得不错 

994
00:48:48,089 --> 00:48:52,115
表现出来的存储系统 

995
00:48:50,066 --> 00:48:55,091
因为你正在做的连续复印 

996
00:48:53,015 --> 00:48:58,097
所有的现金问题都 还不错这里 

997
00:48:55,091 --> 00:49:00,119
但是这只是足够的 额外的工作 ， 

998
00:48:58,097 --> 00:49:01,184
已经为 这个并行代码来完成 

999
00:49:01,019 --> 00:49:04,090
在没有做的 

1000
00:49:02,084 --> 00:49:06,176
顺序代码是完全到位 

1001
00:49:04,009 --> 00:49:10,046
意思是不使用任何额外的存储空间 

1002
00:49:07,076 --> 00:49:12,925
不是抄袭等，这只是够 

1003
00:49:11,027 --> 00:49:15,080
上平行部，它是一个点球 

1004
00:49:13,609 --> 00:49:18,350
并没有真正改善性能在所有 

1005
00:49:15,008 --> 00:49:20,072
使得代码被示为 部分 

1006
00:49:18,035 --> 00:49:23,039
课程网站 ， 但就像我的代码

1007
00:49:21,044 --> 00:49:25,103
我说我撞了它 颇有 几分 

1008
00:49:23,075 --> 00:49:27,134
试图调整它，并发出吱吱它

1009
00:49:26,003 --> 00:49:30,042
各种途径和 从来不会这么 

1010
00:49:28,034 --> 00:49:33,803
我得到了更好的整体性能 

1011
00:49:30,042 --> 00:49:35,441
这一计划的，因此这是一次 

1012
00:49:34,109 --> 00:49:37,160
一个教训，这就是的一个 

1013
00:49:35,819 --> 00:49:40,844
不幸的教训是，你可以花 

1014
00:49:37,619 --> 00:49:44,250
很多时间试图 使 程序运行 

1015
00:49:41,069 --> 00:49:46,118
更快获得绝对行不通的，并 

1016
00:49:44,025 --> 00:49:48,054
这是令人沮丧，因为你把一个 

1017
00:49:46,559 --> 00:49:49,637
大量的工作，你知道这是一个非常 

1018
00:49:48,054 --> 00:49:51,593
很酷的想法 ，你很乐意发布 

1019
00:49:50,339 --> 00:49:54,450
关于它的纸或者告诉 你的朋友 

1020
00:49:52,079 --> 00:49:56,460
关于它， 它只是 无处它 

1021
00:49:54,045 --> 00:49:58,089
只是坐在那里并没有什么 

1022
00:49:56,046 --> 00:50:01,065
不幸的是有没有一个累积 

1023
00:49:58,089 --> 00:50:02,318
计算机的 坏 主意库

1024
00:50:01,065 --> 00:50:06,114
科学不要浪费你的时间尝试 

1025
00:50:03,119 --> 00:50:12,780
这一点，人们可以谈论所以这 

1026
00:50:07,014 --> 00:50:15,102
只是 需要学习，反正 一 课 

1027
00:50:12,078 --> 00:50:17,127
那是 我与经验 再次 

1028
00:50:16,002 --> 00:50:21,051
别人花更多的时间这 

1029
00:50:18,027 --> 00:50:23,366
是最 常见的应用 之一 

1030
00:50:21,051 --> 00:50:27,410
人们试图做 并行 

1031
00:50:23,609 --> 00:50:30,480
编程所以一些经验 

1032
00:50:27,869 --> 00:50:31,980
从这个是你需要一个很好的策略 

1033
00:50:30,048 --> 00:50:34,095
如何你会得到并行 

1034
00:50:31,098 --> 00:50:36,153
您的应用程序，并且我发现你 

1035
00:50:34,095 --> 00:50:39,141
两个基本版本的一个划分 

1036
00:50:37,053 --> 00:50:41,145
为K他们或多或少 

1037
00:50:40,041 --> 00:50:44,046
完全相互独立的 或 

1038
00:50:42,045 --> 00:50:46,050
有点 像分而 治之 

1039
00:50:44,046 --> 00:50:48,123
策略， 其中 你可以保持 它拆分 

1040
00:50:46,005 --> 00:50:51,054
但两个裂口 您创建了 

1041
00:50:49,023 --> 00:50:55,074
那可以去这些并发其他 

1042
00:50:51,099 --> 00:50:56,438
不同类型的并行 太 

1043
00:50:55,074 --> 00:50:58,673
一般要进行内部循环 

1044
00:50:57,329 --> 00:51:01,980
你不能有任何 同步 

1045
00:50:59,339 --> 00:51:05,010
原语有 它只会跑太 

1046
00:51:01,098 --> 00:51:06,227
慢我的玩偶法律正如我所提到的 

1047
00:51:05,001 --> 00:51:10,047
总是那种潜伏 在后台 

1048
00:51:07,109 --> 00:51:12,128
如果你只能养活的一部分 

1049
00:51:10,047 --> 00:51:14,186
你的程序那么另一部分 

1050
00:51:12,299 --> 00:51:17,324
成为瓶颈，但其他 

1051
00:51:14,609 --> 00:51:20,910
就是像我说你可以做到这一点 

1052
00:51:17,549 --> 00:51:23,490
你有你有学习的工具 

1053
00:51:20,091 --> 00:51:24,120
以P线程和你 的知识 

1054
00:51:23,049 --> 00:51:26,097
编程和你 的 理解 

1055
00:51:25,002 --> 00:51:29,411
高速缓存存储器之类 的 东西 

1056
00:51:26,097 --> 00:51:31,140
你有你 需要的 工具 

1057
00:51:29,609 --> 00:51:36,180
这种 有效的程序员 

1058
00:51:32,004 --> 00:51:38,010
说不过你 得并没有什么 

1059
00:51:36,018 --> 00:51:41,837
那跳动的排序试 错和 

1060
00:51:38,046 --> 00:51:43,115
测试和调整，如果试验 

1061
00:51:41,999 --> 00:51:45,035
有需要一些参数

1062
00:51:43,529 --> 00:51:47,190
设置，则 您要运行 实验 

1063
00:51:45,359 --> 00:51:49,376
这将 通过参数 扫 

1064
00:51:47,019 --> 00:51:53,408
试图找出的设置

1065
00:51:49,529 --> 00:51:55,410
应当所以 这是 那种 一点点 

1066
00:51:53,579 --> 00:51:58,650
有关并行编程让我 

1067
00:51:55,041 --> 00:52:01,160
完成本次讲座 有一点点 

1068
00:51:58,065 --> 00:52:03,144
那种关于并发的经典问题 

1069
00:52:01,529 --> 00:52:08,534
当 你这个是关键

1070
00:52:04,044 --> 00:52:09,051
处理 依据是什么，这些系统 

1071
00:52:08,579 --> 00:52:12,960
你调用的共享存储器模型 

1072
00:52:10,014 --> 00:52:16,643
计算如此多核心是一个例子

1073
00:52:12,096 --> 00:52:17,148
的概念性多线程 

1074
00:52:16,769 --> 00:52:20,700
计算记住你是你 

1075
00:52:18,048 --> 00:52:24,114
单个虚拟地址内工作

1076
00:52:20,007 --> 00:52:27,326
空间，您有私人书库但 

1077
00:52:25,014 --> 00:52:31,020
越是世界的堆内存 

1078
00:52:28,019 --> 00:52:33,050
跨线程等完全共享

1079
00:52:31,002 --> 00:52:35,141
这就是你所谓的共享内存 

1080
00:52:33,329 --> 00:52:38,378
编程模型，而这正是我们所 

1081
00:52:35,339 --> 00:52:40,343
在这个过程中确实一直在 寻找这样 

1082
00:52:38,819 --> 00:52:42,890
有一定的 有趣的问题 

1083
00:52:40,739 --> 00:52:45,480
关于所谓的内存一致性 模型 

1084
00:52:42,089 --> 00:52:47,558
在这里我会很说明吧

1085
00:52:45,048 --> 00:52:50,927
简单的例子， 假设我们有 两个 

1086
00:52:48,359 --> 00:52:54,390
全局变量 a和b， 我们有 两个 

1087
00:52:51,359 --> 00:52:57,450
不同线程 因此第一 

1088
00:52:54,039 --> 00:52:59,073
线程会写含义分配 

1089
00:52:57,045 --> 00:53:02,088
一个值和它要 读 

1090
00:52:59,073 --> 00:53:04,089
意打印的B和值

1091
00:53:02,088 --> 00:53:06,120
其他线程会反其道而行之 

1092
00:53:04,089 --> 00:53:08,768
它会写分配值

1093
00:53:07,002 --> 00:53:11,073
在监狱里的价值，因此现在 

1094
00:53:09,569 --> 00:53:15,960
问题是什么是可能的 

1095
00:53:11,091 --> 00:53:17,780
对这一计划的输出 ，所以有 

1096
00:53:15,096 --> 00:53:19,163
模型所接受的那种 

1097
00:53:18,599 --> 00:53:23,720
标准叫做顺序一致性 

1098
00:53:20,063 --> 00:53:28,262
这意味着，可能会发生这些事件 

1099
00:53:23,072 --> 00:53:30,165
还有，这些是 在一个单一的 

1100
00:53:28,829 --> 00:53:34,470
螺纹事情已经发生 

1101
00:53:31,065 --> 00:53:37,116
该线程的顺序，但 

1102
00:53:34,047 --> 00:53:40,122
跨线程是否 写入AA写乙 

1103
00:53:38,016 --> 00:53:43,091
先发生完全是任意的 和 

1104
00:53:41,022 --> 00:53:45,029
类似B的写入是否发生 

1105
00:53:43,091 --> 00:53:50,138
之间

1106
00:53:45,092 --> 00:53:53,731
这两个动作都是以前 也 

1107
00:53:51,038 --> 00:53:56,467
任意的，它的意思就是你 

1108
00:53:54,559 --> 00:54:00,583
可以采取两种 不同的线程 和你 

1109
00:53:56,809 --> 00:54:04,837
可交错他们自己在任何事件 

1110
00:54:00,799 --> 00:54:08,150
的方式，但你应该能够拉出来 

1111
00:54:05,089 --> 00:54:10,400
该交错 顺序的

1112
00:54:08,015 --> 00:54:13,444
任两个两个的顺序

1113
00:54:10,004 --> 00:54:15,913
线程所以当你做， 你最终会 

1114
00:54:13,579 --> 00:54:18,740
你可以列举这样一个例子

1115
00:54:16,309 --> 00:54:20,317
所有你 能说好准备

1116
00:54:18,074 --> 00:54:21,883
看它首先是要么将是 

1117
00:54:21,109 --> 00:54:26,540
右一或右视图

1118
00:54:22,549 --> 00:54:29,750
让我们挑右一所以现在下一个事件 

1119
00:54:26,054 --> 00:54:34,142
将或者 B的 B或 写 的读 

1120
00:54:29,075 --> 00:54:38,114
然后，如果我如果我不写一写读 

1121
00:54:35,042 --> 00:54:41,048
B上我已经完成了这个线程等 

1122
00:54:39,014 --> 00:54:44,743
现在唯一的可能性是写 

1123
00:54:41,048 --> 00:54:46,076
B和阅读等你的工作 

1124
00:54:44,869 --> 00:54:49,915
所有可能的事情，你 送六 

1125
00:54:46,076 --> 00:54:51,164
不同的事件 排序，然后什么 

1126
00:54:50,329 --> 00:54:56,750
将要打印的是很好首先 

1127
00:54:52,064 --> 00:54:58,243
无论你打印前将取决于 

1128
00:54:56,075 --> 00:54:59,171
在这两个的相对顺序 

1129
00:54:58,819 --> 00:55:04,760
线程所以这表明，它们显示

1130
00:55:00,071 --> 00:55:07,680
蓝色B值和红色的红色值

1131
00:55:04,076 --> 00:55:11,102
在对不起红色的值， 

1132
00:55:08,319 --> 00:55:13,940
你会得到这些不同的可能性 

1133
00:55:12,002 --> 00:55:16,081
这些都是六个可能的输出 

1134
00:55:13,094 --> 00:55:20,233
这个程序 ， 但你会看到 ， 

1135
00:55:16,099 --> 00:55:26,210
有两种其它两个输出的一个

1136
00:55:21,079 --> 00:55:28,970
可以想象， 不会 出现 一个是 

1137
00:55:26,021 --> 00:55:31,930
打印换句话说101 

1138
00:55:28,097 --> 00:55:34,100
有他们两个打印原稿 

1139
00:55:32,119 --> 00:55:38,450
这两个变量的值，这就是 

1140
00:55:35,000 --> 00:55:43,022
不可能的，因为我已经都做 

1141
00:55:38,045 --> 00:55:44,072
之前，我可以达到至少一个权 

1142
00:55:43,022 --> 00:55:48,023
这两种报表打印

1143
00:55:44,072 --> 00:55:51,151
右 所以它不可能为 这些来 

1144
00:55:48,023 --> 00:55:54,031
仍然是在原来的值时，我 

1145
00:55:51,799 --> 00:55:59,360
打这些打印语句 

1146
00:55:55,003 --> 00:56:02,015
和订单为准我打这两个如此 

1147
00:55:59,036 --> 00:56:03,101
这两个是不可能的所以这是 

1148
00:56:02,015 --> 00:56:08,050
的 顺序一致性想法 

1149
00:56:04,001 --> 00:56:12,008
有一些非常大的数目，但的 

1150
00:56:08,005 --> 00:56:14,012
在任何一个方案，但可能的输出

1151
00:56:12,008 --> 00:56:19,037
情况下，他们可以在不违反排序 

1152
00:56:15,002 --> 00:56:21,086
由单个线程，以便暗示

1153
00:56:19,037 --> 00:56:25,058
你会说 好这似乎 是相当 

1154
00:56:22,004 --> 00:56:27,011
显而易见的事情，但实际上，如果你认为 

1155
00:56:25,058 --> 00:56:29,114
从硬件的角度来看它不是 

1156
00:56:27,011 --> 00:56:34,013
那微不足道要做到这一点 所以让 

1157
00:56:30,014 --> 00:56:36,101
我只是扔你展示的场景 

1158
00:56:34,013 --> 00:56:40,058
这将违反 多核 硬件 

1159
00:56:37,001 --> 00:56:42,080
顺序一致性假设每个 

1160
00:56:40,058 --> 00:56:49,115
我们的线程都有自己的专用高速缓存 

1161
00:56:42,008 --> 00:56:52,055
所以如果 我执行该语句什么 

1162
00:56:50,015 --> 00:56:56,048
我要做的是我会抢的副本从 

1163
00:56:53,027 --> 00:56:58,115
主存储器 ，并把它变成我的 

1164
00:56:56,048 --> 00:57:03,101
高速缓存和我将赋予该 新值 

1165
00:56:59,015 --> 00:57:08,083
它和同样线程 两人将抢 

1166
00:57:04,001 --> 00:57:13,100
B的一个副本和更新这一点 ， 

1167
00:57:08,083 --> 00:57:16,112
现在，如果我做我的两个打印语句 ，如果 

1168
00:57:14,000 --> 00:57:19,082
线程2个拾起从价值

1169
00:57:17,012 --> 00:57:22,064
内存不知道该线程一个作为 

1170
00:57:19,082 --> 00:57:24,161
该值的修改后的副本则 

1171
00:57:22,064 --> 00:57:27,131
自然会打印一张，同样 

1172
00:57:25,061 --> 00:57:29,147
如果如果一个线程拿起 B 的副本 

1173
00:57:28,031 --> 00:57:34,078
从主内存 ， 它将打印 100， 

1174
00:57:30,047 --> 00:57:37,070
我们会看到的正是这种不能允许

1175
00:57:34,078 --> 00:57:39,089
执行其原因是因为每个 

1176
00:57:37,007 --> 00:57:42,032
这些线程拥有自己的私人 

1177
00:57:39,089 --> 00:57:45,161
这些变量的副本，并且他们 

1178
00:57:42,095 --> 00:57:47,141
不能正常同步，但 你可以 

1179
00:57:46,061 --> 00:57:49,109
看到一个硬件的情况这将是 

1180
00:57:48,041 --> 00:57:53,057
容易 建立这样的硬件， 使 

1181
00:57:50,009 --> 00:57:56,081
这个错误所以它是如何 在工作中 

1182
00:57:53,057 --> 00:57:59,065
多核处理器以及它们具有 

1183
00:57:56,081 --> 00:58:01,127
诱骗他们称之为史努比缓存和

1184
00:57:59,065 --> 00:58:05,078
它就像读者一点点 

1185
00:58:02,027 --> 00:58:07,100
同步的作家，你是 

1186
00:58:05,078 --> 00:58:09,131
正在为您的代理 

1187
00:58:08,000 --> 00:58:12,032
你想让它这样，如果 

1188
00:58:10,031 --> 00:58:14,093
每个人都只是阅读一些共享

1189
00:58:12,032 --> 00:58:17,126
值应该能够得到副本 

1190
00:58:14,093 --> 00:58:20,032
到自己的高速缓存来优化 

1191
00:58:18,026 --> 00:58:22,118
它的性能，但如果他们中的一个

1192
00:58:20,869 --> 00:58:26,390
想要写 它，它需要得到一个 

1193
00:58:23,018 --> 00:58:29,093
它独特的副本，并锁定任何 

1194
00:58:26,039 --> 00:58:33,098
访问，要么其他线程

1195
00:58:29,093 --> 00:58:40,252
读它或将它 从 长 写 

1196
00:58:33,098 --> 00:58:42,113
足以使更新，所以他们 

1197
00:58:41,089 --> 00:58:46,460
他们有一个协议，其中 它们标签 

1198
00:58:43,013 --> 00:58:49,016
其实这些标签是在水平 

1199
00:58:46,046 --> 00:58:52,049
的高速缓存行通常所以 标记 

1200
00:58:49,016 --> 00:58:54,945
在其状态的主存储器的高速缓存行

1201
00:58:52,049 --> 00:59:00,053
和典型的 状态将是无效的 

1202
00:58:55,089 --> 00:59:04,430
它的共享或者其独有所以共享 

1203
00:59:00,053 --> 00:59:06,100
意味着 可以有它的副本，但 

1204
00:59:04,043 --> 00:59:12,044
他们只能是只读 的复制 

1205
00:59:07,000 --> 00:59:16,052
独特的意义，它是专 

1206
00:59:12,053 --> 00:59:17,602
提供给一个单独的线程，所以这是 

1207
00:59:16,052 --> 00:59:20,078
内置到他们的硬件 

1208
00:59:18,079 --> 00:59:23,900
多核处理器 ，从而会 发生 什么 

1209
00:59:20,078 --> 00:59:25,151
然后就是为了 做一个写入 

1210
00:59:23,009 --> 00:59:29,108
一个线程将获得独家

1211
00:59:26,051 --> 00:59:32,078
这个元素的副本， 并且实际 

1212
00:59:30,089 --> 00:59:36,558
标签在这里发生倒在主 

1213
00:59:32,078 --> 00:59:42,367
内存和高速缓存和两个 

1214
00:59:37,359 --> 00:59:45,430
同样，如果如果线程2想要一个到 

1215
00:59:43,069 --> 00:59:50,210
写到B就必须获得 专有副本 

1216
00:59:46,069 --> 00:59:54,050
的那个，然后当读出发生 

1217
00:59:50,021 --> 00:59:56,078
发生了什么实际上是这个高速缓存未命中 

1218
00:59:54,005 --> 00:59:59,051
将发出一个信号， 一个总线上 

1219
00:59:56,078 --> 01:00:02,156
共享通信媒体说我 

1220
00:59:59,051 --> 01:00:06,055
要阅读和的不是主 

1221
01:00:03,056 --> 01:00:09,152
内存响应它实际上会 

1222
01:00:06,091 --> 01:00:13,097
该结果将被供给 

1223
01:00:10,052 --> 01:00:15,361
其他高速缓存，它会转换

1224
01:00:13,097 --> 01:00:19,966
该元件的状态，以被共享 

1225
01:00:15,829 --> 01:00:21,500
本地元素，但你会看到， 

1226
01:00:20,839 --> 01:00:23,660
主内存 

1227
01:00:21,005 --> 01:00:25,016
这还没有更新它穿过

1228
01:00:23,066 --> 01:00:27,080
你已经整个右后卫协议 

1229
01:00:25,061 --> 01:00:28,148
观察，但有时它会更新 

1230
01:00:27,008 --> 01:00:30,014
这有不同的实现 

1231
01:00:29,048 --> 01:00:33,095
但是，这就是为什么它 被称为史努比 

1232
01:00:31,004 --> 01:00:37,040
缓存是，它基本上线程2 

1233
01:00:33,095 --> 01:00:38,189
被偷看或得到它访问 

1234
01:00:37,076 --> 01:00:45,110
在线程的可用信息 

1235
01:00:39,089 --> 01:00:49,103
那些缓存，所以现在线程2将 

1236
01:00:46,001 --> 01:00:52,064
正确得到的副本那是在 

1237
01:00:50,003 --> 01:00:55,025
共享状态 和同样是 

1238
01:00:52,073 --> 01:00:57,104
它会剪断了和线程两个 著名 

1239
01:00:55,025 --> 01:01:01,051
一个将得到一个可读的拷贝这些都是 

1240
01:00:58,004 --> 01:01:04,073
现在所有标记为共享状态 ，所以如果 

1241
01:01:01,051 --> 01:01:07,070
如果其中任何想写他们会 

1242
01:01:04,073 --> 01:01:09,104
必须现在基本上得到独家 

1243
01:01:07,007 --> 01:01:14,042
访问它，并且必须 再 

1244
01:01:10,004 --> 01:01:16,082
禁用副本和其他的 

1245
01:01:15,005 --> 01:01:19,013
其他位置，这样你 能想象这 

1246
01:01:16,082 --> 01:01:20,087
协议是不平凡的实际到

1247
01:01:19,013 --> 01:01:23,027
马上及其实施 方式得到 

1248
01:01:21,032 --> 01:01:27,089
比这更复杂 的所有 

1249
01:01:23,027 --> 01:01:31,109
它的变化左右，但它已经成为了 

1250
01:01:27,089 --> 01:01:32,156
在多核的硬件设计规范，但 

1251
01:01:32,009 --> 01:01:36,028
它实际上是要素的一部分 

1252
01:01:33,056 --> 01:01:38,147
限制了处理器在球场上的计数 

1253
01:01:36,028 --> 01:01:40,127
因为刚涉足硬件

1254
01:01:39,047 --> 01:01:43,102
保持跨越的一致性 

1255
01:01:41,027 --> 01:01:47,029
缓存是不平凡的它工作 

1256
01:01:44,002 --> 01:01:51,002
很快我们在现金利率交谈 

1257
01:01:47,047 --> 01:01:52,073
访问速度所以没有很多的 

1258
01:01:51,002 --> 01:01:54,059
涉及的时间在那里所以实际上 

1259
01:01:52,073 --> 01:01:57,134
实现这个东西使它运行 

1260
01:01:54,059 --> 01:02:00,113
使其规模横跨说八个核 

1261
01:01:58,034 --> 01:02:03,083
10个芯16个核不是不是一个简单的 

1262
01:02:01,013 --> 01:02:06,035
时间，但在背景的推移

1263
01:02:03,083 --> 01:02:10,091
所以你可以为时下最系统 

1264
01:02:06,035 --> 01:02:13,049
你可以假设， 有一些记忆 

1265
01:02:11,063 --> 01:02:14,132
一致性模型，你可以 编程 

1266
01:02:13,049 --> 01:02:18,104
至由 硬件 支持 

1267
01:02:15,032 --> 01:02:21,035
该系统和 该系列 

1268
01:02:19,004 --> 01:02:24,035
多数民众赞成被称为串行化

1269
01:02:21,035 --> 01:02:25,082
第三的最容易理解的 

1270
01:02:24,035 --> 01:02:27,704
这些人是 多 一点点 

1271
01:02:25,082 --> 01:02:31,281
细致入微 

1272
01:02:28,019 --> 01:02:34,980
看，如果在 这里摔了下来底部 

1273
01:02:32,019 --> 01:02:34,980
今天晚上什么事 

1274
01:02:36,069 --> 01:02:38,640
谢谢

1275
01:02:41,079 --> 01:02:51,147
就这样 好了，只是来包装 起来 

1276
01:02:46,023 --> 01:02:54,042
那么它给 你的和你的味道 

1277
01:02:52,047 --> 01:02:56,396
可以看到，让程序运行 

1278
01:02:54,042 --> 01:02:58,050
快速通过多线程是不是不

1279
01:02:56,819 --> 01:03:00,750
方便你经常要重写 

1280
01:02:59,022 --> 01:03:01,029
应用程序，你必须想想 

1281
01:03:00,075 --> 01:03:03,164
算法你不必担心 

1282
01:03:01,092 --> 01:03:07,098
调试它，你已经 

1283
01:03:03,839 --> 01:03:10,650
在无论是在 外壳 的实验室发现

1284
01:03:07,098 --> 01:03:11,196
代理实验室并发性，你 

1285
01:03:10,065 --> 01:03:16,074
无法预测事件的顺序使得 

1286
01:03:12,096 --> 01:03:19,715
它更难以调试代码，以便 

1287
01:03:16,074 --> 01:03:21,126
所有这些因素进来，你有 

1288
01:03:20,579 --> 01:03:23,654
拥有的一些理解 

1289
01:03:22,026 --> 01:03:26,088
所使用的基本机制和 

1290
01:03:24,329 --> 01:03:28,920
什么他们的性能影响是 

1291
01:03:26,088 --> 01:03:32,169
所以特别让我观察 

1292
01:03:28,092 --> 01:03:38,094
在这里，如果我喜欢做 

1293
01:03:33,069 --> 01:03:39,938
遇到像你线程同步

1294
01:03:38,094 --> 01:03:42,983
看到原来他们在哪里

1295
01:03:40,559 --> 01:03:46,260
争夺这个全局变量 P总和 

1296
01:03:43,829 --> 01:03:49,950
或不管它被称为可以 

1297
01:03:46,026 --> 01:03:51,365
想象这些在这场战斗中的高速缓存 

1298
01:03:49,095 --> 01:03:56,121
互相尝试 并获得独家 

1299
01:03:51,599 --> 01:04:02,160
获得 的值这单个存储器 

1300
01:03:57,021 --> 01:04:04,930
因为每个人的奔跑速度一样快 

1301
01:04:02,016 --> 01:04:09,089
因为它 可能可以 但每一个需要 

1302
01:04:05,119 --> 01:04:13,121
获得独家文案写作它和 

1303
01:04:09,089 --> 01:04:14,115
释放它，以便锁定机制

1304
01:04:13,319 --> 01:04:18,410
在它们之间 来回飞

1305
01:04:15,015 --> 01:04:24,021
高速缓存和它真的 不是非常快，所以 

1306
01:04:18,041 --> 01:04:26,930
的那种东西就是为什么和 

1307
01:04:24,021 --> 01:04:31,370
也可以作为应用程序的程序员你 

1308
01:04:27,299 --> 01:04:34,650
拨打电话通话信号您反弹

1309
01:04:31,559 --> 01:04:37,583
成在OS内核 是一种成本 

1310
01:04:34,065 --> 01:04:40,104
参与所以这个东西有所有的坏 

1311
01:04:37,799 --> 01:04:42,880
所有这使程序不是东西 

1312
01:04:41,004 --> 01:04:46,793
运行方式你真的喜欢他们 这么 

1313
01:04:43,609 --> 01:04:48,680
这是并行的挑战之一

1314
01:04:46,829 --> 01:04:51,210
编程是你如何实际上使 

1315
01:04:49,319 --> 01:04:54,760
使用并行这是有

1316
01:04:51,021 --> 01:04:56,059
没有陷入困境由 

1317
01:04:54,076 --> 01:04:59,685
的各种机制的成本

1318
01:04:56,059 --> 01:05:01,078
控制呵呵所以反正这是一部分 

1319
01:05:00,369 --> 01:05:04,300
你有什么体会和 

1320
01:05:01,078 --> 01:05:06,124
了解作为一个程序员是如何将这些 

1321
01:05:04,003 --> 01:05:08,097
事情在 深 的程度 不够 ， 工作 

1322
01:05:07,024 --> 01:05:12,025
您将有 一定意义 的是什么使 

1323
01:05:09,024 --> 01:05:15,070
程序运行更快或更慢的地方 

1324
01:05:12,025 --> 01:05:17,634
错误可能在于所以这只是一个 

1325
01:05:15,007 --> 01:05:21,063
一个更大一点一点味道

1326
01:05:17,859 --> 01:05:22,260
话题所以这是它今天 

