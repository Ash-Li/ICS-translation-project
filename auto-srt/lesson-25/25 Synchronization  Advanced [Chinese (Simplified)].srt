1
00:00:00,003 --> 00:00:05,016
哎好，大家下午好 

2
00:00:01,029 --> 00:00:09,063
欢迎很高兴 见到你，欢迎 到 

3
00:00:05,016 --> 00:00:10,915
我们 对视频 的观众 也 这么 好 

4
00:00:09,063 --> 00:00:13,140
今天我们来看看一些 

5
00:00:11,059 --> 00:00:17,132
周围的人的问题， 其他 问题 

6
00:00:14,004 --> 00:00:19,095
第一同步线程程序

7
00:00:17,789 --> 00:00:22,890
但让我们从最后 一次 审查 的 几个 

8
00:00:20,031 --> 00:00:27,160
的概念， 所以记得， 

9
00:00:22,089 --> 00:00:29,378
信号量是一个非全球非 

10
00:00:27,439 --> 00:00:34,530
同步变量通过操纵

11
00:00:30,179 --> 00:00:38,910
DMV操作和P操作需要 

12
00:00:34,053 --> 00:00:40,152
作为自变量的信号，如果 

13
00:00:38,091 --> 00:00:45,105
旗语重视它递减非零 

14
00:00:41,052 --> 00:00:49,086
信号量，然后继续，如果 

15
00:00:46,005 --> 00:00:53,354
如果信号量的值是 零，那么它 

16
00:00:49,086 --> 00:00:55,142
块等待这个信号量 

17
00:00:53,399 --> 00:00:59,408
值，以用V操作被递增

18
00:00:56,042 --> 00:01:00,048
在V操作增量之后后 

19
00:00:59,489 --> 00:01:04,860
一些操作的递增 

20
00:01:01,002 --> 00:01:06,011
信号量P操作 的继续 

21
00:01:04,086 --> 00:01:10,134
问递减和返回 

22
00:01:06,092 --> 00:01:15,093
控制给调用者 D操作 

23
00:01:11,034 --> 00:01:18,099
从来没有阻止它首先它 增加 

24
00:01:16,002 --> 00:01:21,006
该信号值s，然后它看起来 

25
00:01:18,099 --> 00:01:22,134
在四个队列，看是否有 

26
00:01:21,042 --> 00:01:26,093
被阻止等待的任何过程

27
00:01:23,034 --> 00:01:30,059
对于一些之前不为零 ，如果 

28
00:01:26,093 --> 00:01:33,138
有那么它选择其中的一个

29
00:01:30,059 --> 00:01:38,121
使用一些未指定的条件，然后 

30
00:01:34,038 --> 00:01:41,121
它重新启动，它重新启动该线程

31
00:01:39,021 --> 00:01:47,079
这或者就是这样P动作 

32
00:01:42,021 --> 00:01:50,180
在信号好的等待等待

33
00:01:47,079 --> 00:01:52,167
然后对P的这种语义 

34
00:01:50,369 --> 00:01:56,750
和V确保信号的值是

35
00:01:53,067 --> 00:02:00,096
总是大于等于 现在 为零 

36
00:01:56,075 --> 00:02:03,093
的第一件事，我们看到了如何 保护 

37
00:02:00,096 --> 00:02:05,127
通过使用信号量的共享变量

38
00:02:03,093 --> 00:02:08,732
所谓，保证互斥 

39
00:02:06,027 --> 00:02:12,058
互斥访问

40
00:02:09,569 --> 00:02:15,370
这要更新的关键部分

41
00:02:12,058 --> 00:02:17,116
这些变量或数据结构和 

42
00:02:15,037 --> 00:02:20,104
而我们这样做的方法 是非常 

43
00:02:18,016 --> 00:02:23,080
简单，我们初始化 互斥锁到一个 

44
00:02:21,004 --> 00:02:28,078
然后围绕关键部分

45
00:02:23,008 --> 00:02:30,043
用P以及V 现在有一个 有 

46
00:02:28,078 --> 00:02:31,171
其他方面，我们可以因此 在这里这里是一个 

47
00:02:31,015 --> 00:02:35,107
例如我们使用旗语 在哪里 

48
00:02:32,071 --> 00:02:37,159
提供相互排斥，但我们可以 

49
00:02:36,007 --> 00:02:41,050
还使用 我们的 某些 信号量来 

50
00:02:38,059 --> 00:02:43,150
坐标访问共享数据

51
00:02:41,005 --> 00:02:46,033
结构以不同的方式等等 

52
00:02:44,005 --> 00:02:48,040
这里的想法，我们使用的是前

53
00:02:46,078 --> 00:02:50,083
信号只是为了保护访问

54
00:02:48,085 --> 00:02:52,140
共享变量，但我们也可以 

55
00:02:50,083 --> 00:02:56,092
协调不同的方式获得通过 

56
00:02:53,004 --> 00:02:58,042
保持和这本在这些中

57
00:02:56,092 --> 00:02:59,167
这些类型的场景中，我们使用了 

58
00:02:58,078 --> 00:03:02,170
信号量来跟踪国家 来 

59
00:03:00,067 --> 00:03:05,140
数数的东西来跟踪 

60
00:03:03,007 --> 00:03:07,084
州和通知 等其他线程 

61
00:03:06,004 --> 00:03:12,082
在状态 好的变化， 所以这是一个非常 

62
00:03:08,047 --> 00:03:14,089
不同的使用模式和两个经典 

63
00:03:13,018 --> 00:03:16,072
我们要去的例子 来看看是 

64
00:03:14,089 --> 00:03:18,115
生产者 消费者问题和 

65
00:03:16,072 --> 00:03:21,139
读者的作家的问题，所以让我们来看看 

66
00:03:19,015 --> 00:03:24,073
生产者消费者 首次如此的想法 

67
00:03:22,039 --> 00:03:27,112
生产者消费者的问题是， 

68
00:03:24,073 --> 00:03:31,081
你必须 在形式 的共享资源 

69
00:03:28,012 --> 00:03:34,021
一个缓冲器 的缓冲器 已经有界 

70
00:03:31,081 --> 00:03:38,173
大小，以便它是由n个时隙，并且每个的

71
00:03:35,002 --> 00:03:43,971
槽可容纳一个项目没关系的有一个 

72
00:03:39,073 --> 00:03:46,092
生产者线程产生的项目和

73
00:03:43,989 --> 00:03:50,590
然后将它们插入到缓冲区和 

74
00:03:46,092 --> 00:03:52,161
有检索消费者线程

75
00:03:50,059 --> 00:03:55,093
将删除缓冲器中，然后项

76
00:03:52,989 --> 00:03:59,200
通过对他们采取行动，因此他们消费

77
00:03:55,093 --> 00:04:00,142
以某种方式让他们处理

78
00:03:59,002 --> 00:04:04,069
同步变量 

79
00:04:01,042 --> 00:04:06,531
同步模式是该 

80
00:04:04,087 --> 00:04:08,122
生产者等待空 插槽右 

81
00:04:06,909 --> 00:04:11,928
所以如果有如果缓冲区已满 

82
00:04:09,022 --> 00:04:15,101
生产者不能插入一个项目到 

83
00:04:12,099 --> 00:04:18,430
缓冲所以它等待一个空时隙和 

84
00:04:15,299 --> 00:04:21,160
然后当它发现当一个空槽 

85
00:04:18,043 --> 00:04:23,044
空槽变得可用 它插入 

86
00:04:21,016 --> 00:04:25,069
该项目入 缓冲区 ，然后 

87
00:04:23,053 --> 00:04:30,121
通知有现在的消费者 

88
00:04:25,069 --> 00:04:33,106
在新 项目 的缓冲 

89
00:04:31,021 --> 00:04:37,021
当然，消费者有等待 

90
00:04:34,006 --> 00:04:40,018
一个项目出现在缓冲区 

91
00:04:37,021 --> 00:04:42,040
否则我的意思是不能删除的项 

92
00:04:40,018 --> 00:04:45,085
从空的缓冲区，所以它必须等待 

93
00:04:42,004 --> 00:04:47,029
对于一个 项目是在现有的 

94
00:04:45,085 --> 00:04:50,184
缓冲器和当物品变得 

95
00:04:47,065 --> 00:04:53,116
它可从缓冲区中删除 

96
00:04:50,949 --> 00:04:58,840
并通知生产者是

97
00:04:54,016 --> 00:05:00,034
现在有一个可用插槽好了， 

98
00:04:58,084 --> 00:05:02,115
这其实这个非常简单的模式 

99
00:05:00,034 --> 00:05:06,082
其实真的有用 ， 

100
00:05:03,015 --> 00:05:09,016
在大量 的 应用程序，以便 为显示出来

101
00:05:06,082 --> 00:05:10,090
例如，在多媒体应用 

102
00:05:09,025 --> 00:05:14,106
多媒体应用制片人 

103
00:05:10,009 --> 00:05:18,022
可能会产生MPEG说帧MPEG 

104
00:05:15,006 --> 00:05:21,058
它在视频 和消费者会 

105
00:05:19,003 --> 00:05:24,452
被消耗那些那些MPEG帧和

106
00:05:21,058 --> 00:05:26,577
然后适当地画屏幕

107
00:05:24,479 --> 00:05:30,550
另一个重要的应用是在 

108
00:05:27,099 --> 00:05:32,260
图形用户接口，以便图形化 

109
00:05:30,055 --> 00:05:33,109
用户接口通常

110
00:05:32,026 --> 00:05:39,124
使用这种 生产者-消费者实现

111
00:05:34,009 --> 00:05:44,071
模型，其中，鼠标点击动作和

112
00:05:40,024 --> 00:05:47,073
中鼠标键盘点击

113
00:05:44,071 --> 00:05:48,112
这些都被记录为他们的活动 

114
00:05:47,289 --> 00:05:52,210
通过记录为系统检测

115
00:05:49,012 --> 00:05:55,341
事件并放入某种形式的 

116
00:05:52,021 --> 00:05:57,040
排队和然后各种其它部件 

117
00:05:55,449 --> 00:05:59,620
该系统从队列中检索项 

118
00:05:57,004 --> 00:06:01,102
和， 并将它们反应，从而例如 

119
00:05:59,062 --> 00:06:03,086
图形系统将检索类似事件 

120
00:06:02,038 --> 00:06:07,537
鼠标事件

121
00:06:03,086 --> 00:06:08,575
和鼠标移动鼠标点击它

122
00:06:07,879 --> 00:06:11,870
会画画屏幕右侧相应的

123
00:06:09,349 --> 00:06:15,710
一点点，它会，它会体现它会 

124
00:06:11,087 --> 00:06:17,416
重绘屏幕， 使显示 

125
00:06:15,071 --> 00:06:19,087
您将光标移动向右或

126
00:06:18,199 --> 00:06:24,208
如果你改变了焦点，它会，它会 

127
00:06:19,087 --> 00:06:25,186
重绘它，所以它是一个非常非常普遍 

128
00:06:25,099 --> 00:06:28,430
建模和以后我们会看到 

129
00:06:26,086 --> 00:06:29,093
多线程的，我们可以建立 

130
00:06:28,043 --> 00:06:34,106
使用多线程并发服务器

131
00:06:30,056 --> 00:06:36,134
这这种模式让我们看看我们如何 

132
00:06:35,006 --> 00:06:41,021
将实施上的生产者/消费者 

133
00:06:37,034 --> 00:06:43,061
正元件缓冲器所以这将

134
00:06:41,021 --> 00:06:45,760
实现需要互斥 

135
00:06:43,061 --> 00:06:47,740
Garrety 互斥访问 

136
00:06:45,949 --> 00:06:50,983
当然，资源，然后它需要 

137
00:06:48,289 --> 00:06:55,330
然后另外两个信号计数 

138
00:06:51,289 --> 00:06:58,310
信号量是时隙一信号量 

139
00:06:55,699 --> 00:07:00,771
计算在缓冲区中的可用插槽 

140
00:06:58,031 --> 00:07:02,290
一个项目算到可用项目 

141
00:07:01,419 --> 00:07:05,900
好的 

142
00:07:02,569 --> 00:07:11,578
我们已经可以用这个实现它

143
00:07:05,009 --> 00:07:15,056
这个软件包叫做 s的总线所以ESPA的S 

144
00:07:12,469 --> 00:07:18,517
抛光轮包定义类型 称为S 

145
00:07:16,037 --> 00:07:21,556
浅黄色下划线牛逼的是封装了所有 

146
00:07:18,949 --> 00:07:24,830
是 需要 的数据结构的

147
00:07:21,889 --> 00:07:27,380
实现共享缓冲器 ，以便 

148
00:07:24,083 --> 00:07:28,100
有一个指向缓冲区

149
00:07:27,038 --> 00:07:31,357
这是我们将要实现作为 

150
00:07:29,000 --> 00:07:36,259
阵列，我们将实现我们的 

151
00:07:31,699 --> 00:07:38,870
这个阵列上循环缓冲区的 

152
00:07:36,259 --> 00:07:41,090
时隙的最大数目 等的大小 

153
00:07:38,087 --> 00:07:43,696
缓冲器然后 两个指针 和 

154
00:07:41,009 --> 00:07:47,036
前后跟踪 的中 

155
00:07:44,479 --> 00:07:48,620
前部和后部的缓冲器，以便 

156
00:07:47,036 --> 00:07:51,595
跟踪的第一个和 最后的

157
00:07:48,062 --> 00:07:53,144
在缓冲区的项目，然后三

158
00:07:51,919 --> 00:07:57,590
信号灯互斥锁，并在两 

159
00:07:54,044 --> 00:07:59,263
计数信号，然后将包

160
00:07:57,059 --> 00:08:04,127
由这四个公共 职能 

161
00:07:59,659 --> 00:08:07,684
s 的总线 它创建了被称为针织 

162
00:08:05,027 --> 00:08:10,100
一旦创建缓冲区 并初始化 

163
00:08:07,909 --> 00:08:12,928
一切分配 空间， 

164
00:08:11,000 --> 00:08:16,068
初始化的东西，那么d在它其中 

165
00:08:13,099 --> 00:08:19,680
这可释放一些空间，然后 

166
00:08:16,068 --> 00:08:21,072
一个函数来插入 项目 进入 

167
00:08:19,068 --> 00:08:24,099
排队和一个函数来 删除项目 

168
00:08:22,008 --> 00:08:27,107
从队列中，并返回该项目因此在 

169
00:08:24,099 --> 00:08:27,107
这种情况下，项目仅仅是

170
00:08:30,409 --> 00:08:40,950
所以创建初始化这个 

171
00:08:37,459 --> 00:08:45,930
与n个时隙，我们首先分配缓冲器

172
00:08:40,095 --> 00:08:48,180
为缓冲区和MN 我们设置的空间 

173
00:08:45,093 --> 00:08:54,114
在我们设置的大小为 价值和 

174
00:08:49,008 --> 00:08:57,037
这是通过在我们表明空

175
00:08:55,014 --> 00:09:00,045
通过设置前-后缓冲器为 0 

176
00:08:57,829 --> 00:09:04,620
很好，而且所以每当前部和后部是 

177
00:09:00,045 --> 00:09:06,374
0这就是我们有一个空的缓冲区和 

178
00:09:04,062 --> 00:09:09,099
然后我们初始化3 信号灯等等 

179
00:09:06,779 --> 00:09:13,853
像所有 MEU 得克萨斯州的互斥 

180
00:09:09,099 --> 00:09:14,172
初始化为1 槽旗语 

181
00:09:14,519 --> 00:09:19,760
其跟踪的 数量 

182
00:09:15,072 --> 00:09:23,126
可用时隙被初始化为N和 

183
00:09:19,076 --> 00:09:26,130
该项目旗语初始化为0 

184
00:09:24,026 --> 00:09:30,057
确定 和D 是 非常简单的它 

185
00:09:27,003 --> 00:09:34,042
刚刚解放了的堆空间，我们 

186
00:09:30,057 --> 00:09:36,105
确定分配所以现在 让我们来看看我们如何 

187
00:09:34,339 --> 00:09:39,620
插入项目到缓冲区 ，所以我们 

188
00:09:37,005 --> 00:09:44,079
叫我们要插入此整数项目 

189
00:09:39,062 --> 00:09:48,126
到此缓冲区指向由SP所以

190
00:09:44,079 --> 00:09:51,138
第一线程等待可用 

191
00:09:49,026 --> 00:09:56,042
插槽通过 在槽 做在 P OK 

192
00:09:52,038 --> 00:10:00,111
旗语权利，使P将阻塞，直到

193
00:09:56,042 --> 00:10:04,107
槽是大于或等于 1 行 

194
00:10:01,011 --> 00:10:08,064
一旦有 可用的插槽 则 

195
00:10:05,007 --> 00:10:14,216
它然后它 会 它会 

196
00:10:08,064 --> 00:10:15,069
更新的后部的缓冲器的 行 

197
00:10:14,279 --> 00:10:17,790
所以我们打算把这个项目上 

198
00:10:15,069 --> 00:10:19,208
缓冲器的后部，并因此需要 

199
00:10:17,079 --> 00:10:22,988
以保护访问该共享 

200
00:10:19,829 --> 00:10:26,300
与互斥缓冲区，它的 

201
00:10:23,699 --> 00:10:29,756
通过互斥做撒尿自行车自行车

202
00:10:26,003 --> 00:10:32,222
更新更新我们的后指针好吗 

203
00:10:30,269 --> 00:10:36,120
所以我们前期增加，所以我们增加

204
00:10:32,519 --> 00:10:39,270
后指针再 取取 

205
00:10:36,012 --> 00:10:42,018
的是n / 2模

206
00:10:39,027 --> 00:10:46,086
来计算， 我们要去指数

207
00:10:42,018 --> 00:10:49,020
插入的项目 进入好吧，那么我们做的为V 

208
00:10:46,086 --> 00:10:52,164
互斥好让其他其他 

209
00:10:49,038 --> 00:10:56,103
线程可以可以更新该共享

210
00:10:53,064 --> 00:10:59,142
数据结构，然后我们做一个V来 

211
00:10:57,003 --> 00:11:02,034
项目的数量，以通知所有消费者 

212
00:11:00,042 --> 00:11:05,115
现在有一个项目在中 

213
00:11:02,034 --> 00:11:07,038
缓冲所以这此V是一种 

214
00:11:06,015 --> 00:11:08,112
有趣的你觉得它有点 像 

215
00:11:07,038 --> 00:11:12,135
信号右所以你之类的

216
00:11:09,012 --> 00:11:18,021
信令 消费者，现在 一些 

217
00:11:13,035 --> 00:11:20,109
现在已经发生系统 

218
00:11:18,021 --> 00:11:23,067
删除它是对称的项目，但 

219
00:11:21,009 --> 00:11:25,044
代替的 ，而不是 在操作 

220
00:11:23,067 --> 00:11:27,141
它在运行之前插槽

221
00:11:25,044 --> 00:11:32,066
项目信号量所以要删除的 项 

222
00:11:28,041 --> 00:11:34,125
消费者首先做的项目为P 

223
00:11:32,066 --> 00:11:36,072
旗语所以这个现在 正在等待 

224
00:11:35,025 --> 00:11:37,113
它等待可用项目 

225
00:11:36,072 --> 00:11:42,108
信号量为大于 等于 大于 

226
00:11:38,013 --> 00:11:47,021
一个当这种情况发生则在P在P 

227
00:11:43,008 --> 00:11:51,015
返回，然后我们所做 的更新 

228
00:11:47,021 --> 00:11:56,058
通过一个互斥体 通过预递增 保护 

229
00:11:51,078 --> 00:12:00,120
前服用MOD n和然后读 

230
00:11:56,058 --> 00:12:03,104
该值并将其返回，并把 

231
00:12:01,002 --> 00:12:08,007
它进入这个地方局部变量项目

232
00:12:04,004 --> 00:12:10,083
那么我们释放 互斥锁 ，然后我们做 

233
00:12:08,025 --> 00:12:12,072
上的 槽 数为V，其其 

234
00:12:10,083 --> 00:12:13,110
是公告的 任何 

235
00:12:12,072 --> 00:12:17,117
生产者有现在是一个新的

236
00:12:14,001 --> 00:12:18,008
可用插槽好吗 

237
00:12:19,006 --> 00:12:25,105
有关的任何问题所以这是一个 

238
00:12:24,097 --> 00:12:27,109
小 更微妙 

239
00:12:26,005 --> 00:12:30,067
这看起来很简单，但像所有的 

240
00:12:28,009 --> 00:12:35,041
并发性问题，它实际上很

241
00:12:30,067 --> 00:12:36,136
微妙的所以你可以有 潜力，你 可以 

242
00:12:35,041 --> 00:12:39,139
有许多生产者和很多很多 

243
00:12:37,036 --> 00:12:44,038
消费者都在同一您在操作

244
00:12:40,039 --> 00:12:48,127
知道 相同的相同的共享的缓冲器，以便 

245
00:12:44,038 --> 00:12:53,047
这所以会发生什么，如果如果我们有 

246
00:12:49,027 --> 00:12:55,051
两个消费者 做了APPY关于 这个项目 

247
00:12:53,047 --> 00:12:57,055
信号在准确的同时说

248
00:12:55,051 --> 00:12:59,128
我们的两个核心，并和我们运行 

249
00:12:58,027 --> 00:13:04,084
有两个线程，它们分别各 

250
00:13:00,028 --> 00:13:08,077
执行将P在同一时间上 

251
00:13:04,084 --> 00:13:10,087
相同的是同一个项目 旗语好吗 

252
00:13:08,077 --> 00:13:11,143
因此，即使即使他们访问的 

253
00:13:10,087 --> 00:13:13,174
同时 内核将确保 

254
00:13:12,043 --> 00:13:17,050
其中一人 将执行第一好吗 

255
00:13:14,074 --> 00:13:20,146
所以内核将系列化的P 

256
00:13:17,005 --> 00:13:23,062
操作如果有难以预料 

257
00:13:21,046 --> 00:13:28,060
哪一个首先得到它，但谁的行为 

258
00:13:24,007 --> 00:13:32,064
谁运行有P首先意愿会 

259
00:13:28,006 --> 00:13:34,012
这个递减这个项目 和 信号灯 

260
00:13:32,064 --> 00:13:38,161
那么下 一次 ，当一个线程 

261
00:13:35,002 --> 00:13:41,011
执行它是P＆的项目将是 

262
00:13:39,061 --> 00:13:43,099
零 或非零 行作为结果，以便 

263
00:13:42,001 --> 00:13:46,030
有人赢有 那种一吨的 

264
00:13:43,099 --> 00:13:47,113
喜欢控制比赛，有人赢

265
00:13:46,039 --> 00:13:50,116
比赛总是赢得比赛，因为 

266
00:13:48,013 --> 00:13:53,026
内核被序列化 这些P 

267
00:13:51,016 --> 00:13:56,073
操作和它的执行它们 

268
00:13:53,026 --> 00:13:56,073
原子好吗 

269
00:13:57,056 --> 00:14:03,144
还好现在的有一个

270
00:14:02,003 --> 00:14:06,027
互斥的泛化

271
00:14:04,044 --> 00:14:09,045
问题称为 读写器问题 

272
00:14:06,054 --> 00:14:14,067
所以与相互 互斥 

273
00:14:09,054 --> 00:14:17,151
问题我们保证每个线程 

274
00:14:14,067 --> 00:14:19,071
互斥访问其 

275
00:14:18,051 --> 00:14:22,089
关键的部分，其真实更新

276
00:14:20,007 --> 00:14:24,069
特定资源或访问 

277
00:14:22,089 --> 00:14:25,167
特别是资源 ，我们这样做的 

278
00:14:24,069 --> 00:14:29,112
完全相同的方式访问是否是一个 

279
00:14:26,067 --> 00:14:33,099
读或写的不错，但就是这样的 

280
00:14:30,012 --> 00:14:36,069
在这种情况下，因为过于保守

281
00:14:33,099 --> 00:14:37,110
我们可以在所有我们正在做 ，如果我们 有 

282
00:14:36,069 --> 00:14:40,143
多线程只是读书 

283
00:14:38,001 --> 00:14:43,005
资源就没有理由 

284
00:14:41,043 --> 00:14:45,111
做普的和DS上的资源，或者 

285
00:14:43,005 --> 00:14:47,100
如果我们不改变我们不会改变 

286
00:14:46,011 --> 00:14:51,105
资源我们只是读 它， 

287
00:14:48,045 --> 00:14:53,067
有没有人 写它，然后再 

288
00:14:52,005 --> 00:14:56,028
有没有需要 保护写这么多吧 

289
00:14:53,067 --> 00:14:58,094
读者，我们可以有很多的读者 

290
00:14:56,028 --> 00:15:01,062
因为我们希望所有在同一时间阅读 

291
00:14:58,094 --> 00:15:04,158
阅读资源的变量或 

292
00:15:01,062 --> 00:15:08,087
设置的变量，而且也没有必要 

293
00:15:05,058 --> 00:15:11,079
任何一种同步的 所有好吗 

294
00:15:08,087 --> 00:15:12,153
所以生产者 消费者排序的 

295
00:15:11,079 --> 00:15:15,096
该互斥的泛化

296
00:15:13,053 --> 00:15:17,151
问题这就加强相互排斥 

297
00:15:15,096 --> 00:15:20,169
只有当它是绝对必要 没关系 

298
00:15:18,051 --> 00:15:23,076
所以不可能有是有可能，因为 

299
00:15:21,069 --> 00:15:25,122
许多读者阅读 资源，但 

300
00:15:23,076 --> 00:15:27,117
当一个作家要写那么它

301
00:15:26,022 --> 00:15:31,031
必须有互斥访问 

302
00:15:28,017 --> 00:15:31,112
资源好吗 

303
00:15:33,067 --> 00:15:39,068
所以这是什么样的事情，这 是 

304
00:15:36,032 --> 00:15:41,096
也是一个非常 有用的模式，你必须在 

305
00:15:39,077 --> 00:15:43,088
网上机票预订系统，您

306
00:15:41,096 --> 00:15:45,137
有多个客户端访问 共享 

307
00:15:43,088 --> 00:15:48,089
数据库好了，所以只要 这些 

308
00:15:46,037 --> 00:15:50,132
客户正在阅读的数据库，你可以 

309
00:15:48,098 --> 00:15:51,185
他们都可以在 同一 被阅读 

310
00:15:51,032 --> 00:15:54,035
时间，但只要有人想 

311
00:15:52,085 --> 00:15:56,113
预约和更新 

312
00:15:54,035 --> 00:16:00,134
数据库那么更新有发生 

313
00:15:57,013 --> 00:16:02,021
相互排斥的方式，你知道，如果你 

314
00:16:01,034 --> 00:16:05,081
也如果你有一个像任何形式的 

315
00:16:02,093 --> 00:16:08,186
共享数据结构像在高速缓存 

316
00:16:05,081 --> 00:16:11,135
在这样的你是一个并发代理

317
00:16:09,086 --> 00:16:14,180
马上就会或者如果你写 

318
00:16:12,035 --> 00:16:17,101
尚未 启动该缓存是 

319
00:16:15,008 --> 00:16:19,067
由多个线程所共享和 

320
00:16:18,001 --> 00:16:23,018
多个线程可以读取 

321
00:16:20,039 --> 00:16:24,131
缓存但是当东西时，你的时候 

322
00:16:23,018 --> 00:16:28,070
你会得到一个新的页面，并要缓存 

323
00:16:25,031 --> 00:16:30,038
它那么该 构成一个 

324
00:16:28,007 --> 00:16:33,098
权，这一权利需要发生在 

325
00:16:30,038 --> 00:16:40,055
现在是相互排斥的方式初始 

326
00:16:34,061 --> 00:16:44,099
研究认为是造成科研人员

327
00:16:40,055 --> 00:16:47,108
在定义这个读者的作家的问题

328
00:16:44,099 --> 00:16:50,120
排序几类读写器的 

329
00:16:48,008 --> 00:16:53,102
问题的第一读写器 读取器 

330
00:16:51,002 --> 00:16:57,095
作家的问题是一个实现 

331
00:16:54,002 --> 00:17:00,041
有 利于读者权这样的 想法是 

332
00:16:58,013 --> 00:17:05,078
没有 读者应保持等待 

333
00:17:00,041 --> 00:17:08,093
右除非作家已经具有P 

334
00:17:05,078 --> 00:17:13,150
作为具有某种获取了该锁 

335
00:17:08,093 --> 00:17:17,232
对互斥量上 的 资源，以便 

336
00:17:14,005 --> 00:17:20,704
在这种情况下，你知道说有一个 

337
00:17:18,069 --> 00:17:24,350
作家等着去收购 

338
00:17:21,199 --> 00:17:26,150
互斥和其他读者进来然后 

339
00:17:24,035 --> 00:17:28,073
在此实现， 读者会 

340
00:17:26,015 --> 00:17:33,029
得到优先于 作家和其 

341
00:17:28,073 --> 00:17:34,127
将能够读取 在做 

342
00:17:33,029 --> 00:17:38,054
它的读取和作家将不得不 

343
00:17:35,027 --> 00:17:40,076
等待等法院 ，现在如果多 

344
00:17:38,054 --> 00:17:42,057
读者不断在那么这可能来临

345
00:17:40,076 --> 00:17:44,465
饿死了作家的权利

346
00:17:42,084 --> 00:17:46,110
所以一个作家可能被饿死的排序 

347
00:17:45,149 --> 00:17:50,225
无限期地等待所有这些

348
00:17:47,001 --> 00:17:54,830
读者来完成，它只是基于 

349
00:17:50,909 --> 00:17:56,940
你知道基于如何基于

350
00:17:54,929 --> 00:17:58,016
操作系统决定安排

351
00:17:56,094 --> 00:18:01,161
这些这些不同的读者阅读器 

352
00:17:58,799 --> 00:18:04,350
线程作家可能是可能是 

353
00:18:02,061 --> 00:18:05,210
饿死了所以这就是 那是什么 

354
00:18:04,035 --> 00:18:07,724
我们的意思是，当我们说这是 一个 

355
00:18:05,759 --> 00:18:12,720
德鲁斯读者现在 第二个读者 

356
00:18:08,039 --> 00:18:14,610
各种问题的排序 中 的 

357
00:18:12,072 --> 00:18:16,119
那相反的，因此有利于作家 

358
00:18:14,061 --> 00:18:19,730
右所以一旦任何一个作家准备

359
00:18:17,019 --> 00:18:22,868
写那么它在任何获得优先权

360
00:18:20,279 --> 00:18:26,306
等待读者所以在这种情况下，如果我们 

361
00:18:23,039 --> 00:18:28,073
有，如果我们有多个 作家说 

362
00:18:26,549 --> 00:18:33,560
想写他们可能饿死了

363
00:18:28,379 --> 00:18:36,990
读者现在有有其他 

364
00:18:33,659 --> 00:18:38,730
变种那种交易与 此 

365
00:18:36,099 --> 00:18:40,358
饥饿问题这一潜力 

366
00:18:38,073 --> 00:18:43,772
饥饿问题，但我们不会看

367
00:18:41,249 --> 00:18:46,950
他们在这里所以让我们看看 

368
00:18:44,429 --> 00:18:51,473
解决第一个作家的读者 

369
00:18:46,095 --> 00:18:53,097
问题这么写的 最初一个线程 

370
00:18:51,869 --> 00:18:59,610
无论是在这种阅读器

371
00:18:53,097 --> 00:19:00,111
简化或者 它是一个作家，如果我们 

372
00:18:59,061 --> 00:19:04,840
看看作家，这是非常 

373
00:19:01,011 --> 00:19:05,290
简单， 它只是 作家只是 

374
00:19:06,529 --> 00:19:13,532
做日工此信号灯所以这本 

375
00:19:09,899 --> 00:19:15,935
信号灯W是那种充当的 

376
00:19:13,559 --> 00:19:18,641
像保护资源互斥 

377
00:19:16,259 --> 00:19:24,240
作家所以它可以确保有 

378
00:19:19,379 --> 00:19:27,720
至多在 任何 时候 一个作家 执行 

379
00:19:24,024 --> 00:19:30,122
它的关键部分， 它通过 

380
00:19:27,072 --> 00:19:35,411
只是这此变化这个熟悉的P 

381
00:19:31,022 --> 00:19:38,831
其次如下 -v可以阅读ERRS 的我 

382
00:19:36,059 --> 00:19:42,092
有一点更有趣 所以用 

383
00:19:39,029 --> 00:19:44,190
与读者，我们共享这 

384
00:19:42,389 --> 00:19:45,690
所谓阅读数全局变量 

385
00:19:44,019 --> 00:19:49,348
是要保持 数量的轨道 

386
00:19:45,069 --> 00:19:52,508
正在等待 阅读的读者

387
00:19:49,519 --> 00:19:54,608
阅读资源，有一个互斥体 

388
00:19:53,129 --> 00:19:56,740
信号灯互斥保护保护 

389
00:19:55,409 --> 00:19:59,380
在访问

390
00:19:56,074 --> 00:20:02,095
更新阅读次数没关系的读取和 

391
00:19:59,038 --> 00:20:05,089
权念计数，然后 

392
00:20:02,095 --> 00:20:08,134
有这正如 我们所看到 该 W信号 

393
00:20:05,089 --> 00:20:11,137
这里是用来保护的关键 

394
00:20:09,034 --> 00:20:17,047
在作家和最初两部分 

395
00:20:12,037 --> 00:20:19,048
这些被设置为一个，这样读者 

396
00:20:17,047 --> 00:20:22,051
在每次迭代这个无限循环 

397
00:20:19,048 --> 00:20:23,145
这个无限循环 它会 

398
00:20:22,051 --> 00:20:28,051
增量读计数，因此可保护 

399
00:20:24,045 --> 00:20:32,107
该访问由上新 做的为 P 

400
00:20:28,051 --> 00:20:36,097
这与验票 关联 ，以便文本

401
00:20:33,007 --> 00:20:39,034
只有一个只有一个 读者可以可以 如此 

402
00:20:36,097 --> 00:20:41,163
在P 和 V 之间的这个区域 

403
00:20:39,034 --> 00:20:45,112
构成临界区

404
00:20:42,063 --> 00:20:51,097
相应的阅读数量，使得后 

405
00:20:46,012 --> 00:20:53,451
P完成再然后我们增加 

406
00:20:51,097 --> 00:20:55,153
读计数所以现在有一个 

407
00:20:53,559 --> 00:20:57,940
额外的读卡器等 ，我们可以有 

408
00:20:56,053 --> 00:20:59,098
的这些可能是任意数量的

409
00:20:57,094 --> 00:21:01,105
读者线程右所以这个我们 

410
00:20:59,098 --> 00:21:04,162
这表明有有有

411
00:21:02,005 --> 00:21:07,036
新的读者现在，如果读计数 

412
00:21:05,062 --> 00:21:08,161
一说，这意味着我们是第一个 

413
00:21:07,036 --> 00:21:13,060
读者好了，所以这是排序第一的 

414
00:21:09,061 --> 00:21:17,158
读者带入的这种隐性的队列 

415
00:21:13,006 --> 00:21:21,058
等待的读者，所以如果读计数为1

416
00:21:18,058 --> 00:21:26,907
如果我们是第一个读者，然后我们做在P 

417
00:21:22,012 --> 00:21:31,024
W 上 还好现在将 锁定 任何 

418
00:21:27,429 --> 00:21:34,000
任何现在任何未来的作家，如果有 

419
00:21:31,024 --> 00:21:35,107
已经这样做了 它一个作家的w ^ p个 

420
00:21:34,000 --> 00:21:39,076
那么 这将 阻止等待 那 

421
00:21:36,007 --> 00:21:42,034
作家完成 不错，但如果没有 

422
00:21:39,076 --> 00:21:44,134
作家在其关键的内部

423
00:21:42,034 --> 00:21:49,063
临界区那么这个P将只 

424
00:21:45,034 --> 00:21:53,082
减小信号W的1到0 

425
00:21:49,063 --> 00:21:55,072
然后锁定任何 后续的作家 

426
00:21:53,082 --> 00:21:58,941
还好所以现在经过后，它的完成这个 

427
00:21:56,053 --> 00:22:02,086
增量 和读取计数的阅读 

428
00:21:59,679 --> 00:22:05,380
然后变量，它释放的互斥体 ， 

429
00:22:02,086 --> 00:22:07,086
其他读者可以可以访问 

430
00:22:05,038 --> 00:22:07,086
叙事

431
00:22:09,009 --> 00:22:17,570
现在没事了，但它仍然保持它的 

432
00:22:15,035 --> 00:22:18,041
这是它的控股，所以这是这个 

433
00:22:17,057 --> 00:22:21,016
是一种有趣的 右侧是它的 

434
00:22:18,095 --> 00:22:23,704
它所持有的信号量 即 

435
00:22:21,529 --> 00:22:27,830
锁住了作家，但它不是 

436
00:22:24,559 --> 00:22:32,210
持有任何-任何互斥的权利，因此 

437
00:22:27,083 --> 00:22:35,062
读者现在可以只可刚 读它可以 

438
00:22:32,021 --> 00:22:38,108
做 它的读取和其他 读者是 

439
00:22:35,809 --> 00:22:42,080
在码的 同一相同 部 

440
00:22:39,008 --> 00:22:46,477
还可以做他们的阅读权，从而使 

441
00:22:42,008 --> 00:22:49,009
我们没有，所以我们要允许多个 

442
00:22:46,549 --> 00:22:53,620
现在的读者这个临界区内 

443
00:22:49,009 --> 00:22:55,468
但是却没有作家好了，一切都那么 

444
00:22:54,259 --> 00:22:58,370
一切工作看起来像它的工作原理 

445
00:22:55,549 --> 00:23:00,500
现在好后之后，我们现在读

446
00:22:58,037 --> 00:23:01,836
读者的数量，现在将是 我们 

447
00:23:00,005 --> 00:23:05,027
要递减读者的数量 

448
00:23:02,169 --> 00:23:09,175
所以我们获得互斥体上读取数 

449
00:23:05,072 --> 00:23:10,861
我们读递减计数，然后我们 

450
00:23:09,769 --> 00:23:13,843
检查，看看是否是最后的读者 

451
00:23:11,509 --> 00:23:18,200
好了，如果没有更多的 读者 

452
00:23:14,509 --> 00:23:19,597
换句话说，如果读计数为零，则

453
00:23:18,002 --> 00:23:22,471
与现在我们可以释放互斥

454
00:23:20,389 --> 00:23:26,404
笔者让任何现在的作家能 

455
00:23:22,669 --> 00:23:30,950
可以访问该资源后，我们 

456
00:23:26,539 --> 00:23:33,110
释放作家的作家 

457
00:23:30,095 --> 00:23:34,524
互斥然后我们释放读互斥 

458
00:23:33,011 --> 00:23:35,280
计数

459
00:23:36,026 --> 00:23:44,120
关于这个如此的这么多问题 

460
00:23:43,032 --> 00:23:47,891
有趣的你想想刚 

461
00:23:45,002 --> 00:23:51,026
您有任何空闲时间你是怎么可能

462
00:23:48,179 --> 00:23:54,750
你会如何写一个版本，这

463
00:23:51,044 --> 00:24:05,127
读者的作家的问题，有利于 

464
00:23:54,075 --> 00:24:07,754
作者而非读者是没有哦

465
00:24:06,027 --> 00:24:11,566
好了 ，所以这个问题 是 一个互斥量允许 

466
00:24:08,429 --> 00:24:13,517
多读者的事实，我们 

467
00:24:11,809 --> 00:24:17,610
知道我们将要发布 这样 一个事实 

468
00:24:14,309 --> 00:24:19,370
互斥这里，这个互斥量也仅仅是 

469
00:24:17,061 --> 00:24:21,075
保护访问读取次数 ，所以我们 

470
00:24:19,919 --> 00:24:24,932
在这里获取它，我们在这里释放 

471
00:24:21,075 --> 00:24:28,077
我们已经经过后，我们访问过读 

472
00:24:25,049 --> 00:24:30,086
算不错，但我们还没有 保护 

473
00:24:28,077 --> 00:24:35,100
与任何读取器的关键部分

474
00:24:30,419 --> 00:24:38,070
与除了我们我们是任何互斥 

475
00:24:36,000 --> 00:24:42,002
保持了作家通过，如果我们的

476
00:24:38,007 --> 00:24:44,013
第一个在如果我们是第 一个读者 

477
00:24:42,002 --> 00:24:45,009
您可以添加 就这样隐 

478
00:24:44,013 --> 00:24:50,109
读者的队列 我们保持 

479
00:24:45,072 --> 00:24:53,088
轨道与读算 好了，所以如果 

480
00:24:51,009 --> 00:24:57,009
我们是第一个出来的意思我们

481
00:24:53,088 --> 00:24:58,637
第一读者，然后我们我们获得了这个 

482
00:24:57,009 --> 00:25:01,708
现在如果在作家互斥在p 

483
00:24:59,429 --> 00:25:05,190
有，当然，如果有一个作家 

484
00:25:01,789 --> 00:25:08,825
这里面关键部分则该p 

485
00:25:05,019 --> 00:25:12,108
会等到作家释放好吗 

486
00:25:09,149 --> 00:25:17,250
但一旦一旦我们获得的这本 

487
00:25:13,008 --> 00:25:19,337
这种互斥W，则我们是 块我们 

488
00:25:17,025 --> 00:25:21,111
锁定任何作家没关系，因为 

489
00:25:19,409 --> 00:25:23,970
他们会任何笔者，到达 

490
00:25:22,011 --> 00:25:28,064
我们会做一个P和它会阻止权 

491
00:25:23,097 --> 00:25:30,132
在这里 等待的w 为 非零 

492
00:25:28,064 --> 00:25:32,139
好了，所以我们只是在我们阻挡在外 

493
00:25:31,032 --> 00:25:38,084
任何作家，但随后我们 允许任何 

494
00:25:33,039 --> 00:25:38,084
读者只需访问该资源

495
00:25:39,021 --> 00:25:43,116
还好还好好 

496
00:25:44,062 --> 00:25:52,144
是问题的问题是阻止慢 

497
00:25:50,074 --> 00:25:54,109
它可以 很好 取决于 首先的 

498
00:25:53,044 --> 00:25:56,523
你正在做一个进入 内核的 调用 等等 

499
00:25:55,009 --> 00:25:58,051
这是一个系统调用，所以你穿越 

500
00:25:56,919 --> 00:26:01,150
该边界和总有 

501
00:25:58,051 --> 00:26:04,057
开销与该再关联

502
00:26:01,015 --> 00:26:06,034
堵你封锁，直到你知道 

503
00:26:04,057 --> 00:26:07,150
它可以是排序 的 任意 量 的 

504
00:26:06,034 --> 00:26:10,863
正确的时间，直到有人没有一些

505
00:26:08,005 --> 00:26:14,029
螺纹确实为V 所以是不能慢 

506
00:26:11,169 --> 00:26:17,193
右它只是它只是取决于你不能 

507
00:26:14,074 --> 00:26:18,163
这真的很难约束时间 

508
00:26:17,409 --> 00:26:21,423
你要现在如果你被封锁 

509
00:26:19,063 --> 00:26:22,147
写程序最终正确

510
00:26:21,549 --> 00:26:28,584
你会被解封你 最终 知道 

511
00:26:23,047 --> 00:26:29,976
一些线程将执行为V，但是当 

512
00:26:28,899 --> 00:26:32,230
我们那种假设 内核 

513
00:26:30,399 --> 00:26:34,440
做某种它实现的时候了 

514
00:26:32,023 --> 00:26:39,049
v更高的IT做某种 公平调度 

515
00:26:34,809 --> 00:26:41,440
该所以阻止的块P不会在 

516
00:26:39,049 --> 00:26:42,738
它永远正确的队列 

517
00:26:41,044 --> 00:26:45,070
内核做某种东西 

518
00:26:43,179 --> 00:26:50,204
这是公平的，因此没有保证一个 

519
00:26:45,007 --> 00:26:49,736
P将不会无限期封锁 

520
00:26:54,041 --> 00:27:04,136
还好 有任何问题 ，所以我们可以种 

521
00:27:01,061 --> 00:27:09,083
的把所有的这一起 ，和使用 

522
00:27:05,036 --> 00:27:12,355
在使用我们的生产者-消费者模式 

523
00:27:09,083 --> 00:27:14,132
实现预线程并发 回波 

524
00:27:12,679 --> 00:27:17,960
服务器现在为止，当我们的时候，我们已经 

525
00:27:15,032 --> 00:27:19,094
使用的线程在所有我们 的例子 

526
00:27:17,096 --> 00:27:20,183
使用线程和 进程的 服务器 

527
00:27:19,094 --> 00:27:22,190
我们创建了一个新的线程或进程 

528
00:27:21,083 --> 00:27:27,170
每当一个新的连接 请求 

529
00:27:23,009 --> 00:27:29,078
赶到，那么当时，然后是 

530
00:27:28,007 --> 00:27:32,021
该线程交互与客户端 

531
00:27:30,059 --> 00:27:34,076
然后每当每当 

532
00:27:32,084 --> 00:27:36,553
互动结束它关闭 

533
00:27:34,076 --> 00:27:40,076
连接和退出，杀死了

534
00:27:37,309 --> 00:27:44,030
线程或进程，现在这 没关系 

535
00:27:40,076 --> 00:27:46,159
但它是 低效的，因为我们是 

536
00:27:44,003 --> 00:27:51,095
这个创建和杀死线程

537
00:27:47,059 --> 00:27:54,095
引入架空所以另一种方式 

538
00:27:51,095 --> 00:27:56,934
这样做是为了预处理线或

539
00:27:54,095 --> 00:28:01,103
流程提前创建池 

540
00:27:57,789 --> 00:28:04,520
线程，每个线程，所以我们创建一个 

541
00:28:02,075 --> 00:28:06,122
这些工作线程池，每个 

542
00:28:04,052 --> 00:28:10,103
这些水的线程与互动

543
00:28:07,022 --> 00:28:13,034
可以与客户端交互好了， 

544
00:28:11,003 --> 00:28:15,044
而不是那种创造过程 

545
00:28:13,034 --> 00:28:18,097
和线程在 点播我们创建了一个 

546
00:28:15,044 --> 00:28:21,083
我们所说的一组预先螺纹或 

547
00:28:18,097 --> 00:28:25,115
预螺纹螺纹或预分叉 

548
00:28:21,083 --> 00:28:28,145
该做的工作这样的想法流程

549
00:28:26,015 --> 00:28:31,112
就是我们在这个主线程 

550
00:28:29,045 --> 00:28:35,524
我们是在等待连接服务器

551
00:28:32,012 --> 00:28:39,020
重复调用来自客户端的请求

552
00:28:35,929 --> 00:28:41,620
接受，然后当它时，这 

553
00:28:39,002 --> 00:28:44,033
线程接收该连接请求 

554
00:28:41,062 --> 00:28:46,097
从客户端 接受接受 

555
00:28:44,051 --> 00:28:49,115
调用accept函数返回 

556
00:28:46,097 --> 00:28:51,190
连接文件描述符确定相关联的 

557
00:28:50,015 --> 00:28:56,914
与连接到客户端，

558
00:28:52,009 --> 00:28:57,107
然后它插入该描述符到一个 

559
00:28:57,049 --> 00:29:02,630
到缓冲区中确定现在 还记得 

560
00:28:58,088 --> 00:29:04,151
描述都只是小整数那 

561
00:29:02,063 --> 00:29:06,070
指标描述符表，所以他们 

562
00:29:05,051 --> 00:29:09,060
可以传递

563
00:29:07,033 --> 00:29:12,069
从线程线程，因为所有的

564
00:29:09,519 --> 00:29:17,541
线程共享相同的同

565
00:29:12,069 --> 00:29:21,111
设置相同的描述符表这样的权利 

566
00:29:17,739 --> 00:29:24,753
主线程把反复

567
00:29:22,011 --> 00:29:26,086
接受连接请求和插入

568
00:29:24,879 --> 00:29:30,940
相应的连接文件 

569
00:29:26,086 --> 00:29:34,095
描述符入缓冲区现在每 

570
00:29:30,094 --> 00:29:37,083
工作线程在此等待如此 

571
00:29:34,869 --> 00:29:39,900
区分的项目描述符所以 

572
00:29:37,929 --> 00:29:43,080
工作线程，他们都在等待 

573
00:29:40,179 --> 00:29:45,276
本项 出现在这个缓冲区 

574
00:29:43,008 --> 00:29:51,597
好吧，当一个项目出现的一个 

575
00:29:46,149 --> 00:29:54,183
线程将删除的项目，然后 

576
00:29:51,669 --> 00:29:56,730
使用该描述与互动

577
00:29:54,489 --> 00:29:58,840
与客户端在连接文件 

578
00:29:57,279 --> 00:30:00,730
描述与关联

579
00:29:58,084 --> 00:30:04,023
该之间存在连接

580
00:30:00,073 --> 00:30:07,272
客户端， 因此现在的服务器 还好我们 

581
00:30:04,779 --> 00:30:09,220
有，我们有并发进来 

582
00:30:07,929 --> 00:30:11,013
这些多个工作形式

583
00:30:09,022 --> 00:30:13,821
线程与多互动

584
00:30:11,769 --> 00:30:18,600
客户端，然后当工人线程 

585
00:30:14,019 --> 00:30:21,033
完成服务于特定的客户端 

586
00:30:18,006 --> 00:30:23,795
那么它 只是 和 它检查 

587
00:30:21,159 --> 00:30:27,195
在缓冲区未来文件描述符好吗 

588
00:30:24,389 --> 00:30:30,405
所以这是远远超过我们的效率

589
00:30:27,519 --> 00:30:31,593
以前的模型， 其中为每个新客户 

590
00:30:30,549 --> 00:30:33,555
我们必须创建一个线程或 进程 

591
00:30:32,259 --> 00:30:35,470
然后销毁线程或进程 

592
00:30:34,149 --> 00:30:40,173
一旦我们 完成 了 

593
00:30:35,047 --> 00:30:41,098
好了，所以我们要排序的重新通告 

594
00:30:40,389 --> 00:30:43,452
我们不得不去通过创建 这些 

595
00:30:41,098 --> 00:30:47,427
工作线程通过让他们运行

596
00:30:44,019 --> 00:30:50,021
然后更换破坏或 

597
00:30:48,309 --> 00:30:54,345
该线程 的杀灭与 

598
00:30:50,039 --> 00:30:58,041
只是一个简单的替换它

599
00:30:54,669 --> 00:31:01,790
简单 ， 非常快的操作 

600
00:30:58,059 --> 00:31:04,530
在从缓冲器取出的项目行 

601
00:31:01,079 --> 00:31:07,092
好了，让我们看看会怎样，我们会 

602
00:31:04,053 --> 00:31:09,057
实现这个，喜欢像所有的 

603
00:31:07,092 --> 00:31:10,185
这些服务器的例子是出奇

604
00:31:09,057 --> 00:31:14,064
简单的权利，这是一个全功能的 

605
00:31:11,085 --> 00:31:20,127
一个真正的服务器，但我们可以在一个做到这一点 

606
00:31:14,064 --> 00:31:22,110
一个页面的代码在一个页面所以 这 

607
00:31:21,027 --> 00:31:25,056
普里特我们将使用线程 我们 

608
00:31:23,001 --> 00:31:27,015
并发服务器，我们要使用 

609
00:31:25,056 --> 00:31:30,075
在S BUFF包，所以我们打算 

610
00:31:27,024 --> 00:31:37,109
创建这个这个共享缓冲区全球 

611
00:31:30,075 --> 00:31:39,117
变量称为S的buff，我们有 一个 

612
00:31:38,009 --> 00:31:42,012
听描述符和连接 

613
00:31:40,017 --> 00:31:44,040
描述和我们有客户端长度 

614
00:31:42,039 --> 00:31:46,095
将在使用和客户端加法器

615
00:31:44,004 --> 00:31:49,092
在接受电话，我们有螺纹 

616
00:31:46,095 --> 00:31:51,170
将在何时被使用 ID 我们 

617
00:31:50,028 --> 00:31:56,052
创建当我们创建这个线程 

618
00:31:52,007 --> 00:31:57,075
所以现在我们通过我们将开始 

619
00:31:56,052 --> 00:31:59,127
在这个方案我们打算在传递 

620
00:31:58,038 --> 00:32:02,106
所以服务器的端口号是怎么回事 

621
00:32:00,027 --> 00:32:05,076
被一些端口 ，所以我们 在听 

622
00:32:03,006 --> 00:32:11,007
在作为第一通过了端口号

623
00:32:05,076 --> 00:32:14,133
参数 ，所以我们称之为开放式听取 FD上 

624
00:32:11,007 --> 00:32:17,009
我们一个一个开放第五听 FD创建 

625
00:32:15,033 --> 00:32:19,092
听了描述，并返回 

626
00:32:17,027 --> 00:32:23,052
返回描述符的价值 ， 

627
00:32:19,092 --> 00:32:27,141
听FD然后我们称S buffin它 

628
00:32:23,052 --> 00:32:32,099
以初始化我们共同的缓冲带 

629
00:32:28,041 --> 00:32:35,139
与S 的buff 大小文件描述符 和 

630
00:32:32,099 --> 00:32:38,106
然后我们创建N个线程的集合 

631
00:32:36,039 --> 00:32:40,137
对每一个工作线程会 

632
00:32:39,006 --> 00:32:46,071
执行线程例程

633
00:32:41,037 --> 00:32:47,118
当我们调用线程并没有这样的说法 

634
00:32:46,071 --> 00:32:50,132
一旦我们创建这些所有的这些 

635
00:32:48,018 --> 00:32:58,037
线程然后我们去在这个无限循环 

636
00:32:51,032 --> 00:32:58,037
在这里我们调用 accept 

637
00:32:58,759 --> 00:33:03,778
在此聆听量，使得上 

638
00:33:02,179 --> 00:33:06,320
上可接受的 块直到 一连接 

639
00:33:03,949 --> 00:33:07,951
请求到达时，它的 

640
00:33:06,032 --> 00:33:10,171
接受与连接的文件返回

641
00:33:08,149 --> 00:33:14,200
描述符，可用于向 

642
00:33:10,459 --> 00:33:16,477
与 客户互动，一旦我们得到 

643
00:33:14,659 --> 00:33:19,660
该连接的文件描述符那么我们 

644
00:33:16,639 --> 00:33:22,672
只是简单地将其插入我们插入

645
00:33:19,759 --> 00:33:24,835
该所连接的文件描述符成 

646
00:33:22,969 --> 00:33:26,977
我们共同的缓冲区，然后 等待 

647
00:33:25,519 --> 00:33:29,614
连接请求下一个连接 

648
00:33:27,769 --> 00:33:31,831
请求，以便我们的服务器非常有效 

649
00:33:30,469 --> 00:33:34,492
正确的，我们只是在做 一个接受和 

650
00:33:32,389 --> 00:33:36,448
然后非常快的 插入缓冲 

651
00:33:34,699 --> 00:33:37,705
好吧 ，然后我们将 让 

652
00:33:36,979 --> 00:33:40,940
工作线程做的所有工作

653
00:33:38,299 --> 00:33:47,308
与那些具有 关联 

654
00:33:40,094 --> 00:33:50,923
与现在的描述符该队列 

655
00:33:47,389 --> 00:33:52,456
线程程序首先分离好吗 

656
00:33:51,769 --> 00:33:55,780
所以，这是我们不希望的情况下， 

657
00:33:53,059 --> 00:33:59,101
运行可连接的，因为我们永远不会 

658
00:33:55,879 --> 00:34:01,948
要加入我们永远不会 等待 

659
00:33:59,479 --> 00:34:06,513
这些线程或有任何任何理由 

660
00:34:02,569 --> 00:34:09,740
从主线程所以这次杀了他们

661
00:34:06,819 --> 00:34:11,824
所以现在这个工作线程，并在此 

662
00:34:09,074 --> 00:34:13,079
无限循环每次迭代它消除 

663
00:34:11,869 --> 00:34:15,916
从缓冲器中的项目，因此块 

664
00:34:14,024 --> 00:34:18,663
直到有一个项目，它可以编码 

665
00:34:16,339 --> 00:34:24,346
它可以从缓冲器中删除，并 

666
00:34:18,879 --> 00:34:28,220
将其设置到这个局部变量CON英尺 

667
00:34:25,039 --> 00:34:31,062
然后调用一个辅助类的这 

668
00:34:28,022 --> 00:34:33,050
这就像 辅助函数 

669
00:34:31,269 --> 00:34:35,240
实现逻辑该这 

670
00:34:33,005 --> 00:34:38,364
特定的服务器，这是这 

671
00:34:35,024 --> 00:34:41,045
这种情况下，它的回声服务器，因此这 

672
00:34:38,859 --> 00:34:42,901
这种回声计数程序将互动

673
00:34:41,045 --> 00:34:45,274
与客户端 呼应无论 

674
00:34:43,279 --> 00:34:48,316
客户端发送我们，直到客户机关闭 

675
00:34:45,679 --> 00:34:51,190
该连接，然后当它这样 

676
00:34:48,649 --> 00:34:55,723
每当 客户端已经完成，然后 

677
00:34:51,019 --> 00:34:58,115
然后我们关闭我们关闭我们的最终 

678
00:34:56,389 --> 00:35:01,670
连接 和回去拿 

679
00:34:59,015 --> 00:35:03,484
下一个项目移出缓冲区 

680
00:35:01,067 --> 00:35:04,145
我要指出的是回声计数 

681
00:35:03,619 --> 00:35:07,640
只是一个占位符，这可能是 

682
00:35:05,045 --> 00:35:09,098
任何事情，这可能是一个逻辑 

683
00:35:07,064 --> 00:35:19,067
对于任何一种Web服务的 Web服务器

684
00:35:09,098 --> 00:35:23,467
或任何种类的服务现在到 

685
00:35:19,067 --> 00:35:29,071
初始化这个回波计数功能我们 

686
00:35:24,349 --> 00:35:34,670
需要我们需要 初始化 互斥锁 

687
00:35:29,071 --> 00:35:36,122
所以我们所以这个回声计数功能 

688
00:35:34,067 --> 00:35:39,095
要 拥有它有一个定义一个全局 

689
00:35:37,022 --> 00:35:41,341
变量称为 字节计数所以这 

690
00:35:39,095 --> 00:35:42,514
我们要 保持这种回声服务器 

691
00:35:41,539 --> 00:35:45,544
的轨道 ， 我们已经 字节数的 

692
00:35:43,369 --> 00:35:48,230
从所有 我们 的广大客户的好评

693
00:35:45,589 --> 00:35:50,480
用好交互 所以有 

694
00:35:48,023 --> 00:35:52,067
所谓的 字节数 全局 变量 

695
00:35:50,048 --> 00:35:54,847
被所有 线程 共享 ，我们 

696
00:35:52,067 --> 00:35:57,101
要更新这个这个字节数 

697
00:35:55,279 --> 00:36:00,740
变量我们得到的东西，每次 

698
00:35:58,001 --> 00:36:03,100
每次我们 从 接收数据的时间

699
00:36:00,074 --> 00:36:07,091
客户端，我们要使用互斥 

700
00:36:03,109 --> 00:36:10,177
保护访问字节数好吗 

701
00:36:07,091 --> 00:36:13,094
所以我们要开始有 

702
00:36:10,789 --> 00:36:18,862
初始化我们要调用一个 函数 

703
00:36:14,021 --> 00:36:22,330
初始化初始化这个 

704
00:36:19,519 --> 00:36:27,140
通过首先初始化互斥 ，然后 

705
00:36:22,519 --> 00:36:30,400
设置字节数为零，然后 

706
00:36:27,014 --> 00:36:30,040
内回声数本身

707
00:36:34,097 --> 00:36:40,149
有一些 我们已经看到 子 

708
00:36:38,009 --> 00:36:42,081
我们已经看到了一种方法来初始化 

709
00:36:41,049 --> 00:36:45,054
包你知道，如果我们有某种 

710
00:36:43,062 --> 00:36:47,063
的库函数 是包

711
00:36:45,054 --> 00:36:49,076
要被 多个 线程 使用 

712
00:36:47,072 --> 00:36:52,083
有几种 方法 来实际 

713
00:36:49,076 --> 00:36:55,133
初始化这个包，以便一种方法是 

714
00:36:52,083 --> 00:36:58,166
明确要求有主线程 

715
00:36:56,033 --> 00:37:02,046
调用 这个初始化函数一次 

716
00:36:59,066 --> 00:37:04,119
好了，我们已经看到，随着像在S 

717
00:37:02,046 --> 00:37:09,129
BUFF包右主线程 

718
00:37:05,019 --> 00:37:13,068
调用主线程调用 小号buffin 

719
00:37:10,029 --> 00:37:15,096
之前的任何 同行 的 一次 好吗 

720
00:37:13,068 --> 00:37:18,156
线程执行 和工作线程 

721
00:37:15,096 --> 00:37:21,111
执行，但有另一种方式，我们 可以 

722
00:37:19,056 --> 00:37:23,079
就此别过，我们 可以有 工人 

723
00:37:22,011 --> 00:37:27,012
实际上线程调用初始化 

724
00:37:23,079 --> 00:37:31,086
功能，我们可以使用这种技术 

725
00:37:27,012 --> 00:37:36,048
通过我们定义P个线程提供

726
00:37:32,049 --> 00:37:38,145
一个静态变量，所以这是一个静态的 

727
00:37:36,048 --> 00:37:40,134
局部变量，但你记住，这 

728
00:37:39,045 --> 00:37:45,087
实际上像对待全球 

729
00:37:41,034 --> 00:37:49,053
变量，因此它的每一个线程都可以 访问 

730
00:37:45,087 --> 00:37:52,119
这个变量 还可以 ，但但它的范围 

731
00:37:49,053 --> 00:37:55,056
仅限于迪斯科德cocao 

732
00:37:53,019 --> 00:37:59,082
功能所以没有其他没有其他的功能 

733
00:37:55,056 --> 00:38:01,131
连接可以访问此变量 ，但 

734
00:37:59,082 --> 00:38:05,160
每个执行这个每个线程

735
00:38:02,031 --> 00:38:08,034
线程程序都有对它的访问，并与 

736
00:38:06,006 --> 00:38:11,022
在这种情况下它是像对待

737
00:38:08,061 --> 00:38:13,125
全球右所以如果一个线程更新 

738
00:38:11,076 --> 00:38:17,145
所有其他每个线程看到的价值

739
00:38:14,025 --> 00:38:22,068
相同的值 好了，所以我们可以使用 

740
00:38:18,045 --> 00:38:25,092
这个这个机制从 P个线程，但 

741
00:38:22,068 --> 00:38:28,110
所以我们可以 创建这个这个这个变量 

742
00:38:25,092 --> 00:38:30,177
P型螺纹的一次T和初始化 

743
00:38:29,001 --> 00:38:34,094
它 这个特殊的P个线程值 

744
00:38:31,077 --> 00:38:37,131
有点像在P线 

745
00:38:35,003 --> 00:38:39,084
未初始化的值，因此这是一个值 

746
00:38:38,031 --> 00:38:43,035
即P个线程知道有关 

747
00:38:39,084 --> 00:38:43,166
表明这个 变量要 

748
00:38:43,035 --> 00:38:49,127
没有做过

749
00:38:44,066 --> 00:38:52,735
初始化，然后，然后我们称之为 

750
00:38:50,027 --> 00:38:55,121
在并行线程一次函数在传递 

751
00:38:53,329 --> 00:38:58,329
这个这个变量， 我们的地址 

752
00:38:56,021 --> 00:39:00,850
这个变量来创建我们创建

753
00:38:58,329 --> 00:39:05,390
和函数的地址调用 

754
00:39:01,039 --> 00:39:09,670
初始化不管它是什么 ， 我们 要 

755
00:39:05,039 --> 00:39:09,067
初始化在这种情况下， 回声计数 

756
00:39:09,849 --> 00:39:16,948
该回声计数 变量还等什么 

757
00:39:15,109 --> 00:39:20,240
但这每一个线程将调用 P 

758
00:39:17,839 --> 00:39:25,220
线程一次，但只有一个线程会 

759
00:39:20,024 --> 00:39:29,093
实际调用初始化

760
00:39:25,022 --> 00:39:32,027
功能 中 ， 只有 第一个线程 

761
00:39:29,093 --> 00:39:34,139
执行话音读一次都会 将调用 

762
00:39:32,027 --> 00:39:37,091
它的其他线程这这名P线程 

763
00:39:35,039 --> 00:39:44,248
希望呼叫就会像无操作 是 

764
00:39:37,091 --> 00:39:51,240
问题嗯，这是其他选项， 

765
00:39:44,599 --> 00:39:55,130
所以这样做的好处是，你可以 

766
00:39:52,059 --> 00:39:56,107
你我猜的优点是II不 

767
00:39:55,013 --> 00:40:01,013
知道这只是另一种 方式，你可以 

768
00:39:56,539 --> 00:40:02,545
做到这一点，你我猜它避免它避免了 

769
00:40:01,013 --> 00:40:05,722
不得不这样做在主线程 

770
00:40:02,599 --> 00:40:07,190
你可以，你可以 让你的你可以 

771
00:40:05,839 --> 00:40:08,866
使这个包排序自足

772
00:40:07,019 --> 00:40:11,047
对的，你不是你不是真的 

773
00:40:09,109 --> 00:40:13,730
在主做任何计数

774
00:40:11,047 --> 00:40:14,686
但是， 是的这是这是另一种方式，我们 

775
00:40:13,073 --> 00:40:17,922
可以做，所以我只是想 

776
00:40:15,109 --> 00:40:23,210
告诉你这这这等技术 

777
00:40:18,579 --> 00:40:24,676
好了，所以一旦我们，一旦我们初始化一次 

778
00:40:23,021 --> 00:40:30,028
我们一旦某个线程调用一个ED回声 

779
00:40:25,549 --> 00:40:33,440
算上那么我们初始化REO包 

780
00:40:30,091 --> 00:40:35,770
我们 所有 的访问对这个 

781
00:40:33,044 --> 00:40:39,077
连接描述符，然后我们

782
00:40:36,589 --> 00:40:46,050
反复从所读的文本行

783
00:40:39,077 --> 00:40:47,166
客户端好 ，然后在 

784
00:40:46,005 --> 00:40:50,061
在受保护的方式，我们增加 咬 

785
00:40:48,066 --> 00:40:52,158
与字节数计算，我们 

786
00:40:50,061 --> 00:40:54,156
从客户端是接收的

787
00:40:53,058 --> 00:40:57,132
这个力的读线 b返回

788
00:40:55,056 --> 00:41:00,105
函数，然后我们打印了一点 

789
00:40:58,032 --> 00:41:03,119
消息只是为了某种跟踪 ，所以我们 

790
00:41:01,005 --> 00:41:07,014
可以看到保持我们的运行总的轨道

791
00:41:04,019 --> 00:41:08,070
然后我们释放这个互斥 

792
00:41:07,014 --> 00:41:11,076
字节计数全球字节数

793
00:41:08,007 --> 00:41:12,035
变量，然后我们回显回线

794
00:41:11,076 --> 00:41:16,097
到客户端 

795
00:41:12,098 --> 00:41:24,156
好了，所以有关的任何问题 

796
00:41:16,097 --> 00:41:30,099
是的，这个行清除它做 

797
00:41:25,056 --> 00:41:32,063
先连接好这个问题 是 

798
00:41:30,099 --> 00:41:35,124
在线声明静态变量 

799
00:41:33,026 --> 00:41:41,079
一旦将只执行 第一 

800
00:41:36,024 --> 00:41:44,058
时间一个线程执行 没有这种说法 

801
00:41:41,079 --> 00:41:45,150
它是如此的答案是否定的每家每户 

802
00:41:44,058 --> 00:41:50,076
线程将定义这个变量和

803
00:41:46,005 --> 00:41:54,030
它这个分配给这个本该p 

804
00:41:50,076 --> 00:41:57,120
线程要值 好东西只会 

805
00:41:54,075 --> 00:42:01,083
发生一次是调用的净回声 

806
00:41:58,002 --> 00:42:05,070
算好了，所以第一个线程

807
00:42:02,055 --> 00:42:08,148
执行所该p线程调用一次会 

808
00:42:05,088 --> 00:42:10,116
其实叫ED回声计数每 

809
00:42:09,048 --> 00:42:14,135
其他线程以后每线程 

810
00:42:11,016 --> 00:42:15,035
会不会把它我会像无操作 

811
00:42:17,066 --> 00:42:21,775
是的使用它只是 一个不透明的那些 

812
00:42:23,084 --> 00:42:32,091
该声明将不被设置 

813
00:42:28,002 --> 00:42:36,009
旗一切都是因为经常是啊

814
00:42:33,054 --> 00:42:38,055
不知它会，但不知该 peachoid 

815
00:42:36,072 --> 00:42:41,169
想要的是跟踪，这是它的 

816
00:42:38,064 --> 00:42:46,146
还好执行，所以我，我真的不知道 

817
00:42:42,069 --> 00:42:49,158
如何如何 好 它的实现 ，从而以某种方式 

818
00:42:47,046 --> 00:42:52,089
并行线程想是的，我猜你每次

819
00:42:50,058 --> 00:42:55,059
知道我的意思是 ，这仅仅是C ^ 

820
00:42:52,089 --> 00:42:57,177
报关权，所以没有在P 

821
00:42:55,059 --> 00:43:03,090
线程拥有的声明没有控制

822
00:42:58,077 --> 00:43:05,124
权利，使每个线程会得到它的每一个 

823
00:43:03,009 --> 00:43:08,094
线程将排序更新此静 

824
00:43:06,024 --> 00:43:15,120
可变的，你是对的，如果第一 

825
00:43:09,075 --> 00:43:18,174
线程第二个线程会 会 

826
00:43:16,002 --> 00:43:23,013
再次，但不知何故覆盖该值

827
00:43:19,074 --> 00:43:25,101
皮特的读取一次可以 保持跟踪 

828
00:43:23,031 --> 00:43:28,092
还好在以某种方式 说我我不 

829
00:43:26,001 --> 00:43:32,084
肯定是如何工作的，但是这 是 

830
00:43:28,092 --> 00:43:31,184
这就是你得到的是行为方式 

831
00:43:36,018 --> 00:43:40,089
在别人有一些其他的问题 

832
00:43:38,049 --> 00:43:42,338
各地同步排序的线程 

833
00:43:40,089 --> 00:43:45,177
我们必须正确性问题

834
00:43:42,779 --> 00:43:47,831
知道的，所以我希望你，我希望你 

835
00:43:46,077 --> 00:43:49,586
排序得到这个 意义上 ， 

836
00:43:48,299 --> 00:43:52,304
线程编程是怎么样的 

837
00:43:50,279 --> 00:43:54,660
棘手的业务权等的一个问题

838
00:43:52,799 --> 00:43:58,710
我们 始终必须 了解的是被 

839
00:43:54,066 --> 00:44:02,151
被称为这个想法线程安全所以在 

840
00:43:58,071 --> 00:44:04,146
一般一个线程程序 只能应 

841
00:44:03,051 --> 00:44:06,830
只有通话功能是是

842
00:44:05,046 --> 00:44:10,047
具有此特性线程安全

843
00:44:07,289 --> 00:44:13,345
所谓的线程安全 好和功能 

844
00:44:10,047 --> 00:44:16,119
是线程安全的它是且仅当 

845
00:44:13,849 --> 00:44:20,970
功能可以 由 多个 被 调用 

846
00:44:17,019 --> 00:44:25,448
与此同时线程好了，所以如果我们 

847
00:44:20,097 --> 00:44:26,163
有一个函数f 它的线程安全的，如果和 

848
00:44:25,619 --> 00:44:32,626
只有当它的执行可以交叉 

849
00:44:27,063 --> 00:44:32,752
多线程好吗 

850
00:44:33,068 --> 00:44:39,110
所以我们可以找出四个不同 

851
00:44:36,081 --> 00:44:42,147
线程不安全的功能 ，使类

852
00:44:40,001 --> 00:44:47,006
一类是失败的功能

853
00:44:43,047 --> 00:44:49,050
保护与互斥的共享变量

854
00:44:47,015 --> 00:44:51,021
好了，我们已经看到，随着坏 

855
00:44:49,005 --> 00:44:53,091
算上这是一个 威胁 的例子 

856
00:44:51,075 --> 00:44:58,077
不安全该主程序是一个例子 

857
00:44:54,036 --> 00:44:59,133
现在不安全线程函数 

858
00:44:58,077 --> 00:45:02,082
线程函数是的一个例子

859
00:45:00,033 --> 00:45:04,128
不安全的线程功能，因为它没有 

860
00:45:02,082 --> 00:45:08,145
保护 的 更新行为 

861
00:45:05,028 --> 00:45:11,034
算上可变另一类 

862
00:45:09,045 --> 00:45:13,077
函数， 我们的 主题是不安全 

863
00:45:11,088 --> 00:45:16,179
是那些 保持跟踪功能

864
00:45:13,077 --> 00:45:19,164
在多个国家 的指示，所以如果 

865
00:45:17,079 --> 00:45:22,140
他们存储状态的一些全局 

866
00:45:20,064 --> 00:45:25,067
全局变量的私人或公共全球

867
00:45:23,004 --> 00:45:28,067
这就是线程不安全的变量的净

868
00:45:25,094 --> 00:45:33,096
因为多个线程会 

869
00:45:29,003 --> 00:45:36,009
访问该 状态的 其他方式的另一 

870
00:45:34,014 --> 00:45:37,068
一种线程不安全的功能或 

871
00:45:36,009 --> 00:45:40,068
返回一个指向功能

872
00:45:37,068 --> 00:45:41,103
静态变量所以有有

873
00:45:40,068 --> 00:45:43,131
有一个在多项功能 

874
00:45:42,003 --> 00:45:46,011
写的是标准C库

875
00:45:44,031 --> 00:45:51,123
线程之前甚至对任何人的 

876
00:45:46,083 --> 00:45:54,086
雷达等这样的例子是 C时间 

877
00:45:52,023 --> 00:45:58,086
函数，它接受作为自变量的 

878
00:45:55,013 --> 00:46:01,071
时间击中两个二元结构的时间和 

879
00:45:58,086 --> 00:46:04,095
返回一个字符串指针的日期和 

880
00:46:01,071 --> 00:46:07,092
时间字符串，但在 该地址 

881
00:46:05,076 --> 00:46:09,141
指针总是相同的权利，因此 

882
00:46:07,092 --> 00:46:12,129
此功能是定义某种 

883
00:46:10,041 --> 00:46:15,116
静态变量，它总是返回 

884
00:46:13,029 --> 00:46:19,101
然后就是它它的转换 

885
00:46:16,016 --> 00:46:21,081
二元结构的时间进入到一个字符串

886
00:46:20,001 --> 00:46:23,064
这总是在相同的位置和 

887
00:46:21,081 --> 00:46:25,125
它返回的该地址 

888
00:46:23,064 --> 00:46:28,089
字符串，每次调用返回 

889
00:46:26,025 --> 00:46:32,100
确切地址相同，但不同的 

890
00:46:28,089 --> 00:46:33,183
在该地址 的内容 很好，而且这 

891
00:46:33,000 --> 00:46:36,087
你知道他们 只是 他们没有意识到 

892
00:46:34,083 --> 00:46:37,137
这是 一个坏事 做 

893
00:46:36,087 --> 00:46:39,184
线程程序，因为没有人

894
00:46:38,037 --> 00:46:43,055
在一次写线程程序

895
00:46:40,084 --> 00:46:44,162
然后显然任何功能 

896
00:46:43,055 --> 00:46:47,153
电话和卸不安全功能 

897
00:46:45,062 --> 00:46:50,063
威胁不安全好了，让我们来看看 

898
00:46:48,053 --> 00:46:52,127
这些这些不同 类别的 

899
00:46:50,063 --> 00:46:55,064
功能 好了，所以 一个 类 

900
00:46:53,027 --> 00:46:58,028
功能无法保护共享

901
00:46:55,064 --> 00:47:00,086
变量等修复，因为我们已经看到

902
00:46:58,028 --> 00:47:03,032
是使用T和V，以保证相互 

903
00:47:00,086 --> 00:47:04,151
独占访问，从而保护了 

904
00:47:03,032 --> 00:47:08,057
访问变量，所以我们看到这个 

905
00:47:05,051 --> 00:47:09,134
与良好的计数程序 ，然后 

906
00:47:08,057 --> 00:47:10,136
的问题，也 正如我们所看到 

907
00:47:10,034 --> 00:47:13,088
具有良好的计数是，

908
00:47:11,036 --> 00:47:16,061
同步操作可以是慢 

909
00:47:13,088 --> 00:47:19,135
所以，如果他们在 紧张的内环它 

910
00:47:16,061 --> 00:47:19,135
可它确实能降低运行速度 

911
00:47:20,038 --> 00:47:25,043
还好在安全类2线 

912
00:47:23,051 --> 00:47:28,067
功能依赖于某种

913
00:47:25,088 --> 00:47:30,170
跨越调用持久化状态 

914
00:47:28,067 --> 00:47:36,086
该函数确定 ，所以经典的例子 

915
00:47:31,007 --> 00:47:39,104
是Lipsy兰特函数，其与 

916
00:47:36,086 --> 00:47:45,098
这一点和实施该计划是 

917
00:47:40,067 --> 00:47:49,108
我从K个参加了我们的书所以这 

918
00:47:45,098 --> 00:47:52,151
该R，这是一个伪 

919
00:47:50,008 --> 00:47:56,084
伪随机数生成器的伪 

920
00:47:53,051 --> 00:47:58,058
随机在这个意义上，如果 你给它 

921
00:47:56,084 --> 00:48:01,163
相同的密钥将返回 相同的 

922
00:47:58,058 --> 00:48:04,064
值的 顺序 确定，所以这 是一种 

923
00:48:02,063 --> 00:48:06,149
不错，因为 它允许当你 

924
00:48:04,064 --> 00:48:08,093
测试它允许重复性 所以每 

925
00:48:07,049 --> 00:48:10,100
一次调用它，如果你用它打电话 

926
00:48:08,093 --> 00:48:12,158
你可以你保证相同的种子 

927
00:48:11,000 --> 00:48:18,065
你会得到相同的结果和方式 

928
00:48:13,058 --> 00:48:23,060
这 实现 的是，有在这 

929
00:48:18,065 --> 00:48:25,112
如果有有种子的种子 

930
00:48:23,006 --> 00:48:27,008
可变称为下这是在使用 

931
00:48:26,012 --> 00:48:30,014
随机数的每次迭代

932
00:48:27,008 --> 00:48:33,101
发电机和它的它定义为一个 

933
00:48:30,014 --> 00:48:36,055
全球私人因此静态使它 

934
00:48:34,073 --> 00:48:39,086
私人所以它不是访问 

935
00:48:36,055 --> 00:48:41,111
被调用程序兰特 

936
00:48:39,086 --> 00:48:43,094
功能，但它的它的使用兰德

937
00:48:42,011 --> 00:48:48,083
功能，因此该变量 是 

938
00:48:44,066 --> 00:48:50,069
初始化为1有一个功能

939
00:48:48,083 --> 00:48:52,159
称为S兰德，其允许用户 给 

940
00:48:50,096 --> 00:48:55,153
设置种子值， 使得 

941
00:48:53,059 --> 00:48:58,078
默认速度值是 一个 ，但如果 

942
00:48:56,053 --> 00:49:00,100
用户来电小号 跑，他们可以在一传 

943
00:48:58,078 --> 00:49:03,157
种子，将其然后将

944
00:49:01,000 --> 00:49:09,075
这是刚刚分配到这个这下 

945
00:49:04,057 --> 00:49:12,151
变量，然后每个 兰德 的 迭代 

946
00:49:09,075 --> 00:49:15,127
确实在种子上，以便它的操作 

947
00:49:13,051 --> 00:49:17,143
采用，未来值 是怎么回事 

948
00:49:16,027 --> 00:49:20,029
所使用的是是 的 一个属性 

949
00:49:18,043 --> 00:49:22,138
前值 的 功能 

950
00:49:20,029 --> 00:49:25,048
以前的 值，然后返回一个 

951
00:49:23,038 --> 00:49:28,114
伪随机数，这是一个功能

952
00:49:25,048 --> 00:49:30,055
没关系，明年价值的，所以它依赖 

953
00:49:29,014 --> 00:49:34,087
在每次这样每次迭代 

954
00:49:31,018 --> 00:49:37,021
叫兰德你依靠这 

955
00:49:34,087 --> 00:49:39,126
下，是由所计算的值 

956
00:49:37,021 --> 00:49:42,076
以前的时候，你叫三 

957
00:49:40,026 --> 00:49:44,074
现在没事了，这 是完全正常的 ，并 

958
00:49:42,076 --> 00:49:48,091
有没有问题 ，这在 

959
00:49:44,074 --> 00:49:51,088
非螺纹的情况，但会发生什么

960
00:49:48,091 --> 00:49:55,174
它的多线程现在这样想你 

961
00:49:51,088 --> 00:49:58,093
有多个线程，和他们 

962
00:49:56,074 --> 00:50:01,171
每个调用这个函数兰特的排序 

963
00:49:58,093 --> 00:50:05,110
交错调用两个兰德还好是 

964
00:50:02,071 --> 00:50:10,114
这样的事实： 兰德公司依托 

965
00:50:06,001 --> 00:50:12,076
这个以前的状态，如果多个线程 

966
00:50:11,014 --> 00:50:15,015
呼吁兰德这将打破 

967
00:50:12,085 --> 00:50:17,140
伪随机属性，因此每个线程 

968
00:50:15,024 --> 00:50:20,047
该随机数，每 

969
00:50:18,004 --> 00:50:23,065
螺纹回来不仅是一个功能 

970
00:50:20,047 --> 00:50:25,048
从先前的种子的 

971
00:50:24,001 --> 00:50:29,059
以前的时候，线程调用 

972
00:50:25,048 --> 00:50:30,136
功能也同样的功能 

973
00:50:29,059 --> 00:50:35,116
其他线程呼吁 是 正确的 

974
00:50:31,036 --> 00:50:37,102
所以所以，如果一个特定的线程 调用此 

975
00:50:36,016 --> 00:50:40,021
随机数发生器多次 

976
00:50:38,002 --> 00:50:42,034
它可能不会看到相同的 

977
00:50:40,066 --> 00:50:43,144
伪随机数序列 

978
00:50:42,034 --> 00:50:47,091
因为其他线程将被跳跃 

979
00:50:44,044 --> 00:50:52,108
还好 和 

980
00:50:47,091 --> 00:50:54,136
好了，如果不是它不是不正确

981
00:50:53,008 --> 00:50:56,014
并且，该 程序将失败，但如果 

982
00:50:55,036 --> 00:50:59,098
程序上的计数 

983
00:50:56,068 --> 00:51:04,147
伪随机 属性 ，则它会创建一个 

984
00:50:59,098 --> 00:51:09,189
问题好吗 所以 ，要解决这个 

985
00:51:05,047 --> 00:51:13,102
被改写 兰德并要求它 

986
00:51:10,089 --> 00:51:16,123
需要调用者跟踪这个 

987
00:51:14,002 --> 00:51:19,093
下一个变量好了，所以每个来电者将 

988
00:51:17,023 --> 00:51:22,030
保持自己的本地副本， 下一个 和 它 

989
00:51:19,093 --> 00:51:23,170
将指针 传递 给 R和R与 

990
00:51:22,093 --> 00:51:26,095
我们将计算该值，因此现在这个 

991
00:51:24,007 --> 00:51:28,090
在调用 将更新 状态 

992
00:51:27,013 --> 00:51:32,044
调用 线程，但这是局部的 

993
00:51:29,053 --> 00:51:33,109
状态的线程堆栈好吗 

994
00:51:32,044 --> 00:51:41,044
所以每个线程都有自己的副本 

995
00:51:34,009 --> 00:51:42,103
明年，所以 我们，但我们必须创建一个 

996
00:51:41,044 --> 00:51:45,091
新的功能，我们叫它 

997
00:51:43,003 --> 00:51:47,068
下划线的R代表折返 

998
00:51:45,091 --> 00:51:50,140
这是一个属性，我们将看看 

999
00:51:47,068 --> 00:51:52,072
只是第二，但它的更多的工作 

1000
00:51:51,004 --> 00:51:55,072
程序员因为现在的程序员 

1001
00:51:52,072 --> 00:51:59,073
必须 保持这种这种这种 

1002
00:51:56,008 --> 00:51:59,073
下一个值好吗 

1003
00:52:00,085 --> 00:52:07,117
还好另一种方式线程 

1004
00:52:03,067 --> 00:52:08,164
功能是不安全的就是这个，这是有 

1005
00:52:08,017 --> 00:52:12,109
这些功能 总是保留 

1006
00:52:09,064 --> 00:52:15,088
返回一个指向一些全球性的 

1007
00:52:13,009 --> 00:52:18,028
同一个全局变量或通常这是一个 

1008
00:52:15,088 --> 00:52:20,152
静态变量，但他们总是返回 

1009
00:52:18,028 --> 00:52:25,054
每次相同 的值相同 

1010
00:52:21,052 --> 00:52:26,113
解决好了，所以你可以看到这是 

1011
00:52:25,054 --> 00:52:28,132
类似于我们遇到的那场比赛 

1012
00:52:27,013 --> 00:52:30,094
这里我们 传递的 地址之前

1013
00:52:29,032 --> 00:52:34,120
连接的文件描述符到的

1014
00:52:30,094 --> 00:52:36,172
工作线程好了，所以现在我们正在 创建 

1015
00:52:35,002 --> 00:52:39,061
一场比赛让我们说一个线程假设

1016
00:52:37,072 --> 00:52:43,138
一个线程调用这个 函数 所以 对于 

1017
00:52:39,079 --> 00:52:46,087
实施例 C时间借此这个时间 

1018
00:52:44,038 --> 00:52:48,130
结构作为 行 参数 其可以 

1019
00:52:47,059 --> 00:52:49,153
对应于它可以任意时间

1020
00:52:49,003 --> 00:52:51,091
是当前时间或只是 一些 

1021
00:52:50,053 --> 00:52:56,131
任意时间， 来电者 

1022
00:52:52,018 --> 00:52:58,105
构造和它返回一个指向 

1023
00:52:57,031 --> 00:53:01,060
一个当家球星所以 它只是 返回 

1024
00:52:59,005 --> 00:53:04,030
指针表示该字符串 

1025
00:53:01,006 --> 00:53:07,105
日期和时间的自己的ASCII ASCII 

1026
00:53:04,003 --> 00:53:13,060
字符串， 表示日期和 

1027
00:53:08,059 --> 00:53:17,110
时间，但它总是 它总是 

1028
00:53:13,087 --> 00:53:21,094
返回指针到相同的同一 

1029
00:53:18,001 --> 00:53:25,018
在存储位置好，所以你可以看到

1030
00:53:22,057 --> 00:53:28,123
如果一个线程调用 C时间 问题 

1031
00:53:25,027 --> 00:53:33,028
功能与一个有一个时间来袭 

1032
00:53:29,023 --> 00:53:34,111
它回来的指针到

1033
00:53:33,037 --> 00:53:37,132
对应于 字符串 

1034
00:53:35,011 --> 00:53:41,053
时间结构，但现在我们之前说

1035
00:53:38,032 --> 00:53:44,071
核四线程一个可以使用阅读 

1036
00:53:41,053 --> 00:53:47,059
该字符串另一个线程调用 C时间 

1037
00:53:44,071 --> 00:53:51,100
和C时间该实例会 

1038
00:53:48,013 --> 00:53:54,058
覆盖该时间的复制

1039
00:53:52,000 --> 00:53:57,046
字符串对于该线程是 

1040
00:53:54,058 --> 00:53:59,065
计算所以，当线程最终得到一个

1041
00:53:57,046 --> 00:54:02,140
机会访问时间字符串的 

1042
00:54:00,028 --> 00:54:05,107
访问线程B的时间字符串，而不是 

1043
00:54:03,004 --> 00:54:07,693
三天的时间串 

1044
00:54:05,359 --> 00:54:09,433
还好，它只是取决于如果线程一罐 

1045
00:54:08,089 --> 00:54:12,160
到达那个和读取变量 

1046
00:54:10,099 --> 00:54:16,141
前线程B在写它，然后 

1047
00:54:12,799 --> 00:54:18,841
一切都 很好，否则线程是一个 

1048
00:54:16,519 --> 00:54:21,547
访问了错误的时间串 好了， 

1049
00:54:19,219 --> 00:54:24,680
还有的有一对夫妇的方式来解决 

1050
00:54:21,799 --> 00:54:27,920
这就像我们可以重写 的 

1051
00:54:24,068 --> 00:54:32,727
函数C时间函数采取如 

1052
00:54:27,092 --> 00:54:32,511
添加一个通过了另一种说法 

1053
00:54:33,007 --> 00:54:38,146
位置的时间地址 

1054
00:54:36,859 --> 00:54:40,924
串，所以我们可以要求该 

1055
00:54:38,839 --> 00:54:42,931
主叫方的时间分配空间 

1056
00:54:41,509 --> 00:54:46,588
串并传递地址到C 

1057
00:54:43,759 --> 00:54:49,807
时间功能不错，但这个有这 

1058
00:54:47,299 --> 00:54:55,190
说， 这需要我们改变一切 

1059
00:54:50,239 --> 00:54:56,287
在这里我们调用C时的情况，但 

1060
00:54:55,019 --> 00:54:58,091
我们也不得不改变 

1061
00:54:56,719 --> 00:55:02,776
实施 C时间在直播中 

1062
00:54:58,091 --> 00:55:06,280
在Lipsy 库中的权利，所以我们 

1063
00:55:03,289 --> 00:55:09,292
我们不能没有 访问库ç 

1064
00:55:07,099 --> 00:55:11,137
来源我们的系统上的权利 ， 使 

1065
00:55:09,319 --> 00:55:12,394
这只是不是一个可行的 事情 ，再加上它 

1066
00:55:11,479 --> 00:55:15,680
将打破所有其他程序 

1067
00:55:13,069 --> 00:55:17,170
所谓的C正确的时间，所以我们只是不能做 

1068
00:55:15,068 --> 00:55:20,347
那

1069
00:55:17,017 --> 00:55:23,114
另一个更好的选择的是 

1070
00:55:20,959 --> 00:55:27,046
创建我们自己的新功能好吗 

1071
00:55:24,014 --> 00:55:29,090
所谓的C时强调TTS线程 

1072
00:55:27,829 --> 00:55:34,834
安全，所以我们将创建我们 自己 的 那种 

1073
00:55:29,009 --> 00:55:36,118
为C时包装函数和 

1074
00:55:35,329 --> 00:55:41,397
我们将使用一种叫做锁 

1075
00:55:37,009 --> 00:55:46,012
复制到提供线程安全的访问 

1076
00:55:42,009 --> 00:55:47,690
2C时间，所以 它 的 工作方式 是它会 

1077
00:55:46,039 --> 00:55:51,890
写这个新的函数C时间 

1078
00:55:47,069 --> 00:55:54,116
下划线TS 刚刚如c时间 

1079
00:55:51,089 --> 00:55:57,118
这需要一个指向这次结构 

1080
00:55:55,016 --> 00:56:01,915
但随后增加了第二个参数 

1081
00:55:58,018 --> 00:56:04,557
这是一个指向的威胁 

1082
00:56:02,059 --> 00:56:08,630
线程的时间字符串的私有副本

1083
00:56:04,719 --> 00:56:12,650
好了 ，所以调用者分配的空间 

1084
00:56:08,063 --> 00:56:15,702
并传递指向此该 

1085
00:56:12,065 --> 00:56:18,071
该字符串 

1086
00:56:16,269 --> 00:56:21,328
然后SI的时间内，我们有一个地方 

1087
00:56:19,025 --> 00:56:23,117
可变称为共享 的共享 

1088
00:56:21,859 --> 00:56:26,960
指针好了，这是怎么回事点 

1089
00:56:24,017 --> 00:56:29,376
到这是全球共享数据 

1090
00:56:26,096 --> 00:56:32,425
结构C时间是正在访问 

1091
00:56:29,529 --> 00:56:35,420
所以首先我们要做的锁 

1092
00:56:33,289 --> 00:56:39,346
这是由锁和复制的锁定部分 

1093
00:56:35,042 --> 00:56:43,441
获取互斥 ，然后我们调用C 

1094
00:56:39,859 --> 00:56:43,951
时间在时间 ，所以只有一个线程，我们将 

1095
00:56:43,819 --> 00:56:46,760
有这种互斥 

1096
00:56:44,779 --> 00:56:48,808
因此无论线程，这样一次一次我们

1097
00:56:46,076 --> 00:56:51,092
从T回流，我们知道我们 的 

1098
00:56:49,069 --> 00:56:55,147
只有在这个线程在这个关键 

1099
00:56:51,092 --> 00:56:58,124
部分 因此，我们调用C时正常 点亮 

1100
00:56:55,849 --> 00:57:02,926
它返回一个指针CC时间函数 

1101
00:56:59,024 --> 00:57:05,893
这个相同的位置，然后我们 

1102
00:57:03,619 --> 00:57:10,642
做文案的一部分，我们复制的是 

1103
00:57:06,109 --> 00:57:15,470
字符串私人字符串是 

1104
00:57:10,849 --> 00:57:17,210
在刚刚进入我们的函数传递一次 

1105
00:57:15,047 --> 00:57:18,143
我们已经做了拷贝，然后我们就可以释放 

1106
00:57:17,021 --> 00:57:25,570
新的文本，然后我们返回 

1107
00:57:19,043 --> 00:57:30,118
指针我们回到私人P 回 

1108
00:57:25,759 --> 00:57:33,500
来电者好了，所以，我们不我们不 

1109
00:57:31,018 --> 00:57:33,877
这仅仅是一个更方便的来 

1110
00:57:33,005 --> 00:57:36,020
呼叫者 

1111
00:57:34,039 --> 00:57:38,450
因为使用的是C时段节目

1112
00:57:36,065 --> 00:57:41,674
期待得到该指针回 

1113
00:57:38,045 --> 00:57:43,097
好了，通过使用锁和复制，我们有 

1114
00:57:42,259 --> 00:57:45,295
到我们必须做出 我们必须改变 

1115
00:57:43,097 --> 00:57:49,100
写这个新的功能，但它是相当 

1116
00:57:45,619 --> 00:57:51,661
简单， 那么我们就必须做出改变 

1117
00:57:50,000 --> 00:57:54,289
在我们的程序中的每个地方， 我们称之为 

1118
00:57:52,039 --> 00:57:57,061
C时间，我们必须更新这 两个电话 

1119
00:57:54,289 --> 00:58:03,410
看一次强调TS和创造 

1120
00:57:57,259 --> 00:58:05,950
这个创建这个本地字符串数组好吗 

1121
00:58:03,041 --> 00:58:05,095
是

1122
00:58:07,095 --> 00:58:12,254
为什么，为什么，为什么时间像变量出来 

1123
00:58:10,749 --> 00:58:12,785
意识

1124
00:58:13,031 --> 00:58:15,088
对

1125
00:58:20,001 --> 00:58:23,008
井通常这些功能是

1126
00:58:22,024 --> 00:58:26,080
返回指向一些数据 

1127
00:58:23,071 --> 00:58:27,163
结构等 他们有 几分 

1128
00:58:26,008 --> 00:58:31,066
更新数据结构， 然后 

1129
00:58:28,063 --> 00:58:34,066
返回一个指向它，所以它不会 

1130
00:58:32,038 --> 00:58:37,056
让我不知道我是怎么想这可能 

1131
00:58:34,093 --> 00:58:44,125
返回其 结构，并会始终返回 

1132
00:58:37,056 --> 00:58:46,057
现在我现在想不出任何我不能 

1133
00:58:45,025 --> 00:58:48,028
想不出什么原因，他们会 

1134
00:58:46,057 --> 00:58:50,064
返回任何东西 ，但因为指针 

1135
00:58:48,055 --> 00:58:53,059
他们他们 通常更新一些 

1136
00:58:50,064 --> 00:58:55,158
一些数据结构，然后返回 

1137
00:58:53,095 --> 00:58:55,158
指针指向它 

1138
00:59:01,041 --> 00:59:09,108
如果他们回来，如果他们

1139
00:59:06,036 --> 00:59:13,068
返回标量的标量会 

1140
00:59:10,008 --> 00:59:15,009
总是在EAX 或 RA X全部返还

1141
00:59:13,068 --> 00:59:16,155
右所以 实际上 这将是 所有好 

1142
00:59:15,018 --> 00:59:20,022
正确的那只是它的指针 

1143
00:59:17,055 --> 00:59:22,092
引起 该 问题，因为它是 

1144
00:59:20,058 --> 00:59:24,072
总是返回在 EI X 中的价值 ，但 

1145
00:59:22,092 --> 00:59:26,136
它总是在返回的值相同 

1146
00:59:24,072 --> 00:59:31,130
EAX总是指向 相同的同 

1147
00:59:27,036 --> 00:59:31,130
数据结构一般好 

1148
00:59:33,069 --> 00:59:39,138
现在没事了一个配音一个潜在的 

1149
00:59:38,004 --> 00:59:44,393
锁显著的缺点和 

1150
00:59:40,038 --> 00:59:47,067
副本是这个这个副本可能不 

1151
00:59:44,789 --> 00:59:51,815
始终为 只是做像 那样简单 

1152
00:59:47,067 --> 00:59:52,976
搅拌副本，如果，如果它是一个复杂的 ，如果DIF 

1153
00:59:52,049 --> 00:59:55,530
你正在调用该函数 

1154
00:59:53,579 --> 00:59:57,626
计算一些复杂的数据结构

1155
00:59:55,053 --> 00:59:59,060
像一个嵌套你知道一个结构，其 

1156
00:59:58,049 --> 01:00:03,240
包含结构和指向数组的指针

1157
01:00:00,023 --> 01:00:05,028
那么这个副本可以得到可以得到相当

1158
01:00:03,024 --> 01:00:08,903
它需要什么复杂的权 

1159
01:00:05,073 --> 01:00:10,922
我们所说的深拷贝，这样可以 是 

1160
01:00:09,119 --> 01:00:13,260
可能是非常困难 的，但在这 

1161
01:00:11,579 --> 01:00:15,150
情况下，它很简单，我们只是我们只是 

1162
01:00:13,026 --> 01:00:18,095
做我们只是复制一个字符串 

1163
01:00:15,015 --> 01:00:21,404
另一个好，然后 最后的 

1164
01:00:18,095 --> 01:00:23,178
第四 类的螺纹不安全的函数 

1165
01:00:21,539 --> 01:00:27,150
是 不安全的 调用 函数的函数

1166
01:00:24,078 --> 01:00:29,357
右所以它是一种明显的，然后 

1167
01:00:27,015 --> 01:00:31,047
显而易见的解决方法是不调用线程 

1168
01:00:30,059 --> 01:00:33,113
从内部不安全的功能

1169
01:00:31,047 --> 01:00:38,866
功能，然后你可以把它 线程 

1170
01:00:33,599 --> 01:00:41,640
安全现在有一个 非常有趣的 

1171
01:00:39,289 --> 01:00:45,320
线程安全的重要子类

1172
01:00:41,064 --> 01:00:48,763
函数调用重新输入功能，使 

1173
01:00:45,599 --> 01:00:52,890
一个可重入函数可重入，如果 

1174
01:00:49,339 --> 01:00:56,450
它不包含访问共享 

1175
01:00:52,089 --> 01:00:58,100
共享变量好了，所以如果要是所有 

1176
01:00:56,045 --> 01:01:02,384
每次它访问变量是 

1177
01:00:59,000 --> 01:01:06,015
包含在被声明为本地 

1178
01:01:02,789 --> 01:01:08,220
可变的 ，并且存储在栈上 

1179
01:01:06,015 --> 01:01:10,020
该功能还行这就是所谓的一 

1180
01:01:08,022 --> 01:01:12,063
折返功能，因为有 

1181
01:01:10,065 --> 01:01:15,014
没有访问任何类型的共享 

1182
01:01:12,063 --> 01:01:16,982
变量有没有没有 

1183
01:01:15,599 --> 01:01:19,643
由于需要在每次同步

1184
01:01:17,549 --> 01:01:23,597
功能运行时访问自己的

1185
01:01:20,039 --> 01:01:28,043
所有的变量和它的本地副本

1186
01:01:24,029 --> 01:01:31,170
多线程执行两个实例 

1187
01:01:28,079 --> 01:01:33,720
一个可重入函数 的 也没关系各 

1188
01:01:31,017 --> 01:01:35,094
线程都有自己独立的堆栈，所以你 

1189
01:01:33,072 --> 01:01:37,073
不必担心任何种类的 

1190
01:01:35,094 --> 01:01:39,102
他们可以运行同步

1191
01:01:37,073 --> 01:01:41,100
所以独立的原因 ，我们进入 

1192
01:01:40,074 --> 01:01:43,162
功能是如此重要，是因为

1193
01:01:42,000 --> 01:01:48,016
它的价格昂贵做

1194
01:01:44,062 --> 01:01:49,084
同步还等什么，你 可以 

1195
01:01:48,016 --> 01:01:51,058
与这些反应完全避免它

1196
01:01:49,084 --> 01:01:57,118
功能折返 功能， 使 

1197
01:01:51,058 --> 01:01:59,137
他们是如此高效的是，作为

1198
01:01:58,018 --> 01:02:02,116
图显示每一重入函数 

1199
01:02:00,037 --> 01:02:07,078
是线程安全的，但不是每一个线程安全

1200
01:02:03,016 --> 01:02:09,109
功能折返，所以我们看到，

1201
01:02:07,078 --> 01:02:12,097
权利之前 ，当我们有一个函数 

1202
01:02:10,009 --> 01:02:14,065
访问共享变量，我们 可以 

1203
01:02:12,097 --> 01:02:17,104
使其通过保护线程安全

1204
01:02:14,065 --> 01:02:19,120
用互斥锁还可以，但它不是 真正的 

1205
01:02:18,067 --> 01:02:27,154
趋势，因为它实际上是 

1206
01:02:20,002 --> 01:02:30,076
访问共享变量的 还好现在开始 

1207
01:02:28,054 --> 01:02:32,071
在标准C的所有功能

1208
01:02:30,094 --> 01:02:34,159
这是在后面列举库

1209
01:02:32,071 --> 01:02:37,162
你的K 和 R 质感线程安全的好 

1210
01:02:35,059 --> 01:02:40,117
但不一定重返进入

1211
01:02:38,062 --> 01:02:42,118
最最最这就要求我们的线程安全 

1212
01:02:41,017 --> 01:02:45,025
只需有几个例外 

1213
01:02:43,018 --> 01:02:47,089
我在这里列出我不，我不认为我 

1214
01:02:45,097 --> 01:02:49,123
不要以为这是完整的，但这些 

1215
01:02:47,089 --> 01:02:52,162
只是一些显着的人的例子

1216
01:02:50,023 --> 01:02:58,036
所以每一个每一个 线程 

1217
01:02:53,062 --> 01:03:01,063
不安全的函数Linux提供了一个 

1218
01:02:58,036 --> 01:03:03,133
这是由表示重入版本

1219
01:03:01,063 --> 01:03:05,128
下划线R和然后该折返

1220
01:03:04,033 --> 01:03:10,105
版本有不同的组不同的 

1221
01:03:06,028 --> 01:03:12,037
参数通常是 唯一 的 例外 

1222
01:03:11,005 --> 01:03:16,086
我知道是我净n到这 

1223
01:03:13,018 --> 01:03:20,110
是一个 过时的 网络 的一个插曲 

1224
01:03:16,086 --> 01:03:22,183
协议转换排序二进制的

1225
01:03:21,001 --> 01:03:27,067
网络地址 ，以人类可读 

1226
01:03:23,083 --> 01:03:29,089
ASCII地址，但是这是，这是 

1227
01:03:27,076 --> 01:03:31,168
往往不是由其他 的电话，以 通过删除 

1228
01:03:30,043 --> 01:03:34,099
这是我想他们只是从来就不曾 

1229
01:03:32,068 --> 01:03:35,155
不屑于创建一个重入版本 

1230
01:03:34,099 --> 01:03:39,171
它因为有有其他 

1231
01:03:36,055 --> 01:03:40,071
选项替代使用 

1232
01:03:40,819 --> 01:03:46,170
还好另一个让 我们不得不 另一 件事 

1233
01:03:43,023 --> 01:03:48,066
担心的是，我们已经看到又是种族

1234
01:03:46,017 --> 01:03:51,896
这是在螺纹真正布盖布

1235
01:03:48,066 --> 01:03:54,072
程序，它通常涉及到一些 

1236
01:03:52,049 --> 01:04:00,050
一种意想不到的共享，以便在这 

1237
01:03:54,072 --> 01:04:02,169
情况下，我们重温这这这 

1238
01:04:00,059 --> 01:04:05,970
不正确线程程序，在那里我们 

1239
01:04:03,069 --> 01:04:09,123
引入 通过使 引入的阵列 

1240
01:04:05,097 --> 01:04:10,946
当我们创建线程，我们我们通过

1241
01:04:10,023 --> 01:04:16,382
参数线程这就 好比 

1242
01:04:11,819 --> 01:04:17,894
本地线程ID 我们传递的一个地址 

1243
01:04:16,589 --> 01:04:21,630
我们已经存储在变量

1244
01:04:18,569 --> 01:04:30,210
栈和它 得到 我的 

1245
01:04:21,063 --> 01:04:35,252
将循环迭代，所以我们已经看到， 

1246
01:04:30,021 --> 01:04:38,630
这会导致这会导致数组 ， 所以 我们在 

1247
01:04:35,819 --> 01:04:39,893
很快我们最初设置 为0，那么我们 

1248
01:04:38,819 --> 01:04:46,200
创建一个新的线程是纯线 

1249
01:04:40,559 --> 01:04:47,656
0，则该线程取消引用 

1250
01:04:46,002 --> 01:04:53,141
指针以获得其本地的副本 

1251
01:04:48,529 --> 01:04:57,150
这种局部线程ID，但现在的 

1252
01:04:53,339 --> 01:05:01,361
我们已经推出了之间的竞争

1253
01:04:57,015 --> 01:05:03,974
我和增量的间接引用

1254
01:05:01,559 --> 01:05:07,170
我和 主递增

1255
01:05:04,109 --> 01:05:10,410
螺纹和我在反引用

1256
01:05:07,017 --> 01:05:12,069
对线程因此，如果这个反引用 

1257
01:05:10,041 --> 01:05:15,075
发生了，我比以前增加

1258
01:05:12,069 --> 01:05:18,072
我们是很好的，但如果这个提领 

1259
01:05:15,075 --> 01:05:21,150
碰巧我们在其他增加我打完 

1260
01:05:18,099 --> 01:05:24,116
也就是说，当我等于1，则我们得到 

1261
01:05:22,005 --> 01:05:28,024
在同行线程错误的值

1262
01:05:25,016 --> 01:05:28,375
我的ID

1263
01:05:29,003 --> 01:05:33,072
所以你可能会问，我觉得有一个 

1264
01:05:31,047 --> 01:05:35,115
你 知道这个问题之前， 

1265
01:05:33,099 --> 01:05:37,101
看来这种情况发生 的几率 

1266
01:05:36,015 --> 01:05:42,090
似乎如此之低，为什么，为什么你 连 

1267
01:05:38,019 --> 01:05:44,082
担心，所以我们实际上创建 

1268
01:05:42,009 --> 01:05:47,046
只是排序测试了这一点，我们写了一个 

1269
01:05:44,082 --> 01:05:51,084
程序，看看 我们可以看到，如果 我们 

1270
01:05:48,027 --> 01:05:54,054
其实可以看得出这场比赛中 

1271
01:05:51,084 --> 01:05:55,170
练习，这就是为什么伟大的事情 

1272
01:05:54,054 --> 01:05:58,128
约2:13一样的是， 你 可以试试 

1273
01:05:56,007 --> 01:06:02,078
东西出来 的权利 等等，所以我们 刚刚试了一下 

1274
01:05:59,028 --> 01:06:05,100
出来，所以我们写了它，我们写了一个简单的 

1275
01:06:03,041 --> 01:06:09,042
创建一百个主线程 

1276
01:06:06,000 --> 01:06:11,004
每个和我们不同的线程 

1277
01:06:09,051 --> 01:06:13,140
通过艺术的说法，我们的任务 

1278
01:06:11,004 --> 01:06:18,009
这个局部变量 我 的地址 

1279
01:06:14,004 --> 01:06:21,057
好吧，然后在每个对等线程我们 

1280
01:06:18,009 --> 01:06:22,017
分离线程提领，然后 

1281
01:06:21,093 --> 01:06:26,100
我们有保存价值的功能

1282
01:06:23,007 --> 01:06:31,103
所以，我们要存储 我们存储 

1283
01:06:27,063 --> 01:06:36,063
我以供将来参考该值 

1284
01:06:32,066 --> 01:06:38,085
还好 所以现在如果没有你追我赶 的 

1285
01:06:36,063 --> 01:06:40,071
在100个线程会得到一个独立的 

1286
01:06:38,085 --> 01:06:43,089
不同线程ID右所以每个各

1287
01:06:41,043 --> 01:06:46,095
值0到99，如果我们做了一个 

1288
01:06:44,025 --> 01:06:50,028
它的柱状图会有完全相同 

1289
01:06:46,095 --> 01:06:52,137
每一个我每个值的一个实例 

1290
01:06:50,028 --> 01:06:56,055
确定 ，但如果有一场比赛将有 

1291
01:06:53,037 --> 01:06:58,041
是的我的一些值 会有 

1292
01:06:56,055 --> 01:07:00,147
中遇到的多个实例 

1293
01:06:58,041 --> 01:07:06,138
在多线程确定，所以你可以看到，如果 

1294
01:07:01,047 --> 01:07:08,145
我们再回到这里如果，如果，如果我们输了，如果 

1295
01:07:07,038 --> 01:07:12,104
对线程失去了比赛，我得到 

1296
01:07:09,045 --> 01:07:12,104
之后才能提领递增

1297
01:07:14,018 --> 01:07:24,095
现在我们已经有了对线程 0实际上 

1298
01:07:19,065 --> 01:07:24,068
得到 一个1个 OK 的ID 

1299
01:07:24,097 --> 01:07:29,098
然后皮埃尔线 之一，如果没有 

1300
01:07:28,057 --> 01:07:31,150
比赛稍后即，稍后即得到正确的值 

1301
01:07:30,007 --> 01:07:37,072
一所以现在我们有两个实例 

1302
01:07:32,005 --> 01:07:41,014
一个好 了，让我们来看看，所以这是的 

1303
01:07:37,072 --> 01:07:42,148
这样的情况下，我们已经绘制的结果 

1304
01:07:41,059 --> 01:07:45,097
情况下不会产生竞争，从而沿 

1305
01:07:43,048 --> 01:07:49,051
x轴抱歉，这是太小的 

1306
01:07:45,097 --> 01:07:51,184
x轴为我们提供了所有 的 我 的100个 值 

1307
01:07:49,051 --> 01:07:54,082
0至99，然后 将y轴是 

1308
01:07:52,084 --> 01:07:57,163
算上所以这是我们正在做一个一击 

1309
01:07:54,082 --> 01:08:01,150
对这些所有值0直方图

1310
01:07:58,063 --> 01:08:04,108
通过99所以在这种情况下，每个值 

1311
01:08:02,005 --> 01:08:11,032
有且只有一个实例，这样没有竞争 

1312
01:08:05,008 --> 01:08:16,051
有在不涉及种族没有种族 

1313
01:08:11,077 --> 01:08:18,100
在所有99是 谁运行 的所有100个 实例 

1314
01:08:16,051 --> 01:08:20,092
它在单核笔记本电脑 所以现在每 

1315
01:08:19,000 --> 01:08:25,063
线程排序的 同时反过来对 

1316
01:08:20,092 --> 01:08:27,160
单芯它发生了几次权 

1317
01:08:25,063 --> 01:08:30,064
所以有几次， 其中 一个 

1318
01:08:28,006 --> 01:08:36,019
线程被抢占，而另一 

1319
01:08:30,064 --> 01:08:38,128
线程开始 运行之前， 它可以 使 

1320
01:08:36,073 --> 01:08:41,077
同行11个线程被抢占 

1321
01:08:39,028 --> 01:08:43,120
之前，我可以取消引用变量，以便 

1322
01:08:41,077 --> 01:08:45,100
它得到了错误的错误值，但 

1323
01:08:44,002 --> 01:08:51,058
这不是很常见，它只是它发生 

1324
01:08:46,000 --> 01:08:54,003
1 2 3 4 5 6 7倍 ，但现在如果我们运行 

1325
01:08:51,076 --> 01:08:56,095
这个程序在多核服务器上 

1326
01:08:54,003 --> 01:08:58,045
你可以看到它发生了很多 实际上它 

1327
01:08:56,095 --> 01:09:00,099
发生的大部分时间，因此几乎 

1328
01:08:58,072 --> 01:09:05,109
我们从未几乎从来没有得到正确的 

1329
01:09:01,035 --> 01:09:05,109
对于我的ID正确的值 

1330
01:09:06,119 --> 01:09:09,218
好了，这是 又一个例子 

1331
01:09:08,069 --> 01:09:12,074
一些创造的 东西我可以 

1332
01:09:10,109 --> 01:09:14,174
推动你疯了，如果你 不小心 

1333
01:09:12,569 --> 01:09:18,623
当您在程序和线程 

1334
01:09:14,759 --> 01:09:20,813
用好线程和使我们看到了 

1335
01:09:19,109 --> 01:09:26,580
消除 这些种 方式 

1336
01:09:21,299 --> 01:09:30,395
擦除是为了避免这种共享 

1337
01:09:26,058 --> 01:09:33,090
状态， 在 这种情况下，通过对分配 

1338
01:09:31,259 --> 01:09:36,290
每个线程分配一个单独的块

1339
01:09:33,009 --> 01:09:38,678
在中热量将举行

1340
01:09:36,029 --> 01:09:42,081
将持有的 本地 ID 

1341
01:09:39,569 --> 01:09:46,580
线程，然后指针传递到 

1342
01:09:42,081 --> 01:09:48,370
该 存储到该唯一的块 

1343
01:09:46,679 --> 01:09:48,721
线 

1344
01:09:50,179 --> 01:09:55,770
好了，如果，如果所有的，是不是 

1345
01:09:52,859 --> 01:09:58,868
足够的理由担心而现在你 

1346
01:09:55,077 --> 01:10:00,113
应在非常失去的睡眠 

1347
01:09:58,949 --> 01:10:03,840
想到写一个线程程序 

1348
01:10:01,013 --> 01:10:09,812
另一件事要担心的是僵局 

1349
01:10:03,084 --> 01:10:11,130
好了，所以这里的程序，如果僵持 

1350
01:10:09,929 --> 01:10:18,630
它在等待出现一些状况 

1351
01:10:12,003 --> 01:10:22,112
这不会发生好了，让我们说 

1352
01:10:18,063 --> 01:10:24,078
一个典型的场景右 TP是 

1353
01:10:22,409 --> 01:10:27,840
电势的P动作是一个潜在的 

1354
01:10:24,078 --> 01:10:28,877
问题，因为它会 阻止正确的，它的 

1355
01:10:27,084 --> 01:10:33,173
等待的信号， 它的 

1356
01:10:29,579 --> 01:10:35,760
阻塞成为非零那么它的 

1357
01:10:33,929 --> 01:10:38,981
这不是太难以想象的场景 

1358
01:10:35,076 --> 01:10:42,081
其中一些有一些组合 

1359
01:10:39,449 --> 01:10:46,020
P公司 P 的 操作那种块 

1360
01:10:43,026 --> 01:10:47,255
对方出好，并使其 

1361
01:10:46,002 --> 01:10:50,073
不可能他们的条件 

1362
01:10:47,489 --> 01:10:55,520
等待上发生这样的 例子，让我们 

1363
01:10:50,073 --> 01:10:59,192
说你有两个两个线程需要 

1364
01:10:55,052 --> 01:11:01,901
二两线一和二需要 

1365
01:10:59,849 --> 01:11:04,290
两个不同的资源A和B 顺序 

1366
01:11:02,369 --> 01:11:08,381
继续让他们必须获得他们 

1367
01:11:04,029 --> 01:11:11,708
要做互斥一个PE，关于 

1368
01:11:08,489 --> 01:11:13,650
互斥锁是与关联 

1369
01:11:11,969 --> 01:11:17,036
与这些 相关的新德州

1370
01:11:13,065 --> 01:11:22,076
两种资源让我们说一个过程

1371
01:11:17,639 --> 01:11:26,400
取得它确实是这样的阶段互斥为P 

1372
01:11:22,076 --> 01:11:29,100
这是一个它的好了，所以它成功 的是 

1373
01:11:26,004 --> 01:11:33,533
它，所以它获得该资源，然后 

1374
01:11:30,000 --> 01:11:38,073
它被通过线程抢占到

1375
01:11:33,929 --> 01:11:41,933
获取B首先， 而不是获取 

1376
01:11:38,073 --> 01:11:44,121
由于某种原因，线程B获得B上

1377
01:11:41,969 --> 01:11:48,540
现在线程持有资源的锁

1378
01:11:45,021 --> 01:11:53,780
和线程两项诉讼上的锁

1379
01:11:48,054 --> 01:11:55,573
资源B，因此现在让我们说过程 

1380
01:11:53,969 --> 01:11:59,420
线程目前两人被抢占左右， 

1381
01:11:56,059 --> 01:12:02,670
一个线程运行，因此现在它的 等待 

1382
01:11:59,042 --> 01:12:06,138
它试图做两次尝试收购 

1383
01:12:02,067 --> 01:12:10,112
在资源B，但威胁到锁

1384
01:12:07,038 --> 01:12:13,089
我们整个的僵局，并在同一时间 

1385
01:12:11,012 --> 01:12:17,109
线程试图获取 的锁 

1386
01:12:13,089 --> 01:12:20,091
资源，但过程中的一个持有 

1387
01:12:18,009 --> 01:12:23,100
这一权利使 他们每个所以这里的 

1388
01:12:21,009 --> 01:12:27,045
其中一个线程 在等待这种情况下， 

1389
01:12:24,000 --> 01:12:30,039
信号量与B相关联，成为 

1390
01:12:27,045 --> 01:12:32,100
非零所以它挡在这名 P 

1391
01:12:30,039 --> 01:12:36,123
操作并在同一时间线 

1392
01:12:33,000 --> 01:12:40,092
2被阻止在用于P操作 

1393
01:12:37,023 --> 01:12:44,027
对于资源既不是那些 

1394
01:12:40,092 --> 01:12:48,156
信号灯将永远被释放， 

1395
01:12:44,063 --> 01:12:50,157
线程一和二僵持好吗 

1396
01:12:49,056 --> 01:12:53,124
而且它的发生是因为就在那里

1397
01:12:51,057 --> 01:12:56,100
这是无害的小虫子 在这 

1398
01:12:54,024 --> 01:13:00,071
其中一个线程获取的情况下

1399
01:12:57,000 --> 01:13:00,071
他们以不同的顺序资源 

1400
01:13:04,086 --> 01:13:10,128
所以这里有一个程序的例子 

1401
01:13:08,001 --> 01:13:13,002
死锁，如果你看了 这个 你 

1402
01:13:11,028 --> 01:13:14,085
知道的事实，这是错误的和马车 

1403
01:13:13,011 --> 01:13:17,070
你不跳出正确的，所以这是 

1404
01:13:14,085 --> 01:13:19,179
这种东西很微妙 如此 

1405
01:13:17,007 --> 01:13:25,014
这里有这里的，我们要 的 程序 

1406
01:13:20,079 --> 01:13:31,086
创建两个线程，我们已经有了一个数组 等等 

1407
01:13:26,004 --> 01:13:35,103
我们有互斥体 的一个数组的数组 

1408
01:13:31,086 --> 01:13:38,157
2个互斥的，所以我们创建了两个线程 

1409
01:13:36,039 --> 01:13:43,113
我们 通过每一个线程是本地 

1410
01:13:39,057 --> 01:13:45,105
线程ID 所以 0和1，因此在这里我们 

1411
01:13:44,013 --> 01:13:49,029
避免我们只是投放了比赛 

1412
01:13:46,005 --> 01:13:52,011
该线程ID是一个指针 好 

1413
01:13:49,029 --> 01:13:54,045
这是一个有些奇怪，但也没关系 

1414
01:13:52,011 --> 01:14:03,036
然后我们在等待 这些线程 

1415
01:13:54,045 --> 01:14:05,130
完成好每个线程 是要 

1416
01:14:03,036 --> 01:14:09,081
获得这 两个信号灯这些 

1417
01:14:06,003 --> 01:14:12,005
2个互斥体，但它会 做一个 

1418
01:14:09,081 --> 01:14:11,132
不同的 顺序 

1419
01:14:14,219 --> 01:14:18,270
好了，所以它会 做它作为一个 

1420
01:14:16,005 --> 01:14:20,654
它的功能要采取的ID，这样 

1421
01:14:18,027 --> 01:14:24,033
这将缝制线零 将第一 

1422
01:14:20,699 --> 01:14:28,020
获得互斥0，然后再 

1423
01:14:24,087 --> 01:14:33,093
获得互斥1-0这样的话它会 

1424
01:14:28,002 --> 01:14:37,035
获得互斥体1和线程1将第一 

1425
01:14:33,093 --> 01:14:42,135
获得你技术的一个然后收购 

1426
01:14:37,035 --> 01:14:44,109
互斥0 好了 ，所以如果我们得出 

1427
01:14:43,035 --> 01:14:46,044
戴克 ，然后，然后 它会尝试 

1428
01:14:45,009 --> 01:14:49,658
到那么它会增加数量，使得此 

1429
01:14:47,025 --> 01:14:52,080
完全是假的，但它只是 

1430
01:14:49,739 --> 01:14:55,620
说明了 这个问题，所以 你 可以 

1431
01:14:52,008 --> 01:14:57,026
看到线程0做了 苦工旗语0 

1432
01:14:55,062 --> 01:15:00,101
接着是日工旗语1和 

1433
01:14:57,098 --> 01:15:05,160
线程1做了苦工信号灯1

1434
01:15:01,001 --> 01:15:08,100
接着是日工旗语0，所以我们 

1435
01:15:06,006 --> 01:15:11,105
可以看到这一点，这是一个问题 很 

1436
01:15:09,000 --> 01:15:14,018
显然 ，如果我们回到 我们的进步 

1437
01:15:11,699 --> 01:15:14,180
图 

1438
01:15:15,093 --> 01:15:24,106
所以，如果你看一下线程0 这是做 

1439
01:15:20,068 --> 01:15:26,161
日工旗语1和它遵循一个苦工 

1440
01:15:25,006 --> 01:15:32,014
旗语随后在信号量为V 1 

1441
01:15:27,061 --> 01:15:34,123
1和线程1也被做了苦工 

1442
01:15:32,086 --> 01:15:40,090
旗语随后在信号量为V 1 

1443
01:15:35,023 --> 01:15:44,101
1所以，如果如果你把你的取

1444
01:15:40,009 --> 01:15:46,063
这两个区域的交集你 

1445
01:15:45,001 --> 01:15:49,009
得到禁止区域的信号1 

1446
01:15:47,044 --> 01:15:53,068
好了，所以这 是强制执行 区域 

1447
01:15:49,081 --> 01:15:57,094
互斥等此此的 

1448
01:15:53,068 --> 01:15:59,149
用旗语1相关的资源和 

1449
01:15:57,094 --> 01:16:02,098
如果您对旗语0做同样的事情 

1450
01:16:00,049 --> 01:16:05,053
所以在这里线程1我们收购 

1451
01:16:03,034 --> 01:16:09,112
这里信号量0，在这里将其释放

1452
01:16:05,089 --> 01:16:13,090
而我们在线程0我们收购它 

1453
01:16:10,012 --> 01:16:16,090
这里和这里释放它，所以如果你

1454
01:16:13,009 --> 01:16:20,080
采取这些两路口 你 

1455
01:16:16,009 --> 01:16:23,055
现在得到S0确定该禁止区域

1456
01:16:21,061 --> 01:16:23,136
问题 

1457
01:16:26,009 --> 01:16:34,078
是 对是本地区本在这里 

1458
01:16:29,389 --> 01:16:36,472
所谓的僵局区域因为受 

1459
01:16:34,159 --> 01:16:41,900
你知道规则的时间不能去

1460
01:16:37,219 --> 01:16:45,050
向后艺术一旦轨迹 进入 

1461
01:16:41,009 --> 01:16:47,998
进入这个僵局区域那么它的

1462
01:16:45,005 --> 01:16:51,092
注定，因为没有一次进入 

1463
01:16:48,889 --> 01:16:54,400
这一次，它进入这个僵局区 

1464
01:16:51,092 --> 01:16:56,180
有无处它去最终 

1465
01:16:54,004 --> 01:17:00,008
不管它是如何进展的每 

1466
01:16:57,008 --> 01:17:01,085
轨迹将导致这一点 

1467
01:17:00,044 --> 01:17:05,125
在这儿，它的盒装并不能和 

1468
01:17:02,057 --> 01:17:05,125
不能再继续

1469
01:17:10,007 --> 01:17:20,846
所以如此，有趣，这是有点 

1470
01:17:16,098 --> 01:17:22,176
这一地区 十二月这里 就对了 

1471
01:17:20,909 --> 01:17:26,550
排序的这两个的尾端的 

1472
01:17:23,076 --> 01:17:27,665
禁止区域，这代表美国 

1473
01:17:26,055 --> 01:17:30,126
永远不能 达到所以这些都是 

1474
01:17:28,349 --> 01:17:34,260
不可达 状态可以或可以不 

1475
01:17:31,026 --> 01:17:39,033
很有趣，那么是什么使这个 

1476
01:17:34,026 --> 01:17:43,805
所以讨厌的就是它的不确定性

1477
01:17:39,096 --> 01:17:45,155
正确的某些程序的一些轨迹，如果 

1478
01:17:44,039 --> 01:17:48,128
他们很幸运，他们会绕开这个 

1479
01:17:46,019 --> 01:17:53,033
死锁区域，然后程序 

1480
01:17:48,929 --> 01:17:58,650
将会运行得很好那里也 没关系，所以如果 

1481
01:17:53,159 --> 01:18:00,630
如果它的轨迹 ，也许只是一些你 

1482
01:17:58,065 --> 01:18:02,070
知道只是一些随意调度 

1483
01:18:00,063 --> 01:18:08,088
由上校做出决定 

1484
01:18:03,015 --> 01:18:12,084
弹道轨迹被通过 

1485
01:18:08,088 --> 01:18:15,111
在这个 方向上死锁区域和 

1486
01:18:12,084 --> 01:18:19,463
那么它最终将没有任何运行

1487
01:18:16,011 --> 01:18:22,310
问题，所以它只是它仅在 

1488
01:18:20,219 --> 01:18:24,224
轨迹土地它的僵局中 

1489
01:18:22,409 --> 01:18:25,420
区域然后他们说我们在 

1490
01:18:24,719 --> 01:18:27,788
麻烦

1491
01:18:25,519 --> 01:18:30,840
所以所以这 真的是个讨厌的 

1492
01:18:28,409 --> 01:18:32,690
真是可恶的是，你可以运行 

1493
01:18:30,084 --> 01:18:36,105
你的 一百万次 的程序 和 

1494
01:18:32,069 --> 01:18:39,038
每一个轨迹的每一个 

1495
01:18:37,005 --> 01:18:42,036
亿个轨迹裙子僵局

1496
01:18:39,659 --> 01:18:45,900
地区还好，但对万和第一 

1497
01:18:42,036 --> 01:18:49,040
时间，你运行它，它在进入 

1498
01:18:45,009 --> 01:18:51,518
死锁区域，然后死锁好吗 

1499
01:18:49,004 --> 01:18:55,283
所以这是它非常这是一个非常艰难的 

1500
01:18:52,409 --> 01:18:57,530
问题来 处理，现在还好你 

1501
01:18:55,679 --> 01:19:01,733
它很容易避免

1502
01:18:57,053 --> 01:19:05,852
如果是在获取锁的线程 

1503
01:19:02,219 --> 01:19:09,311
在资源获取所有这些锁

1504
01:19:06,329 --> 01:19:12,368
好了，所以在我们的例子，如果以相同的顺序

1505
01:19:10,139 --> 01:19:15,300
我们重写这个计划，使每个

1506
01:19:12,719 --> 01:19:17,770
螺纹线程0和线程1获取 

1507
01:19:15,003 --> 01:19:21,003
他们以相同的顺序锁，使

1508
01:19:18,229 --> 01:19:23,266
旗语0第一后跟旗语

1509
01:19:21,003 --> 01:19:23,302
1

1510
01:19:23,078 --> 01:19:29,687
那么，如果出现这种情况，我们可以看到 

1511
01:19:27,009 --> 01:19:36,072
它消除 了深度的潜力 

1512
01:19:30,389 --> 01:19:44,880
死锁的区域还好所以现在任何 

1513
01:19:37,053 --> 01:19:47,076
轨迹，我们需要将将 

1514
01:19:44,088 --> 01:19:50,133
很好，因为我们已经消除了该 

1515
01:19:47,076 --> 01:19:52,205
死锁区域和顺序 

1516
01:19:51,033 --> 01:19:55,058
我们释放锁不要紧

1517
01:19:52,889 --> 01:20:02,460
因为那种效应 

1518
01:19:55,058 --> 01:20:03,887
在它影响该地区无法访问

1519
01:20:02,046 --> 01:20:07,535
你知道这样做的大小和形状 

1520
01:20:04,409 --> 01:20:10,710
原因不能到达的区域，但它 

1521
01:20:07,949 --> 01:20:11,954
从未有我们下达订单

1522
01:20:10,071 --> 01:20:17,142
它不可能引入锁 

1523
01:20:12,449 --> 01:20:24,120
死锁区好了，这就是它 

1524
01:20:18,042 --> 01:20:26,061
今天希望大家有一个非常好的 

1525
01:20:24,012 --> 01:20:29,071
感恩节假期 ，我们会看到你 

1526
01:20:26,061 --> 01:20:28,630
星期二

