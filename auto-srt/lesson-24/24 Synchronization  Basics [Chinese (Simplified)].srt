1
00:00:00,989 --> 00:00:06,960
没事好，大家下午好 

2
00:00:02,879 --> 00:00:10,820
很高兴见到你欢迎欢迎所有

3
00:00:06,096 --> 00:00:09,182
这些学生观看视频，以及 

4
00:00:11,009 --> 00:00:17,618
在我们开始之前，我们都在谈论 

5
00:00:14,219 --> 00:00:20,460
可连接和分离线程和你 

6
00:00:17,699 --> 00:00:22,980
问你为什么会问题

7
00:00:20,046 --> 00:00:23,139
曾经 希望有正在运行的线程和 

8
00:00:22,098 --> 00:00:26,057
非分离模式，你知道为什么你会

9
00:00:24,039 --> 00:00:28,113
曾经遇到想要让他们跑过瘾 

10
00:00:26,939 --> 00:00:31,140
我没有给你 一个很好的答案 

11
00:00:29,013 --> 00:00:34,017
所以我想 尝试回答 这个问题的 

12
00:00:31,014 --> 00:00:38,753
你最好证明有一个 

13
00:00:34,053 --> 00:00:40,137
重要的一类排序平行的 

14
00:00:38,879 --> 00:00:42,960
节目有一个很重要 

15
00:00:41,037 --> 00:00:46,080
称为叉并行编程模型 

16
00:00:42,096 --> 00:00:51,695
并加入其中的计划包括的 

17
00:00:46,008 --> 00:00:55,029
在每个每个事物一系列阶段 

18
00:00:52,559 --> 00:00:59,591
阶段，你有一个工人或 主 

19
00:00:56,001 --> 00:01:07,002
对不起，它创造了一堆工人 

20
00:00:59,879 --> 00:01:08,885
线程， 然后将每个那些工人 

21
00:01:07,011 --> 00:01:12,770
螺纹销售问题的某些部分 

22
00:01:08,939 --> 00:01:14,340
像这样也许你采取这一阶段 

23
00:01:12,869 --> 00:01:17,400
你的数据结构，你打破它 

24
00:01:14,034 --> 00:01:19,050
成 块，然后每个线程 更新 

25
00:01:17,004 --> 00:01:23,097
该数据结构的它自己的块 

26
00:01:19,005 --> 00:01:25,062
无论出于何种 原因主遂将 

27
00:01:24,033 --> 00:01:27,072
等待线程的工作 

28
00:01:26,007 --> 00:01:31,014
完成才可以继续到下一个 

29
00:01:27,072 --> 00:01:33,611
阶段，因此它不喜欢，所以这是 

30
00:01:31,014 --> 00:01:37,086
所谓的叉，然后等待 

31
00:01:34,259 --> 00:01:41,490
所有线程做一个完成 

32
00:01:37,086 --> 00:01:43,705
加盟好了，所以这 就是所谓的这个叫 

33
00:01:41,049 --> 00:01:46,071
叉， 这就是所谓的加盟， 

34
00:01:44,479 --> 00:01:49,571
只有当所有的线程都 

35
00:01:46,071 --> 00:01:52,103
完成了它可以去做下一个 DO 

36
00:01:50,399 --> 00:01:53,030
下一阶段 

37
00:01:54,042 --> 00:01:58,120
好了，所以这这种模式是 真的 

38
00:01:57,019 --> 00:02:03,028
等东西的科学重要 

39
00:01:59,002 --> 00:02:05,053
计算，你可能会很 

40
00:02:03,028 --> 00:02:08,367
模拟一些你在模拟域 

41
00:02:05,071 --> 00:02:10,138
自然 ，所以你 表示一些 

42
00:02:08,619 --> 00:02:14,470
域一样，也许你如何模拟 

43
00:02:11,038 --> 00:02:19,054
热过度，你知道的板金属流动

44
00:02:14,047 --> 00:02:22,048
板，所以你可能会拥有这些 

45
00:02:19,054 --> 00:02:24,103
工人可能会上访域 

46
00:02:22,048 --> 00:02:27,082
集合之中的 工人，然后 

47
00:02:25,003 --> 00:02:30,067
这些阶段的每一个是一个时间步长 

48
00:02:27,082 --> 00:02:31,138
然后所以一旦当所有的工人

49
00:02:30,067 --> 00:02:35,074
已经 完成了一个时间步长那么他们可以 

50
00:02:32,038 --> 00:02:38,041
前进到 下一个 时间步长等 

51
00:02:36,037 --> 00:02:40,042
对不起，我不知道 为什么我没有想到的 

52
00:02:38,041 --> 00:02:46,129
它这是一个这是一个重要的原因 

53
00:02:40,087 --> 00:02:48,456
为什么你不这样行吗，所以我们看到了 ，我们已经 

54
00:02:47,029 --> 00:02:51,558
看到螺纹螺纹程序

55
00:02:49,239 --> 00:02:56,470
是不错的，因为你认为你可以分享 

56
00:02:51,819 --> 00:02:59,410
所有的全局变量，但共享 

57
00:02:56,047 --> 00:03:01,054
可以能产生意想不到的后果如此 

58
00:02:59,041 --> 00:03:05,370
不知何故，我们需要一种机制，在这里 我们可以 

59
00:03:02,017 --> 00:03:09,031
控制每个单独的如何流 

60
00:03:05,739 --> 00:03:11,920
线程是交错的，这样不好 

61
00:03:09,031 --> 00:03:14,044
当我们共享数据的事情不会发生 

62
00:03:11,092 --> 00:03:15,148
结构好了，所以这个 的 过程 

63
00:03:14,044 --> 00:03:18,153
控制的交织 

64
00:03:16,048 --> 00:03:20,086
所谓同步，所以我们打算 

65
00:03:18,549 --> 00:03:23,110
看，你可以 用它来 技术 

66
00:03:20,086 --> 00:03:26,161
通过写入正确的线程程序 

67
00:03:23,011 --> 00:03:30,013
现在正确同步他们先

68
00:03:27,061 --> 00:03:31,126
虽然我们需要有一个清晰的思路，从而 

69
00:03:30,013 --> 00:03:33,088
共享是问题的权利，如果我们有 

70
00:03:32,026 --> 00:03:36,091
线程不 共享任何 

71
00:03:33,088 --> 00:03:37,150
资源那么就没有 问题 吧 

72
00:03:36,091 --> 00:03:39,097
我们看到这个的时候，我们看着它 

73
00:03:38,005 --> 00:03:43,039
处理没有共享数据 

74
00:03:40,051 --> 00:03:45,055
流程结构，所以我们 处理 

75
00:03:43,084 --> 00:03:47,119
只是独立运行，我们真的不

76
00:03:45,091 --> 00:03:49,135
不在乎别人是交错的 音符不 

77
00:03:48,019 --> 00:03:53,056
忧虑 不错，但只要 他们 

78
00:03:50,035 --> 00:03:55,072
介绍分享那么接下来我们就来 

79
00:03:53,056 --> 00:03:57,121
小心好吗 

80
00:03:55,072 --> 00:03:59,095
因此了解如何同步 

81
00:03:58,021 --> 00:04:03,058
线程我们首先需要有一个明确的 

82
00:03:59,095 --> 00:04:07,096
的我们 所说的 做法， 只要在分享 

83
00:04:03,058 --> 00:04:10,066
螺纹种子计划所以 答案 

84
00:04:08,005 --> 00:04:13,042
是不是这么简单的全局变量 

85
00:04:10,066 --> 00:04:21,082
共享和堆叠变量不 

86
00:04:13,042 --> 00:04:23,116
分享好了，所以我们有一个，而不是什么 

87
00:04:21,082 --> 00:04:26,098
当且仅当变量X共享

88
00:04:24,016 --> 00:04:30,016
多线程参考一些实例 

89
00:04:26,098 --> 00:04:32,101
使变量X，所以如果只有一个 

90
00:04:30,016 --> 00:04:38,029
线程访问特定 

91
00:04:33,001 --> 00:04:42,001
可变 那么它就是 它的不共享好吗 

92
00:04:38,029 --> 00:04:44,068
所以为了正是我们的意思是知道 

93
00:04:42,001 --> 00:04:47,065
通过共享我们需要回答三个 

94
00:04:44,068 --> 00:04:50,071
问题好吗第一什么是记忆 

95
00:04:47,065 --> 00:04:52,152
模型线程确定 第二电源 

96
00:04:50,098 --> 00:04:56,113
的变量实例 映射到存储器 

97
00:04:53,052 --> 00:04:58,129
然后，然后第三个多少个 线程 

98
00:04:57,013 --> 00:05:01,021
可能会引用这些实例

99
00:04:59,029 --> 00:05:02,104
这些变量 的 好了，我们来看看 

100
00:05:01,021 --> 00:05:04,068
每个那些现在将每个 那些 

101
00:05:03,004 --> 00:05:09,036
三个 问题 

102
00:05:04,068 --> 00:05:11,089
好了，首先 是内存模型 

103
00:05:09,036 --> 00:05:13,123
概念模型是一点点 

104
00:05:11,089 --> 00:05:14,116
从操作 模型的不同

105
00:05:14,023 --> 00:05:18,049
这样它确实有效 

106
00:05:15,016 --> 00:05:20,047
好了，所以在概念上 我们有多个 

107
00:05:18,049 --> 00:05:22,105
在的上下文中运行的线程 

108
00:05:20,047 --> 00:05:25,050
单进程 好一些的那 

109
00:05:23,005 --> 00:05:28,024
上下文被共享和 它 的一些 不 

110
00:05:25,077 --> 00:05:30,145
共享，每个线程都有自己的 

111
00:05:28,024 --> 00:05:33,070
单独的线程ID堆栈的堆栈指针

112
00:05:31,045 --> 00:05:37,114
程序计数器条件码

113
00:05:33,007 --> 00:05:39,106
通用寄存器，然后他们 

114
00:05:38,014 --> 00:05:42,085
所有共享剩余的进程上下文 

115
00:05:40,069 --> 00:05:44,137
与数据结构，所述 

116
00:05:42,085 --> 00:05:46,180
内核维护的线程

117
00:05:45,037 --> 00:05:51,043
虚拟数据结构以支持 

118
00:05:47,008 --> 00:05:55,024
虚拟内存系统打开的文件 安装 

119
00:05:51,097 --> 00:05:56,188
信号处理程序等等，这样的 

120
00:05:55,096 --> 00:05:58,135
概念模型 ， 如果这是 

121
00:05:57,088 --> 00:05:59,143
如果这真的执行它 

122
00:05:59,035 --> 00:06:03,046
将是很好的它将使事情

123
00:06:00,043 --> 00:06:05,136
在实际简化了 我们无奈 

124
00:06:03,046 --> 00:06:08,138
生活这种模式是没有严格执行 

125
00:06:06,036 --> 00:06:10,091
现在虽然寄存器值是真的 

126
00:06:09,038 --> 00:06:12,107
右上校保持分离 

127
00:06:10,091 --> 00:06:15,095
上下文的所有寄存器使 

128
00:06:13,007 --> 00:06:18,068
那这部分是好的 ，但由于 

129
00:06:16,031 --> 00:06:21,038
线程共享地址空间中的线程 

130
00:06:18,068 --> 00:06:23,135
可以访问所述存储器中的一个堆

131
00:06:22,001 --> 00:06:24,092
线程可以访问的另一个堆栈 

132
00:06:24,035 --> 00:06:26,063
线 

133
00:06:24,092 --> 00:06:29,143
好了，所以虽然这些概念 

134
00:06:26,063 --> 00:06:36,101
堆栈是分离和不同的，并 

135
00:06:30,043 --> 00:06:38,078
私人他们 真的没有，因此这 

136
00:06:37,001 --> 00:06:41,009
可以创造一些问题，所以这里是一个 

137
00:06:38,078 --> 00:06:45,122
例如，我们会回来给 你 

138
00:06:41,081 --> 00:06:48,113
后来的这一个线程如何 访问 

139
00:06:46,022 --> 00:06:50,063
另一个线程的堆栈所以这里 

140
00:06:49,013 --> 00:06:55,061
我们定义了一个名为全局变量 

141
00:06:50,063 --> 00:06:58,106
指针是炭星和星

142
00:06:55,061 --> 00:07:00,089
然后在声明一个主程序

143
00:06:59,006 --> 00:07:03,089
局部变量称为消息，这些消息 

144
00:07:00,089 --> 00:07:07,127
包含它的两个元素的阵列，其 

145
00:07:03,089 --> 00:07:09,116
包含了两个字符串这些 

146
00:07:08,027 --> 00:07:12,059
将由线程被打印出来 

147
00:07:10,016 --> 00:07:15,020
我们要 创建 ，然后我们 

148
00:07:12,059 --> 00:07:17,093
全局指针分配给兽医 

149
00:07:15,002 --> 00:07:22,076
阵列的消息的地址行

150
00:07:17,093 --> 00:07:23,189
所以现在指针指向消息和

151
00:07:22,094 --> 00:07:28,139
那么，我们在一个循环中创建我们创建了两个

152
00:07:24,089 --> 00:07:31,178
其中的每一个线程执行这 

153
00:07:29,039 --> 00:07:37,103
程序调用线程，和我们

154
00:07:32,078 --> 00:07:39,080
传递参数所以吨线程 

155
00:07:38,003 --> 00:07:41,003
将分配一个线程ID，但在这种情况下， 

156
00:07:39,008 --> 00:07:42,080
我们要分配我们自己的地方 

157
00:07:41,003 --> 00:07:46,046
通过使此 扫描 索引 线程ID 

158
00:07:43,052 --> 00:07:49,055
好了，所以这是 我们讲到 的 例子 

159
00:07:46,046 --> 00:07:50,129
关于这最后 一次，它是它是一种 

160
00:07:49,055 --> 00:07:53,138
这是这 是完全没有问题没有 

161
00:07:51,029 --> 00:07:56,084
的比赛，但它是一个 有点怪异 

162
00:07:54,038 --> 00:08:01,087
因为我们要利用这个指标我 

163
00:07:56,084 --> 00:08:01,087
它转换为通用指针好吗 

164
00:08:03,003 --> 00:08:10,004
再经过我们创建这些线程 

165
00:08:04,092 --> 00:08:12,147
那么 我们一定会喜欢，主线程现在 

166
00:08:10,004 --> 00:08:15,063
每个线程程序取消引用其 

167
00:08:13,047 --> 00:08:19,071
参数，以获得当地的地方 

168
00:08:15,099 --> 00:08:20,172
线程ID，然后它声明 

169
00:08:19,071 --> 00:08:22,149
我们要去的静态变盘点

170
00:08:21,072 --> 00:08:24,123
使用计算有多少 次这样的 

171
00:08:23,049 --> 00:08:28,053
线程程序被调用的内 

172
00:08:25,023 --> 00:08:32,046
线程，然后它只是打印一个简单的

173
00:08:28,089 --> 00:08:36,238
从识别消息给 

174
00:08:32,046 --> 00:08:41,124
局部线程ID，然后该 消息 

175
00:08:37,039 --> 00:08:45,510
我的ID索引，以便指针指向

176
00:08:42,024 --> 00:08:49,077
消息，因此线程为零将打印打招呼 

177
00:08:45,051 --> 00:08:52,116
从foo和线程1将打印打招呼 

178
00:08:49,077 --> 00:08:56,165
从酒吧，然后，然后我们 增加 

179
00:08:53,016 --> 00:08:57,065
预增量计数器变量 

180
00:08:57,092 --> 00:09:05,100
好了，所以虽然它 没有你不会 

181
00:09:03,075 --> 00:09:07,131
你会看起来我们在访问 

182
00:09:06,000 --> 00:09:10,026
这个全局变量的指针，但由于 

183
00:09:08,031 --> 00:09:13,047
这被分配到 的地址 

184
00:09:10,026 --> 00:09:17,058
主主局部变量 

185
00:09:13,047 --> 00:09:21,066
线程堆栈我们已经得到了这一点 ，这些同行 

186
00:09:17,058 --> 00:09:24,126
线程访问的局部变量 

187
00:09:21,066 --> 00:09:26,079
主线程栈 好了，所以，我只是 

188
00:09:25,026 --> 00:09:28,119
这是 不是 你永远要做到这一点 

189
00:09:26,079 --> 00:09:31,175
这是一个非常不好的做法，但我这是 在 

190
00:09:29,019 --> 00:09:32,075
之类的话， 可 有时 会发生 

191
00:09:32,009 --> 00:09:36,096
偶然你知道，如果你忘 了 

192
00:09:35,055 --> 00:09:40,119
指针实际分配给您 

193
00:09:37,077 --> 00:09:43,080
知道一些一些堆栈地址好了， 

194
00:09:41,019 --> 00:09:46,035
那所以第二个问题是如何 

195
00:09:44,007 --> 00:09:49,020
我们映射变量实例存储 

196
00:09:46,035 --> 00:09:50,121
现在我们看着这个时候我们时，我们 

197
00:09:49,002 --> 00:09:53,064
研究联系起来，但我们只是回顾

198
00:09:51,021 --> 00:09:57,072
再次快速这确保 

199
00:09:53,082 --> 00:09:58,167
很明显你这么全局变量 

200
00:09:57,072 --> 00:10:03,114
是被引用变量

201
00:09:59,067 --> 00:10:05,151
的功能和虚拟的外 

202
00:10:04,014 --> 00:10:08,022
内存当它符号链接

203
00:10:06,051 --> 00:10:10,062
分辨率确保有 

204
00:10:08,022 --> 00:10:11,100
每个全局的只有一个实例

205
00:10:10,062 --> 00:10:17,073
借助 可变 

206
00:10:12,000 --> 00:10:21,074
现在内存局部变量的声明 

207
00:10:17,073 --> 00:10:21,074
上的功能的 内部的叠层 

208
00:10:22,034 --> 00:10:28,041
没有静态属性，所以在 

209
00:10:26,064 --> 00:10:31,080
每个这种情况下，堆叠为 每个线程 

210
00:10:29,004 --> 00:10:33,092
将包含 本地 的一个实例 

211
00:10:31,008 --> 00:10:33,020
变量 

212
00:10:36,062 --> 00:10:42,134
如果变量的声明里面现在

213
00:10:40,092 --> 00:10:44,184
与静态属性的功能

214
00:10:43,034 --> 00:10:47,046
然后该变量的范围是 

215
00:10:45,084 --> 00:10:49,182
限于该功能意味着没有 

216
00:10:47,046 --> 00:10:53,145
其他函数可以访问它，但是 

217
00:10:50,082 --> 00:10:55,170
静态变量与所有一起存储

218
00:10:54,045 --> 00:10:58,068
其他局部变量所以有任何 

219
00:10:56,007 --> 00:11:02,016
静态变量的内部声明

220
00:10:58,068 --> 00:11:05,085
函数中只有一个实例 

221
00:11:03,006 --> 00:11:07,089
内存，如果你是有发言权

222
00:11:05,085 --> 00:11:09,093
该声明的多种功能

223
00:11:08,043 --> 00:11:12,090
同样用相同的一个静态变量

224
00:11:09,093 --> 00:11:13,167
命名编译器会会 

225
00:11:12,009 --> 00:11:18,045
如果它会消除歧义那些莫名其妙

226
00:11:14,067 --> 00:11:22,145
它会追加某种独特的 IT 

227
00:11:19,026 --> 00:11:23,045
会以某种方式使这个名字 唯一 好吗 

228
00:11:23,066 --> 00:11:28,068
好了，什么还记得如何将所有这些 

229
00:11:26,004 --> 00:11:34,032
不同类型的变量的实例 

230
00:11:28,068 --> 00:11:35,133
被映射到存储器凯指针是一个 

231
00:11:34,032 --> 00:11:42,120
全局变量，所以有一个实例 

232
00:11:36,033 --> 00:11:46,127
在地址 空间的指针，它的 

233
00:11:43,002 --> 00:11:47,009
存储在所述在所述数据段

234
00:11:49,087 --> 00:11:58,099
我 我和消息的本地实例 

235
00:11:56,017 --> 00:12:02,080
变量两大 所以有一个 

236
00:11:58,099 --> 00:12:07,152
这些实例存储 在堆栈 上 

237
00:12:02,008 --> 00:12:10,096
主栈， 我们将表示这些 

238
00:12:08,052 --> 00:12:15,057
这种表示 我们会说 我 变 

239
00:12:11,068 --> 00:12:19,090
我点M表示变量I被存储在

240
00:12:15,057 --> 00:12:25,096
主堆叠和消息被存储在 

241
00:12:19,009 --> 00:12:27,040
名字的堆栈现在没事了我的ID是本地 

242
00:12:25,096 --> 00:12:30,124
可变宣布仿射在此线程 

243
00:12:28,021 --> 00:12:32,077
常规等有实际意义上 

244
00:12:31,024 --> 00:12:34,063
有两个这样的线程 有 

245
00:12:32,077 --> 00:12:37,171
那里现在是有记忆有

246
00:12:34,063 --> 00:12:40,141
还有我的ID一个一个的两个实例 

247
00:12:38,071 --> 00:12:44,143
每个堆栈好与相关联的 

248
00:12:41,041 --> 00:12:48,127
堆栈每个线程等等相关的我

249
00:12:45,043 --> 00:12:53,062
ID T0存储在对等体线程0堆 

250
00:12:49,027 --> 00:12:59,098
我的ID 点t1被存储在同行 

251
00:12:53,062 --> 00:13:03,651
线程堆栈1 OK，现在这个计数器 

252
00:12:59,098 --> 00:13:06,207
变静态计数器变量

253
00:13:04,209 --> 00:13:09,216
仅仅只有一个实例中的虚拟 

254
00:13:07,089 --> 00:13:11,890
内存和它在数据 段 

255
00:13:09,279 --> 00:13:14,910
随着像其他的全局变量 

256
00:13:11,089 --> 00:13:14,091
像指针

257
00:13:16,081 --> 00:13:22,093
现在没事了这样的 一个问题是这 

258
00:13:20,092 --> 00:13:28,093
这些变量是共享的，其是

259
00:13:22,093 --> 00:13:31,099
不行，所以我们能记住我们 

260
00:13:28,093 --> 00:13:34,120
说的是，如果它比它的共享

261
00:13:31,099 --> 00:13:40,120
一个线程正在访问的一个实例 

262
00:13:35,002 --> 00:13:43,020
该变量好了，让我们让我们 只 

263
00:13:41,002 --> 00:13:45,010
列出所有不同的 变量和 

264
00:13:43,038 --> 00:13:47,104
那么让我们来看看这些线程 

265
00:13:46,000 --> 00:13:51,085
看看它是否通过引用 

266
00:13:48,004 --> 00:13:56,071
线程好了，所以怎么样怎么样 

267
00:13:51,085 --> 00:14:00,154
指针在那里只是它的 

268
00:13:56,071 --> 00:14:03,153
由主线程和引用什么 

269
00:14:01,054 --> 00:14:03,153
关于对零线

270
00:14:06,086 --> 00:14:15,164
没错这就是由对等线程 零引用

271
00:14:09,044 --> 00:14:19,130
这里就在这里，类似的还有 

272
00:14:16,064 --> 00:14:23,065
桃花红一个好了，所以指针 

273
00:14:20,003 --> 00:14:23,038
所有三个线程引用

274
00:14:24,007 --> 00:14:33,053
现在大概数才算数不 

275
00:14:30,005 --> 00:14:38,081
由主线程引用，但它是 

276
00:14:33,053 --> 00:14:42,122
现在 两个对等线程 引用 

277
00:14:38,081 --> 00:14:46,166
关于我多数民众赞成引用什么主 

278
00:14:43,022 --> 00:14:49,078
通过主菜，但不通过但不 

279
00:14:47,066 --> 00:14:51,122
无论是两个线程 

280
00:14:49,078 --> 00:14:55,127
现在怎么样的邮件消息

281
00:14:52,022 --> 00:15:00,065
排列好，这样是一个的被访问 

282
00:14:56,027 --> 00:15:04,094
我的主要和间接通过指针 

283
00:15:00,065 --> 00:15:08,086
它是由每一个两个引用

284
00:15:04,094 --> 00:15:13,127
对线程现在来谈谈我的ID 

285
00:15:08,086 --> 00:15:15,101
在对等体定义线程在零好了，所以 

286
00:15:14,027 --> 00:15:17,090
多数民众赞成引用这是一个本地 

287
00:15:16,001 --> 00:15:19,076
可变的，所以它只能通过同行引用 

288
00:15:17,009 --> 00:15:20,054
螺纹零右它不是由引用 

289
00:15:19,076 --> 00:15:30,082
任一其他线程并且类似地

290
00:15:21,035 --> 00:15:30,082
对于我的ID，并在同行中一个威胁 

291
00:15:32,029 --> 00:15:41,998
所以给出好的鉴于定义，然后 

292
00:15:36,939 --> 00:15:46,600
这些变量的共享，所以 

293
00:15:42,259 --> 00:15:46,600
它与没错真的简单

294
00:15:49,072 --> 00:15:55,072
好了，所以这个问题是 不计计数 

295
00:15:53,024 --> 00:15:58,093
作为共享变量，答案是肯定的 

296
00:15:55,072 --> 00:16:01,154
因为，因为它声明为static 

297
00:15:58,093 --> 00:16:06,116
它 在 有它 的 一个实例 在 

298
00:16:02,054 --> 00:16:09,080
虚拟内存和每个线程的 

299
00:16:07,016 --> 00:16:12,235
引用该实例好了，所以它的 

300
00:16:09,008 --> 00:16:14,527
它的共享它真的像一个全球 

301
00:16:12,379 --> 00:16:19,730
变量它只是一个范围仅限于 

302
00:16:15,319 --> 00:16:21,470
在IT卖场以相同的方式在全球 

303
00:16:19,073 --> 00:16:23,162
变量是但其范围限于 

304
00:16:21,047 --> 00:16:26,206
了在好限定为使得所述函数

305
00:16:24,062 --> 00:16:28,067
以确定是否 这些每一个 都是 

306
00:16:26,629 --> 00:16:30,637
是否这些变量是

307
00:16:28,067 --> 00:16:33,098
共享的，哪些不是，我们只是我们 

308
00:16:30,709 --> 00:16:35,733
只是看对面，任何任何去 

309
00:16:33,098 --> 00:16:38,827
其 由超过 共享变量

310
00:16:35,949 --> 00:16:46,300
一个多线程那么它的共享， 

311
00:16:39,709 --> 00:16:51,715
指针共享，以便指针被共享 

312
00:16:46,003 --> 00:16:53,512
计数不共享 ，不，不指望这 

313
00:16:51,769 --> 00:16:57,832
一年 ，因为这是 它是由引用 

314
00:16:53,809 --> 00:16:59,860
对 零 线 和同行线程一个我的 

315
00:16:58,399 --> 00:17:04,461
不共享，因为它只是引用 

316
00:17:00,319 --> 00:17:04,326
由主让

317
00:17:07,042 --> 00:17:14,141
信息访问所有三个引用

318
00:17:10,037 --> 00:17:16,996
线程所以它的共享，但我的ID 是被 

319
00:17:15,041 --> 00:17:20,128
不共享，因为它只是引用 

320
00:17:17,329 --> 00:17:25,100
正好一个线程好了，所以这样的指针 

321
00:17:21,028 --> 00:17:26,105
计数和消息共享 

322
00:17:25,001 --> 00:17:32,096
在这个程序中的变量和其他人

323
00:17:27,005 --> 00:17:36,032
正在运行的份额肯定将让第二 

324
00:17:33,005 --> 00:17:39,092
过程并对其所以如果你声明 

325
00:17:36,032 --> 00:17:41,051
我的想法静态与第二过程 

326
00:17:39,092 --> 00:17:43,981
的覆盖是啊，这将是一个 

327
00:17:41,051 --> 00:17:47,117
比赛好了，所以这 将我们 只是依赖 

328
00:17:44,809 --> 00:17:49,280
在其上哪个线程执行的第一 所以 

329
00:17:48,017 --> 00:17:51,276
你真的不想做 

330
00:17:49,028 --> 00:17:51,177
那

331
00:17:54,064 --> 00:18:01,069
好 了，所以我们有一个非常清晰的概念 

332
00:17:58,025 --> 00:18:01,114
现在我们通过共享的意思

333
00:18:07,369 --> 00:18:12,448
所以这些能够共享变量

334
00:18:10,035 --> 00:18:15,072
像这样在这方面它是非常方便 

335
00:18:13,159 --> 00:18:19,860
但 你可以碰到一些真是可恶 

336
00:18:15,072 --> 00:18:24,121
是非常令人吃惊的问题，以便让 

337
00:18:19,086 --> 00:18:26,495
我告诉你一个例子，这是 一个程序 

338
00:18:24,769 --> 00:18:28,980
叫爸爸 算上如此明显有 

339
00:18:27,269 --> 00:18:32,306
有毛病这个 我给你 

340
00:18:28,098 --> 00:18:35,120
一点点线索，但我们想要做的是什么 

341
00:18:32,639 --> 00:18:39,480
我们要建立我们要创建 一个 

342
00:18:36,002 --> 00:18:42,191
线程束或多个 线程 

343
00:18:39,048 --> 00:18:44,627
而且每个线程将增加 

344
00:18:42,389 --> 00:18:47,476
一个 名为 全局变量 计算一些 

345
00:18:45,059 --> 00:18:53,070
次数相同 的 次数 

346
00:18:48,259 --> 00:18:56,288
所以，所以我们通过 他们的数量 

347
00:18:53,007 --> 00:18:57,986
迭代作为第一个参数，并 

348
00:18:56,549 --> 00:19:01,625
这里是我们的好这里是我们全球

349
00:18:58,049 --> 00:19:04,145
全局共享的变量，而您 

350
00:19:02,309 --> 00:19:07,364
记得挥发性意味着任何人都 

351
00:19:05,009 --> 00:19:09,600
记得那是什么 意思 有啥 

352
00:19:07,859 --> 00:19:13,190
挥发性什么是挥发性告诉 

353
00:19:09,006 --> 00:19:12,065
编译器是 

354
00:19:15,018 --> 00:19:26,977
这里的机会

355
00:19:17,059 --> 00:19:28,820
你不能 真正访问你， 你 

356
00:19:27,139 --> 00:19:31,730
在正确的方向 实际上告诉 

357
00:19:28,082 --> 00:19:34,097
它告诉编译器从来没有把那个 

358
00:19:31,073 --> 00:19:36,472
在寄存器变量好了，所以它总是 

359
00:19:34,097 --> 00:19:39,136
它总是读取 该值 

360
00:19:37,129 --> 00:19:42,490
内存或者其保存至内存 和你做 

361
00:19:40,009 --> 00:19:48,076
因为正是那种的 

362
00:19:42,049 --> 00:19:51,095
你那么那么在提到 可能性 

363
00:19:48,679 --> 00:19:54,470
这在这种情况下，我们有我们创建了两个 

364
00:19:51,095 --> 00:19:57,394
线程但是有两个不同的调用 

365
00:19:54,047 --> 00:20:01,073
2并行线程创建这些线程 

366
00:19:58,249 --> 00:20:05,330
将要运行的线程程序 

367
00:20:01,073 --> 00:20:06,122
所谓的线程，它会通过 ，并作为 

368
00:20:05,033 --> 00:20:09,071
数量的参数地址 

369
00:20:07,022 --> 00:20:12,691
迭代，这应该 是它应该 

370
00:20:09,071 --> 00:20:13,990
现在迭代记得 当 我们 

371
00:20:12,889 --> 00:20:16,894
看，当我们路过连接 

372
00:20:14,629 --> 00:20:20,683
文件描述符如果 如果我们传递一个 

373
00:20:17,389 --> 00:20:22,450
解决是 好的，但在这 一场比赛 

374
00:20:21,169 --> 00:20:25,100
情况下，有没有比赛，这是好的这是 

375
00:20:22,999 --> 00:20:27,350
罚款只是 为了打发 号的 地址 

376
00:20:25,001 --> 00:20:29,062
迭代那么，为什么在这一点，好吗 

377
00:20:27,035 --> 00:20:32,036
情况下，却是不行的，当我们 

378
00:20:29,071 --> 00:20:34,120
传递连接文件描述符 

379
00:20:32,036 --> 00:20:36,735
我们 从接受我们的线程 获得 

380
00:20:34,759 --> 00:20:36,762
常规

381
00:20:51,049 --> 00:20:55,488
正是因为线程 不 

382
00:20:53,409 --> 00:20:57,471
修改的值 ，而这个问题我们 

383
00:20:55,929 --> 00:20:59,952
曾是以前， 我们的主线程 

384
00:20:58,029 --> 00:21:02,115
改性使得连接到 脚本 上 

385
00:21:00,159 --> 00:21:04,170
下次调用接受，但在这里它的 

386
00:21:02,889 --> 00:21:07,600
只是只读 变量，因此我们 

387
00:21:04,269 --> 00:21:09,490
不错 ，但你看怎么靠谱 

388
00:21:07,006 --> 00:21:11,017
推理可以得到正确的有你 

389
00:21:09,049 --> 00:21:13,051
不能做模式匹配 来确定 

390
00:21:11,071 --> 00:21:15,100
你是否已经有了种族或种族不

391
00:21:13,069 --> 00:21:20,086
所以你不能只是 说好这是 

392
00:21:16,000 --> 00:21:23,799
总是坏传递 的一些 地址 

393
00:21:20,086 --> 00:21:24,405
变量为一个线程例行 好吗 

394
00:21:23,799 --> 00:21:27,837
因为它不只是依赖于 

395
00:21:25,179 --> 00:21:30,490
背景好了 ，所以在这种 情况下，我们是 

396
00:21:28,179 --> 00:21:34,254
传递迭代的 和与数

397
00:21:30,049 --> 00:21:36,055
每个线程，然后我们在等待 

398
00:21:34,929 --> 00:21:38,740
每个这些线程的完成所以这 

399
00:21:37,009 --> 00:21:42,037
是一个考察你为什么other--例子 

400
00:21:38,074 --> 00:21:45,172
需要你为什么会想有一个非 

401
00:21:42,037 --> 00:21:48,846
分离线程，因为你不能我们 

402
00:21:46,072 --> 00:21:50,098
希望在我们检查的时候 ，我们检查 

403
00:21:49,179 --> 00:21:52,690
计 值 ，我们必须确保 

404
00:21:50,098 --> 00:21:53,133
我们检查之前，每个线程完成 

405
00:21:52,069 --> 00:21:55,908
我们是否得到了正确的值或不 

406
00:21:54,033 --> 00:21:59,035
好了，所以我们等待每个线程 

407
00:21:56,529 --> 00:22:01,530
完成现在，因为我们已经创建了两个 

408
00:21:59,035 --> 00:22:04,120
线程其中每个 递增 

409
00:22:01,539 --> 00:22:07,210
算上编辑时间我们预计数为 

410
00:22:05,002 --> 00:22:09,067
等于两倍 和国际热核实验堆的 ，如果 

411
00:22:07,021 --> 00:22:13,120
这不是我们打印我最喜欢的错误 

412
00:22:09,085 --> 00:22:17,113
消息否则我们与价值

413
00:22:14,002 --> 00:22:20,101
算上否则我们打印好 也 

414
00:22:18,013 --> 00:22:23,086
算好了所以现在有什么价值

415
00:22:21,019 --> 00:22:30,138
在线程例行 事情 很 

416
00:22:23,086 --> 00:22:31,275
简单，它取消引用的论据 

417
00:22:30,309 --> 00:22:35,380
中传递 ，并将其存储在 

418
00:22:32,049 --> 00:22:38,085
编辑的本地副本，然后将其循环 

419
00:22:35,038 --> 00:22:42,073
参议员时间，可以增加 数 

420
00:22:38,409 --> 00:22:46,457
每次这样，然后返回，所以这是 

421
00:22:42,073 --> 00:22:48,732
很乏味什么可以去错了， 

422
00:22:46,889 --> 00:22:51,010
因为这是线程，因为这是 

423
00:22:49,389 --> 00:22:52,392
并发并发编程

424
00:22:51,001 --> 00:22:55,650
特别是因为这螺纹 

425
00:22:52,419 --> 00:22:57,420
编程 什么 还有的零碎 

426
00:22:55,659 --> 00:22:59,610
微妙的东西 可以去错了 ，所以 它变成 

427
00:22:57,429 --> 00:23:04,516
这一计划有一个很 

428
00:22:59,061 --> 00:23:04,750
这个bug没关系，因为当我们运行 

429
00:23:05,057 --> 00:23:12,075
当我们在 Linux机器 上运行它 有时 

430
00:23:09,035 --> 00:23:14,097
如果我们10000的 参数 调用它 

431
00:23:12,075 --> 00:23:18,254
有时我们得到正确的答案 

432
00:23:14,097 --> 00:23:20,192
接下来的两次一两万然后

433
00:23:18,929 --> 00:23:27,660
一次，我们运行它，我们得到了一些奇怪的号码 

434
00:23:21,092 --> 00:23:31,104
13000 51完全不对等 什么 

435
00:23:27,066 --> 00:23:33,165
究竟发生了什么事在这里好吗 

436
00:23:32,004 --> 00:23:38,085
所以要明白，我们来看看 

437
00:23:34,065 --> 00:23:41,097
该计数器的汇编语言 

438
00:23:38,085 --> 00:23:43,140
循环使我们想要 我们 ，我们需要 

439
00:23:41,097 --> 00:23:47,121
看看 这个十二月语言 

440
00:23:44,004 --> 00:23:49,076
在线程程序计数器循环，使 

441
00:23:48,021 --> 00:23:52,083
我们将其拆分成三个 组块 

442
00:23:50,012 --> 00:23:56,013
在第一块是那种让 

443
00:23:52,083 --> 00:23:57,147
准备好循环中，我们会打电话给该 

444
00:23:56,022 --> 00:24:06,089
头， 我们表示 ，我们将 其 表示 为 

445
00:23:58,047 --> 00:24:08,109
线程我和我H，则我们，我们将 

446
00:24:06,089 --> 00:24:10,125
我们将在这三个隔离

447
00:24:09,009 --> 00:24:14,061
直接相关说明

448
00:24:11,025 --> 00:24:17,060
以递增数 好了，所以你看 

449
00:24:14,061 --> 00:24:19,122
第一指令将其加载 

450
00:24:17,006 --> 00:24:23,091
全球 在全局变量的值 

451
00:24:20,022 --> 00:24:30,601
算到 寄存器 路X所以我们会代表 

452
00:24:24,045 --> 00:24:33,141
， 随着I L接下来它增加RDX 

453
00:24:30,799 --> 00:24:39,090
我们将 那 表示 我U表示更新 ，以便 

454
00:24:34,041 --> 00:24:41,930
它更新RDX，然后将其存储 

455
00:24:39,009 --> 00:24:42,848
重视RDX的更新值成 

456
00:24:42,299 --> 00:24:46,260
计数

457
00:24:42,929 --> 00:24:52,070
好了，进入位置 相关联 

458
00:24:46,026 --> 00:24:51,107
与当地的全局 变量 计数和 

459
00:24:52,081 --> 00:24:56,176
然后的休息休息

460
00:24:54,091 --> 00:24:59,179
这个循环正准备 在做 

461
00:24:57,076 --> 00:25:01,150
下一次迭代直接不 

462
00:25:00,079 --> 00:25:03,112
有关增加计数，所以我们会 

463
00:25:02,005 --> 00:25:07,077
只是排序组的这一起， 

464
00:25:04,012 --> 00:25:08,013
称其为T的 我的 尾巴 

465
00:25:12,068 --> 00:25:20,112
现在让我们来看看让我们看看如何 

466
00:25:18,054 --> 00:25:23,058
如何将这些两个线程可能是可能是 

467
00:25:21,012 --> 00:25:26,034
执行，一般我们记得

468
00:25:23,094 --> 00:25:27,156
不能假设有任何具体 

469
00:25:26,034 --> 00:25:29,130
交错所以任何交织

470
00:25:28,056 --> 00:25:34,128
这两个线程可以不管 

471
00:25:30,003 --> 00:25:37,026
如何远程它看起来那么让我们来看看 

472
00:25:35,028 --> 00:25:39,030
在一个例子，让我们说，我们正在执行

473
00:25:37,053 --> 00:25:45,108
在单核，所以我们只打算 

474
00:25:39,003 --> 00:25:47,055
做一个指令的时间和在本 

475
00:25:46,008 --> 00:25:48,060
栏将显示哪些线程 

476
00:25:47,082 --> 00:25:52,146
执行

477
00:25:48,006 --> 00:25:54,048
所以无论是线程1或线程2，然后 

478
00:25:53,046 --> 00:26:00,128
我们将表示用来指示 在 

479
00:25:55,002 --> 00:26:04,002
线程 正在执行 是H 路S或T 

480
00:26:01,028 --> 00:26:08,100
然后这个列显示的值 

481
00:26:04,002 --> 00:26:10,086
RDX 线程 数 1和此列 

482
00:26:09,000 --> 00:26:13,017
示出了RDX的 线程数的值 

483
00:26:10,086 --> 00:26:14,151
2右键并自该内核保持 

484
00:26:13,017 --> 00:26:17,049
所有的单独副本

485
00:26:15,051 --> 00:26:22,065
通用寄存器的每个

486
00:26:17,049 --> 00:26:23,097
每个线程这些可以是不同的好吗 

487
00:26:22,065 --> 00:26:29,127
然后这最后一列显示 

488
00:26:23,097 --> 00:26:31,149
在内存计数的 值 ，因此，让我们开始 

489
00:26:30,027 --> 00:26:36,102
执行所以最初计数等于 

490
00:26:32,049 --> 00:26:38,148
0和线程一个得到内核 

491
00:26:37,002 --> 00:26:42,038
调度线程的线程1，因此执行 

492
00:26:39,048 --> 00:26:44,115
说， 对 对数 没有影响CH1 

493
00:26:42,038 --> 00:26:50,094
那么线程1个负载计数的值

494
00:26:45,015 --> 00:26:53,037
到 了RDX的副本， 所以现在对其进行更新 

495
00:26:50,094 --> 00:26:55,116
我们的DX等于1家，然后商店 

496
00:26:53,037 --> 00:26:58,068
在RDX该值

497
00:26:56,016 --> 00:27:02,061
回算 那么现在算等于 1 

498
00:26:58,068 --> 00:27:05,073
就在这个 点的内核决定 

499
00:27:02,061 --> 00:27:08,070
调度线程-所以线程 2开始 

500
00:27:05,073 --> 00:27:13,080
执行和它开始时执行 

501
00:27:08,007 --> 00:27:20,022
计数的值是1，从而它执行h的 

502
00:27:13,008 --> 00:27:23,022
然后，我给它 装算入艺术 融入 

503
00:27:20,085 --> 00:27:24,140
线2的RDX的副本， 所以现在我们的DX 

504
00:27:23,094 --> 00:27:27,182
等于1

505
00:27:25,004 --> 00:27:32,012
更新它现在是等于 2，然后 

506
00:27:28,082 --> 00:27:37,100
多数民众赞成看重回店来算

507
00:27:33,002 --> 00:27:40,049
内核 然后决定哦，然后再 

508
00:27:38,000 --> 00:27:42,098
在完成执行 尾 

509
00:27:40,067 --> 00:27:45,092
指令，让我们说，我们只是

510
00:27:42,098 --> 00:27:47,141
这样做的这个，然后一次迭代的 

511
00:27:45,092 --> 00:27:49,145
这一点上，内核决定 

512
00:27:48,041 --> 00:27:53,045
调度线程之一，因为线程2是 

513
00:27:50,045 --> 00:27:54,086
完成这样的线程1执行 

514
00:27:53,045 --> 00:27:57,119
剩下的说法，这有

515
00:27:54,086 --> 00:28:01,100
执行在这一点上两个线程 

516
00:27:58,019 --> 00:28:04,043
完成和计数等于2 

517
00:28:02,000 --> 00:28:09,029
这是值我们希望确定，所以 

518
00:28:04,043 --> 00:28:10,091
这所以这是 确定 并注意使 

519
00:28:09,029 --> 00:28:12,058
这其实是这是一个同盟间 

520
00:28:10,091 --> 00:28:18,182
该工程确定我们得到正确的 值 

521
00:28:12,058 --> 00:28:20,129
并注意 我 是如何 做一组 3 

522
00:28:19,082 --> 00:28:24,128
这实际上涉及到的指令

523
00:28:21,029 --> 00:28:26,096
和更新算在一起，我们将 

524
00:28:25,028 --> 00:28:28,070
调用我们会打电话给那些3 

525
00:28:26,096 --> 00:28:30,119
指令的关键部分 ，我已经 

526
00:28:28,007 --> 00:28:34,013
颜色编码，让您能轻松地 

527
00:28:31,019 --> 00:28:36,056
跟踪它们的 行 现在 让我们 看看 

528
00:28:34,076 --> 00:28:39,119
让我们来看看另一个另一 

529
00:28:36,056 --> 00:28:41,138
交织是可行的，但右 

530
00:28:40,019 --> 00:28:47,042
在这种情况下，它会导致错误的

531
00:28:42,038 --> 00:28:51,137
值确定，所以在这里我们先从 线程1 

532
00:28:47,042 --> 00:28:55,124
再次，它加载它的计数值 

533
00:28:52,037 --> 00:28:59,090
到 了RDX的副本 更新，但随后 

534
00:28:56,024 --> 00:29:03,029
之前， 我 可以存储它 的内核决定 

535
00:28:59,009 --> 00:29:07,022
调度线程-所以线程2开始 

536
00:29:03,029 --> 00:29:11,050
X执行它加载到计算它的拷贝 

537
00:29:08,003 --> 00:29:16,091
RDX的-和通知数仍为0 

538
00:29:11,005 --> 00:29:20,054
右侧是它的 1 在它的价值 

539
00:29:16,091 --> 00:29:22,094
线程1在RDX RDX的副本 

540
00:29:20,099 --> 00:29:27,164
线程1，但它并没有被更新中 

541
00:29:23,021 --> 00:29:31,076
内存故当线程时负载2 

542
00:29:28,064 --> 00:29:34,148
其计值现在它的复制和RDX 

543
00:29:31,076 --> 00:29:37,097
是0就在这个点的内核 

544
00:29:35,048 --> 00:29:38,124
重新排定线程1执行这样

545
00:29:37,097 --> 00:29:43,186
线程1做它

546
00:29:39,024 --> 00:29:47,028
或者它的RDX的副本进入次数和 

547
00:29:44,059 --> 00:29:50,400
然后执行完它的故事 

548
00:29:47,028 --> 00:29:52,089
指令上校重新安排 

549
00:29:50,004 --> 00:29:57,090
线程可拿起离开的地方 

550
00:29:52,089 --> 00:30:02,136
关闭它 更新的计数的复印件 

551
00:29:58,026 --> 00:30:06,695
所以现在RDX从0到1，然后进入它

552
00:30:03,036 --> 00:30:08,103
该值 装入计数 ，以便所有门店

553
00:30:06,929 --> 00:30:11,520
我们所做的是，我们已经覆盖数 

554
00:30:09,003 --> 00:30:14,022
出 值1，我们已经直接覆盖 

555
00:30:11,052 --> 00:30:16,077
为 1的值， 所以当我们完成 

556
00:30:14,022 --> 00:30:22,089
这两个线程 的 执行 数有 

557
00:30:16,077 --> 00:30:23,151
错误的值的 好 ，则 

558
00:30:22,089 --> 00:30:25,140
一般像一般的一点需要注意 

559
00:30:24,051 --> 00:30:28,116
你是怎么看这些关键部分 

560
00:30:26,004 --> 00:30:32,079
已经正确交错在这 

561
00:30:29,016 --> 00:30:35,040
这种情况下，这是第一 临界 

562
00:30:33,015 --> 00:30:39,021
线程1部分之前 所 执行 的 

563
00:30:35,004 --> 00:30:40,913
线程2 确定，但在 关键部分 

564
00:30:39,075 --> 00:30:43,148
这种情况下，两个关键部分 

565
00:30:41,309 --> 00:30:44,480
交错好吗 

566
00:30:45,064 --> 00:30:49,066
让我们看看那另一个例子所以 

567
00:30:48,064 --> 00:30:53,110
在这里你可以看到，这些 都是 

568
00:30:49,084 --> 00:31:02,543
交错如此 陈腐表明，它可能 

569
00:30:54,001 --> 00:31:03,200
一个问题是，所以我原谅 

570
00:31:10,039 --> 00:31:24,077
还有没有好 了，问题是我会 

571
00:31:14,169 --> 00:31:29,380
或者数数，如果我们还好是找

572
00:31:24,077 --> 00:31:32,976
这种不稳定的 它没有我呀，这样 

573
00:31:29,038 --> 00:31:35,587
这就是为什么我的意思实际上和 

574
00:31:33,669 --> 00:31:38,210
编译器可以编译这个

575
00:31:35,929 --> 00:31:39,770
以不同的方式代码右边 有 

576
00:31:38,021 --> 00:31:42,050
实际上是一个增量指令 

577
00:31:39,077 --> 00:31:45,083
将增加它在内存中的变量

578
00:31:42,005 --> 00:31:47,018
所以你可以做的编译器

579
00:31:45,083 --> 00:31:48,152
可能生成此这三 

580
00:31:47,063 --> 00:31:49,159
指令序列是一个指令

581
00:31:49,052 --> 00:31:53,087
然后我们就没有这个问题 

582
00:31:50,059 --> 00:31:57,097
但 问题是，这是它的它的 

583
00:31:53,087 --> 00:31:59,126
加载到寄存器 中，然后 

584
00:31:57,097 --> 00:32:04,186
递增，然后保存，以便 

585
00:32:00,026 --> 00:32:07,028
问题就来了约，因为我们可以这样 

586
00:32:05,059 --> 00:32:09,980
这个线程可以在 它 之前中断 

587
00:32:07,046 --> 00:32:14,101
完成这三步序列本 

588
00:32:09,098 --> 00:32:14,101
负载修改存储序列是 

589
00:32:16,004 --> 00:32:19,004
北 

590
00:32:20,029 --> 00:32:25,052
这 将又不干 ，因此 这是正确的 

591
00:32:23,018 --> 00:32:26,060
是的，我想我没有 清除它 

592
00:32:25,052 --> 00:32:28,139
防止它被存储 

593
00:32:26,006 --> 00:32:31,097
永久在寄存器中右所以它

594
00:32:29,039 --> 00:32:33,098
如果它可能要被装载到 

595
00:32:32,051 --> 00:32:36,134
注册，但随后 它会被写 回 

596
00:32:33,098 --> 00:32:37,106
还好，而编译 器将有 

597
00:32:37,034 --> 00:32:41,045
就像我们已经 与当地 看到 它的选项

598
00:32:38,078 --> 00:32:42,176
变量权的编译器只是 把它 

599
00:32:41,045 --> 00:32:44,123
从未分配 税基它 只是不断 

600
00:32:43,076 --> 00:32:46,117
在寄存器 ，局部 变量的所有 

601
00:32:45,023 --> 00:32:49,034
时间好了，所以这也是预防 

602
00:32:47,017 --> 00:32:56,024
归因防止编译器 

603
00:32:49,034 --> 00:32:56,041
这样做的好了，让我们来看看另一个 

604
00:32:56,024 --> 00:33:01,031
例 

605
00:32:57,004 --> 00:33:05,057
所以在这里线程一个开始，它加载 它 

606
00:33:01,094 --> 00:33:07,193
负载数到 RDX那么线程2 

607
00:33:05,057 --> 00:33:13,064
启动和加载帐户，这是 

608
00:33:08,093 --> 00:33:15,131
仍是0到2 RDX更新它，然后 

609
00:33:13,064 --> 00:33:19,120
它存储所以现在算等于1时

610
00:33:16,031 --> 00:33:24,038
线程1恢复更新其价值 

611
00:33:20,002 --> 00:33:27,011
计数和RDX 并存储回 

612
00:33:25,001 --> 00:33:33,023
计数等我们再次，我们有 

613
00:33:27,029 --> 00:33:34,061
同样的问题还行， 因此问题 

614
00:33:33,023 --> 00:33:37,070
这里要说的是我们这些交错

615
00:33:34,061 --> 00:33:40,100
这些关键部分，你可以 

616
00:33:37,007 --> 00:33:42,011
明白这是为什么不好用一个漂亮的 

617
00:33:41,000 --> 00:33:45,004
排序的图形技术的称为 

618
00:33:42,074 --> 00:33:44,140
进度图

619
00:33:47,004 --> 00:33:54,012
所以，在进度图，如果我们有四个 N 

620
00:33:53,004 --> 00:34:00,009
线程是二维笛卡尔的N-

621
00:33:55,002 --> 00:34:03,006
电网为特征的执行 

622
00:34:00,045 --> 00:34:06,057
并发螺纹的状态空间

623
00:34:03,024 --> 00:34:09,443
节目所以在这种情况下，每个在这里我们

624
00:34:06,057 --> 00:34:14,126
有两个线程所以这是一个这是一个它是一个 

625
00:34:09,659 --> 00:34:16,685
图2d坐标系，使每个各轴 

626
00:34:14,639 --> 00:34:19,667
代表进度执行 

627
00:34:16,919 --> 00:34:23,015
一些螺纹的进展，以便在x轴 

628
00:34:19,919 --> 00:34:27,720
这里是一个线程和y轴 

629
00:34:23,879 --> 00:34:30,450
对应于螺纹2和然后每个

630
00:34:27,072 --> 00:34:32,151
这些边缘中的一个对应于所述 

631
00:34:30,045 --> 00:34:35,121
在指令执行好了，所以我们 

632
00:34:33,051 --> 00:34:39,170
开始时在 初始 状态，然后 

633
00:34:36,021 --> 00:34:41,108
我们执行的第一件事就是H1如此 

634
00:34:39,629 --> 00:34:45,570
多数民众赞成这个本弧这里代表

635
00:34:42,008 --> 00:34:48,024
所以这个这个位置这点权 

636
00:34:45,057 --> 00:34:51,102
在这里表示 ，我们已经 将 状态 

637
00:34:48,024 --> 00:34:54,057
执行^ h我们执行完毕H1在 

638
00:34:52,002 --> 00:34:57,078
线程1，但我们还没有 执行任何 

639
00:34:54,057 --> 00:34:58,134
在线程2 OK指令，因此在 

640
00:34:57,078 --> 00:35:01,167
一般来说，这些 点 的每一点 

641
00:34:59,034 --> 00:35:05,097
代表排序的当前进度 

642
00:35:02,067 --> 00:35:07,071
该程序 或执行 状态 的 这样 

643
00:35:05,097 --> 00:35:10,125
例如，这这种情况下就 在这里 

644
00:35:07,071 --> 00:35:14,097
表示 的状态下螺纹1具有 

645
00:35:11,025 --> 00:35:18,083
完成了完成的L1和线程2是 

646
00:35:14,097 --> 00:35:17,183
完成S2

647
00:35:21,002 --> 00:35:27,009
现在程序的执行是 

648
00:35:25,023 --> 00:35:30,069
建模为从 一个状态 的过渡 

649
00:35:27,027 --> 00:35:33,056
其他 和有一些使从 

650
00:35:30,069 --> 00:35:37,718
由此而有关于 如何 约束 

651
00:35:33,299 --> 00:35:42,302
对这些这些国家如何推进 

652
00:35:38,339 --> 00:35:44,490
所以从这个状态L1S来呀明显 

653
00:35:42,599 --> 00:35:46,680
时间不能倒退的权利，所以我们 

654
00:35:44,049 --> 00:35:48,848
不能，我们不能倒退想在这个 

655
00:35:46,068 --> 00:35:51,437
方向向左 ，我们不能去 

656
00:35:49,289 --> 00:35:55,530
下好了，所以我们只能 往右走 

657
00:35:52,049 --> 00:35:58,140
和上， 因为我们假定 

658
00:35:55,053 --> 00:35:59,151
每个 指令 只 执行 有 

659
00:35:58,014 --> 00:36:02,183
一条指令执行时间我们

660
00:36:00,051 --> 00:36:05,360
不能斜着走那会是两个

661
00:36:02,309 --> 00:36:10,740
说明右所以从 L1 S到 

662
00:36:05,819 --> 00:36:13,823
接下来的执行状态是不是在这里，IFS 

663
00:36:10,074 --> 00:36:17,393
一个线程执行或在这里 如果螺纹 

664
00:36:13,859 --> 00:36:19,880
线程执行好了，你可以把

665
00:36:18,059 --> 00:36:23,087
所有这些在一起，形成一个轨迹 

666
00:36:19,088 --> 00:36:26,267
表征的一个执行 

667
00:36:23,339 --> 00:36:29,010
程序右和任何 可行的组 

668
00:36:27,059 --> 00:36:34,520
从一种状态过渡到下一个 

669
00:36:29,001 --> 00:36:44,088
对应于一个可行的轨迹，从而 

670
00:36:34,052 --> 00:36:49,148
因此对于例H 1升1个ü1个 小时2升2 S 1 T＆ 

671
00:36:44,088 --> 00:36:54,096
1 U 2 U 2 号第2和T 2 

672
00:36:50,048 --> 00:36:58,095
这是一个可行的 ，这是一个可行的 

673
00:36:55,068 --> 00:37:01,217
轨迹，它是一个可能的话，

674
00:36:58,095 --> 00:37:04,173
表示一个可能的执行左右

675
00:37:01,829 --> 00:37:08,150
一组的交错此的

676
00:37:05,073 --> 00:37:07,115
程序

677
00:37:09,349 --> 00:37:15,371
现在这些1b中这三这三个 

678
00:37:12,027 --> 00:37:18,042
说明陆和 S是该操作 

679
00:37:15,569 --> 00:37:22,430
操作数形式我们称之为 

680
00:37:18,042 --> 00:37:22,043
对于关键部分 来算 

681
00:37:24,005 --> 00:37:31,026
而这个想法是，里面的说明

682
00:37:28,859 --> 00:37:33,750
这些关键部分将是 

683
00:37:31,026 --> 00:37:38,028
对于计算出相同的全球 

684
00:37:33,075 --> 00:37:40,116
变量不应该 ，所以我们 交错 

685
00:37:38,028 --> 00:37:42,090
可以通过利用几何抓住这个

686
00:37:41,016 --> 00:37:46,041
这些关键的交点 

687
00:37:42,009 --> 00:37:50,045
部分就形成了我们 所说 的 不安全 

688
00:37:46,041 --> 00:37:55,056
区域所以在这和不安全的地区

689
00:37:51,026 --> 00:37:57,365
是不安全的区域内的点

690
00:37:55,056 --> 00:38:00,060
是在执行那些那些点

691
00:37:57,599 --> 00:38:03,990
其中临界区正在 或 

692
00:38:00,096 --> 00:38:05,124
交错好了，所以这个特定 

693
00:38:03,099 --> 00:38:08,121
例如有内部的四点 

694
00:38:06,024 --> 00:38:10,089
不安全的区域，如果一个曾经的轨迹

695
00:38:09,021 --> 00:38:12,048
倒是那些点之一，那么我们已经 

696
00:38:10,089 --> 00:38:16,268
交错的关键部分， 我们很 

697
00:38:12,048 --> 00:38:18,072
会得到 错误的答案好了， 

698
00:38:17,069 --> 00:38:21,680
这个想法是尽量留 出的这些 

699
00:38:18,072 --> 00:38:20,168
不安全的地区

700
00:38:23,048 --> 00:38:29,144
如果我们这样做，我们说的是轨迹 

701
00:38:26,009 --> 00:38:33,014
为安全 所以这里 的 一个例子 

702
00:38:30,044 --> 00:38:35,072
轨迹是安全的，现在这是好的 

703
00:38:33,095 --> 00:38:37,234
权这一点就 在这里 不 

704
00:38:35,072 --> 00:38:39,721
不安全的区域，因为我们还没有 

705
00:38:38,089 --> 00:38:44,091
执行我们已经执行H1在这里 

706
00:38:40,369 --> 00:38:47,390
记得有一个 点对应于和它的 

707
00:38:44,109 --> 00:38:53,420
我们已经完成了指令

708
00:38:47,039 --> 00:38:54,047
该指令所以后来所以在这里我们 

709
00:38:53,042 --> 00:38:56,093
踢脚不安全的地区，但它 

710
00:38:55,019 --> 00:38:58,908
还是好了 ，所以这是一个安全的轨迹 

711
00:38:56,093 --> 00:39:03,772
我们会找到正确答案，这一个 

712
00:38:59,079 --> 00:39:09,082
但是这个轨迹是不安全 

713
00:39:04,609 --> 00:39:12,655
因为它在其进入不安全区域 

714
00:39:09,109 --> 00:39:16,250
在这一点上这里即使它 

715
00:39:13,069 --> 00:39:17,510
迅速退出有一个 

716
00:39:16,025 --> 00:39:21,121
交错有一个创建

717
00:39:17,051 --> 00:39:21,058
潜在的一个正确的 答案 

718
00:39:26,007 --> 00:39:31,176
好了，问题 是我们怎么样 

719
00:39:29,008 --> 00:39:32,092
保证安全的轨道，这是 

720
00:39:31,869 --> 00:39:38,410
这该是我们所谓的同步 

721
00:39:33,064 --> 00:39:40,102
所以在某种程度上我们希望，我们 要排序的 

722
00:39:38,041 --> 00:39:45,097
配置内核， 这样永远也不会 

723
00:39:41,002 --> 00:39:47,811
安排一个不安全的轨迹所以怎么办

724
00:39:45,097 --> 00:39:52,153
我们这样做 

725
00:39:47,829 --> 00:39:55,930
所以在某种程度上 我们，我们必须同步 

726
00:39:53,053 --> 00:39:58,054
那些线程的执行和另一 

727
00:39:55,093 --> 00:39:59,098
办法想这是 我们需要 

728
00:39:58,054 --> 00:40:04,054
保证互斥访问 

729
00:40:00,043 --> 00:40:06,118
在关键部分因此一旦一次 

730
00:40:04,054 --> 00:40:08,122
内核开始，一旦线程开始 

731
00:40:07,018 --> 00:40:11,026
实际执行的第一条指令 

732
00:40:09,022 --> 00:40:14,023
在它的关键部分，我们不希望它 

733
00:40:11,026 --> 00:40:16,039
由另一个线程中断是 

734
00:40:14,023 --> 00:40:17,122
也有类似的关键部分，我们没关系 

735
00:40:16,039 --> 00:40:19,105
不 希望它被打断我们不 

736
00:40:18,022 --> 00:40:22,117
想一个一个关键部分

737
00:40:20,005 --> 00:40:24,091
对于某些 全局变量是 

738
00:40:23,017 --> 00:40:27,216
由具有另一个线程中断

739
00:40:24,091 --> 00:40:29,188
没事这是目前内 

740
00:40:27,369 --> 00:40:46,210
同样重要的部分好遗憾是 

741
00:40:30,088 --> 00:40:46,096
问题好了，所以问题 是怎么 

742
00:40:46,021 --> 00:40:49,069
有可能是你 得到一个正确的 

743
00:40:47,068 --> 00:40:51,075
轨迹和它发生 的权利，你可以 

744
00:40:49,069 --> 00:40:56,070
运行它，有时你这样做只是取决于 

745
00:40:52,038 --> 00:40:59,056
通常这是错的，有时它是正确的 

746
00:40:56,007 --> 00:41:00,088
它只是取决于它只是取决于 

747
00:40:59,056 --> 00:41:04,078
内核如何 安排它， 你不能 

748
00:41:01,051 --> 00:41:06,130
假定任何特定调度权 

749
00:41:04,078 --> 00:41:08,101
所以，如果你说，如果你想，如果你想 

750
00:41:07,003 --> 00:41:10,782
声称你 永远不会得到 

751
00:41:09,001 --> 00:41:12,076
正确的答案那么你就假设 

752
00:41:11,079 --> 00:41:15,153
内核总是会 安排 

753
00:41:12,076 --> 00:41:16,168
不安全的轨迹，但你不能

754
00:41:15,819 --> 00:41:20,250
假设实际上它 并不有时 

755
00:41:17,068 --> 00:41:19,125
你只是很幸运 

756
00:41:22,066 --> 00:41:27,255
然后事实证明， 你有 你 

757
00:41:26,044 --> 00:41:31,093
必须调用此函数一个漂亮 

758
00:41:27,849 --> 00:41:33,930
为了 使绊 了这么大数量 

759
00:41:31,093 --> 00:41:36,115
将是有意义的权利是 

760
00:41:33,093 --> 00:41:41,222
通常什么什么内核所做的是 

761
00:41:37,015 --> 00:41:45,174
我们只能安排

762
00:41:42,059 --> 00:41:46,155
我们只能重新安排你知道一个线程

763
00:41:45,309 --> 00:41:50,710
换出来，并安排另一个线程 

764
00:41:47,019 --> 00:41:52,047
在当有一些例外， 所以没关系 

765
00:41:50,071 --> 00:41:52,970
其将控制传递 回 

766
00:41:52,299 --> 00:41:56,230
核心 

767
00:41:53,609 --> 00:41:59,230
所以这些异常有两种形式

768
00:41:56,023 --> 00:42:00,852
无论是叫助理制作系统 

769
00:41:59,023 --> 00:42:03,552
调用，以便将那将陷 入 

770
00:42:01,059 --> 00:42:06,060
内核所以这是例外的形式 或 

771
00:42:03,759 --> 00:42:08,763
定时器中断 熄灭这 

772
00:42:06,069 --> 00:42:11,121
控制转移回回 

773
00:42:08,799 --> 00:42:13,990
内核所以计时器定时器 

774
00:42:11,589 --> 00:42:16,617
在间隔会去像 

775
00:42:13,099 --> 00:42:20,478
毫秒右所以，如果我们 只是 

776
00:42:16,869 --> 00:42:23,910
在每个线程的时候做一个迭代

777
00:42:21,369 --> 00:42:25,690
一个线程得到执行的机会 

778
00:42:24,279 --> 00:42:28,930
非常低的定时器会 去 

779
00:42:25,069 --> 00:42:32,140
而线程执行 你关闭

780
00:42:28,093 --> 00:42:34,096
知道这是它的小环但我们和 

781
00:42:33,004 --> 00:42:35,103
我们没有做任何系统调用 权 

782
00:42:35,023 --> 00:42:38,074
所以有没有什么的，虽然 

783
00:42:36,039 --> 00:42:40,158
没有什么我们不是 我们不是 

784
00:42:38,074 --> 00:42:42,139
我们不是我们 不是通过 控制回 

785
00:42:40,509 --> 00:42:45,250
到内核必须让自己的 唯一 

786
00:42:43,039 --> 00:42:48,678
办法内核是会得到 访问 

787
00:42:45,025 --> 00:42:50,047
如果定时器中断熄灭，所以如果 

788
00:42:49,029 --> 00:42:53,980
我们正在做一个非常 小的数目 

789
00:42:50,047 --> 00:42:55,066
迭代以你知道的概率 

790
00:42:53,098 --> 00:42:58,887
所以这里的它会定时间隔 

791
00:42:55,066 --> 00:43:01,215
关在这里这个是这样的时间间隔

792
00:42:59,769 --> 00:43:03,700
概率， 我们必须 

793
00:43:01,809 --> 00:43:05,890
这就是线程将不得不一直

794
00:43:03,007 --> 00:43:07,030
定时器中断前 右计划

795
00:43:05,089 --> 00:43:09,708
将关闭或中断一个或 

796
00:43:07,093 --> 00:43:11,191
两个迭代 所以事实证明，我们有 

797
00:43:10,509 --> 00:43:15,400
安排 我们必须调用这个 

798
00:43:12,091 --> 00:43:18,166
与 ITER 中 的 很多功能 

799
00:43:15,004 --> 00:43:20,086
是相当大，使得该 

800
00:43:19,066 --> 00:43:23,925
定时器中断的 概率 

801
00:43:21,022 --> 00:43:26,841
在那段 期间会关闭

802
00:43:24,519 --> 00:43:29,603
该循环，但得到越来越大 

803
00:43:27,039 --> 00:43:30,071
这是有道理的

804
00:43:35,089 --> 00:43:39,137
所以从这个经典的解决方案来 

805
00:43:37,739 --> 00:43:44,160
从最早期的20世纪60年代 一个 

806
00:43:39,569 --> 00:43:47,606
著名计算机科学家荷兰人 

807
00:43:44,016 --> 00:43:50,405
名为埃德加·埃德加·戴克斯特拉，他想出了 

808
00:43:47,939 --> 00:43:51,020
与经典的第一 溶液中以 

809
00:43:50,549 --> 00:43:55,565
这个问题是我们要什么 

810
00:43:51,749 --> 00:43:56,831
看着它，它仍然是 第一它的 

811
00:43:55,709 --> 00:43:59,738
基本的和非常通用 和 

812
00:43:57,569 --> 00:44:03,630
还有的存在一直 多次迭代和 

813
00:43:59,999 --> 00:44:06,010
这个想法，但信号灯的变化

814
00:44:03,063 --> 00:44:11,672
分别为第一和经典的解决方案 

815
00:44:06,109 --> 00:44:17,640
我们来看看好了，所以信号灯 

816
00:44:12,239 --> 00:44:20,130
是一个非全球整数这 

817
00:44:17,064 --> 00:44:26,453
用作由同步变量

818
00:44:20,013 --> 00:44:30,592
两内核函数称为 PMž我们 

819
00:44:27,029 --> 00:44:30,097
两个系统调用称为 P和V 

820
00:44:32,014 --> 00:44:41,015
这些P＆V或对应于荷兰 

821
00:44:35,012 --> 00:44:42,065
话，但我们才刚刚我们 只是给他们打电话 

822
00:44:41,015 --> 00:44:47,081
你只要 学会 P和V权 

823
00:44:42,065 --> 00:44:52,124
他们做了什么什么，所以每一种需要

824
00:44:47,081 --> 00:44:56,156
作为信号 和P的一个参数

825
00:44:53,024 --> 00:45:03,026
操作有以下语义如果 

826
00:44:57,056 --> 00:45:08,057
如果s是非零然后减 1 它 

827
00:45:03,044 --> 00:45:11,090
并立即返回这个 测试，如果 

828
00:45:08,066 --> 00:45:14,087
它，它的非零和减量 

829
00:45:11,009 --> 00:45:23,024
发生原子那么那么他们永远是 

830
00:45:14,087 --> 00:45:27,158
然而打断如果s 为零 ，则 

831
00:45:24,005 --> 00:45:32,087
暂停本线程，直到S成为非 

832
00:45:28,058 --> 00:45:38,102
零和线程，然后重新启动 

833
00:45:32,087 --> 00:45:41,144
通过V 操作没关系所以如果T，如果 

834
00:45:39,002 --> 00:45:44,053
信号量是零和 P只是阻止它只是 

835
00:45:42,044 --> 00:45:48,062
被暂停，直到它被重新启动 

836
00:45:44,053 --> 00:45:51,152
通过V 操作，然后它经过 

837
00:45:48,062 --> 00:45:55,063
现在重新启动P操作可以 

838
00:45:52,052 --> 00:45:58,087
减量S按一个和 返回控制 

839
00:45:55,063 --> 00:45:58,087
呼叫者 

840
00:46:02,349 --> 00:46:07,414
还好在Z操作只值被增加了 

841
00:46:05,018 --> 00:46:10,867
一个和该增量不像 

842
00:46:07,999 --> 00:46:12,680
算上加再加，我们望着眼前 

843
00:46:11,029 --> 00:46:15,031
看着那个增量出现 

844
00:46:12,068 --> 00:46:18,187
原子好了，所以它绝不可能 

845
00:46:15,229 --> 00:46:22,258
中断，然后它增加后 

846
00:46:18,799 --> 00:46:24,170
s时，检查，看看是否有任何任何 

847
00:46:22,519 --> 00:46:25,600
被阻止在 豌豆线程

848
00:46:24,017 --> 00:46:28,846
操作以便你 能想到 的内核 

849
00:46:26,329 --> 00:46:31,375
只是让那些线程队列

850
00:46:28,999 --> 00:46:34,220
阻塞在豌豆操作和V 

851
00:46:31,789 --> 00:46:36,410
操作它增加后 的IT 

852
00:46:34,022 --> 00:46:38,851
该排队任何任何线程检查

853
00:46:36,041 --> 00:46:40,690
这被阻止，因为当他们 

854
00:46:39,049 --> 00:46:45,200
豌豆操作信号量为零 

855
00:46:41,059 --> 00:46:46,087
然后重新启动正好一个 

856
00:46:45,002 --> 00:46:48,053
在一些不确定的那些线程

857
00:46:46,339 --> 00:46:52,130
订购一些工人没关系， 你不能 

858
00:46:48,071 --> 00:46:56,072
你不能假设它只是使用一个挑选

859
00:46:52,013 --> 00:47:03,040
有的一些选择算法，它和

860
00:46:56,072 --> 00:47:07,651
然后将其它它畅通 悬浮 

861
00:47:03,004 --> 00:47:09,077
挂起的进程，然后 

862
00:47:08,299 --> 00:47:12,910
完成它的豌豆操作由 

863
00:47:10,013 --> 00:47:12,091
是递减

864
00:47:16,619 --> 00:47:20,770
好吧，这看起来很简单 ，但 

865
00:47:19,045 --> 00:47:23,053
它可以 是 一种很难 让你的头 

866
00:47:20,077 --> 00:47:33,175
第一次 在 你 身边 看到这么 

867
00:47:23,053 --> 00:47:38,071
有关于PMD任何问题好了， 

868
00:47:34,075 --> 00:47:41,164
该核心理念， 大会 

869
00:47:38,071 --> 00:47:45,084
P和V的这些定义是，它 

870
00:47:42,064 --> 00:47:47,125
规定了信号量不变

871
00:47:45,084 --> 00:47:51,172
所谓信号灯不变的是

872
00:47:48,025 --> 00:47:55,644
S的是，对于 一个信号量 重塑： 

873
00:47:52,072 --> 00:47:56,131
操作上通过P和D操作 s是 

874
00:47:55,869 --> 00:47:59,580
总是大于或等于零 

875
00:47:57,031 --> 00:47:59,058
好的 

876
00:48:00,119 --> 00:48:05,920
而这 似乎 并不 非常令人兴奋的 ，但 

877
00:48:03,097 --> 00:48:06,163
事实证明，这是 一个非常有用的 

878
00:48:05,092 --> 00:48:09,139
物业，这将使我们执行 

879
00:48:07,063 --> 00:48:13,131
这些相互互斥

880
00:48:10,039 --> 00:48:17,130
所以 T和 V 的关键部分 

881
00:48:14,031 --> 00:48:21,067
操作由P个线程中提供

882
00:48:18,003 --> 00:48:23,047
三个函数的形式有一个 

883
00:48:21,067 --> 00:48:24,130
肖明它的功能它初始化

884
00:48:23,074 --> 00:48:26,155
信号量一定的价值 

885
00:48:25,003 --> 00:48:30,076
好了，信号量可以初始化 

886
00:48:27,055 --> 00:48:36,118
到大于 任何任意值 或等于 

887
00:48:31,003 --> 00:48:41,011
到零一些重量是T操作 

888
00:48:37,018 --> 00:48:43,102
有的岗位是V 工作好吗 

889
00:48:41,083 --> 00:48:46,117
因为我是老派 

890
00:48:44,002 --> 00:48:50,841
我为那些在提供包装函数

891
00:48:47,017 --> 00:48:55,068
中称为P的硅Si PP点.h文件 

892
00:48:50,859 --> 00:48:55,680
和D 还好 它也更紧凑 

893
00:48:59,279 --> 00:49:08,310
好了，所以记得我们的召回 我们的越野车 

894
00:49:04,599 --> 00:49:13,150
程序调用坏计数II这 是 

895
00:49:08,589 --> 00:49:14,628
让我们为计数错误的答案，所以 

896
00:49:13,015 --> 00:49:20,041
我们如何使用信号量来解决这个问题 

897
00:49:14,979 --> 00:49:25,900
节目所以基本的想法是创建一个 

898
00:49:20,041 --> 00:49:27,067
信号量，其被初始化 为1， 并 

899
00:49:25,009 --> 00:49:28,368
因此按照定义 ，我们会打电话给任何 

900
00:49:27,067 --> 00:49:31,069
信号量，其被初始化为1 

901
00:49:29,259 --> 00:49:34,930
多数民众赞成用于 相互提供 

902
00:49:31,069 --> 00:49:36,888
排除我们会打电话给一个互斥体 好吗 

903
00:49:34,093 --> 00:49:41,372
这可以追溯到 早期的Dijkstra 

904
00:49:37,509 --> 00:49:44,607
论文，所以我们唯一的关联互斥

905
00:49:42,209 --> 00:49:49,215
初始化为1，为每个共享

906
00:49:45,489 --> 00:49:51,537
变量在我们的程序 确定，所以在这 

907
00:49:49,269 --> 00:49:52,365
案例数我们已经算 ， 所以 我们 有一个 

908
00:49:51,969 --> 00:49:56,034
共享变量，我们关心 

909
00:49:53,229 --> 00:49:59,170
约所以我们，我们将创建一个新的文本 

910
00:49:56,619 --> 00:50:02,170
将调用互斥体，然后你 

911
00:49:59,017 --> 00:50:06,816
围绕与关键部分

912
00:50:02,017 --> 00:50:09,606
对于与你叫 PE 豌豆数 

913
00:50:06,969 --> 00:50:12,690
那么你执行关键部分 

914
00:50:09,759 --> 00:50:12,690
然后调用V 

915
00:50:14,039 --> 00:50:17,115
现在有一些有一些

916
00:50:16,289 --> 00:50:21,150
术语我们将使用我们谈 

917
00:50:18,015 --> 00:50:24,093
关于信号灯所以二进制信号 

918
00:50:21,015 --> 00:50:27,644
是在所述信号值始终0 1 

919
00:50:24,093 --> 00:50:28,862
再一个互斥这算哪门子 它是一个 

920
00:50:27,779 --> 00:50:34,140
多数民众赞成在使用 二进制 信号 

921
00:50:29,699 --> 00:50:37,757
互斥P 操作是 

922
00:50:34,014 --> 00:50:40,493
称为加锁互斥将指 

923
00:50:38,279 --> 00:50:44,375
V被有时解锁或释放

924
00:50:40,619 --> 00:50:46,664
互斥并且如果一个进程保持 

925
00:50:45,239 --> 00:50:53,130
互斥那么这意味着它已经 

926
00:50:47,069 --> 00:50:55,073
锁定但不是不可不释放， 

927
00:50:53,013 --> 00:50:56,462
互斥体和二进制 信号 s 为 

928
00:50:55,109 --> 00:51:00,116
总是被初始化为1

929
00:50:56,579 --> 00:51:02,627
会计旗语和互斥 

930
00:51:00,809 --> 00:51:04,862
用于相互 排斥 的借口 ，但你 

931
00:51:03,059 --> 00:51:08,066
还可以使用信号量来 排序 的 数 

932
00:51:05,339 --> 00:51:11,426
在系统中， 常常事件 

933
00:51:08,759 --> 00:51:15,660
那些占信号灯有几分 

934
00:51:12,209 --> 00:51:24,215
是大于 1 的非非值

935
00:51:15,066 --> 00:51:26,525
好了， 为互斥，我们将做的 

936
00:51:24,809 --> 00:51:30,821
解决我们的节目，我们创建一个新 程序 

937
00:51:27,119 --> 00:51:34,208
所谓的好计数C在 这里 ， 我们 

938
00:51:30,929 --> 00:51:38,972
初始化一个互斥体，我们创建一个互斥体和 

939
00:51:35,009 --> 00:51:42,044
它初始化到1，然后我们环绕 

940
00:51:39,359 --> 00:51:44,396
的关键部分，其是 3 

941
00:51:42,359 --> 00:51:46,385
汇编语言指令体现 

942
00:51:44,729 --> 00:51:49,380
实现这个数加上加 

943
00:51:46,619 --> 00:51:54,682
指令我们 用P 包围它 

944
00:51:49,038 --> 00:51:58,867
通过V加上它，如果我们这样做 

945
00:51:55,249 --> 00:51:58,345
我们始终得到正确的 答案 

946
00:51:59,098 --> 00:52:04,121
但你知道 P和D 我们的系统调用 等等 

947
00:52:03,859 --> 00:52:06,680
还有的开销与这些相关的

948
00:52:05,021 --> 00:52:08,110
所以他们不是事实上 它们是 免费的 

949
00:52:06,068 --> 00:52:09,667
数量级这个程序运行上 

950
00:52:08,299 --> 00:52:13,375
数量级比慢

951
00:52:10,279 --> 00:52:20,420
不正确马车版本没事 如此如此 

952
00:52:14,059 --> 00:52:22,062
为什么这些互斥体工作，所以这里我们

953
00:52:20,042 --> 00:52:25,046
搞到现在的进度图，我们已经 

954
00:52:22,359 --> 00:52:28,700
我们装饰我们的计划与P 和 V 

955
00:52:25,046 --> 00:52:30,140
操作所以 我们把在P前 

956
00:52:28,007 --> 00:52:35,012
关键的部分，我们执行的关键

957
00:52:31,004 --> 00:52:37,903
部分，然后我们称之为V和现在如果 

958
00:52:36,002 --> 00:52:41,099
你看 一个 数P和ZP 

959
00:52:38,299 --> 00:52:44,325
递增P的总和递减 

960
00:52:42,017 --> 00:52:47,093
签署 为单位递增 信号灯 前 

961
00:52:44,559 --> 00:52:51,230
所以，如果你只是 看价值 

962
00:52:47,093 --> 00:52:54,188
该 信号在每一个点的

963
00:52:51,023 --> 00:52:59,048
执行状态空间， 你会得到这些 

964
00:52:55,088 --> 00:53:00,140
你会得到这些值，以便我们在这里 

965
00:52:59,048 --> 00:53:04,093
在原点初始化信号 

966
00:53:01,004 --> 00:53:10,453
我们把它初始化为1这样的价值 

967
00:53:04,093 --> 00:53:12,122
我们 在原点 信号 为1， 

968
00:53:10,849 --> 00:53:15,740
比方说，我们只是待着 所以我们 

969
00:53:13,022 --> 00:53:20,048
刚刚执行的线程1小时1后如此 

970
00:53:15,074 --> 00:53:22,076
信号为1，我们做PE的 

971
00:53:20,048 --> 00:53:26,065
信号量是1因此P只是坐在递减

972
00:53:22,094 --> 00:53:29,149
和现在前进因此该信号

973
00:53:26,065 --> 00:53:33,089
值变为0，并将其保持 为零 

974
00:53:30,049 --> 00:53:36,053
直到我们执行V和，当我们 

975
00:53:33,089 --> 00:53:39,188
完成执行在V信号量

976
00:53:36,089 --> 00:53:42,140
现在的问题是是1再次确定 ，所以，如果我们经历 

977
00:53:40,088 --> 00:53:46,091
类似的道理，如果我们看一下

978
00:53:43,004 --> 00:53:50,090
轨迹去了任何一点 

979
00:53:47,018 --> 00:53:55,040
状态空间让我们说，让我们说这个 

980
00:53:51,026 --> 00:53:59,305
点这里 所以 到那里我们 

981
00:53:55,004 --> 00:54:03,083
可能我们可以执行的线程1到 

982
00:53:59,539 --> 00:54:08,450
至此完成 L1，然后 

983
00:54:04,019 --> 00:54:11,097
执行H 2，然后做这个 

984
00:54:08,045 --> 00:54:15,048
指向信号量是0 

985
00:54:11,097 --> 00:54:17,130
然后茶递减信号使 

986
00:54:15,075 --> 00:54:18,120
现在是零下之一，但就是这样的 

987
00:54:18,003 --> 00:54:21,072
不可能

988
00:54:19,002 --> 00:54:24,087
不能发生，因为P个块 

989
00:54:21,099 --> 00:54:27,141
记住，如果如果信号量是0 P 

990
00:54:25,005 --> 00:54:31,016
块不 好吗 递减这么 

991
00:54:28,041 --> 00:54:35,118
第t操作的语义

992
00:54:31,016 --> 00:54:39,045
禁止这这这是转型

993
00:54:36,018 --> 00:54:41,049
禁止在转变到状态 

994
00:54:39,045 --> 00:54:47,118
而信号量是零的状态 

995
00:54:41,049 --> 00:54:49,092
哪里会减 1， 所以它 

996
00:54:48,018 --> 00:54:52,065
创建它创造了我们所说的 

997
00:54:49,092 --> 00:54:54,186
禁止区域所以这些这些点 

998
00:54:52,065 --> 00:54:59,072
在状态空间， 旗语 

999
00:54:55,086 --> 00:55:02,097
将有减1的值

1000
00:54:59,072 --> 00:55:07,095
不可行，可从来没有 达到 

1001
00:55:02,097 --> 00:55:09,102
的T和V的 行，从而定义

1002
00:55:07,095 --> 00:55:14,126
此这 形成的禁区域 

1003
00:55:10,047 --> 00:55:17,109
周围的不安全区域，这样做 

1004
00:55:15,026 --> 00:55:19,122
提供互斥访问

1005
00:55:18,009 --> 00:55:26,013
你向在每个临界区

1006
00:55:20,022 --> 00:55:30,057
线程好了，所以如果是这样，这 是 

1007
00:55:26,013 --> 00:55:32,049
根本原因T公司和V的CAN 

1008
00:55:30,057 --> 00:55:34,058
被用来提供互斥

1009
00:55:32,049 --> 00:55:34,067
访问

1010
00:55:36,035 --> 00:55:45,040
因此， 在这个任何问题 我解释过 

1011
00:55:41,006 --> 00:55:44,014
这么清楚，有没有问题 

1012
00:55:47,044 --> 00:55:52,663
没事不错嘛你 去你 

1013
00:55:49,091 --> 00:55:59,050
获得去年初离开的话，在工作

1014
00:55:53,059 --> 00:56:02,630
您Mallik实验室没事 ，所以我们会看到 

1015
00:55:59,869 --> 00:56:04,220
你周一我们要看看 一些 

1016
00:56:02,063 --> 00:56:05,075
排序的一些高级的主题，这是 

1017
00:56:04,022 --> 00:56:08,131
像她第一次接触 

1018
00:56:05,075 --> 00:56:10,894
周二同步，我们来看看 

1019
00:56:08,329 --> 00:56:13,400
在同步更高级的主题

1020
00:56:11,569 --> 00:56:15,571
在方式方法，你可以使用信号灯

1021
00:56:13,004 --> 00:56:16,090
为提供其他其他更 

1022
00:56:15,589 --> 00:56:22,720
有趣的其他有趣的种 

1023
00:56:17,026 --> 00:56:22,072
为你的程序的同步好吗 

