1
00:00:00,003 --> 00:00:05,252
所以我们现在已经通过所有得到

2
00:00:02,073 --> 00:00:07,077
机器代码讲座和我们 

3
00:00:05,279 --> 00:00:09,840
开始谈论现在没事了，你 

4
00:00:08,013 --> 00:00:13,095
知道这东西有什么可以用它做什么

5
00:00:09,084 --> 00:00:15,117
这讲座 沿行 

6
00:00:13,095 --> 00:00:18,254
这是 那种 你现在 什么 

7
00:00:16,017 --> 00:00:21,072
授权现在你 可以看看 做 

8
00:00:19,109 --> 00:00:24,600
并理解机器码这 

9
00:00:21,072 --> 00:00:26,073
材料是一 点点 ，它实际上 

10
00:00:24,006 --> 00:00:28,062
有本书的一整章 

11
00:00:26,073 --> 00:00:29,148
在 性能优化 第 5 章 

12
00:00:29,016 --> 00:00:32,935
而我们只打算做一个讲座 

13
00:00:30,048 --> 00:00:35,079
它和我们没有 任何实验室 

14
00:00:33,079 --> 00:00:37,980
不幸的是，真正让你

15
00:00:35,079 --> 00:00:38,438
把你的极限在这里面太 

16
00:00:37,098 --> 00:00:40,101
不好，因为它是一个非常有趣的 

17
00:00:39,149 --> 00:00:44,520
话题和一个我认为你会发现 

18
00:00:41,028 --> 00:00:47,073
自己配备齐全，有 

19
00:00:44,052 --> 00:00:49,053
通常是一些小考试的问题， 

20
00:00:47,073 --> 00:00:51,107
是那种基于一些 

21
00:00:49,053 --> 00:00:54,066
材料在这里你会发现在旧考试 

22
00:00:52,007 --> 00:00:59,066
但真正的想法 是如何才能让 

23
00:00:54,066 --> 00:01:02,067
程序跑得快给我几分 

24
00:00:59,129 --> 00:01:06,000
知道我使用的是什么算法，我已经 

25
00:01:02,067 --> 00:01:09,586
也许是得到运行程序如何 

26
00:01:06,000 --> 00:01:13,059
我可以让它运行 得更快和 的 一个 

27
00:01:10,189 --> 00:01:16,140
它的主题是，你可以排序的做 

28
00:01:13,059 --> 00:01:21,152
这层可以排序 第一的 

29
00:01:16,014 --> 00:01:25,035
所有这样做的东西，以避免排序 

30
00:01:22,052 --> 00:01:27,120
事情让程序运行缓慢 

31
00:01:25,035 --> 00:01:30,734
跨多种设备和 

32
00:01:28,002 --> 00:01:33,491
只是让你 和我将之形容 

33
00:01:31,049 --> 00:01:35,280
为使您的代码更编译 

34
00:01:33,689 --> 00:01:36,782
友好，我们将谈论什么 

35
00:01:35,028 --> 00:01:39,042
意味着 你必须有一些 

36
00:01:37,619 --> 00:01:40,715
理解和欣赏什么 

37
00:01:39,042 --> 00:01:43,781
编译器善于和 他们是什么 

38
00:01:41,579 --> 00:01:46,290
不擅长，能够做到这一点， 我 

39
00:01:44,159 --> 00:01:48,160
描述这些作为样的东西 

40
00:01:46,029 --> 00:01:50,070
你应该只是 在习惯 

41
00:01:48,259 --> 00:01:52,590
当你写的程序写这 

42
00:01:50,007 --> 00:01:55,089
代码，我会形容为编译器 

43
00:01:52,059 --> 00:01:59,948
友好的，然后一个新的 水平是好的 

44
00:01:56,052 --> 00:02:01,331
因为我已经有点带走 

45
00:02:00,479 --> 00:02:04,110
事情真的应该已经 

46
00:02:01,799 --> 00:02:06,420
有摆在首位，现在怎么可以 

47
00:02:04,011 --> 00:02:08,890
让我的程序运行得更快

48
00:02:06,042 --> 00:02:11,097
特别是我怎么能适应 

49
00:02:08,989 --> 00:02:13,200
该类型的能力

50
00:02:11,097 --> 00:02:14,148
机，这个方案 

51
00:02:13,002 --> 00:02:17,007
要上运行，并能 再次去 

52
00:02:15,048 --> 00:02:19,092
从那些通常会使 

53
00:02:17,025 --> 00:02:22,086
计划跨多种跑得快

54
00:02:19,092 --> 00:02:25,095
机器的人 的 那个变得 非常 

55
00:02:22,086 --> 00:02:27,090
具体的和非常具体是一个危险的 

56
00:02:25,095 --> 00:02:30,494
的事，因为即使是在世界上的发言权 

57
00:02:28,026 --> 00:02:33,048
x86上有很多种的 

58
00:02:31,349 --> 00:02:36,180
他们可在 任何给定 

59
00:02:33,048 --> 00:02:38,837
在 时间点和它们随着时间的推移 

60
00:02:36,018 --> 00:02:42,033
还有 这样 你就可以使程序运行 

61
00:02:39,269 --> 00:02:46,290
对一个特定型号的真快

62
00:02:42,033 --> 00:02:48,039
一个x86处理器，但可能无法在其 

63
00:02:46,029 --> 00:02:50,061
如果你想太硬，你会发现 

64
00:02:48,093 --> 00:02:51,147
你的努力是有点浪费，当你 

65
00:02:50,061 --> 00:02:53,070
它移动到另一个 ， 另一方面 

66
00:02:52,047 --> 00:02:55,134
这些总体思路我要去

67
00:02:53,007 --> 00:02:58,098
实际描述跨越相当工作 

68
00:02:56,034 --> 00:03:04,113
机器的范围，这样，我就说说 

69
00:02:59,061 --> 00:03:06,069
更多的 ，因为我们走，因此用于 

70
00:03:05,013 --> 00:03:08,432
在坏日子，如果 你 

71
00:03:06,069 --> 00:03:09,168
要 编程，运行速度快，你必须 

72
00:03:08,549 --> 00:03:12,510
写汇编代码，这只是 

73
00:03:10,068 --> 00:03:14,237
平原不再 成立了，如果有人 

74
00:03:12,051 --> 00:03:17,120
告诉你，这是真的 ， 那是 因为他们是 

75
00:03:14,849 --> 00:03:19,950
充满了它，它只是不 除非 真 

76
00:03:17,579 --> 00:03:21,632
除特殊情况

77
00:03:19,095 --> 00:03:25,095
你在一个非常 小的 资源 运行 

78
00:03:22,109 --> 00:03:30,131
约束机如非常小的 

79
00:03:25,095 --> 00:03:30,162
动力不足的嵌入式系统等等，让我们 

80
00:03:30,329 --> 00:03:33,690
只是假设， 我们将使用 

81
00:03:31,062 --> 00:03:34,131
编译器，我们将为此承担 

82
00:03:33,069 --> 00:03:36,123
当然，我们要 使用GCC因为 

83
00:03:35,031 --> 00:03:38,100
这是一般可用它不是 

84
00:03:37,023 --> 00:03:42,902
其实最好的编译器在那里 

85
00:03:39,000 --> 00:03:45,989
英特尔做一个编译器，它的成本钱 

86
00:03:43,109 --> 00:03:48,510
它 真的 许可之类的东西，但它 

87
00:03:45,989 --> 00:03:51,011
可以做一些令人惊讶的事情 和其他 

88
00:03:48,051 --> 00:03:55,120
编译器存在，但GCC是排序的 

89
00:03:51,209 --> 00:03:55,246
足够好的编译器对于大多数人 

90
00:03:55,091 --> 00:04:00,168
但有一些事一些功能 

91
00:03:59,094 --> 00:04:03,263
那种拼图的编译器 ，它们 

92
00:04:01,068 --> 00:04:05,657
真的不明白编译器不

93
00:04:04,109 --> 00:04:09,030
真正理解例如，该 

94
00:04:06,269 --> 00:04:11,306
当你说你正在使用的号码是

95
00:04:09,003 --> 00:04:15,072
一个INT 实际上可能范围在更 

96
00:04:11,639 --> 00:04:17,639
设置值越小，他们有一个 

97
00:04:15,072 --> 00:04:19,391
很很难理解 记忆 

98
00:04:17,639 --> 00:04:22,910
参考图案和效果 

99
00:04:20,039 --> 00:04:22,910
过程调用

100
00:04:24,083 --> 00:04:32,099
所以一般用 什么 的 发生 

101
00:04:28,035 --> 00:04:35,106
编译器是它有一个整体的排序 

102
00:04:32,099 --> 00:04:37,146
的优化策略和食谱

103
00:04:36,006 --> 00:04:42,009
一些食谱如何尝试 

104
00:04:38,046 --> 00:04:44,058
不同的战略和应用它们，但 

105
00:04:42,036 --> 00:04:46,122
一般来说，如果它曾经感觉这 

106
00:04:44,058 --> 00:04:48,060
代码是什么，给人的感觉并不 

107
00:04:47,022 --> 00:04:50,088
自信能够做出 

108
00:04:48,078 --> 00:04:52,167
某些变革，但它只是 

109
00:04:50,088 --> 00:04:54,171
不会，将保持事情更 

110
00:04:53,067 --> 00:04:57,135
直接执行的到底 是什么 

111
00:04:55,071 --> 00:05:01,098
你描述的， 我们将展示 的 例子 

112
00:04:58,035 --> 00:05:03,126
随着我们一起出去，这样的事儿 

113
00:05:01,098 --> 00:05:05,106
优化编译器总是有一个 

114
00:05:04,026 --> 00:05:08,103
备用位置，这是不 

115
00:05:06,006 --> 00:05:10,098
优化有时候会得到

116
00:05:09,003 --> 00:05:15,096
麻烦，如果你希望你的程序 运行 

117
00:05:10,098 --> 00:05:16,197
更快，编译器只是在自己的

118
00:05:15,096 --> 00:05:19,131
保守Ÿ决定不 这样做 

119
00:05:17,097 --> 00:05:21,189
优化 和 技巧 的一个 

120
00:05:20,031 --> 00:05:24,090
你会发现，现在，这是非常有用的 

121
00:05:22,089 --> 00:05:26,157
您可以阅读汇编代码运行 

122
00:05:24,009 --> 00:05:29,055
编译器你看到了什么优化 

123
00:05:27,057 --> 00:05:31,101
它，如果它没有的东西 

124
00:05:30,036 --> 00:05:34,044
你希望它能够做到你 

125
00:05:32,001 --> 00:05:38,028
回去弄清楚 所以很 

126
00:05:34,044 --> 00:05:42,087
通过改写的方式共同您 

127
00:05:38,028 --> 00:05:47,049
程序在相同的语言，而不是 

128
00:05:42,087 --> 00:05:48,183
调 并 达到使其运行速度更快 

129
00:05:47,049 --> 00:05:51,084
使其 更友好的编译器是 

130
00:05:49,083 --> 00:05:52,146
有什么不妥 ，只要 

131
00:05:51,084 --> 00:05:54,084
因为你不那么只是 完全 

132
00:05:53,046 --> 00:05:58,107
泯程序， 使它 

133
00:05:54,084 --> 00:06:00,159
完全无法辨认所以我们只描述 

134
00:05:59,007 --> 00:06:04,032
某种一般的优化和 

135
00:06:01,059 --> 00:06:05,115
你亲眼看见 的 这个版本 

136
00:06:04,032 --> 00:06:10,050
一些汇编代码 中 我们已经 

137
00:06:06,015 --> 00:06:13,044
看着哦，我会主要使用排序 

138
00:06:10,005 --> 00:06:14,090
从多维数组的例子

139
00:06:13,044 --> 00:06:18,069
因为那些实际上是 相当容易 

140
00:06:15,035 --> 00:06:20,082
任务，但这些优化类型 

141
00:06:18,069 --> 00:06:24,144
应用于其它类型的程序作为 

142
00:06:20,082 --> 00:06:27,120
， 所以你当我们描述以前看到 

143
00:06:25,044 --> 00:06:31,703
如何做数组索引 中 

144
00:06:28,002 --> 00:06:35,049
多维数组 ， 老 

145
00:06:32,099 --> 00:06:37,770
的代码风格，如果你有一个变量 

146
00:06:35,067 --> 00:06:40,116
眼睛阵列 是由你的 

147
00:06:37,077 --> 00:06:43,134
程序员写 的如何式 

148
00:06:41,016 --> 00:06:47,058
您转换行我J列成

149
00:06:44,034 --> 00:06:49,050
在一个 一维阵列 位置 ，从而 

150
00:06:47,058 --> 00:06:51,105
记住它的列的 只是数 

151
00:06:49,005 --> 00:06:54,018
次 行号加列 

152
00:06:52,005 --> 00:06:57,054
数字标准之一，所以，会给

153
00:06:54,063 --> 00:06:59,121
了，这将是非常典型的代码 

154
00:06:57,054 --> 00:07:02,133
那就给你 喜欢 的符号 

155
00:07:00,021 --> 00:07:06,108
这一点，如果你想设置一个轨排 

156
00:07:03,033 --> 00:07:12,036
在在一个值阵列的

157
00:07:07,008 --> 00:07:15,012
B的维的行是这样的码 

158
00:07:12,036 --> 00:07:17,049
你会写，主要是观察 

159
00:07:15,012 --> 00:07:21,030
这个循环的唯一变量内

160
00:07:17,049 --> 00:07:24,063
这就是变化为J，因此从 

161
00:07:21,003 --> 00:07:26,070
阵列角度来看你的这种计算 

162
00:07:24,063 --> 00:07:28,161
n次我，如果它被 不断地重复 

163
00:07:26,097 --> 00:07:32,103
一遍又一遍这个循环中，然后你 

164
00:07:29,061 --> 00:07:34,149
只是在浪费这是浪费精力 ，所以你 

165
00:07:33,003 --> 00:07:39,036
可以做什么所谓的代码议案， 

166
00:07:35,049 --> 00:07:41,070
是预先计算的n倍值I 

167
00:07:39,036 --> 00:07:44,040
循环 再使用外过来 

168
00:07:41,007 --> 00:07:48,015
一遍又一遍 的内部和编译器会 

169
00:07:44,004 --> 00:07:51,042
通常这样做时，他们可以检测

170
00:07:48,078 --> 00:07:53,124
例如，它是一个数组访问 

171
00:07:51,078 --> 00:07:56,082
代码和它有这个技术， 它会 

172
00:07:54,024 --> 00:08:00,042
一般做优化， 这样，如果 

173
00:07:57,018 --> 00:08:08,055
你设置要说1的优化级别

174
00:08:00,042 --> 00:08:10,125
或更高GCC，我们可以在此看到 

175
00:08:08,055 --> 00:08:14,058
事实上， 这是该代码，我跑了 

176
00:08:11,025 --> 00:08:16,074
通过使用GCC优化 1，你 

177
00:08:14,085 --> 00:08:17,181
看到因为这样 读指令显示它 

178
00:08:16,074 --> 00:08:21,161
推动这个乘法之外 

179
00:08:18,081 --> 00:08:24,180
循环并就好像你一点点 

180
00:08:22,061 --> 00:08:26,070
其实这个代码更加 它 

181
00:08:25,008 --> 00:08:29,106
转码成的东西， 看起来 

182
00:08:27,051 --> 00:08:34,089
更像一个指针代码访问数组 

183
00:08:30,078 --> 00:08:39,087
和通过该元素通过步进 

184
00:08:34,089 --> 00:08:42,165
所述阵列另外一个元件和 

185
00:08:40,068 --> 00:08:45,120
我们已经看到了这个已经当GCC 

186
00:08:43,065 --> 00:08:46,944
把一个乘法或除法由 

187
00:08:46,002 --> 00:08:50,121
移位和AD 

188
00:08:47,529 --> 00:08:51,566
和这样的 乘法 运算 

189
00:08:50,319 --> 00:08:54,310
或者除以常数

190
00:08:51,899 --> 00:09:03,160
我们已经看到了一个 例子，说和 

191
00:08:54,031 --> 00:09:07,123
如果，如果我们采取了类似一个会发生

192
00:09:03,016 --> 00:09:11,041
那个节目我之前表现出与应用 

193
00:09:08,023 --> 00:09:13,060
它的每一行，所以我们要设置其 

194
00:09:11,041 --> 00:09:15,210
数组我们要设定每一个 

195
00:09:13,006 --> 00:09:20,095
其行 之一的 值 

196
00:09:15,579 --> 00:09:23,230
维阵列乙然后再次，如果我们我们 

197
00:09:21,049 --> 00:09:27,078
把这些代码我们提振了结束时间 

198
00:09:23,023 --> 00:09:29,622
我在那里所以现在内环好 

199
00:09:27,519 --> 00:09:31,930
但你知道，这个乘法 

200
00:09:29,829 --> 00:09:34,660
是没有必要的，因为无论是什么

201
00:09:31,093 --> 00:09:36,732
我们从 我做等于0至我等于 

202
00:09:34,066 --> 00:09:40,245
1至I等于2 是我们只是增加 

203
00:09:37,569 --> 00:09:44,574
参数 NI通过我们添加结束 

204
00:09:40,839 --> 00:09:45,936
它使我们能够而且这就是所谓的一 

205
00:09:45,069 --> 00:09:48,093
强度下降，我们已经采取了 

206
00:09:46,809 --> 00:09:48,906
乘法和把它变成 

207
00:09:48,309 --> 00:09:52,314
此外，由于有一些 

208
00:09:49,779 --> 00:09:56,980
怎么这个变量的预测图案

209
00:09:52,809 --> 00:09:59,410
NI将被更新的另一 

210
00:09:56,098 --> 00:10:02,110
例如，再次数组索引是 

211
00:09:59,041 --> 00:10:07,770
好榜样的优化设想 

212
00:10:03,001 --> 00:10:10,027
我们有我们代表作为一个图像

213
00:10:08,139 --> 00:10:14,290
像素值的二维阵列 

214
00:10:10,036 --> 00:10:16,036
我们想要做什么一个什么东西 

215
00:10:14,029 --> 00:10:19,087
过滤操作，我们要 

216
00:10:16,036 --> 00:10:21,118
采取的四个邻国的总和 

217
00:10:19,087 --> 00:10:25,056
给定像素南北东，西 

218
00:10:22,018 --> 00:10:29,367
一起平均那些 或它们求和 

219
00:10:25,839 --> 00:10:34,895
在一起， 所以 自然 的 方式，你会 

220
00:10:29,529 --> 00:10:39,490
写这篇文章，看看是说我想 

221
00:10:35,399 --> 00:10:43,428
通常在你的图像从顶部数

222
00:10:39,049 --> 00:10:46,518
下来，所以你说这 是在 

223
00:10:43,689 --> 00:10:48,690
上述该像素低于该像素 

224
00:10:46,959 --> 00:10:53,982
是像素 的左边， 这是 

225
00:10:48,699 --> 00:10:55,787
像素 ，如果你这样做是正确 的 

226
00:10:54,189 --> 00:10:59,800
和公正编译直通 

227
00:10:56,579 --> 00:11:00,587
不幸的是，看起来好像有 

228
00:10:59,008 --> 00:11:05,377
三种不同的乘法

229
00:11:01,379 --> 00:11:09,660
用n 我减1加我1， 我和若 

230
00:11:06,169 --> 00:11:11,246
编译器为聪明 也不会实现 

231
00:11:09,066 --> 00:11:12,935
这些 都是相互关联的 ，并 

232
00:11:11,939 --> 00:11:15,660
它会发出三种不同的乘法 

233
00:11:13,529 --> 00:11:17,534
操作只是做这一个像素 

234
00:11:15,066 --> 00:11:20,455
事情而如果我多一点 

235
00:11:18,029 --> 00:11:23,093
聪明，这是一个其中I手动 

236
00:11:21,049 --> 00:11:28,118
重写了代码，所以编译器会 

237
00:11:23,669 --> 00:11:32,970
把它捡起来我会说好，如果我， 所以 我和 

238
00:11:28,739 --> 00:11:35,970
J是我N次加J和我可以得到 

239
00:11:32,097 --> 00:11:37,646
上述下方的像素由像素 

240
00:11:35,097 --> 00:11:42,356
移该关闭设置，通过一个 

241
00:11:38,519 --> 00:11:44,573
n个值，然后它会发出 

242
00:11:43,229 --> 00:11:47,270
这个代码将与代码编译

243
00:11:45,059 --> 00:11:49,148
与只有 一个乘法和一般 

244
00:11:47,639 --> 00:11:52,661
它 成倍 的方式 曾经是一个非常 

245
00:11:49,949 --> 00:11:54,020
昂贵的指令时下足够 

246
00:11:52,859 --> 00:11:55,940
这大约需要硬件资源

247
00:11:54,659 --> 00:11:58,664
三个时钟周期，所以它不是 一个巨大的 

248
00:11:56,669 --> 00:12:00,704
交易，但任何时候 ，你可以采取三种 

249
00:11:59,159 --> 00:12:08,207
乘法，并只使用一个替代 

250
00:12:01,019 --> 00:12:10,022
通常是一个好主意， 这样的问题 

251
00:12:08,639 --> 00:12:11,684
问题是，如果你 想 什么 

252
00:12:10,319 --> 00:12:14,324
优化 您的空间，也有很多 

253
00:12:12,089 --> 00:12:18,092
优化，这将使你的 

254
00:12:14,819 --> 00:12:19,350
代码是在更大的代价 

255
00:12:18,119 --> 00:12:21,146
为了走得更快 权 

256
00:12:19,035 --> 00:12:24,254
这一次，虽然我要说这是

257
00:12:21,389 --> 00:12:25,457
实际上较短的代码正确和公正

258
00:12:24,569 --> 00:12:28,643
看看指令数，从而 

259
00:12:26,069 --> 00:12:31,070
通常这样的代码，你知道使用 

260
00:12:29,309 --> 00:12:33,317
是一个更大的问题时的记忆是

261
00:12:31,169 --> 00:12:36,266
那种你知道回到 原 

262
00:12:33,389 --> 00:12:40,412
IBM PC有内存640千字节所以在

263
00:12:37,139 --> 00:12:42,218
其最大的配置，这 是一个 

264
00:12:40,619 --> 00:12:44,663
大不了实际购买那么远那么 

265
00:12:42,929 --> 00:12:47,850
你知道 当时 这是 一个大问题 

266
00:12:45,059 --> 00:12:49,157
记忆，但现在内存的大小 

267
00:12:47,085 --> 00:12:50,564
的程序通常是 一个非常 小的 

268
00:12:50,039 --> 00:12:55,066
你要处理什么用的分数

269
00:12:51,329 --> 00:12:54,427
总体但它是一个 有效的问题 

270
00:12:56,058 --> 00:13:01,095
好吧，这 只是给出了一个例子 

271
00:12:59,022 --> 00:13:04,086
和一般的编译器都还不错 

272
00:13:01,095 --> 00:13:05,984
在做这些 低级别的优化 

273
00:13:04,086 --> 00:13:08,094
这样，如果你编写代码的 方式 

274
00:13:06,839 --> 00:13:11,730
这是合理的，但有一些其他 

275
00:13:08,094 --> 00:13:13,125
那些编译器，甚至在 

276
00:13:11,073 --> 00:13:15,141
你可以 买到 高档的编译器 可能不 

277
00:13:14,025 --> 00:13:18,069
能够计算出来 ， 所以我喜欢 

278
00:13:16,041 --> 00:13:21,045
说明这与当第一 

279
00:13:18,069 --> 00:13:25,658
长期我们曾经聊到十三我 

280
00:13:21,045 --> 00:13:27,114
看一些实验室代码，一些

281
00:13:26,279 --> 00:13:30,990
学生写的，我被 吓坏了 

282
00:13:28,014 --> 00:13:32,963
这段代码和我把它拿给 

283
00:13:30,099 --> 00:13:33,162
TAS 和他们没有想出什么 

284
00:13:33,089 --> 00:13:37,145
是错的，我也出了许多 

285
00:13:34,062 --> 00:13:39,461
其他训练有素的C程序员 

286
00:13:37,649 --> 00:13:44,070
专业人士那里我们去看起来还好 

287
00:13:40,019 --> 00:13:46,410
我让我们弄清楚我是什么原因 

288
00:13:44,007 --> 00:13:47,076
这段代码吓坏了这样的想法 

289
00:13:46,041 --> 00:13:50,030
这个代码 应该是 相当 

290
00:13:47,076 --> 00:13:53,094
简单有一个字符串s 和我 

291
00:13:50,399 --> 00:13:59,760
希望该 字符串转换所有 

292
00:13:53,094 --> 00:14:00,132
在它字符转换为小写，所以我 

293
00:13:59,076 --> 00:14:03,144
刚刚经历的字符串读取 

294
00:14:01,032 --> 00:14:05,088
并且对于每个字符串的位置测试 

295
00:14:04,044 --> 00:14:09,045
字符， 如果它是介于两者之间 

296
00:14:05,088 --> 00:14:10,113
大写一个， 然后我上如果Z 

297
00:14:09,054 --> 00:14:13,163
将它转移 到 之间 

298
00:14:11,013 --> 00:14:16,222
一个小写字母和小写ž否则我 

299
00:14:13,649 --> 00:14:21,180
将改变它， 非常简单 

300
00:14:16,339 --> 00:14:25,500
但如果你运行这个 你看 ，如果你 

301
00:14:21,018 --> 00:14:29,055
上升到 五十万字，其 

302
00:14:25,005 --> 00:14:32,022
听起来好像很多 ，但它需要 240 

303
00:14:29,055 --> 00:14:36,126
或者这么这么这么 四分钟运行此 

304
00:14:32,067 --> 00:14:38,130
代码和你去嗯 ，这是一个相当 大 的 

305
00:14:37,026 --> 00:14:40,975
字符串它真的不是 一个大的字符串你 

306
00:14:39,003 --> 00:14:43,292
应该能够做到小写 

307
00:14:41,209 --> 00:14:46,140
字符串转换少了很多 

308
00:14:43,589 --> 00:14:47,910
超过 四秒，并同时发现 

309
00:14:46,014 --> 00:14:50,082
这种增长是非线性的是二次 

310
00:14:47,091 --> 00:14:52,122
它的增长作为字符串的方 

311
00:14:50,082 --> 00:14:54,123
长度，这是不好的 

312
00:14:53,022 --> 00:14:57,011
不幸的是它的种类和 

313
00:14:55,023 --> 00:14:59,031
这种方式是对一个它是非常 

314
00:14:57,209 --> 00:15:03,300
易非常容易有计划 

315
00:14:59,031 --> 00:15:05,064
有一些隐藏的参数错误 

316
00:15:03,003 --> 00:15:09,030
这使得它们运行的二次和你 

317
00:15:05,064 --> 00:15:11,133
运行测试，你测试的字符串 

318
00:15:09,057 --> 00:15:14,058
10000以下，它看起来并不 

319
00:15:12,033 --> 00:15:17,046
什么大不了的 ，因为运行时间 

320
00:15:14,067 --> 00:15:20,067
微不足道左右，但随后所有的 

321
00:15:17,046 --> 00:15:25,134
突然它击中一个非常糟糕的情况下，所以这 

322
00:15:20,067 --> 00:15:28,091
是有什么东西错在这里 如此 

323
00:15:26,034 --> 00:15:33,090
什么是如此糟糕有关此计划以及 

324
00:15:28,091 --> 00:15:37,152
关键是去在测试这样 的 

325
00:15:33,009 --> 00:15:39,033
调用sterlin所以它的方式是 

326
00:15:38,052 --> 00:15:42,123
确定无论是走到了尽头 

327
00:15:40,014 --> 00:15:45,089
字符串是通过调用sterlin到 

328
00:15:43,023 --> 00:15:49,026
找出串有多长和 

329
00:15:45,089 --> 00:15:52,131
现在记住，如果我们做的 

330
00:15:49,053 --> 00:15:54,135
转换的for 循环 成细末，以 

331
00:15:53,031 --> 00:15:58,059
格式如您所看到有各种 

332
00:15:55,035 --> 00:16:01,128
方式转换，但所有 他们的 

333
00:15:58,059 --> 00:16:05,085
测试被内置到循环使

334
00:16:02,028 --> 00:16:07,122
那主要特征是这个调用 

335
00:16:05,085 --> 00:16:11,112
sterlin会发生每次你去的时间 

336
00:16:08,022 --> 00:16:16,041
通过循环 和人忽视 

337
00:16:12,012 --> 00:16:18,018
当你看这个事实的不同 

338
00:16:16,041 --> 00:16:21,096
for 循环 的初始化 的部分

339
00:16:18,072 --> 00:16:25,077
只被执行一次，但无论是

340
00:16:21,096 --> 00:16:27,144
测试 和更新获得递增的get 

341
00:16:26,022 --> 00:16:32,037
应用每次通过运行时

342
00:16:28,044 --> 00:16:33,126
循环 因此 ，如果这是越来越称为很多 

343
00:16:32,037 --> 00:16:37,128
倍有字符在 

344
00:16:34,026 --> 00:16:39,123
循环字符串中的权利，现在该怎么做 

345
00:16:38,028 --> 00:16:43,029
sterlin工作记忆和看到的唯一 

346
00:16:40,023 --> 00:16:45,075
你 知道一个字符串是多么漫长的 道路 是 

347
00:16:43,038 --> 00:16:48,111
逐步通过整个事情，找到 

348
00:16:45,075 --> 00:16:51,078
在结束 这样sterlin空字符

349
00:16:49,011 --> 00:16:55,047
本身是在一个线性时间的操作

350
00:16:51,078 --> 00:16:57,084
字符串，你这样做等 

351
00:16:55,047 --> 00:17:01,059
你在做最终调用一个函数 

352
00:16:58,038 --> 00:17:04,049
这需要时间 n 串 越来越 

353
00:17:01,059 --> 00:17:08,093
较短，当您去，但不是非常快 ，所以 

354
00:17:04,049 --> 00:17:08,093
基本上这就是二次性能

355
00:17:09,043 --> 00:17:14,107
并解释为什么 你认为 

356
00:17:11,053 --> 00:17:18,058
运行时 如此特别 ，如果我只是做 

357
00:17:15,007 --> 00:17:23,041
以下变化不大 我介绍 

358
00:17:18,058 --> 00:17:24,136
一个局部变量叫格伦和我的预 

359
00:17:23,041 --> 00:17:26,119
计算sterlin因为该字符串 不是 

360
00:17:25,036 --> 00:17:28,072
字符串的长度没有改变 

361
00:17:27,019 --> 00:17:33,025
我只是改变的字符 

362
00:17:28,072 --> 00:17:35,149
串嗯然后让程序会 

363
00:17:33,025 --> 00:17:38,074
做同样的事情，但现在的运行时间 

364
00:17:36,049 --> 00:17:41,062
那么短 ， 它 甚至 不 显示 它 

365
00:17:38,074 --> 00:17:42,145
这也许是第二次做一百万 

366
00:17:41,062 --> 00:17:45,115
字符它只是没有 什么大不了的 

367
00:17:43,045 --> 00:17:50,059
所有 理所应当的，它只是 运行 

368
00:17:46,015 --> 00:17:52,084
通过所以这只是一个例子 

369
00:17:50,059 --> 00:17:56,083
我在我的 职业生涯 见过很多之一 

370
00:17:52,084 --> 00:17:58,105
这里的东西，似乎差不多

371
00:17:56,083 --> 00:18:03,151
微不足道的原来是 一个严重 

372
00:17:59,005 --> 00:18:08,020
性能问题，为什么 不能一 

373
00:18:04,051 --> 00:18:14,097
编译身影了这一点，为什么不能一 

374
00:18:08,002 --> 00:18:21,040
智能编译器看原来代码 

375
00:18:14,097 --> 00:18:22,180
并说好，你 知道这是什么 

376
00:18:21,058 --> 00:18:25,087
程序员写的，但我知道一个更好的办法 

377
00:18:23,008 --> 00:18:27,063
要做到 这一点，我会预先 在 计算 sterlin 

378
00:18:25,087 --> 00:18:30,139
提前量是否有一对夫妇的原因 

379
00:18:28,035 --> 00:18:33,097
一个 实际上 是 ，如果你 看一下代码 

380
00:18:31,039 --> 00:18:37,123
为sterlin你看，它实际上 

381
00:18:33,097 --> 00:18:39,106
修改字符串和 sterlin我的意思 

382
00:18:38,023 --> 00:18:41,089
这里的代码修改 

383
00:18:40,006 --> 00:18:45,040
字符串，我们呼吁严厉的土地 

384
00:18:41,089 --> 00:18:46,141
它所以你必须非常小心 

385
00:18:45,004 --> 00:18:49,027
做了分析，编译器会以

386
00:18:47,041 --> 00:18:52,090
弄清楚， 即使串 

387
00:18:49,063 --> 00:18:54,079
正在改变你要的结果

388
00:18:52,009 --> 00:19:03,070
从sterlin得到的是不会改变 

389
00:18:54,079 --> 00:19:08,104
右所以这是 一个原因之一和 

390
00:19:04,051 --> 00:19:11,074
第二个是很好，怎么做怎么做的 

391
00:19:09,004 --> 00:19:14,022
可以在编译器哪个版本的

392
00:19:11,074 --> 00:19:16,078
sterlin实际上是要习惯

393
00:19:14,022 --> 00:19:19,090
记住，看到每个文件的获取 

394
00:19:17,014 --> 00:19:22,069
分开 和事后才 编译 

395
00:19:19,009 --> 00:19:22,045
所有这一切得到了汇聚 

396
00:19:22,069 --> 00:19:24,145
链接

397
00:19:23,026 --> 00:19:28,030
而一些即使以后发生 

398
00:19:25,045 --> 00:19:31,048
节目开始 所以即使 

399
00:19:28,003 --> 00:19:33,034
有一个标准sterlin功能，它是

400
00:19:31,048 --> 00:19:34,126
不一定是这样的 情况 

401
00:19:33,061 --> 00:19:38,083
一个将实际 的习惯 

402
00:19:35,026 --> 00:19:40,081
最后的程序，以便编译器真的 

403
00:19:38,083 --> 00:19:42,178
不能肯定的说

404
00:19:40,081 --> 00:19:45,088
特别是想象我提供了一个排序

405
00:19:43,078 --> 00:19:50,083
像这样的 定制 sterlin 功能 

406
00:19:46,051 --> 00:19:51,133
这是保持党 的 总和轨道

407
00:19:50,083 --> 00:19:54,091
所有它的字符串长度

408
00:19:52,033 --> 00:19:59,089
被称为上或其他一些副作用

409
00:19:54,091 --> 00:20:00,157
这样的那么好，即这项 方案 

410
00:19:59,089 --> 00:20:04,093
会产生非常不同的结果 

411
00:20:01,057 --> 00:20:07,060
如果不是，如果我是否我做

412
00:20:04,093 --> 00:20:09,139
优化，因此编译器必须 

413
00:20:07,006 --> 00:20:12,058
假设sterlin仅仅是一个黑盒子 

414
00:20:10,039 --> 00:20:17,047
，做任何它 并不能 

415
00:20:13,012 --> 00:20:19,063
对什么 任何假设 怎么样 

416
00:20:17,047 --> 00:20:22,054
副作用，它可能有 等等 

417
00:20:19,063 --> 00:20:23,124
所以它不会 对最优化 

418
00:20:22,054 --> 00:20:27,070
任何机器 

419
00:20:24,024 --> 00:20:33,052
即使有最好的编译器，这是

420
00:20:27,007 --> 00:20:34,060
只是一个 例子，你可以告诉 

421
00:20:33,052 --> 00:20:37,141
我已经得到了一种致敏 

422
00:20:35,023 --> 00:20:43,116
这让我发现这些只是很多 

423
00:20:38,041 --> 00:20:52,060
人不嗯让我们看看这个 

424
00:20:44,016 --> 00:20:57,037
让我们看看哦，这是另一个坏榜样 

425
00:20:52,006 --> 00:21:02,032
不好的编码例想象我想

426
00:20:57,037 --> 00:21:06,109
来计算二维 阵列的 

427
00:21:02,086 --> 00:21:10,093
在一个 一维阵列 BI要 

428
00:21:07,009 --> 00:21:16,036
做B时B子我是所有 的总和 

429
00:21:10,093 --> 00:21:17,149
在 一 排 我 的元素 ，因此这一次 

430
00:21:16,036 --> 00:21:22,060
是一个相当明显的 一种方式来写 

431
00:21:18,049 --> 00:21:24,094
这个程序，你说好 BI厨师 

432
00:21:22,006 --> 00:21:26,035
0和我要去只是它积累 

433
00:21:24,094 --> 00:21:28,156
我将逐步行和积累 

434
00:21:26,089 --> 00:21:31,162
所有的价值，当然，我们现在知道 

435
00:21:29,056 --> 00:21:34,075
我们可以通过移动i次提高该 

436
00:21:32,062 --> 00:21:35,110
N OUT等等，我并不想 

437
00:21:34,075 --> 00:21:37,123
说明 

438
00:21:36,001 --> 00:21:41,005
但你会在节目中看到这 

439
00:21:38,023 --> 00:21:43,332
是在内部循环，我们想看看 

440
00:21:41,014 --> 00:21:45,112
简单一些浮点 

441
00:21:43,539 --> 00:21:48,591
说明和注意主 

442
00:21:46,012 --> 00:21:50,053
他们的特点是移动指令 

443
00:21:49,059 --> 00:21:53,080
像移动那些你熟悉

444
00:21:50,053 --> 00:21:54,115
与除非我们我们把

445
00:21:53,008 --> 00:21:58,015
在这些XMM之一浮点数据

446
00:21:55,015 --> 00:22:03,061
寄存器，这样你在这里看到的主要的事情 

447
00:21:58,078 --> 00:22:04,150
是它从内存中读取 它的加入 

448
00:22:03,061 --> 00:22:07,114
东西，然后将它的 写作 

449
00:22:05,005 --> 00:22:12,013
回到内存 ，什么内存 

450
00:22:08,014 --> 00:22:14,050
位置对应于I B等什么 

451
00:22:12,058 --> 00:22:15,067
它通过这个循环意味着每一次 

452
00:22:14,005 --> 00:22:19,054
它不必做读 存储器和 

453
00:22:16,048 --> 00:22:23,062
除了 B的存储器写

454
00:22:19,099 --> 00:22:26,170
内存读取，即使可能的

455
00:22:23,062 --> 00:22:30,160
AI的B 是相同的值，可以 

456
00:22:27,007 --> 00:22:33,061
只是把它更新到 了在前面 

457
00:22:31,006 --> 00:22:35,565
这个循环的执行权 ，为什么做 

458
00:22:34,024 --> 00:22:38,026
你要为什么你读它，为什么 

459
00:22:36,159 --> 00:22:41,110
你写出来， 然后读回 

460
00:22:38,026 --> 00:22:42,100
在增量，然后再复制它 

461
00:22:41,011 --> 00:22:44,086
背出它为什么 去保持 

462
00:22:43,000 --> 00:22:48,045
来回跳跃内存之间 

463
00:22:44,086 --> 00:22:51,112
并注册 了一遍又一遍 

464
00:22:48,045 --> 00:22:54,061
良好的原因是因为在C你 

465
00:22:52,012 --> 00:22:56,931
不能肯定有没有什么 

466
00:22:54,061 --> 00:23:00,133
被称为混叠，我演示 

467
00:22:57,039 --> 00:23:07,600
在这里想象一下，如果B行只是

468
00:23:01,033 --> 00:23:09,064
声明是 确定，所以想象 和 

469
00:23:07,006 --> 00:23:13,065
你可以做这在 C，这是合法的C 

470
00:23:09,064 --> 00:23:15,483
代码， 你可以做一个内存中的数据 

471
00:23:13,659 --> 00:23:18,710
结构覆盖另一数据结构 

472
00:23:16,059 --> 00:23:22,090
这所指的内容混淆当两个 

473
00:23:19,169 --> 00:23:23,256
该程序的分开的部分是 

474
00:23:22,009 --> 00:23:26,053
指的是在相同的位置 

475
00:23:24,039 --> 00:23:31,450
内存和C编译器 已经没办法了 

476
00:23:26,053 --> 00:23:32,134
知道是否有大量的工作 

477
00:23:31,045 --> 00:23:36,058
和优化编译器来检测 

478
00:23:33,034 --> 00:23:38,089
赛车可能性，但一般般 

479
00:23:36,058 --> 00:23:41,027
假设混叠可能 因此 发生 

480
00:23:38,089 --> 00:23:44,188
想象这发生混淆 ，使 

481
00:23:41,549 --> 00:23:48,730
阵列B可与它们对应于这 

482
00:23:45,088 --> 00:23:51,089
阵列的行的 

483
00:23:48,073 --> 00:23:52,082
井那么当然它的初始值是 

484
00:23:51,089 --> 00:23:54,188
四后八 16，但如果你追踪 

485
00:23:53,063 --> 00:23:57,071
通过什么这个代码将做到这一点有

486
00:23:55,088 --> 00:24:01,100
那种奇怪的行为可能是

487
00:23:58,043 --> 00:24:05,080
不是任何有用的东西，但它 只是 

488
00:24:02,000 --> 00:24:10,043
表明 会发生什么是 

489
00:24:05,008 --> 00:24:12,044
此为B得到更新它的 有效 

490
00:24:10,043 --> 00:24:18,059
改变和它的变化，然后什么 

491
00:24:13,016 --> 00:24:22,019
求和等过程中被读取

492
00:24:18,059 --> 00:24:23,114
这是C等一种现实的可能性

493
00:24:22,019 --> 00:24:28,061
当它给 像代码 编译器 

494
00:24:24,014 --> 00:24:31,046
这一点， 必须假定这两个 

495
00:24:28,061 --> 00:24:32,155
内存位置可能重叠告上法庭 

496
00:24:31,046 --> 00:24:35,138
对方所以这就是为什么它是仔细 

497
00:24:33,055 --> 00:24:40,142
写出来，然后回读 

498
00:24:36,038 --> 00:24:43,106
在一遍又一遍，因此 ，如果我只是 

499
00:24:41,042 --> 00:24:46,127
通过 再次引入一个 重写这个代码 

500
00:24:44,006 --> 00:24:50,009
局部变量和在该累加 

501
00:24:47,027 --> 00:24:53,033
仅 在端部 的局部 变量，然后 

502
00:24:50,036 --> 00:24:55,112
我签署到B子我那么你会 

503
00:24:53,087 --> 00:24:57,166
看到此相同循环突然

504
00:24:56,012 --> 00:25:04,015
得到了很多简单的，它只是一个读

505
00:24:58,066 --> 00:25:08,129
浮点 读的广告做到这一点， 

506
00:25:04,042 --> 00:25:10,094
我们其实看到内存实际上是 

507
00:25:09,029 --> 00:25:12,101
限制的执行的一个 

508
00:25:10,094 --> 00:25:15,161
在程序的性能限制等等 

509
00:25:13,001 --> 00:25:18,080
这是快速地将是显著和 

510
00:25:16,061 --> 00:25:21,062
再次在这个时候，你作为一个 

511
00:25:18,008 --> 00:25:23,102
程序员将很难 认为这是一个很大的 

512
00:25:21,062 --> 00:25:26,114
交易，但C编译器不能做，在 

513
00:25:24,074 --> 00:25:28,169
一般的，因为它不能确定 

514
00:25:27,014 --> 00:25:31,021
推进什么可能的混淆可以有 

515
00:25:29,069 --> 00:25:31,084
是 

516
00:25:34,369 --> 00:25:40,320
所以这两个例子这么说来获得 

517
00:25:38,519 --> 00:25:43,200
引入局部变量的习惯

518
00:25:40,032 --> 00:25:45,971
并使用它们，那是你的方式

519
00:25:43,002 --> 00:25:47,921
告诉编译器 不会调用相同 

520
00:25:46,259 --> 00:25:49,334
功能翻来覆去不读 

521
00:25:48,119 --> 00:25:52,145
并在写同一个内存位置 

522
00:25:50,009 --> 00:25:54,026
一次又一次地只是 将其保持 在 

523
00:25:52,379 --> 00:25:55,385
暂时的，然后它会 

524
00:25:54,179 --> 00:25:57,227
自动分配的寄存器和

525
00:25:55,979 --> 00:26:02,580
其存储在寄存器和一切 

526
00:25:57,659 --> 00:26:06,752
将是很好的好，这样的排序的 

527
00:26:02,058 --> 00:26:10,187
那种我们称之为优化 

528
00:26:07,589 --> 00:26:12,450
阻滞剂样的事情 ，你作为 

529
00:26:10,709 --> 00:26:13,748
程序员可以做出差异 

530
00:26:12,045 --> 00:26:16,454
和主阻滞剂是存储器

531
00:26:14,099 --> 00:26:20,105
引用别名和函数调用

532
00:26:16,859 --> 00:26:22,862
和体悟 什么可能 

533
00:26:20,159 --> 00:26:24,167
所以现在发生在函数调用 

534
00:26:22,889 --> 00:26:27,200
我们要做的是转变 

535
00:26:24,239 --> 00:26:27,200
问题

536
00:26:43,039 --> 00:26:54,122
我认为你做的区别 

537
00:26:48,031 --> 00:27:00,035
不，不，这是 艾伦·C代码我敢肯定，这 

538
00:26:55,022 --> 00:27:04,061
是LC的代码，因为它跑了，所以这是 

539
00:27:00,071 --> 00:27:06,089
初始化调用它的阵列乙 

540
00:27:04,061 --> 00:27:11,072
记住这些都是在恒星这些都不是 

541
00:27:06,089 --> 00:27:15,152
二维阵列权，所以这是 

542
00:27:11,072 --> 00:27:18,116
话说现在是一个把它看作一个 

543
00:27:16,052 --> 00:27:23,096
九个四个元件的线性阵列

544
00:27:19,016 --> 00:27:26,099
元素和一个加三就是 去 

545
00:27:23,096 --> 00:27:28,103
在三个所以这是它被宣称B是 

546
00:27:26,099 --> 00:27:31,130
不是指针它是一个数组，但请记住

547
00:27:29,066 --> 00:27:34,109
一个数组，你 可以拒绝 该 

548
00:27:32,003 --> 00:27:36,011
该数组作为对基准的命名

549
00:27:35,009 --> 00:27:45,097
指针可读参考不是

550
00:27:37,001 --> 00:28:07,013
写参考对对这个 

551
00:27:45,097 --> 00:28:10,103
也因此， 问题是， 他 为什么要 使用 

552
00:28:07,022 --> 00:28:12,074
空终止字符串，它确实

553
00:28:11,003 --> 00:28:15,056
它可能是一个错误的决定 

554
00:28:12,074 --> 00:28:18,139
多种原因的权利，但我认为 ， 在 

555
00:28:15,056 --> 00:28:22,082
的C一般想到的就是别人谁了 

556
00:28:19,039 --> 00:28:25,097
或一对夫妇的人 谁曾写 

557
00:28:22,082 --> 00:28:27,161
大量的汇编 代码 ，并希望 

558
00:28:25,097 --> 00:28:29,108
提起这个水平，所以他们不 

559
00:28:28,061 --> 00:28:33,074
一遍又一遍地写相同的东西 

560
00:28:30,008 --> 00:28:35,105
再次但是在 如何思维 

561
00:28:33,074 --> 00:28:37,076
我可能是最抽象可能使 

562
00:28:36,005 --> 00:28:40,058
他们试图提供种类的 

563
00:28:37,076 --> 00:28:42,077
上机级的顶部的最小层 

564
00:28:40,058 --> 00:28:43,136
编程，将让他们写 

565
00:28:42,077 --> 00:28:45,161
，可以运行 从一台机器代码 

566
00:28:44,036 --> 00:28:47,114
另一个所以在一切他们做自己 

567
00:28:46,061 --> 00:28:50,096
那种用最简单的 

568
00:28:48,014 --> 00:28:54,020
表示不承担任何 种类 

569
00:28:50,096 --> 00:28:54,162
的有没有数组的你知道最 

570
00:28:54,002 --> 00:28:58,095
语言 

571
00:28:55,062 --> 00:29:01,074
将有数组边界检查和

572
00:28:59,013 --> 00:29:04,080
阵列将是一个数据结构， 其 

573
00:29:01,074 --> 00:29:06,081
将包括它的大小，你所知道的范围内 

574
00:29:04,008 --> 00:29:08,031
价值观和东西，看到的只是不那么 

575
00:29:07,044 --> 00:29:11,142
对看到的一切都是 西装在 

576
00:29:09,003 --> 00:29:21,072
最低限度， 你知道它的存在了 

577
00:29:12,042 --> 00:29:24,114
对于 40 年的东西所以没有帕斯卡尔 

578
00:29:21,072 --> 00:29:27,081
不继续看不出是根本就没有 

579
00:29:25,014 --> 00:29:30,051
真正帕斯卡尔被创造了作为一门语言 

580
00:29:27,081 --> 00:29:32,169
由SONA和力高的教学 

581
00:29:30,051 --> 00:29:35,064
精神，这是非常多的 

582
00:29:33,069 --> 00:29:38,127
教学语言，所以这是真的

583
00:29:35,064 --> 00:29:41,136
旨在帮助 谁需要 学生 

584
00:29:39,027 --> 00:29:46,089
帮助和 c是由专业的设计 

585
00:29:42,036 --> 00:29:49,074
程序员，让他们编写代码

586
00:29:46,089 --> 00:29:50,181
在他们的方式没有得到让 他们感到 非常 

587
00:29:49,074 --> 00:29:55,127
两者之间的不同理论 

588
00:29:51,081 --> 00:29:55,127
语言对是 

589
00:30:01,269 --> 00:30:14,281
那是什么对不起˚F哦，是的，这是一个 

590
00:30:10,025 --> 00:30:16,034
错误那里 我会 仔细检查 这 或 

591
00:30:14,389 --> 00:30:18,468
人们可以检查 它，我敢肯定 

592
00:30:16,034 --> 00:30:22,085
这个代码是好 太多 

593
00:30:19,179 --> 00:30:24,500
如果没有可以肯定地 说双星 

594
00:30:22,085 --> 00:30:37,134
B等于一加三和会 

595
00:30:24,005 --> 00:30:37,404
工作的权利问题，你怎么看 

596
00:30:39,069 --> 00:30:46,093
你认为这是28家我不会 

597
00:30:45,013 --> 00:30:48,088
尝试在手在这里执行它，但让我们 

598
00:30:46,093 --> 00:30:50,104
检查一下你，我会检查这个代码 

599
00:30:48,088 --> 00:30:52,090
出来， 如果它 需要 我们修复它 

600
00:30:51,004 --> 00:31:03,025
固定好感谢指点出来 

601
00:30:53,008 --> 00:31:07,009
是啊 不，不作任何区别 

602
00:31:03,025 --> 00:31:08,029
在这段代码根本不 知道它的 

603
00:31:07,018 --> 00:31:11,095
分配没有什么区别可言 

604
00:31:08,065 --> 00:31:14,080
在这里，所以我会检查 可能是 

605
00:31:11,095 --> 00:31:15,148
双星B等于8 + 3， 但我这个 

606
00:31:14,008 --> 00:31:21,075
是前一阵子， 我写了这个代码 

607
00:31:16,048 --> 00:31:21,147
出来仔细检查它虽然 好了， 

608
00:31:22,077 --> 00:31:32,104
反正这是排序的结束 

609
00:31:25,021 --> 00:31:34,075
故事一个简单简单的乐观主义者 

610
00:31:33,004 --> 00:31:35,086
他们是简单的优化它的 

611
00:31:34,075 --> 00:31:39,100
只是你必须给他们的一种习惯 

612
00:31:35,086 --> 00:31:41,101
没事做， 现在我们要做的 

613
00:31:40,000 --> 00:31:44,047
是去比这个票友一点点， 

614
00:31:42,001 --> 00:31:46,042
我说，这变得有效

615
00:31:44,047 --> 00:31:50,094
系统相关的，但相当多 

616
00:31:46,042 --> 00:31:52,099
现在， 所有的处理器都具有相似的 

617
00:31:50,094 --> 00:31:56,140
实现他们都做什么是已知的

618
00:31:52,099 --> 00:31:59,125
作为乱序 执行 除的

619
00:31:57,004 --> 00:32:02,023
最原始的微控制器等 

620
00:32:00,025 --> 00:32:06,100
这是一种优化的哦，所以 

621
00:32:02,059 --> 00:32:08,086
你会发现 好这个一般方法 

622
00:32:07,000 --> 00:32:13,033
将跨很多种的工作

623
00:32:08,086 --> 00:32:15,109
机器还等什么，我要做的就是为 

624
00:32:13,033 --> 00:32:17,110
通过启动一系列例子做到这一点

625
00:32:16,009 --> 00:32:19,084
一些不是很高效的代码和 

626
00:32:18,001 --> 00:32:25,039
使其运行 速度更快， 更快， 

627
00:32:19,084 --> 00:32:28,117
我们将得到的40左右的速度向上只是 

628
00:32:25,048 --> 00:32:31,060
在做什么，我们正在这样做这 一切 

629
00:32:29,017 --> 00:32:33,079
说好假设我 有一个 开始 

630
00:32:31,006 --> 00:32:37,018
数据结构， 看起来像的方式 

631
00:32:33,079 --> 00:32:39,081
帕斯卡尔影响阵列抱歉，我有 

632
00:32:37,072 --> 00:32:41,145
并不反对帕斯卡尔 

633
00:32:39,081 --> 00:32:45,105
我们曾经教过它回到过去

634
00:32:42,045 --> 00:32:47,106
但这样一个典型的方式，你会实施 

635
00:32:46,005 --> 00:32:50,100
阵列中的语言是你提供 

636
00:32:48,006 --> 00:32:52,079
既存储在这些值 

637
00:32:51,000 --> 00:32:55,011
阵列再有会是其他 

638
00:32:52,079 --> 00:32:58,170
与 它 相关联的信息 

639
00:32:55,011 --> 00:33:01,110
例如什么尺寸是所以这是 

640
00:32:59,007 --> 00:33:04,071
排序排序的漂亮抽象的方式来的 

641
00:33:02,001 --> 00:33:08,064
做到这一点，你写的代码 ， 确保 

642
00:33:05,034 --> 00:33:11,133
如果你曾经尝试超越 

643
00:33:08,073 --> 00:33:13,116
阵列上的边界你 返回 

644
00:33:12,033 --> 00:33:20,115
误差信号等这个特定 

645
00:33:14,016 --> 00:33:23,016
工作，你看到的是什么， 我想 

646
00:33:21,015 --> 00:33:25,088
找回我通过一个元素的任命 

647
00:33:23,016 --> 00:33:29,052
然后该值的指针变 

648
00:33:25,088 --> 00:33:31,113
用于检索从价值 

649
00:33:29,052 --> 00:33:34,056
阵列和 的这个 返回值 

650
00:33:32,013 --> 00:33:36,105
功能是 再到0或1 0含义 

651
00:33:34,056 --> 00:33:38,145
失败的一个意义的成功，我 

652
00:33:37,005 --> 00:33:41,094
写作是这样，我用数据 

653
00:33:39,045 --> 00:33:43,134
键入我会打电话数据强调了T 和 

654
00:33:41,094 --> 00:33:46,098
这样我可以运行这个我可以编译 

655
00:33:44,034 --> 00:33:49,071
该代码使用不同的定义 

656
00:33:46,098 --> 00:33:50,187
数据强调T对长期浮动获得 

657
00:33:49,071 --> 00:33:52,155
和双打，我们将看到怎样的 

658
00:33:51,087 --> 00:33:58,176
性能特点是那些 

659
00:33:53,055 --> 00:34:01,074
用不同的数据类型和移位

660
00:33:59,076 --> 00:34:05,150
我将使用的基准是 

661
00:34:01,074 --> 00:34:09,078
相当简单的一个 ，它只是 给 了一个 

662
00:34:06,005 --> 00:34:12,024
阵列或这些矢量中的一个

663
00:34:09,078 --> 00:34:14,133
我只是想所有的 元素结合

664
00:34:12,069 --> 00:34:16,146
它无论是计算它们的和或 

665
00:34:15,033 --> 00:34:21,048
产品，再次我要 使用 

666
00:34:17,046 --> 00:34:24,060
宏这里 的ident及以上，并确定 

667
00:34:21,048 --> 00:34:27,137
那些使得op是加法和 

668
00:34:24,006 --> 00:34:29,082
同一性值是0，其中我的OP是 

669
00:34:28,037 --> 00:34:32,121
乘法 和单位元 

670
00:34:30,036 --> 00:34:35,097
1，这样我可以比较加法和 

671
00:34:33,021 --> 00:34:37,107
乘法，从而使我们的排序 

672
00:34:35,097 --> 00:34:39,196
这里八种可能性两个不同 

673
00:34:38,007 --> 00:34:43,103
在四个不同的 数据类型的 操作 

674
00:34:40,096 --> 00:34:45,107
所以这是写在 那种 

675
00:34:44,003 --> 00:34:47,872
最简单的方式，我是 

676
00:34:46,007 --> 00:34:50,012
使用该功能名为get BEC 

677
00:34:47,899 --> 00:34:54,800
元件来检索连续

678
00:34:50,057 --> 00:34:59,140
此数组的值，然后执行 

679
00:34:54,008 --> 00:35:03,011
其上操作所以现在来表达 

680
00:35:00,004 --> 00:35:07,019
这种表现，我们要使用一个 

681
00:35:03,083 --> 00:35:10,136
公制我引入了一个名为CPE 这 

682
00:35:07,055 --> 00:35:12,143
代表每个元素和周期 

683
00:35:11,036 --> 00:35:14,120
想法是，通常当你写代码 

684
00:35:13,043 --> 00:35:16,127
这说通过什么效果步骤 

685
00:35:15,002 --> 00:35:20,003
有排序的一些线性性能 

686
00:35:17,027 --> 00:35:24,040
当你长大了，你真的不希望 

687
00:35:20,021 --> 00:35:27,032
要知道 它 到底 借此很多 

688
00:35:24,004 --> 00:35:29,087
秒或微秒或纳秒 

689
00:35:27,032 --> 00:35:31,109
做你有种 想 操作 

690
00:35:30,023 --> 00:35:35,102
知道往往更什么是它的整体 

691
00:35:32,009 --> 00:35:37,058
性能 特点并且还 

692
00:35:36,002 --> 00:35:39,077
原来，当你做低级别 

693
00:35:37,058 --> 00:35:42,062
代码优化它的有用得多 

694
00:35:39,077 --> 00:35:44,165
想在 的 时钟周期计算 

695
00:35:42,098 --> 00:35:47,120
该处理器的内时钟而不是

696
00:35:45,065 --> 00:35:49,121
绝对的术语如纳秒

697
00:35:48,002 --> 00:35:53,023
因为处理器是否正在运行

698
00:35:50,021 --> 00:35:56,033
在 两千兆赫至2.3千兆赫的我 

699
00:35:53,041 --> 00:35:59,087
真的不我过，没有控制 

700
00:35:56,033 --> 00:36:01,121
作为一个程序员，但 我能控制 

701
00:35:59,087 --> 00:36:02,174
它的低层次的多少时钟 

702
00:36:02,021 --> 00:36:07,076
周期被用于不同 

703
00:36:03,074 --> 00:36:09,086
计算的部分 所以这就是为什么 

704
00:36:07,076 --> 00:36:11,162
这就是所谓的每个元素和你的周期 

705
00:36:09,086 --> 00:36:14,132
可以把它看成，这表明一些

706
00:36:12,062 --> 00:36:18,077
实际测量， 通常一 

707
00:36:15,032 --> 00:36:21,041
像这样的功能得到了我的表现 

708
00:36:18,077 --> 00:36:23,123
合并将有一些开销 固定 

709
00:36:22,022 --> 00:36:26,057
这与建立相关的量

710
00:36:24,023 --> 00:36:28,094
循环做顶级呼叫， 

711
00:36:26,057 --> 00:36:31,115
所有的东西，然后一些部件 

712
00:36:28,094 --> 00:36:33,128
这是线性的大小等我 

713
00:36:32,015 --> 00:36:38,108
想知道的是，线性范围 

714
00:36:34,028 --> 00:36:40,115
组件 我会和这将决定 

715
00:36:39,008 --> 00:36:42,077
这就是我会打电话给 每个周期 

716
00:36:41,015 --> 00:36:46,067
你能想到的范围元素 

717
00:36:42,077 --> 00:36:49,096
排序 增加的增量成本的 

718
00:36:46,067 --> 00:36:49,096
一个更元件到 所述阵列 

719
00:36:53,043 --> 00:36:59,172
所以现在如果我运行 这个功能 我发现 

720
00:36:57,049 --> 00:37:01,090
你，我只显示 我主要 

721
00:36:59,559 --> 00:37:06,520
只显示四个结果，因为它变成 

722
00:37:01,009 --> 00:37:08,688
它是否是int或长或浮或 

723
00:37:06,052 --> 00:37:11,151
双是不会真正有什么 

724
00:37:09,579 --> 00:37:14,650
性能对于大多数的效果

725
00:37:11,619 --> 00:37:16,300
这样的情况下，如果我只是通过运行此代码 

726
00:37:14,065 --> 00:37:18,070
一个编译器，不要做任何 

727
00:37:16,003 --> 00:37:20,562
优化它需要大约20 个循环 

728
00:37:18,007 --> 00:37:23,026
每个元素，如果我打开 

729
00:37:20,859 --> 00:37:26,950
优化级别 1，它是有点 

730
00:37:23,089 --> 00:37:28,177
它需要先认真优化 

731
00:37:26,095 --> 00:37:31,153
在半所以我到 10个时钟时间

732
00:37:29,077 --> 00:37:34,096
每个元素的周期仅通过改变 

733
00:37:32,053 --> 00:37:38,097
编译和jeezum最 

734
00:37:34,096 --> 00:37:42,163
未经优化的代码，我能想到的在这里 

735
00:37:38,097 --> 00:37:46,236
然后我不会去通过这 一切，但 

736
00:37:43,063 --> 00:37:48,154
使用排序的那种东西我

737
00:37:47,109 --> 00:37:52,720
前面所描述的那种切掉 

738
00:37:49,054 --> 00:37:54,573
一些冗余的这一方案 

739
00:37:52,072 --> 00:37:56,095
你可以得到它下来 的东西 

740
00:37:55,059 --> 00:37:58,140
有点简单 ， 这么一 件事 

741
00:37:56,095 --> 00:38:00,172
而不是你看到的 我是在 之前 

742
00:37:58,869 --> 00:38:03,640
调用此获取 deck元素，每 

743
00:38:01,072 --> 00:38:05,421
火候做它去边界检查 

744
00:38:03,064 --> 00:38:07,090
并且它是一种愚蠢的 ，以保持边界 

745
00:38:06,069 --> 00:38:11,200
反复检查同一阵列 

746
00:38:07,009 --> 00:38:13,042
当再次声明，我踩着我使用它

747
00:38:11,002 --> 00:38:16,671
长度多少的 定 

748
00:38:14,023 --> 00:38:19,051
元素来访问，所以如果我愿意 

749
00:38:16,869 --> 00:38:21,640
到 放弃的平衡检测我所能 

750
00:38:19,051 --> 00:38:24,070
做的是引入一个函数，将 

751
00:38:21,064 --> 00:38:26,733
只要给我实际的数据存储 

752
00:38:24,007 --> 00:38:29,056
这种载体的一部分，并跳过所有 

753
00:38:27,309 --> 00:38:33,250
其他 的 东西 ，所以我可以写一个 

754
00:38:30,019 --> 00:38:34,093
循环它， 我介绍你了解当地 

755
00:38:33,025 --> 00:38:40,027
变量和所有的那种东西 ，我们 

756
00:38:34,093 --> 00:38:43,120
描述并在累积的临时 

757
00:38:40,045 --> 00:38:46,434
之类的东西，然后程序 

758
00:38:44,002 --> 00:38:48,031
实际上 更快地再次 得到了很多 与 

759
00:38:46,839 --> 00:38:50,844
这是一切从这里走出IS 

760
00:38:48,049 --> 00:38:52,141
优化级1等抛弃它 

761
00:38:51,339 --> 00:38:58,341
下降到略高于 时钟周期 

762
00:38:53,041 --> 00:39:00,000
整数添加或三个时钟

763
00:38:58,359 --> 00:39:02,080
周期最多5个时钟周期通过 

764
00:39:00,369 --> 00:39:04,230
双精度乘数

765
00:39:02,008 --> 00:39:06,100
所以这是相当不错的我已经有点 

766
00:39:04,023 --> 00:39:09,037
有了一定的提高，但事情的 

767
00:39:07,000 --> 00:39:09,052
问题是好是最好有 

768
00:39:09,037 --> 00:39:11,131
是

769
00:39:09,052 --> 00:39:15,055
和第一， 也试着去了解 

770
00:39:12,031 --> 00:39:18,058
是什么样的，这些数字 3和5 

771
00:39:15,055 --> 00:39:20,127
这似乎有什么东西接近 1.25 

772
00:39:18,058 --> 00:39:23,104
那么， 从 未来 这些 数字 和 

773
00:39:21,027 --> 00:39:28,033
这是否表明一些基本 

774
00:39:24,004 --> 00:39:30,070
在我的计划不仅限于以及为了 

775
00:39:28,087 --> 00:39:31,108
要做到这一点，你必须 有一些 

776
00:39:30,007 --> 00:39:33,088
底层硬件 的理解

777
00:39:32,008 --> 00:39:39,097
并有一个非常好的当然你也可以 

778
00:39:34,051 --> 00:39:40,135
拿我认为， 这就是所谓的 ECE 741所以 

779
00:39:39,097 --> 00:39:42,139
会告诉你， 你都做不到的一切

780
00:39:41,035 --> 00:39:45,118
想像想 知道关于处理器 

781
00:39:43,039 --> 00:39:48,064
设计和你实际设计 

782
00:39:46,018 --> 00:39:49,114
处理器是这样，但我假设 

783
00:39:48,064 --> 00:39:50,119
你不打算这样做 了一段时间 

784
00:39:50,014 --> 00:39:54,021
因为如果你有大约七 

785
00:39:51,019 --> 00:39:58,063
先决条件于 发生 之前做 

786
00:39:54,084 --> 00:40:00,172
所以让我给 你简单 

787
00:39:58,063 --> 00:40:02,152
版本和文森不大不小的一个想法 

788
00:40:01,072 --> 00:40:06,103
一个什么样的处理器已经长得很像 

789
00:40:03,052 --> 00:40:11,053
自1995年左右，所以这是旧的 东西 

790
00:40:07,003 --> 00:40:13,057
但它足以实际上 真正 

791
00:40:11,062 --> 00:40:16,159
理解它是如此难以它真的 

792
00:40:13,057 --> 00:40:19,129
细节是相当 巨大的，因此 

793
00:40:17,059 --> 00:40:22,132
它甚至没有教示于例如 447 

794
00:40:20,029 --> 00:40:24,073
在ECE是计算机架构

795
00:40:23,032 --> 00:40:26,116
当然，他们并不真正进入 

796
00:40:24,073 --> 00:40:27,079
这种 设计在这里，因为他们 

797
00:40:27,016 --> 00:40:31,051
相当困难的，他们实际上是很难 

798
00:40:28,033 --> 00:40:35,059
设计你自己的，但其基本思想是 

799
00:40:31,051 --> 00:40:37,060
你想想一个程序一样是 

800
00:40:35,059 --> 00:40:40,096
电脑只是读取指令

801
00:40:37,006 --> 00:40:42,040
做什么它说做读取 

802
00:40:40,096 --> 00:40:44,128
另一个指令做什么，说 

803
00:40:42,094 --> 00:40:46,159
这样做并没有任何与 

804
00:40:45,028 --> 00:40:48,124
程序实际上是如何 执行的是什么 

805
00:40:47,059 --> 00:40:50,158
他们已经建立起来的是这个庞大的 

806
00:40:49,024 --> 00:40:55,036
硬件基础设施来进行 

807
00:40:51,058 --> 00:40:56,113
程序运行方式 会比如果快 

808
00:40:55,036 --> 00:40:59,131
它只是做一条指令 

809
00:40:57,013 --> 00:41:01,111
时间，它采用 了一种技术，是 

810
00:41:00,031 --> 00:41:04,129
所谓的超标量乱序

811
00:41:02,011 --> 00:41:07,060
执行和想法 大致 

812
00:41:05,029 --> 00:41:08,101
讲它需要你的程序，如果你 

813
00:41:07,006 --> 00:41:11,020
想你的程序作为一个线性 

814
00:41:09,001 --> 00:41:14,280
指令序列，它只是 

815
00:41:11,074 --> 00:41:15,903
吸入尽可能多的，因为它可以 

816
00:41:14,289 --> 00:41:19,341
并将其拉它除了要认识到 

817
00:41:16,569 --> 00:41:21,910
某些操作真的不依赖 

818
00:41:19,809 --> 00:41:22,890
彼此 ，所以我 可以甚至开始一个 

819
00:41:21,091 --> 00:41:24,660
虽然后来在节目

820
00:41:23,619 --> 00:41:26,640
那么一个我的工作， 现在 

821
00:41:25,479 --> 00:41:29,410
因为它们是相互独立的 

822
00:41:26,829 --> 00:41:31,660
其他和它的提取他们所称 

823
00:41:29,041 --> 00:41:33,750
指令级并行的地方 

824
00:41:31,066 --> 00:41:36,915
其中， 即使你的程序是 

825
00:41:34,119 --> 00:41:40,660
埋在指令的线性序列 

826
00:41:37,509 --> 00:41:42,640
居然还有几分森林 

827
00:41:40,066 --> 00:41:44,071
需要不同的计算

828
00:41:42,064 --> 00:41:47,793
做了一些 依赖于对方， 

829
00:41:45,016 --> 00:41:51,091
一些不然后有一堆

830
00:41:48,369 --> 00:41:56,406
硬件，所以这里这个是向上 

831
00:41:51,091 --> 00:41:58,950
上半部分显示了这个想法取的 

832
00:41:56,739 --> 00:42:01,820
指令，以便有一个高速缓冲存储器 

833
00:41:59,769 --> 00:42:04,770
高性能高速本地内存 

834
00:42:02,549 --> 00:42:07,900
这只是拉着你的 

835
00:42:04,869 --> 00:42:10,630
尽可能快，因为它可以和这些指令

836
00:42:07,009 --> 00:42:12,888
指令接着喂一大堆 

837
00:42:10,063 --> 00:42:16,242
硬件将提取出来 

838
00:42:13,779 --> 00:42:18,788
这些低级别操作和数字 

839
00:42:16,809 --> 00:42:23,810
出哪些取决于哪个人对 

840
00:42:18,869 --> 00:42:25,968
再有一组 

841
00:42:23,909 --> 00:42:27,975
在这部分内容 在于功能单元 

842
00:42:26,859 --> 00:42:30,926
能够执行 这些低级 

843
00:42:28,569 --> 00:42:35,580
操作做算术 

844
00:42:31,529 --> 00:42:38,550
浮点运算读取数据 

845
00:42:35,679 --> 00:42:40,683
从存储器来存储数据回 存储器 

846
00:42:38,739 --> 00:42:42,776
所有使用缓存这是 一件好事 

847
00:42:41,079 --> 00:42:46,098
你要 很快就会 了解 

848
00:42:43,109 --> 00:42:48,198
什么这一切缓存，但想到 

849
00:42:46,269 --> 00:42:54,321
的一些以此为高速拷贝 

850
00:42:48,999 --> 00:42:58,097
数据存储和 UM还等什么这个这个 

851
00:42:54,789 --> 00:43:00,867
逻辑试图做的就是继续向上分叉 

852
00:42:58,979 --> 00:43:04,038
产卵关操作根据您的

853
00:43:01,569 --> 00:43:06,615
程序和保持这些一样忙碌 

854
00:43:04,569 --> 00:43:08,595
他们可以做的 不同 片段 

855
00:43:07,029 --> 00:43:12,036
你的代码做不同的指令 

856
00:43:08,829 --> 00:43:14,852
从与之前不同的顺序

857
00:43:12,099 --> 00:43:18,132
原来你认为寄存器作为 

858
00:43:15,059 --> 00:43:21,084
小该组寄存器是的一部分 

859
00:43:18,429 --> 00:43:23,487
这被读取和写入内存它 

860
00:43:21,309 --> 00:43:26,000
原来，在执行寄存器 

861
00:43:24,009 --> 00:43:27,770
现在只要成为该名称

862
00:43:26,000 --> 00:43:29,081
的东西，一个指令 

863
00:43:27,077 --> 00:43:31,109
生产和一些其它指令

864
00:43:29,081 --> 00:43:34,142
消耗它的一些目标 

865
00:43:32,009 --> 00:43:38,036
它是为他人而这个源 

866
00:43:35,042 --> 00:43:40,115
整了一堆东西在这里只是有点 

867
00:43:38,036 --> 00:43:43,115
神奇传递之一的结果 

868
00:43:41,015 --> 00:43:46,073
计算以输入到另一个 

869
00:43:44,015 --> 00:43:48,022
基于寄存器的名称计算

870
00:43:46,073 --> 00:43:50,141
而没有将它们存储在 和 

871
00:43:48,085 --> 00:43:53,108
明确的寄存器文件存在 

872
00:43:51,041 --> 00:43:56,108
寄存器文件，当事情 样的解决 

873
00:43:54,008 --> 00:43:59,054
下来，他们得到反正存储起来 

874
00:43:57,008 --> 00:44:01,103
有很多东西怎么回事，但 

875
00:43:59,054 --> 00:44:04,106
考虑主要的 是你的 

876
00:44:02,003 --> 00:44:08,009
该机 拥有的资源 做多 

877
00:44:05,006 --> 00:44:11,075
操作都在同一 时间 ，如果你 

878
00:44:08,009 --> 00:44:16,091
能以某种方式构建程序 等等 

879
00:44:11,075 --> 00:44:18,098
这些都可以习惯，所以这是 

880
00:44:16,091 --> 00:44:20,135
正如我所说这就是所谓的超标 

881
00:44:18,098 --> 00:44:22,109
指示处理器是一个可以做

882
00:44:21,035 --> 00:44:29,081
以上 每个时钟 一条 指令 

883
00:44:23,009 --> 00:44:31,061
周期，实际上英特尔在93开始 

884
00:44:29,081 --> 00:44:33,119
最先奔腾可以做两 

885
00:44:31,061 --> 00:44:35,072
在一次指令，但随后一点点 

886
00:44:34,019 --> 00:44:37,112
后来他们想出了 一个叫 

887
00:44:35,072 --> 00:44:40,073
Pentium Pro的是 排序依据 

888
00:44:38,012 --> 00:44:44,029
所有现代处理器和领先的

889
00:44:40,073 --> 00:44:48,074
建筑师的方式是CMU毕业 

890
00:44:44,029 --> 00:44:52,121
但这种乱序执行 的是 

891
00:44:48,074 --> 00:44:54,152
多数民众赞成采用 了时下所以其他 模型 

892
00:44:53,021 --> 00:44:58,037
就是这些功能单元都比较 

893
00:44:55,052 --> 00:44:59,120
复杂得多， 你 认为他们可能会 在 

894
00:44:58,037 --> 00:45:03,059
他们有什么所谓流水线 

895
00:45:00,002 --> 00:45:05,024
和流水线的想法是 想象 

896
00:45:03,059 --> 00:45:09,092
你可以分解计算成 

897
00:45:05,042 --> 00:45:11,045
一系列不同的阶段简单的

898
00:45:09,092 --> 00:45:13,184
例子是，如果 你想 计算 

899
00:45:11,072 --> 00:45:16,157
乘以B加C，你先做倍 

900
00:45:14,084 --> 00:45:18,143
然后你做的加号，但它实际上 

901
00:45:17,057 --> 00:45:22,091
得到更重要的是，你可以采取 

902
00:45:19,043 --> 00:45:26,105
像 乘法和休息 

903
00:45:22,091 --> 00:45:28,187
成更小 的步骤， 可以 

904
00:45:27,005 --> 00:45:31,049
做 的 方式 一 前 一 后 说 

905
00:45:29,087 --> 00:45:32,129
然后，如果你有一个单独的 

906
00:45:31,049 --> 00:45:35,078
专用硬件为每个的 

907
00:45:33,029 --> 00:45:38,102
阶段，那么你可以做到这一点叫 

908
00:45:35,078 --> 00:45:39,084
流水线这是当一个操作 

909
00:45:39,002 --> 00:45:42,018
从一个移动

910
00:45:39,084 --> 00:45:43,092
舞台下一个新的操作 

911
00:45:42,018 --> 00:45:48,072
可以进来后面开始启动

912
00:45:44,064 --> 00:45:50,073
的事情，所以这个例子说明我想象 

913
00:45:48,072 --> 00:45:53,145
有一个三阶段的流水线乘法器 

914
00:45:51,054 --> 00:45:58,056
我想这样做计算的 

915
00:45:54,045 --> 00:46:01,098
次B A倍C和现在相乘那些 

916
00:45:58,074 --> 00:46:04,089
在一起，使 观察的是， 

917
00:46:01,098 --> 00:46:06,171
一时间B与C时代不依赖于 

918
00:46:04,089 --> 00:46:08,187
对方以任何方式，所以我可以做他们 

919
00:46:07,071 --> 00:46:12,084
既和我没有做硬件 

920
00:46:09,087 --> 00:46:14,111
他们同时但我有他们

921
00:46:12,084 --> 00:46:18,084
够对方后做一个正确的

922
00:46:15,011 --> 00:46:22,065
所以我可以养活第一计算成 

923
00:46:18,084 --> 00:46:24,141
上步骤 倍第一阶段a倍 乙 

924
00:46:22,065 --> 00:46:26,139
步骤之一，然后次第二步它会 

925
00:46:25,041 --> 00:46:32,082
转移到第二阶段和时间步骤 

926
00:46:27,039 --> 00:46:35,124
三颗，将进入第三阶段 ，但 

927
00:46:32,082 --> 00:46:38,169
现在我可以在时间开始C时代

928
00:46:36,024 --> 00:46:42,111
步骤二，因为这个阶段开始 

929
00:46:39,069 --> 00:46:45,084
可一次次B，从移动 

930
00:46:43,011 --> 00:46:49,017
第一阶段到 第二阶段，所以我可以 

931
00:46:45,084 --> 00:46:53,097
遵循正确的背后只是一个时钟周期 

932
00:46:49,017 --> 00:46:56,103
这背后的其他操作现在 P次 

933
00:46:53,097 --> 00:46:58,191
一个 时代 P2显然取决于 两个 

934
00:46:57,003 --> 00:47:03,096
这些产品，因此无法启动 

935
00:46:59,091 --> 00:47:05,097
直到C时代结束，然后 

936
00:47:03,096 --> 00:47:06,132
将通过管道进行，而不 

937
00:47:05,097 --> 00:47:09,129
别的 

938
00:47:07,032 --> 00:47:13,106
所以总体那么我们所做的事会 

939
00:47:10,029 --> 00:47:18,036
通常似乎是九步价值

940
00:47:14,006 --> 00:47:23,012
算术共有七个步骤 

941
00:47:18,099 --> 00:47:22,112
这里，是因为管道问题 

942
00:47:26,059 --> 00:47:33,068
它如果他有像 这 是一个 

943
00:47:30,032 --> 00:47:34,094
图片浏览，如果有不同 

944
00:47:33,068 --> 00:47:37,139
在这些不同的地方乘数

945
00:47:34,094 --> 00:47:48,128
是的，你可以做这两个完全 

946
00:47:38,039 --> 00:47:50,081
相互独立是的，这是 

947
00:47:49,028 --> 00:47:53,087
都在一个单一的单核 

948
00:47:50,081 --> 00:47:55,082
处理器多核是又一此

949
00:47:53,087 --> 00:47:58,091
比你低级别的并行 

950
00:47:55,082 --> 00:48:00,149
通过多核获得， 它的存在 

951
00:47:58,091 --> 00:48:02,123
除了在那种 最低端的最低 

952
00:48:01,049 --> 00:48:05,051
功率和嵌入式处理器的一些 

953
00:48:03,023 --> 00:48:06,116
这个版本存在， 大部分的 

954
00:48:05,069 --> 00:48:07,157
时间你的硬件没有被完全 

955
00:48:07,016 --> 00:48:12,104
利用它的一两件事你要 

956
00:48:08,057 --> 00:48:14,156
学习一下，这样的 想法 

957
00:48:13,004 --> 00:48:17,012
流水线它这是一个有点像 

958
00:48:15,056 --> 00:48:19,112
并行，但它不是，你有 

959
00:48:17,084 --> 00:48:23,095
资源的多个副本 ，它是 

960
00:48:20,012 --> 00:48:26,075
你有这个能力，以流 

961
00:48:23,095 --> 00:48:28,097
通过一个单一的 硬件 操作 

962
00:48:26,075 --> 00:48:35,171
资源引号例外各 

963
00:48:29,015 --> 00:48:38,102
其他等等，以及这是 一个小 

964
00:48:36,071 --> 00:48:42,086
位 比 大幅机 更 近 

965
00:48:39,002 --> 00:48:46,016
但不是说更是一 

966
00:48:42,086 --> 00:48:49,154
最近英特尔的x86版本 

967
00:48:46,016 --> 00:48:53,087
系列和功能单元包括

968
00:48:50,054 --> 00:48:56,057
哦，有很多的 功能 单元 

969
00:48:53,087 --> 00:48:57,125
可以做不同的事情，但是当 

970
00:48:56,057 --> 00:49:02,084
你说 起来还有一种可能性 

971
00:48:58,025 --> 00:49:04,079
它做两个负载在一个商店 

972
00:49:02,084 --> 00:49:06,146
整数运算两个浮点 

973
00:49:04,079 --> 00:49:09,167
乘以一个加法和一个师 

974
00:49:07,046 --> 00:49:12,074
他们不可能都发生在同一

975
00:49:10,067 --> 00:49:14,078
时间，因为有一些 共享 

976
00:49:12,074 --> 00:49:16,082
功能单元但问题是 

977
00:49:14,078 --> 00:49:18,166
没什么很多 的设备有 

978
00:49:16,082 --> 00:49:18,166
可以做的东西

979
00:49:19,076 --> 00:49:26,185
也可以测量一个如何 

980
00:49:23,839 --> 00:49:28,840
现在的指令有两个特点 

981
00:49:26,869 --> 00:49:30,916
经营多久没有考虑 

982
00:49:28,849 --> 00:49:34,790
从开始到结束，但怎么也 

983
00:49:31,339 --> 00:49:37,640
紧密间隔开的可互操作是 

984
00:49:34,079 --> 00:49:39,170
因为这个管道，所以你看到的

985
00:49:37,064 --> 00:49:42,793
他们大部分采取 的 一些数 

986
00:49:40,007 --> 00:49:45,014
时钟周期来执行，但他们也 

987
00:49:43,369 --> 00:49:48,442
管道，这样就可以做了一系列的 

988
00:49:45,077 --> 00:49:50,096
他们只是一个周期相隔只有 

989
00:49:49,099 --> 00:49:53,197
不同的人是那朵你会 

990
00:49:50,096 --> 00:49:55,145
注意分工都非常慢 

991
00:49:54,079 --> 00:49:58,670
这不是管道和分裂是 

992
00:49:56,045 --> 00:50:05,123
大多数非常昂贵的操作 

993
00:49:58,067 --> 00:50:08,074
机相对而言所以我 

994
00:50:06,023 --> 00:50:13,042
权利要求则是这些这些 

995
00:50:08,074 --> 00:50:15,913
特征则提供一个限制

996
00:50:13,042 --> 00:50:20,096
如何快速我们的程序可以运行我们的 

997
00:50:16,579 --> 00:50:22,730
原计划中，我有一个系列 

998
00:50:20,096 --> 00:50:25,145
乘法例如的

999
00:50:22,073 --> 00:50:29,932
这里整数，这显示了该代码 

1000
00:50:26,045 --> 00:50:31,142
它和我的结果所需要的 

1001
00:50:30,589 --> 00:50:34,636
以前我一个乘法的结果

1002
00:50:32,042 --> 00:50:37,681
可以开始下一 所以有一个三 

1003
00:50:35,059 --> 00:50:40,190
时钟周期的志愿者，你会看到 

1004
00:50:38,059 --> 00:50:41,110
其实我的所有测量 

1005
00:50:40,019 --> 00:50:43,948
对应于我打电话是什么 

1006
00:50:41,569 --> 00:50:47,920
延迟约束这些机器这是

1007
00:50:44,119 --> 00:50:50,660
只是根据需要多少时间 

1008
00:50:47,092 --> 00:50:53,096
从操作的开始到 

1009
00:50:50,066 --> 00:50:55,121
结束， 原因是我们认为 

1010
00:50:53,096 --> 00:50:58,145
图的由正在做计算

1011
00:50:56,021 --> 00:51:03,430
这个程序，它做了一系列的 

1012
00:50:59,045 --> 00:51:05,066
乘法和我需要的结果 

1013
00:51:03,619 --> 00:51:07,940
一个乘法 之前，我可以开始 

1014
00:51:05,066 --> 00:51:11,138
接下来一般来说，如果你 看看这个 

1015
00:51:07,094 --> 00:51:14,098
循环代码它来计算ECX的 

1016
00:51:12,038 --> 00:51:19,227
它的更新值之前，它 现在可以 

1017
00:51:14,098 --> 00:51:21,125
开始下 一个，因此 这就是为什么 

1018
00:51:19,569 --> 00:51:25,624
即使这 我有一个管道 

1019
00:51:22,025 --> 00:51:29,054
乘法器我的程序本身限制了我

1020
00:51:26,119 --> 00:51:31,990
对所有的顺序执行

1021
00:51:29,054 --> 00:51:31,099
乘

1022
00:51:34,055 --> 00:51:40,134
让我们看看，如果我们不能获得超出 

1023
00:51:38,019 --> 00:51:43,104
约束，且势必延迟 以及有一个 

1024
00:51:41,034 --> 00:51:45,051
相当普遍的技术，你可能 

1025
00:51:44,004 --> 00:51:47,085
听说以前这就是所谓的循环 

1026
00:51:45,051 --> 00:51:54,129
展开和循环展开的想法 

1027
00:51:47,085 --> 00:51:57,126
仅仅是你，而不是执行 

1028
00:51:55,029 --> 00:52:00,093
一环内的一个值，你执行 

1029
00:51:58,026 --> 00:52:03,078
多个单因此该代码所示 

1030
00:52:00,093 --> 00:52:06,174
由两个展开和它说什么 是我 

1031
00:52:03,078 --> 00:52:10,080
进入 步骤通过这个 阵列中的两个 

1032
00:52:07,074 --> 00:52:12,108
在时间和中的每个元素 

1033
00:52:10,008 --> 00:52:15,084
内循环我要去结合 

1034
00:52:13,008 --> 00:52:18,012
从二和二加一的和我值

1035
00:52:16,056 --> 00:52:20,109
必须把一些额外的代码来完成 

1036
00:52:18,048 --> 00:52:23,112
如果关闭则 按原费率会发生什么

1037
00:52:21,009 --> 00:52:27,024
是冯WENK，但你的想法 和 

1038
00:52:24,012 --> 00:52:29,079
这个想法， 我表现出的两个验证码 

1039
00:52:27,024 --> 00:52:32,079
但你能 想象这个申请 

1040
00:52:29,079 --> 00:52:35,145
的循环展开这样的不同值 

1041
00:52:32,079 --> 00:52:39,093
这将有助于我们 任何好当我运行它 

1042
00:52:36,045 --> 00:52:41,139
我得到的是整数 加法得到了 

1043
00:52:39,093 --> 00:52:45,102
快一点， 但其他的 人都没有 

1044
00:52:42,039 --> 00:52:49,043
改善所有所以这一块是怎么回事 

1045
00:52:46,002 --> 00:52:52,014
更快，因为基本上都是旧代码

1046
00:52:49,079 --> 00:52:53,130
这是 回路 的开销 

1047
00:52:52,014 --> 00:52:56,088
索引和增量足以 

1048
00:52:54,003 --> 00:52:59,052
放缓我失望，因为它已经 

1049
00:52:56,088 --> 00:53:01,182
接近时钟周期，所以我只是管理 

1050
00:52:59,079 --> 00:53:05,151
敲下来是 在等待时间 

1051
00:53:02,082 --> 00:53:08,085
束缚， 这特定的指令 ， 但 

1052
00:53:06,051 --> 00:53:10,140
它没有其他的人，因为我 

1053
00:53:08,085 --> 00:53:14,109
仍然有顺序的依赖 

1054
00:53:11,004 --> 00:53:18,051
为了得到我XI的新价值有 

1055
00:53:15,009 --> 00:53:23,018
首先做一个计算，然后查看 

1056
00:53:18,087 --> 00:53:22,118
另外 之前，我可以开始一个又一个 

1057
00:53:23,042 --> 00:53:28,077
但是这显示了我，我可以做一个方式 

1058
00:53:26,028 --> 00:53:31,032
非常非常小的改变和变化 

1059
00:53:28,077 --> 00:53:34,098
性能相当显着什么，如果 

1060
00:53:31,068 --> 00:53:37,109
我把这些括号内将它们转移 

1061
00:53:34,098 --> 00:53:37,109
向右 

1062
00:53:40,009 --> 00:53:49,022
这会让和LO任何区别 

1063
00:53:46,085 --> 00:53:57,088
不料但你会发现 ，我会 

1064
00:53:50,003 --> 00:54:01,031
调用改造展开的，以 

1065
00:53:57,088 --> 00:54:03,113
同时 我会 计算一个元素 

1066
00:54:01,031 --> 00:54:05,108
谈论在 一分钟内 ，但我会用 

1067
00:54:04,013 --> 00:54:08,108
这小写字母a说我做的 

1068
00:54:06,008 --> 00:54:10,106
联想ivities形成，你会看到 

1069
00:54:09,008 --> 00:54:16,085
突然我的时间的锐减中 

1070
00:54:11,006 --> 00:54:22,007
一半这三种 情况等等 

1071
00:54:16,085 --> 00:54:24,127
事情是怎么回事 ，并 让我们看看 

1072
00:54:22,007 --> 00:54:29,012
这是为什么，现在我就为大家介绍它 

1073
00:54:25,027 --> 00:54:33,038
所以，如果我把 我的照片从之前 

1074
00:54:29,057 --> 00:54:35,105
， 想想 这些 计算 

1075
00:54:33,038 --> 00:54:38,054
在PI，你会看到，现在 我已经 

1076
00:54:36,005 --> 00:54:43,007
改变计算的结构 

1077
00:54:38,054 --> 00:54:44,150
让我的头发明智结合各 

1078
00:54:43,007 --> 00:54:49,007
对所述阵列的元件中的元件

1079
00:54:45,005 --> 00:54:51,008
然后累加这些成

1080
00:54:49,007 --> 00:54:53,096
总体计算 ，所以我实际上已经 

1081
00:54:51,008 --> 00:54:55,073
括号的那个变速

1082
00:54:53,096 --> 00:54:59,108
从根本上改变了我 怎么 做我 

1083
00:54:56,045 --> 00:55:01,100
计算你 现在可以看到 

1084
00:55:00,008 --> 00:55:04,043
这 正是这个关键路径 

1085
00:55:02,000 --> 00:55:07,031
确定在这种情况下 的 

1086
00:55:04,043 --> 00:55:09,092
性能限制刚刚短 

1087
00:55:07,031 --> 00:55:12,124
由两个因素， 这就是为什么我 

1088
00:55:09,092 --> 00:55:16,103
现在运行两次为快

1089
00:55:13,024 --> 00:55:19,115
操作不是整数加法，但 

1090
00:55:17,003 --> 00:55:23,006
其他三个业务我剪

1091
00:55:20,015 --> 00:55:25,019
通过只是这种转变的一个因素或两个

1092
00:55:23,033 --> 00:55:28,091
现在有一些好 消息 和坏消息 

1093
00:55:25,055 --> 00:55:32,098
这里的好消息是，如果这是整 

1094
00:55:28,091 --> 00:55:35,098
算术我们已经知道 你知道 

1095
00:55:32,098 --> 00:55:39,116
补算术 

1096
00:55:35,098 --> 00:55:41,135
联想和交换这 的确让 

1097
00:55:40,016 --> 00:55:44,108
不要紧对乘法 

1098
00:55:42,035 --> 00:55:46,130
和另外所以它其实并不重要 

1099
00:55:45,008 --> 00:55:48,071
什么顺序我结合这些元素 和 

1100
00:55:47,003 --> 00:55:51,041
我要 得到确切的答案一样 

1101
00:55:48,071 --> 00:55:54,080
不管是什么，但你也看到了 

1102
00:55:51,068 --> 00:55:56,114
投票 点并非如此所以用 

1103
00:55:54,008 --> 00:55:58,075
浮点这种转变移位这些 

1104
00:55:57,014 --> 00:56:01,052
由于四舍五入的括号 

1105
00:55:59,047 --> 00:56:03,131
可能性和甚至可能 

1106
00:56:01,052 --> 00:56:07,088
溢出你可能会得到不同的值 

1107
00:56:04,031 --> 00:56:09,035
从这些计算，但 随后 的结果 

1108
00:56:07,088 --> 00:56:10,100
再次，如果你认为你知道的 是 

1109
00:56:09,071 --> 00:56:14,105
真的要发生 

1110
00:56:11,000 --> 00:56:16,037
机会是不，这不是真的 

1111
00:56:15,005 --> 00:56:18,071
会影响 结果 的 

1112
00:56:16,037 --> 00:56:20,069
程序但它足以改变的那 

1113
00:56:18,071 --> 00:56:22,106
大多数 C编译器的大多数编译器 

1114
00:56:20,069 --> 00:56:24,167
期间将不会进行任何更改， 

1115
00:56:23,006 --> 00:56:27,038
变化的关联性，因为他们是 

1116
00:56:25,067 --> 00:56:30,098
当涉及到非常保守

1117
00:56:27,038 --> 00:56:32,129
浮点所以这是你的东西 

1118
00:56:30,098 --> 00:56:34,175
作为应用程序的程序员必须 有 

1119
00:56:33,029 --> 00:56:37,058
要知道不够好， 这是 一个有效的CAN 

1120
00:56:35,075 --> 00:56:43,103
我做这个转变不会弄乱 

1121
00:56:37,058 --> 00:56:45,080
事情了， 现在我会说是现在 

1122
00:56:44,003 --> 00:56:48,056
这有一组新的绑定 

1123
00:56:45,008 --> 00:56:49,082
如此丰富 似乎 什么 是 

1124
00:56:48,056 --> 00:56:52,079
排序的最好的，你可以做基于 

1125
00:56:50,054 --> 00:56:55,067
一些约束在节目中和

1126
00:56:52,079 --> 00:56:57,080
有人说很好的延迟之前 

1127
00:56:55,067 --> 00:57:00,104
通过的总时间为给定的 

1128
00:56:57,089 --> 00:57:02,114
给定的操作是比比皆是，现在我说 

1129
00:57:01,004 --> 00:57:04,085
以及还有一个更基本的

1130
00:57:03,014 --> 00:57:07,103
结合我称之为吞吐量

1131
00:57:04,085 --> 00:57:09,119
这只是基于我只有绑定

1132
00:57:08,003 --> 00:57:15,034
如此多的硬件在那里，我可以 

1133
00:57:10,019 --> 00:57:18,115
只有泵这么快 ，所以例如 

1134
00:57:15,034 --> 00:57:26,060
这两个界定所述吞吐量是1 

1135
00:57:19,015 --> 00:57:28,070
因为我只有实际 

1136
00:57:26,006 --> 00:57:32,030
变成被要求的限制在于

1137
00:57:28,007 --> 00:57:38,084
我在从内存和I阅读 

1138
00:57:32,084 --> 00:57:41,084
有 两种不同的 负载单位哦，不，我 

1139
00:57:39,047 --> 00:57:45,113
对不起， 我只有一个乘法器 

1140
00:57:41,084 --> 00:57:47,168
在一个整数加法的

1141
00:57:46,013 --> 00:57:51,026
吞吐量开往这两个实际上 

1142
00:57:48,068 --> 00:57:52,127
只是1/2， 因为 它原来有 

1143
00:57:51,026 --> 00:57:55,031
硬件 设计 的一些奇怪的一部分 

1144
00:57:53,027 --> 00:57:57,032
有两个浮点乘法器 

1145
00:57:55,031 --> 00:57:59,036
但只有一个浮点加法器和 

1146
00:57:57,077 --> 00:58:00,170
我们会看到 ，我们 实际上 可以 使这个 

1147
00:57:59,081 --> 00:58:02,106
乘法代码的运行速度比

1148
00:58:01,007 --> 00:58:04,011
附加码 

1149
00:58:03,006 --> 00:58:07,014
并在这里再次我的极限会

1150
00:58:05,001 --> 00:58:11,025
我只需要 加载的单位和我 

1151
00:58:07,014 --> 00:58:13,014
必须要和我要读 的每 

1152
00:58:11,034 --> 00:58:14,079
元素我计算我必须 

1153
00:58:13,014 --> 00:58:21,030
从存储器中读出的一个元件，所以我 

1154
00:58:14,079 --> 00:58:23,082
不能得到低于好了，但我们看到了 

1155
00:58:21,003 --> 00:58:26,007
这种转变现在让我们休息 

1156
00:58:23,082 --> 00:58:27,176
这项延迟限制的，并得到 

1157
00:58:26,007 --> 00:58:30,039
更接近于吞吐量

1158
00:58:28,076 --> 00:58:33,132
这里的另一个技术，可以 

1159
00:58:31,002 --> 00:58:36,048
使用 排序 ，再次 获得更多的 

1160
00:58:34,032 --> 00:58:39,120
并行去，我称之为

1161
00:58:36,048 --> 00:58:42,093
多个蓄电池的想法是，让我们

1162
00:58:40,002 --> 00:58:44,061
一个假设有奇数 

1163
00:58:42,093 --> 00:58:48,108
元素和偶数元件 

1164
00:58:44,079 --> 00:58:51,093
从阵列中，我们可以，我们可以计算 

1165
00:58:49,008 --> 00:58:54,033
单独的和或产品这两个的 

1166
00:58:51,093 --> 00:58:56,124
套元件中 ，然后将最末端 

1167
00:58:54,033 --> 00:59:00,039
他们结合在一起，这是另一种 

1168
00:58:57,024 --> 00:59:01,121
的关联性变换 形式 

1169
00:59:00,039 --> 00:59:05,085
他们正在改变的顺序我们 

1170
00:59:02,021 --> 00:59:07,023
结合东西放在一起它只是 

1171
00:59:05,085 --> 00:59:09,090
我们正在做的奇偶的西装 

1172
00:59:07,023 --> 00:59:17,100
在一般每冰值，如果方式或

1173
00:59:10,035 --> 00:59:19,077
我们做 一些通过 一些参数 我和 

1174
00:59:18,000 --> 00:59:21,084
它具有相同的问题， 如果它是 

1175
00:59:19,077 --> 00:59:22,146
整数运算，如果罚款是

1176
00:59:21,084 --> 00:59:27,111
浮点有风险

1177
00:59:23,046 --> 00:59:30,048
改变 程序 的 行为 ，但 

1178
00:59:28,011 --> 00:59:33,060
你会看到 ， 我们 再次 获得了切割 

1179
00:59:30,066 --> 00:59:39,090
在这里一半以下 一个 一点点 

1180
00:59:33,006 --> 00:59:40,092
整数加法和再次，我们可以

1181
00:59:39,009 --> 00:59:43,032
通过 看这些图片把它 

1182
00:59:41,046 --> 00:59:44,130
什么是在什么获取计算 和 

1183
00:59:44,013 --> 00:59:48,051
你看到我们正在做的是我们 

1184
00:59:45,003 --> 00:59:49,089
这里所有的计算甚至 偶数 

1185
00:59:48,051 --> 00:59:52,059
被组合编号的元素和

1186
00:59:50,016 --> 00:59:57,060
这里所有的奇数者和尽头 

1187
00:59:52,059 --> 01:00:00,144
我们结合这些一起，所以我们

1188
00:59:57,006 --> 01:00:04,053
可以概括这一点，如果我们可以通过展开 

1189
01:00:01,044 --> 01:00:08,112
升K的因素，我们可以积累

1190
01:00:05,007 --> 01:00:11,076
ķ导致平行，然后我们可以 

1191
01:00:09,012 --> 01:00:14,071
用于以L和K的各种值

1192
01:00:11,076 --> 01:00:18,111
一般 LSB KET 的倍数 

1193
01:00:14,071 --> 01:00:22,153
所以你运行它，你可以 得到 

1194
01:00:19,011 --> 01:00:25,015
浮点乘法即可

1195
01:00:23,053 --> 01:00:36,099
实际上它弄下来几乎是这个 

1196
01:00:25,051 --> 01:00:39,076
吞吐量将结合的0.5，这是 

1197
01:00:36,099 --> 01:00:43,099
不正确，这是整数加法我 

1198
01:00:39,076 --> 01:00:47,085
应该说，传统可以再次 

1199
01:00:43,099 --> 01:00:52,147
得到它下降到大约0.5 和一般 

1200
01:00:48,066 --> 01:00:54,142
通过排序挑选最好的参数我的 

1201
01:00:53,047 --> 01:00:58,096
可以得到非常 接近吞吐量 

1202
01:00:55,042 --> 01:00:59,140
发现这个处理器的 ，所以我一直 

1203
01:00:58,096 --> 01:01:02,170
能够把一些东西记 

1204
01:01:00,004 --> 01:01:05,092
原本是20个时钟周期比10 

1205
01:01:03,007 --> 01:01:10,060
现在我得到它归结为 一个或 

1206
01:01:06,028 --> 01:01:15,037
所以现在每疾病更少的时钟周期

1207
01:01:11,023 --> 01:01:19,039
就像 最后一步是好的是 ， 

1208
01:01:15,037 --> 01:01:20,089
好， 因为它真正去认识你 

1209
01:01:19,039 --> 01:01:22,066
记得当我谈到

1210
01:01:20,089 --> 01:01:25,105
浮点 我提到有 

1211
01:01:22,066 --> 01:01:29,158
特殊 寄存器组是上 

1212
01:01:26,005 --> 01:01:33,016
86，我们正在呼吁 XMM寄存器上 

1213
01:01:30,058 --> 01:01:34,087
锋利的机器 ，现在有好 

1214
01:01:33,016 --> 01:01:37,018
这种新一代有事

1215
01:01:34,087 --> 01:01:38,128
这些都是所谓的ymm寄存器

1216
01:01:37,036 --> 01:01:42,048
特征是两倍大XMM 

1217
01:01:39,028 --> 01:01:50,097
特别是 这些寄存器，这样 

1218
01:01:42,048 --> 01:01:53,137
寄存器是32个字节长 和 

1219
01:01:50,097 --> 01:01:56,116
有内走出一个新版本

1220
01:01:54,037 --> 01:02:00,051
一年 的东西，他们称之为DX 512 

1221
01:01:57,016 --> 01:02:02,049
其中寄存器是512位，这样的 

1222
01:02:00,051 --> 01:02:07,055
256个网站 

1223
01:02:02,049 --> 01:02:11,097
长期没有它 512 

1224
01:02:07,091 --> 01:02:13,158
获得64个字节写64个字节会有 

1225
01:02:11,097 --> 01:02:15,105
是两倍大，因为这些和我 

1226
01:02:14,058 --> 01:02:20,070
之前提到的，你 可以认为 这些 

1227
01:02:16,005 --> 01:02:23,040
作为 32个单独 操作的一种方式 

1228
01:02:20,007 --> 01:02:26,049
字符，我可以把它们作为

1229
01:02:23,004 --> 01:02:29,103
浮点 和我们之前看到的那个 

1230
01:02:27,012 --> 01:02:33,048
您现在的常规浮点 

1231
01:02:30,039 --> 01:02:36,081
利用 休达的低位 为 的 

1232
01:02:33,048 --> 01:02:39,134
这些寄存器的字节，但有

1233
01:02:36,081 --> 01:02:43,128
也说明称为向量加法 

1234
01:02:40,034 --> 01:02:47,088
其中一个指令具有的效果 

1235
01:02:44,028 --> 01:02:48,035
做8浮点加法的 

1236
01:02:47,088 --> 01:02:51,123
一旦

1237
01:02:48,098 --> 01:02:53,196
卸载数据和双精度的

1238
01:02:52,023 --> 01:02:58,101
对方做他们四人在上一次 

1239
01:02:54,096 --> 01:03:00,102
这些和硬件是有 

1240
01:02:59,001 --> 01:03:04,020
它只是坐在那里等待使用 

1241
01:03:01,002 --> 01:03:07,065
它很少被解雇了，真正 

1242
01:03:04,002 --> 01:03:10,089
利用它，但是，这样的浮动 

1243
01:03:07,065 --> 01:03:13,071
点乘数，可以做一个 40个 点 

1244
01:03:11,007 --> 01:03:16,094
乘法在三个时钟周期 和 

1245
01:03:13,071 --> 01:03:19,079
这是完全管线实际上可以做

1246
01:03:16,094 --> 01:03:22,161
8次浮点乘法中 

1247
01:03:19,079 --> 01:03:25,082
平行和管道中的三个时钟 

1248
01:03:23,061 --> 01:03:25,109
周期 

1249
01:03:26,005 --> 01:03:31,063
正如我所提到的 尖锐机具有 

1250
01:03:29,068 --> 01:03:34,081
早期版本， 其中数字 

1251
01:03:32,008 --> 01:03:36,094
其中一半，因此它可以为单一的做 

1252
01:03:34,081 --> 01:03:41,152
精度或两个双 精度在 

1253
01:03:36,094 --> 01:03:44,128
一次，如果我写的代码，它使用 

1254
01:03:42,052 --> 01:03:48,401
我所说的矢量代码，那么你 可以看到 

1255
01:03:45,028 --> 01:03:53,028
我可以约四倍下降

1256
01:03:48,869 --> 01:03:56,950
这里整个董事会，并使其运行 

1257
01:03:53,028 --> 01:04:02,059
更快所以这0.06是真的 

1258
01:03:56,095 --> 01:04:11,140
0.0625 右它做 16个操作 

1259
01:04:02,059 --> 01:04:13,156
每对时钟周期，并且不能 很 

1260
01:04:12,004 --> 01:04:16,045
打约束矢量吞吐量但是在 

1261
01:04:14,056 --> 01:04:19,057
一般制作这个 东西跑得 

1262
01:04:16,081 --> 01:04:20,086
更快， 所以人们真正担心 

1263
01:04:19,057 --> 01:04:22,129
关于你能想象这些 

1264
01:04:21,031 --> 01:04:25,039
说明书介绍的东西

1265
01:04:23,029 --> 01:04:29,068
像的视频处理 的图像处理 

1266
01:04:25,039 --> 01:04:32,041
的声音 种类的信号 处理，其中 的 

1267
01:04:29,068 --> 01:04:35,007
性能真正重要的速度有多快 

1268
01:04:32,041 --> 01:04:38,065
你能多快显示图像您

1269
01:04:35,619 --> 01:04:40,480
可以旋转的东西，你知道有多快 

1270
01:04:38,065 --> 01:04:42,130
您可以执行图形会产生很大的

1271
01:04:40,048 --> 01:04:45,114
在视频游戏中的差异是一个 

1272
01:04:43,003 --> 01:04:48,079
大驱动程序，但即使是其他 

1273
01:04:46,014 --> 01:04:50,068
你可能会 在图像等做业务

1274
01:04:49,006 --> 01:04:52,063
这些指令被真正 设计 

1275
01:04:50,068 --> 01:04:54,073
做到这一点， 人们编写代码的那些 

1276
01:04:52,063 --> 01:04:57,064
样的 应用程序 变得非常 擅长 

1277
01:04:55,018 --> 01:04:59,697
在某种程度上，他们可以做写代码

1278
01:04:57,064 --> 01:05:02,107
这个载体ID什么所谓的矢量化 

1279
01:04:59,859 --> 01:05:04,900
可惜所以英特尔编译器 

1280
01:05:03,007 --> 01:05:08,020
实际上会自动做一些

1281
01:05:04,009 --> 01:05:08,092
这个给你 ，他们试图将GCC 

1282
01:05:08,002 --> 01:05:12,088
实现它并没有 很努力 

1283
01:05:09,073 --> 01:05:16,126
好，所以我想他们停止它，它 

1284
01:05:13,006 --> 01:05:20,074
原来有一个网络搁置，这是 

1285
01:05:17,026 --> 01:05:22,057
从书本网页的web上 

1286
01:05:20,074 --> 01:05:24,118
如果 说明如何 做到这一点编程 

1287
01:05:22,057 --> 01:05:27,124
你有兴趣有扩展

1288
01:05:25,018 --> 01:05:33,046
GCC 他们很时髦很奇怪 

1289
01:05:28,024 --> 01:05:35,038
的东西，但你可以写代码 ， 然后 

1290
01:05:33,046 --> 01:05:36,139
会被编译到利用

1291
01:05:35,038 --> 01:05:38,104
这些类型的指令，这就是 

1292
01:05:37,039 --> 01:05:39,068
我是如何做到 这一点，我是如何得到这些 

1293
01:05:39,004 --> 01:05:45,077
性能

1294
01:05:39,068 --> 01:05:47,227
结果还好 ， 所以 如果你 将告诉 您 

1295
01:05:45,077 --> 01:05:50,104
真想 和但这是非常 

1296
01:05:47,839 --> 01:05:54,862
该机的具体只会工作，上 

1297
01:05:51,004 --> 01:05:56,093
那么你有你其实可以调 

1298
01:05:55,069 --> 01:05:59,270
它，所以它很容易编译它去 

1299
01:05:56,093 --> 01:06:01,121
不同的机器，但它之间的 

1300
01:05:59,027 --> 01:06:06,038
仍然是一个相当具体， 很 

1301
01:06:02,021 --> 01:06:08,027
具体到GCC事实上， 这样的排序 

1302
01:06:06,038 --> 01:06:11,051
显示你但如果你 真的想 

1303
01:06:08,027 --> 01:06:13,088
推你现在能做的，让我们呃得 

1304
01:06:11,051 --> 01:06:16,360
回的 事情 之一 ，我告诉你 

1305
01:06:13,088 --> 01:06:18,089
你如何 可以，如果你认为你的 

1306
01:06:16,819 --> 01:06:21,868
程序作为一个很长的线性序列 

1307
01:06:18,089 --> 01:06:23,818
指令那么事情是试图

1308
01:06:22,309 --> 01:06:27,740
抓住尽可能多的那些 ，和他们拉 

1309
01:06:24,619 --> 01:06:29,180
除了尽可能快，因为它可以 ，但当然 

1310
01:06:27,074 --> 01:06:30,077
你知道你的程序 实际上 是 

1311
01:06:29,018 --> 01:06:33,047
通常一个循环，并没有很多的 

1312
01:06:31,004 --> 01:06:35,089
在循环指令，因此是怎么回事 

1313
01:06:33,047 --> 01:06:39,946
该转动成线性序列 

1314
01:06:35,089 --> 01:06:43,288
以及依靠的是如何做的想法

1315
01:06:40,369 --> 01:06:47,540
你处理分支因此通常 

1316
01:06:44,089 --> 01:06:49,089
程序或取出一个头敛 

1317
01:06:47,054 --> 01:06:52,103
说明它会来一个 

1318
01:06:49,089 --> 01:06:57,230
分支指令的条件跳转

1319
01:06:53,003 --> 01:07:01,004
某种并且有一个难题，因为 

1320
01:06:57,023 --> 01:07:05,362
一般这个分支既可以 我 

1321
01:07:01,004 --> 01:07:08,027
抱歉， 既可以采取意味着它 

1322
01:07:05,569 --> 01:07:10,400
会去转移目标 ，也可能 

1323
01:07:08,027 --> 01:07:12,074
做到这一点，通过这意味着它叫秋天 

1324
01:07:10,004 --> 01:07:15,029
测试失败，所以它只是 继续 

1325
01:07:12,074 --> 01:07:17,443
执行，有没有办法优先

1326
01:07:15,065 --> 01:07:23,126
要知道会发生什么，这些往往能 

1327
01:07:18,109 --> 01:07:26,540
依赖数据等的方式，这是 

1328
01:07:24,026 --> 01:07:28,052
处理 在现代处理器是 

1329
01:07:26,054 --> 01:07:31,633
做了所谓的分支预测 

1330
01:07:28,052 --> 01:07:33,121
这是本质上只是猜测哪些

1331
01:07:32,119 --> 01:07:35,191
该方法分支要去会 

1332
01:07:33,589 --> 01:07:37,730
要采取与否，你预测和 

1333
01:07:35,839 --> 01:07:40,220
然后你开始沿执行

1334
01:07:37,073 --> 01:07:43,076
预测方向，但这样做 的方式 

1335
01:07:40,022 --> 01:07:45,421
如果你 犯了一个错误 ，你有没有 

1336
01:07:43,076 --> 01:07:48,101
造成不可弥补的损害 的程序 

1337
01:07:45,619 --> 01:07:50,662
我们将看到这 意味着 什么 还等什么 

1338
01:07:49,001 --> 01:07:52,010
真正发生的事就是在这里有一个

1339
01:07:51,049 --> 01:07:56,250
大量的逻辑是 

1340
01:07:52,091 --> 01:07:58,173
试图吸出的指令，然后 

1341
01:07:56,025 --> 01:08:01,124
还有，作为一个分支单元

1342
01:07:59,073 --> 01:08:04,092
后来基本上沿着来，说 

1343
01:08:02,024 --> 01:08:07,047
是啊你 没事你预测 

1344
01:08:04,092 --> 01:08:08,163
正确地这样 你就可以继续下去，或者 

1345
01:08:07,047 --> 01:08:11,139
将抛出一个标志，并且说，哦等待 

1346
01:08:09,063 --> 01:08:14,076
分钟停止你的预测错误，你 

1347
01:08:12,039 --> 01:08:16,116
错误预测 该分支路回100 

1348
01:08:14,076 --> 01:08:19,098
时钟周期以前是不是很久 以前 

1349
01:08:17,016 --> 01:08:24,093
但一些数量的时钟周期的前 

1350
01:08:19,098 --> 01:08:26,139
你要修复它，所以这样的手 

1351
01:08:24,093 --> 01:08:29,106
然后跳跃的 方式 变得更加的情况下， 

1352
01:08:27,039 --> 01:08:33,638
猜测在这里，然后要么 

1353
01:08:30,006 --> 01:08:43,038
确认或否认猜测下降

1354
01:08:33,989 --> 01:08:45,020
下面所以一般这时如果它会 

1355
01:08:43,038 --> 01:08:48,096
预测的一种方式，并开始执行 

1356
01:08:45,299 --> 01:08:51,326
所以可以想象，例如在如环 

1357
01:08:48,096 --> 01:08:52,131
我向您展示 您预测， 

1358
01:08:51,569 --> 01:08:54,900
分支将被 采用，但你会回去 

1359
01:08:53,031 --> 01:08:57,440
在循环的开始再次这是 

1360
01:08:54,009 --> 01:08:58,928
实际上是一个相当不错的猜测这是一个好 

1361
01:08:57,719 --> 01:09:02,746
猜赞美你打的结束 

1362
01:08:59,819 --> 01:09:06,750
循环，但我们只是猜测方式 

1363
01:09:02,989 --> 01:09:10,440
所以程序将只保留 猜测 

1364
01:09:06,075 --> 01:09:11,082
该分支将被采用，并通过 

1365
01:09:10,044 --> 01:09:14,058
这意味着所有这些猜测 

1366
01:09:12,045 --> 01:09:16,874
基本上建立 这个长的直线 

1367
01:09:14,058 --> 01:09:23,061
指令序列， 可以是 

1368
01:09:17,279 --> 01:09:25,325
被引用，并执行与一般 

1369
01:09:23,088 --> 01:09:27,217
他们中的一些将获取和 一些 

1370
01:09:25,739 --> 01:09:30,180
他们实际上已经做了 

1371
01:09:28,009 --> 01:09:34,830
这是在要求操作

1372
01:09:30,018 --> 01:09:39,021
指令，然后发生的事情是，如果

1373
01:09:34,083 --> 01:09:42,119
如果标志上升，他们说没有，这是 

1374
01:09:39,048 --> 01:09:46,787
无效，那么会发生什么是 它 会 

1375
01:09:43,019 --> 01:09:50,398
回去并取消所有的指令 

1376
01:09:47,219 --> 01:09:53,520
已 被获取 和执行， 

1377
01:09:50,569 --> 01:09:55,590
顺便它确实是 你会 发现 

1378
01:09:53,052 --> 01:09:58,128
不仅 所有这些 指令修改 

1379
01:09:55,059 --> 01:10:01,098
注册并拥有 的 多个 副本 

1380
01:09:59,028 --> 01:10:03,033
所有的寄存器回去这些都是 

1381
01:10:01,098 --> 01:10:03,156
寄存器这些是值该 

1382
01:10:03,078 --> 01:10:04,155
我敢肯定的 

1383
01:10:04,056 --> 01:10:07,134
这些是 

1384
01:10:05,055 --> 01:10:10,101
推测值追加更新 

1385
01:10:08,034 --> 01:10:13,053
他们所以当谈到时间取消 

1386
01:10:11,001 --> 01:10:16,002
它只是 取消了所有 这些待发 

1387
01:10:13,053 --> 01:10:21,102
更新并回到 该值 

1388
01:10:16,011 --> 01:10:25,023
它的某些问题的 存在 

1389
01:10:22,002 --> 01:10:28,023
大块他们所谓的寄存器 

1390
01:10:25,023 --> 01:10:30,084
重命名单元，其排序多的 

1391
01:10:28,023 --> 01:10:43,023
因为他们 得到 的所有寄存器的副本

1392
01:10:30,084 --> 01:10:44,118
累积有更多的它会

1393
01:10:43,023 --> 01:10:47,028
通常有几百reg的 

1394
01:10:45,018 --> 01:10:51,080
这些类型的虚拟寄存器，以保持

1395
01:10:47,073 --> 01:10:55,104
未决复制到实际寄存器 

1396
01:10:51,008 --> 01:10:57,009
它它存储知道这里是的 

1397
01:10:56,004 --> 01:11:01,053
这里原值是这里的第一次更新是 

1398
01:10:57,009 --> 01:11:02,088
这里的第二个更新的第三和

1399
01:11:01,053 --> 01:11:05,148
它使所有的曲目， 你可以 

1400
01:11:03,069 --> 01:11:07,146
想象为什么这不是你的东西

1401
01:11:06,048 --> 01:11:10,062
学习一个学期的课程 的权利 

1402
01:11:08,046 --> 01:11:11,133
该跟踪所有这些 

1403
01:11:10,062 --> 01:11:14,097
不同的东西飞过 ，并确保 

1404
01:11:12,033 --> 01:11:15,036
它的工作原理 是一个相当棘手 

1405
01:11:14,097 --> 01:11:16,101
商业

1406
01:11:15,036 --> 01:11:19,119
但在概念上它是一个非常 

1407
01:11:17,037 --> 01:11:22,071
简单的想法 ，它 只是比赛确实关闭 

1408
01:11:20,019 --> 01:11:25,077
纯粹基于 很多东西 

1409
01:11:22,071 --> 01:11:28,088
投机，然后仅当它是一个 

1410
01:11:25,077 --> 01:11:30,168
错误不言而喻 哦 ，它像是回滚 

1411
01:11:28,088 --> 01:11:33,123
就好像它仅 执行到一 

1412
01:11:31,068 --> 01:11:38,151
某一点，然后 向前 移动 

1413
01:11:34,023 --> 01:11:42,030
并开始在去所以正确的方法 

1414
01:11:39,051 --> 01:11:45,054
并因此， 它可以 逃脱这个 

1415
01:11:42,093 --> 01:11:47,112
这是非常有趣的和棘手的东西 

1416
01:11:45,081 --> 01:11:50,100
但你还记得我们在前期谈

1417
01:11:48,012 --> 01:11:53,034
当然有关的区别 

1418
01:11:51,000 --> 01:11:55,041
使用条件和移动条件 

1419
01:11:53,034 --> 01:11:58,080
跳到实施条件

1420
01:11:55,041 --> 01:12:01,047
运算和条件可移动 

1421
01:11:58,008 --> 01:12:04,053
采取完全 的体系中的地位

1422
01:12:02,001 --> 01:12:08,028
这 条管线，但条件跳转 

1423
01:12:05,025 --> 01:12:10,032
如果它是一个不可预知的分支 

1424
01:12:08,028 --> 01:12:12,120
问题是，它可能会熄灭并执行 

1425
01:12:10,095 --> 01:12:14,160
让做了很多工作，浪费，但即使的

1426
01:12:13,002 --> 01:12:18,024
比 当它回来，并有 恶化 

1427
01:12:15,006 --> 01:12:18,695
重新启动需要一段时间 来 排序的补 

1428
01:12:18,042 --> 01:12:20,951
把所有的 

1429
01:12:19,289 --> 01:12:24,337
在系统中的缓冲区，并获得

1430
01:12:21,329 --> 01:12:24,373
在开足马力运行整个事情 

1431
01:12:26,042 --> 01:12:32,801
这样那样的结束了，则该 

1432
01:12:31,199 --> 01:12:34,260
这样，我形容它首先是做不 

1433
01:12:33,179 --> 01:12:37,590
做任何愚蠢的事

1434
01:12:34,026 --> 01:12:40,032
甚至和愚蠢的可能是 太强 

1435
01:12:37,059 --> 01:12:42,188
字不做 那种牢记 

1436
01:12:40,086 --> 01:12:43,140
有一些事情，你 应该 

1437
01:12:42,719 --> 01:12:47,820
作为一个程序员做所有的时间

1438
01:12:44,004 --> 01:12:50,033
而且他们 并不明显也许 再 

1439
01:12:47,082 --> 01:12:52,125
开始思考调整和越来越

1440
01:12:50,429 --> 01:12:55,590
一些指令级并行和我 

1441
01:12:53,025 --> 01:12:57,644
把它描述 为对机器，但我 

1442
01:12:55,059 --> 01:12:59,648
说几乎 所有时下的处理器 

1443
01:12:57,869 --> 01:13:03,000
这是一类机等等这些 

1444
01:13:00,179 --> 01:13:05,246
通用技术将工作的那些 

1445
01:13:03,000 --> 01:13:08,061
改变关联的想法会 

1446
01:13:05,849 --> 01:13:09,941
工作无论是你知道 ARM 

1447
01:13:08,061 --> 01:13:12,126
处理器内置到我的手机或

1448
01:13:10,769 --> 01:13:16,110
x86处理器内置到您的笔记本电脑 

1449
01:13:13,026 --> 01:13:18,905
或者鲨鱼的一台机器都 

1450
01:13:16,011 --> 01:13:20,690
有执行相同的一般 

1451
01:13:19,139 --> 01:13:25,214
结构使这些技术将工作 

1452
01:13:20,789 --> 01:13:27,853
横跨所有他们 确定 这会做 

1453
01:13:25,889 --> 01:13:27,943
今天它 

