1
00:00:00,000 --> 00:00:06,779
大家下午好，欢迎213 

2
00:00:03,024 --> 00:00:10,543
它的好，看你只是一个提醒 

3
00:00:06,779 --> 00:00:13,844
你的攻击实验室是由于在今晚

4
00:00:10,759 --> 00:00:18,180
下午11:59 你有一个 伟大的一天 

5
00:00:14,429 --> 00:00:21,431
这对于这个实验室和缓存实验室里，我们会去 

6
00:00:18,018 --> 00:00:22,089
并写信大约在同一时间 

7
00:00:21,449 --> 00:00:27,150
这将是 现金 有点紧 

8
00:00:22,089 --> 00:00:27,156
实验室它会由于下周四，所以你 

9
00:00:27,015 --> 00:00:33,084
可能想你可能希望得到 

10
00:00:28,056 --> 00:00:34,985
开始 不久 B2上一讲我们 

11
00:00:33,084 --> 00:00:37,116
了解了存储层次 和 

12
00:00:35,489 --> 00:00:42,440
缓存的想法今天我们要 

13
00:00:38,016 --> 00:00:45,395
看一个非常重要的一种缓存 

14
00:00:42,044 --> 00:00:48,683
这是一家 被 称为缓存 

15
00:00:45,539 --> 00:00:50,550
回忆和他们对我们很重要 

16
00:00:49,079 --> 00:00:52,050
你作为一个程序员，因为他们可以 

17
00:00:50,055 --> 00:00:53,127
对这么大的影响 

18
00:00:52,005 --> 00:00:56,016
你的 程序 的性能，所以如果你 

19
00:00:54,027 --> 00:00:59,156
了解这些缓存的存在 

20
00:00:56,016 --> 00:01:00,485
回忆和你知道他们的是如何工作的

21
00:00:59,399 --> 00:01:04,010
程序员，你就可以拿 

22
00:01:00,629 --> 00:01:04,010
利用这一点 ， 在 你的程序 

23
00:01:07,051 --> 00:01:12,095
所以最后一次 看的 

24
00:01:10,073 --> 00:01:19,135
内存层次是一家集 

25
00:01:12,095 --> 00:01:19,099
具有较小昂贵的存储设备 

26
00:01:20,059 --> 00:01:28,061
设备 的更快的设备 

27
00:01:23,021 --> 00:01:31,021
顶部和较慢的便宜，多 

28
00:01:28,079 --> 00:01:34,120
在较大的装置在底部和 

29
00:01:31,021 --> 00:01:37,097
然后在这个层次中的每个级别

30
00:01:35,002 --> 00:01:42,025
该等级 k作为该装置

31
00:01:37,097 --> 00:01:44,189
高速缓存保存的块的子集 

32
00:01:42,043 --> 00:01:52,052
被在包含在设备 

33
00:01:45,089 --> 00:01:54,095
在级别k 加-1现在回忆较低水平

34
00:01:52,052 --> 00:01:58,088
缓存的总体思路，所以我们有一个

35
00:01:54,095 --> 00:01:59,174
字节的存储阵列， 它是 这是我们 

36
00:01:58,088 --> 00:02:05,107
打破它任意成

37
00:02:00,074 --> 00:02:07,543
块，这些本集合

38
00:02:05,899 --> 00:02:12,140
存储器是较大的慢和更便宜和 

39
00:02:08,209 --> 00:02:14,218
所以它和它比 一个 更大 

40
00:02:12,014 --> 00:02:17,018
缓存是小更快 ， 更 

41
00:02:14,299 --> 00:02:18,304
昂贵的，并且，其保持并且 

42
00:02:17,018 --> 00:02:22,085
认为是块的子集

43
00:02:18,799 --> 00:02:23,896
包含在 主存储器中 ，然后 

44
00:02:22,085 --> 00:02:25,178
块被复制之间来回

45
00:02:24,769 --> 00:02:29,660
在这些块中的存储器高速缓存

46
00:02:26,078 --> 00:02:32,120
大小传送单元，从而，例如，如果 

47
00:02:29,066 --> 00:02:38,425
我们的程序请求 一直一个字 

48
00:02:33,002 --> 00:02:41,006
包含在块号4它要求 

49
00:02:39,019 --> 00:02:44,150
高速缓存发送到返回字 

50
00:02:41,006 --> 00:02:45,895
多数民众赞成在含有4块高速缓存

51
00:02:44,015 --> 00:02:47,114
外观和它在它的块

52
00:02:46,489 --> 00:02:50,810
块的子集，它的 

53
00:02:48,014 --> 00:02:53,048
朝发现块4不 

54
00:02:50,081 --> 00:02:56,135
有那么它要求 主存储器 发送 

55
00:02:53,048 --> 00:02:58,085
它块4 其中它不和 I和然后 

56
00:02:57,035 --> 00:03:02,060
当在该块到达它 

57
00:02:58,085 --> 00:03:03,163
如果潜在的缓存缓存存储

58
00:03:02,006 --> 00:03:07,007
覆盖现有的一些块 

59
00:03:04,063 --> 00:03:09,068
同样，如果如果我们的程序要求的 

60
00:03:07,007 --> 00:03:12,044
如果这是包含在数据字

61
00:03:09,068 --> 00:03:14,150
块10 缓存 看起来看到它 

62
00:03:13,007 --> 00:03:18,029
没有该块，因此请求 

63
00:03:15,005 --> 00:03:19,324
从存储器块中其拷贝 

64
00:03:18,029 --> 00:03:23,048
到高速缓存 

65
00:03:19,819 --> 00:03:27,260
现在 将覆盖 现有的块 

66
00:03:23,048 --> 00:03:29,947
随后，如果如果我们的程序要求 

67
00:03:27,026 --> 00:03:32,455
或者，如果我们的程序引用一个请求

68
00:03:30,379 --> 00:03:35,440
该中都包含的块10字

69
00:03:32,689 --> 00:03:38,150
例如那么缓存 ，然后 我们有一个 

70
00:03:35,989 --> 00:03:40,078
命中和高速缓存可以返回 块 

71
00:03:38,015 --> 00:03:43,024
立即而不去的 

72
00:03:40,879 --> 00:03:49,930
接触存储器的昂贵的操作

73
00:03:43,159 --> 00:03:51,950
现在从存储器中取出该块 

74
00:03:50,389 --> 00:03:54,290
有一个非常重要的一类 

75
00:03:51,095 --> 00:03:57,334
缓存这些所谓的高速缓存的思想

76
00:03:54,029 --> 00:04:00,928
其包含在CPU中的记忆

77
00:03:58,189 --> 00:04:03,202
芯片本身和完全管理 

78
00:04:01,189 --> 00:04:08,150
通过硬件和他们实施 

79
00:04:03,319 --> 00:04:10,730
使用快速SRAM存储器和想法 

80
00:04:08,015 --> 00:04:14,464
这个缓存是紧挨着 

81
00:04:10,073 --> 00:04:16,109
寄存器文件 是经常举行 

82
00:04:14,599 --> 00:04:19,190
从主 存储器 存取块或多个块中 

83
00:04:17,009 --> 00:04:21,014
被频繁好了，所以访问 

84
00:04:19,019 --> 00:04:25,618
希望因为原则 

85
00:04:21,059 --> 00:04:28,061
当地大多数 我们对数据的请求 的 

86
00:04:25,789 --> 00:04:31,940
实际上将被送达了 这 一点 

87
00:04:28,061 --> 00:04:33,134
在 几个周期缓存而不是 

88
00:04:31,094 --> 00:04:36,112
在这个集合，而不是从这种缓慢 

89
00:04:34,034 --> 00:04:36,112
主内存

90
00:04:39,046 --> 00:04:44,755
现在高速缓冲存储器的管理

91
00:04:41,069 --> 00:04:47,075
完全硬件因此，这意味着 

92
00:04:45,169 --> 00:04:50,150
该心脏 有必须有 

93
00:04:47,075 --> 00:04:52,079
知道如何 看 硬件逻辑 

94
00:04:50,015 --> 00:04:54,074
在高速缓存 ，并确定 块 

95
00:04:53,015 --> 00:04:57,214
是否一个特定的 块是 

96
00:04:54,074 --> 00:04:58,873
包含有这么缓存记忆

97
00:04:57,349 --> 00:05:01,970
已经在一个非常样的组织 

98
00:04:59,539 --> 00:05:04,570
严格简单的方法，这样的逻辑

99
00:05:01,097 --> 00:05:06,194
查找逻辑可以很简单，所以 

100
00:05:04,849 --> 00:05:12,050
这是非常所有的缓存记忆

101
00:05:07,094 --> 00:05:13,753
通过 以下方式组织的，你可以 

102
00:05:12,005 --> 00:05:19,063
想想，你能想到的缓存 

103
00:05:14,599 --> 00:05:19,630
为s的阵列等于给S集 

104
00:05:19,919 --> 00:05:25,984
每个组由电子商务到到e线 

105
00:05:27,077 --> 00:05:38,102
其中的每一行由D的块的

106
00:05:33,003 --> 00:05:43,982
它等于2到 数据a 的 d字节 

107
00:05:39,002 --> 00:05:46,071
这 表明这些是否有效位

108
00:05:44,279 --> 00:05:47,345
这些数据位实际上是位

109
00:05:46,071 --> 00:05:49,460
和数据 块实际上是 

110
00:05:47,939 --> 00:05:52,110
有意义的权利有可能 他们 

111
00:05:50,099 --> 00:05:53,140
可能仅仅是 随机位像你知道 

112
00:05:52,011 --> 00:05:56,540
当你第一次打开 机器 

113
00:05:53,509 --> 00:05:58,650
没有什么在缓存中，但这些 

114
00:05:56,639 --> 00:05:59,642
位将有值权的能力 

115
00:05:58,065 --> 00:06:01,137
是一或 零，但他们不会 

116
00:05:59,939 --> 00:06:05,400
实际上对应于 数据好所以 

117
00:06:02,037 --> 00:06:08,133
有效位告诉我们，如果这些如果这是

118
00:06:05,004 --> 00:06:10,095
打架实际上意味着什么 ，然后 

119
00:06:09,033 --> 00:06:14,522
有一些额外的比特称为 

120
00:06:11,031 --> 00:06:16,049
标记位，这将有助于我们寻找

121
00:06:14,819 --> 00:06:18,823
该块我会告诉你在一分钟内 

122
00:06:16,049 --> 00:06:22,131
现在，当我们谈论我们的高速缓存大小 

123
00:06:19,219 --> 00:06:27,080
我们指的是 数据的数量 

124
00:06:23,031 --> 00:06:32,660
中包含的块 的字节 和 

125
00:06:27,008 --> 00:06:37,077
所以每个缓存有有s设置有

126
00:06:32,939 --> 00:06:40,560
ee值每块集合和有乙字节 

127
00:06:37,077 --> 00:06:45,566
每块好了，所以总高速缓存尺寸为C 

128
00:06:40,056 --> 00:06:47,435
为s次; 乘以B 现在没事所以有 

129
00:06:46,259 --> 00:06:50,330
很多术语 来排序保持 挺直 

130
00:06:47,939 --> 00:06:53,011
它很容易去迷惑 

131
00:06:50,969 --> 00:06:56,054
线和块之间的差异

132
00:06:53,659 --> 00:06:59,490
线并设置好了 ，所以我们将通过 

133
00:06:56,819 --> 00:07:02,888
一些例子 ，希望这些意志 

134
00:06:59,049 --> 00:07:08,052
开始更有意义， 现在让我们来看看 

135
00:07:03,509 --> 00:07:12,515
在一般的我们如何如何缓存 

136
00:07:08,052 --> 00:07:15,131
硬件实现读，所以当我们的

137
00:07:12,569 --> 00:07:17,644
程序访问时，我们的计划 

138
00:07:15,599 --> 00:07:22,673
执行一些指令 

139
00:07:18,319 --> 00:07:26,384
在内存中引用了一些字的

140
00:07:23,339 --> 00:07:30,300
CPU发送一个地址到高速缓存和

141
00:07:26,969 --> 00:07:32,026
S 和它要求高速缓存 返回 

142
00:07:30,003 --> 00:07:32,242
字

143
00:07:32,066 --> 00:07:41,134
在该 地址类的话现金 

144
00:07:37,055 --> 00:07:46,064
获取该地址，这将是一个 

145
00:07:42,034 --> 00:07:50,102
如果在86 64 和壳体64位地址

146
00:07:47,045 --> 00:07:53,090
它划分地址为 多个 

147
00:07:51,002 --> 00:07:55,070
其是它们是区域

148
00:07:53,009 --> 00:07:57,053
通过对组织确定

149
00:07:55,007 --> 00:08:02,081
缓存还好它们是由那些确定 

150
00:07:58,034 --> 00:08:05,078
参数s那是在 S数 

151
00:08:03,044 --> 00:08:08,141
步骤a 每组的行数和 

152
00:08:05,078 --> 00:08:11,150
乙每个数据块的大小，以便在低 

153
00:08:09,041 --> 00:08:15,053
阶位有乙低位比特 

154
00:08:12,005 --> 00:08:21,094
其确定在块中的偏移量 

155
00:08:15,053 --> 00:08:26,071
那这个词开始在下一s 位 

156
00:08:22,039 --> 00:08:29,066
被视为无 符号 整数，其 

157
00:08:26,071 --> 00:08:31,073
用作索引的阵列 

158
00:08:29,066 --> 00:08:32,162
赛斯还记得我们只是觉得 这些 

159
00:08:31,091 --> 00:08:37,150
因为觉得这个缓存作为数组 

160
00:08:33,062 --> 00:08:40,136
设定的设定索引位提供索引 

161
00:08:38,005 --> 00:08:45,098
入到该阵列 的集合和 

162
00:08:41,036 --> 00:08:49,118
然后所有剩余 位的全部 

163
00:08:46,043 --> 00:08:52,061
剩余的t比特构成了我们 

164
00:08:50,018 --> 00:08:55,112
调用一个标签，这将有助于我们，当我们做 

165
00:08:52,061 --> 00:08:59,129
我们的搜索 所以缓存逻辑借此 

166
00:08:56,012 --> 00:09:03,080
解决它首先提取了 

167
00:09:00,029 --> 00:09:06,047
设置索引并使用该 作为指标 

168
00:09:03,008 --> 00:09:09,056
这个数组来识别的一组 

169
00:09:06,047 --> 00:09:12,131
如果此块是 集合 对不起，如果 

170
00:09:10,028 --> 00:09:16,037
如果块包含数据的字

171
00:09:13,031 --> 00:09:20,035
在该地址的数据字是在 

172
00:09:17,018 --> 00:09:26,022
它缓存将是在集合

173
00:09:20,071 --> 00:09:29,080
由该组索引表示好 

174
00:09:26,022 --> 00:09:31,119
所以第一它识别哪个索引到 

175
00:09:29,008 --> 00:09:31,047
在看

176
00:09:35,033 --> 00:09:43,058
然后它会检查它检查所有的标签 

177
00:09:40,016 --> 00:09:45,020
在 该组 的 线路 ， 看是否 

178
00:09:43,058 --> 00:09:47,147
有任何这些线路中的任何一个都 

179
00:09:45,056 --> 00:09:51,122
匹配的标签，一个标签相匹配的 

180
00:09:48,047 --> 00:09:55,070
经t 在地址 标签位 好吗 

181
00:09:52,022 --> 00:09:56,641
如果任何检查，看是否有效 

182
00:09:55,007 --> 00:09:57,074
位被打开，所以如果这两个 

183
00:09:56,839 --> 00:10:00,901
条件成立，如果有一条线 

184
00:09:58,037 --> 00:10:03,946
在设定为任何地方的 

185
00:10:01,459 --> 00:10:07,910
有效位是一个，有一个

186
00:10:04,279 --> 00:10:09,560
匹配的标签，然后我们有一个好打 

187
00:10:07,091 --> 00:10:16,112
那么，我们要寻找的块 

188
00:10:09,056 --> 00:10:18,119
此集合中包含没关系，如果我们一旦我们

189
00:10:17,012 --> 00:10:21,080
确定与我们已经我们已经 

190
00:10:19,019 --> 00:10:24,598
然后，确定该块现金用途 

191
00:10:21,008 --> 00:10:26,051
该低位 B个比特来确定 

192
00:10:24,769 --> 00:10:29,720
这里是其中数据我们

193
00:10:27,023 --> 00:10:33,092
内 的兴趣开始好吗 

194
00:10:29,072 --> 00:10:36,121
块没事，让我们来看一个更 

195
00:10:33,092 --> 00:10:38,174
一个最简单的一种具体的例子 

196
00:10:36,769 --> 00:10:43,795
现金是当E等于一个时 

197
00:10:39,074 --> 00:10:46,112
这里只有一条 线每设置 好了，所以一 

198
00:10:44,029 --> 00:10:52,370
每套这样的一个平等一行 

199
00:10:47,012 --> 00:10:54,101
现金被称为直接映射缓存等等 

200
00:10:52,037 --> 00:10:57,496
在这里，我们有一个 套每套包括 

201
00:10:55,001 --> 00:11:00,074
单行 ，现在亲假设 

202
00:10:57,829 --> 00:11:04,690
我们的程序引用的数据项在 

203
00:11:00,074 --> 00:11:07,082
特定地址的CPU感觉， 

204
00:11:04,069 --> 00:11:08,164
地址到高速缓存会缓存

205
00:11:07,082 --> 00:11:13,094
该地址将其分解成这些 

206
00:11:09,064 --> 00:11:14,383
为这三个字段 ， 然后 

207
00:11:13,094 --> 00:11:19,136
这个特定的地址 

208
00:11:14,959 --> 00:11:22,820
块偏移量是4和该组 

209
00:11:20,036 --> 00:11:24,625
指数是一个，然后有一些标签 

210
00:11:22,082 --> 00:11:26,110
我们将只表示与位

211
00:11:24,949 --> 00:11:31,300
粉嫩的颜色

212
00:11:27,001 --> 00:11:34,240
所以缓存中提取了一组索引

213
00:11:31,003 --> 00:11:37,099
这是一个，然后它使用 如作为 

214
00:11:34,339 --> 00:11:38,260
该指数进入设置 

215
00:11:40,839 --> 00:11:46,310
然后它就可以说，它只是忽略所有 

216
00:11:43,073 --> 00:11:48,107
我们正在寻找其他的去集德块 

217
00:11:46,031 --> 00:11:51,092
对于是在它的将是现金 

218
00:11:49,007 --> 00:11:54,011
在此插图 头号那么它 

219
00:11:51,092 --> 00:11:55,154
标签的比较骤降和 

220
00:11:54,011 --> 00:11:59,026
有效位，并认为他们承担 

221
00:11:56,054 --> 00:12:01,079
在和它匹配 的有效 位 

222
00:11:59,026 --> 00:12:07,067
然后它看起来在 块偏移量 

223
00:12:01,079 --> 00:12:08,150
为四个，这告诉它 的 

224
00:12:07,067 --> 00:12:10,163
四乘四十倍假设这 

225
00:12:09,005 --> 00:12:14,012
什么是指令引用了 

226
00:12:11,063 --> 00:12:17,105
在四个字节的开始，对于偏移 

227
00:12:14,057 --> 00:12:20,102
所以现在的高速缓存会借此 int和 

228
00:12:18,005 --> 00:12:29,057
它发回 了对 CPU，其 

229
00:12:21,002 --> 00:12:34,025
把它在寄存器 没关系，如果标签 

230
00:12:29,057 --> 00:12:35,446
和不匹配 的旧线，如果 

231
00:12:34,025 --> 00:12:39,101
标签不匹配，则有一个 小姐 

232
00:12:35,959 --> 00:12:42,034
在这种情况下， 高速缓存再去捡 

233
00:12:40,001 --> 00:12:46,025
的块中的相应块 

234
00:12:42,709 --> 00:12:49,760
从存储器中，然后覆盖该 

235
00:12:46,025 --> 00:12:51,068
块在一行，然后它可以充当

236
00:12:49,076 --> 00:12:53,174
那么它可以读取它可以 得到的字 

237
00:12:51,068 --> 00:12:57,077
淘汰掉块 ， 并发送回 

238
00:12:54,074 --> 00:12:59,147
到处理器，你知道让我 问你 

239
00:12:58,058 --> 00:13:01,085
问题只是 为了看看 实物支票 

240
00:13:00,047 --> 00:13:05,075
看看，如果你有以下沿 

241
00:13:01,085 --> 00:13:08,143
此所以，如果有一个 小姐和缓存 

242
00:13:05,075 --> 00:13:11,090
必须请求 从 存储器 块 

243
00:13:09,043 --> 00:13:16,046
从 存储器中 取出它 ，然后覆盖 

244
00:13:11,009 --> 00:13:20,036
在当前行中的块 做它 

245
00:13:16,073 --> 00:13:22,151
还必须更改标签骤降或 两个 

246
00:13:21,017 --> 00:13:26,024
那些留相同的，所以不会在做

247
00:13:23,051 --> 00:13:29,129
那 是在这 条线标记位 获得 

248
00:13:26,087 --> 00:13:31,160
用不同的值覆盖或为 

249
00:13:30,029 --> 00:13:43,091
它同

250
00:13:32,006 --> 00:13:45,100
同样现在不同了保存不同的原因

251
00:13:43,091 --> 00:13:45,154
这将是不同的 

252
00:13:47,063 --> 00:13:56,962
我们没有改变是的，我很抱歉 

253
00:13:58,073 --> 00:14:03,075
Olek几乎可以肯定有不同 

254
00:14:01,949 --> 00:14:15,968
数据，但它有一个 不同 

255
00:14:03,075 --> 00:14:18,093
地址正是它错过了错过

256
00:14:16,139 --> 00:14:21,500
因为它错过，因为标签

257
00:14:18,093 --> 00:14:23,172
标签不匹配

258
00:14:21,005 --> 00:14:26,010
如果有效位是假的，并且标签 

259
00:14:24,072 --> 00:14:29,801
匹配，那么那么这也 将 是一个 

260
00:14:26,055 --> 00:14:33,072
错过哦，那么你就不行 那 

261
00:14:30,449 --> 00:14:41,910
右没关系佳好 佳 好 

262
00:14:33,072 --> 00:14:44,076
伟大没事让我做一些让利 

263
00:14:41,091 --> 00:14:48,380
我做一个非常简单的具体实例 

264
00:14:45,012 --> 00:14:52,068
直接映射高速缓存是如何工作的III 

265
00:14:49,199 --> 00:14:54,240
要你真正了解详细

266
00:14:52,068 --> 00:14:56,076
这将如何工作 ，但我也想 

267
00:14:54,024 --> 00:15:00,053
做点关于弱点 

268
00:14:57,048 --> 00:15:01,277
直接映射缓存--is，为什么，为什么你 

269
00:15:00,269 --> 00:15:06,287
希望有多于一行 

270
00:15:01,709 --> 00:15:08,880
每设置好了，我们 这是一个非常 

271
00:15:06,449 --> 00:15:12,180
简单我们遇到了，我们有我们的记忆系统 

272
00:15:08,088 --> 00:15:14,357
包括好 16个字节，所以它不是 一个 

273
00:15:12,018 --> 00:15:19,041
有 4位 地址 非常 有用的系统 

274
00:15:15,149 --> 00:15:24,050
并且，它的分解成 2块 

275
00:15:19,041 --> 00:15:27,047
每个字节缓存我们共有4套 

276
00:15:24,005 --> 00:15:33,104
每个组的一个块

277
00:15:27,047 --> 00:15:36,416
现在我们4我们的 4位 地址，因为 

278
00:15:33,149 --> 00:15:39,180
等于这是2到 1，我们只 

279
00:15:36,839 --> 00:15:42,720
需要一个块 偏移位权有 

280
00:15:39,018 --> 00:15:44,237
在这样的字节的块 只有 2字节 

281
00:15:42,072 --> 00:15:48,156
我们要寻找的是无论是 在0或1 

282
00:15:44,399 --> 00:15:52,920
没关系 ，因为我们有4套，我们需要 

283
00:15:49,056 --> 00:15:54,147
掀起设置索引比特，然后将 

284
00:15:52,092 --> 00:15:57,881
其余位总是标记位 

285
00:15:55,047 --> 00:15:59,088
这种情况下， 只是一个标签的所有 死亡 

286
00:15:58,709 --> 00:16:04,470
现在，让我们 

287
00:15:59,088 --> 00:16:06,167
让我们假设我们的程序执行 

288
00:16:04,047 --> 00:16:10,106
引用的说明

289
00:16:07,067 --> 00:16:13,143
下列存储器地址零 一个 

290
00:16:10,529 --> 00:16:16,680
七八零和这些 

291
00:16:14,043 --> 00:16:18,051
引用读，他们是 

292
00:16:16,068 --> 00:16:22,967
每读一个字节读好 喜欢我 

293
00:16:19,023 --> 00:16:25,052
说这是一个非常简单的系统， 

294
00:16:23,579 --> 00:16:28,592
让我们来看看现在会发生什么，我们开始

295
00:16:25,259 --> 00:16:35,810
出艺术最初 是我们的缓存 

296
00:16:28,709 --> 00:16:37,796
空有效位都设置为零， 

297
00:16:35,081 --> 00:16:42,123
现在高速缓存接收到用于请求 

298
00:16:38,579 --> 00:16:44,666
这就是在地址零所以它字节

299
00:16:43,023 --> 00:16:49,050
提取组索引位，它们在 

300
00:16:45,449 --> 00:16:54,630
这种情况下是零零散所以这些所以它的 

301
00:16:49,005 --> 00:16:55,104
要在设置 零四个在 看 

302
00:16:54,063 --> 00:17:00,066
这种情况下，由于有效为零它只是 

303
00:16:56,049 --> 00:17:05,618
这是一个好小姐所以它是蚀刻 

304
00:17:00,066 --> 00:17:09,102
从存储器块粘块，以便 

305
00:17:06,059 --> 00:17:11,132
这种记忆，这是不错的，这是 

306
00:17:10,002 --> 00:17:15,301
使用阵列符号为存储器所以这

307
00:17:11,789 --> 00:17:18,150
就像从延长字节

308
00:17:15,319 --> 00:17:24,750
零偏移抵消一个包容性 

309
00:17:18,015 --> 00:17:27,048
内存标签位为零 ， 有效 

310
00:17:24,075 --> 00:17:31,094
位为1点确定现在下 下 

311
00:17:27,048 --> 00:17:34,059
自带的地址是地址1 

312
00:17:31,094 --> 00:17:37,107
嗯，这是一个正确的打击 ，因为我们设置 

313
00:17:34,059 --> 00:17:40,094
阻止包含字节的块

314
00:17:38,007 --> 00:17:44,070
和地址1 已经 在缓存 

315
00:17:40,094 --> 00:17:46,188
标签和标签没关系匹配所以我们 

316
00:17:44,007 --> 00:17:52,736
好那你现在我们得到的地址一击

317
00:17:47,088 --> 00:17:55,092
7，从而高速缓存中提取所述一组索引 

318
00:17:53,429 --> 00:18:01,830
位，在这种情况下是 11或4或 

319
00:17:56,028 --> 00:18:04,119
3，而看起来组 3有没有有效 

320
00:18:01,083 --> 00:18:08,148
位，所以这是一个小姐和它加载 

321
00:18:05,019 --> 00:18:11,091
对于 存储器跨越 数据 

322
00:18:09,048 --> 00:18:15,103
字节6 和7 

323
00:18:11,091 --> 00:18:19,096
在这种情况下， 该标签是 

324
00:18:16,003 --> 00:18:21,087
零好，所以我们记录，我们记录 

325
00:18:19,096 --> 00:18:23,128
在我们的 元数据 

326
00:18:21,087 --> 00:18:28,174
还好自带由下一个引用 

327
00:18:24,028 --> 00:18:34,062
8现在8 具有零 零 一组索引 

328
00:18:29,074 --> 00:18:37,078
零但是这 目前占用 

329
00:18:34,062 --> 00:18:42,070
零 块 一个， 我们可以告诉大家， 

330
00:18:37,078 --> 00:18:45,082
因为地址 8具有的1和一个标签 

331
00:18:42,007 --> 00:18:47,080
现有的块的块在 

332
00:18:45,082 --> 00:18:50,170
在地址0更早地址有一个标记 

333
00:18:48,043 --> 00:18:55,120
零所以这是 一个小姐，现在我们有 

334
00:18:51,007 --> 00:18:58,074
去获取包含块字节 

335
00:18:56,002 --> 00:19:04,071
8号到内存中，因此现在我们有 

336
00:18:59,037 --> 00:19:09,121
字节8和9，我们在我们的新标签做 

337
00:19:04,089 --> 00:19:14,107
现在没事了下一 条指令是 

338
00:19:10,021 --> 00:19:16,030
字节0，我们只是我们只是 更换我们 

339
00:19:15,007 --> 00:19:20,044
有它，我们有在我们的缓存和 

340
00:19:17,011 --> 00:19:24,025
我们刚刚更换它，所以它的另一 

341
00:19:20,044 --> 00:19:26,077
想念所以这是不幸的，它是 

342
00:19:24,025 --> 00:19:31,039
唯一的原因，我们错过这 是 因为 

343
00:19:26,077 --> 00:19:37,135
我们已经有了每套 等只有一行 

344
00:19:31,039 --> 00:19:40,101
我们被迫覆盖该说

345
00:19:38,035 --> 00:19:46,104
包含块字节块0 1 

346
00:19:41,001 --> 00:19:50,017
当我们的时候，我们错过了上块8 9 

347
00:19:47,004 --> 00:19:51,070
好了，所以这一点，你看有很多 

348
00:19:50,017 --> 00:19:54,115
房间在我们的缓存 我们还有 

349
00:19:51,007 --> 00:19:57,034
我们已经有了，我们没有 二 两线 

350
00:19:55,015 --> 00:20:01,039
即使访问权限，所以我们我们的缓存

351
00:19:57,097 --> 00:20:03,118
很多大，但只是因为那种 

352
00:20:01,039 --> 00:20:06,130
我们缓存的低相关性的 

353
00:20:04,018 --> 00:20:08,067
和排序模式 的 访问权限 

354
00:20:07,003 --> 00:20:11,044
我们赠送了模式

355
00:20:08,067 --> 00:20:16,068
我们已经有了一个 小姐真的是种 

356
00:20:11,071 --> 00:20:15,168
不必要所以噢对不起 

357
00:20:28,036 --> 00:20:35,119
六岁的时候，我们引用时，我们 

358
00:20:32,179 --> 00:20:40,130
引用了七它实际上是在

359
00:20:36,019 --> 00:20:42,508
它在 该块6一个 偏移 

360
00:20:40,013 --> 00:20:44,075
7点你，因为我们的块两个 

361
00:20:42,679 --> 00:20:46,728
字节他们会一直开始在偶数 

362
00:20:44,075 --> 00:20:46,494
多

363
00:20:51,021 --> 00:21:02,570
任何其他问题好了，所以这个所以这 

364
00:21:00,059 --> 00:21:05,138
排序就是 为什么你的理由 

365
00:21:02,759 --> 00:21:10,440
缓存具有更高的 相关性 更高 

366
00:21:05,849 --> 00:21:14,927
电子商务值，所以让我们来看看 ，并因此对 

367
00:21:10,044 --> 00:21:19,973
用于 为电子的值E时 的值 

368
00:21:15,629 --> 00:21:21,647
大于一大于我们参考 

369
00:21:20,369 --> 00:21:25,382
他们 作为方式来关联集 

370
00:21:21,809 --> 00:21:28,876
相联高速缓存所以这里Ë等于 二 

371
00:21:25,499 --> 00:21:32,552
所以这是一个2路它的2路相联 

372
00:21:29,479 --> 00:21:36,479
让我们，让我们假设我们有AA 2路

373
00:21:33,029 --> 00:21:39,035
2路相联缓存，以便我们在这里 

374
00:21:36,479 --> 00:21:42,536
有，我们有我们的台阵 和现在 

375
00:21:39,629 --> 00:21:48,650
每组包含两行，而不是没关系 

376
00:21:43,049 --> 00:21:52,105
一条线的，并假设我们介绍

377
00:21:48,839 --> 00:21:54,866
用以下形式的地址 

378
00:21:52,609 --> 00:21:59,626
我们正在寻找 开头 的单词 

379
00:21:55,109 --> 00:22:08,147
在 我们的块内关闭组四 

380
00:21:59,779 --> 00:22:11,786
在中集头号 还好使 

381
00:22:08,489 --> 00:22:17,542
即设置索引，所以这是缓存中提取 

382
00:22:12,479 --> 00:22:21,512
设置0 1 这被设置为 将其设置 

383
00:22:18,019 --> 00:22:28,320
扔掉所有其他组和现在 

384
00:22:21,809 --> 00:22:31,200
并联它搜索它搜索 

385
00:22:28,032 --> 00:22:34,591
标签则搜索 匹配的标签中 

386
00:22:31,002 --> 00:22:37,211
这两种都这些行和 

387
00:22:34,879 --> 00:22:41,580
防 有效 位，所以如果我们 得到一个匹配 

388
00:22:37,409 --> 00:22:47,491
标签和有效位真的，那么我们有 

389
00:22:41,058 --> 00:22:50,707
AA那么我们必须得一击即是的

390
00:22:48,229 --> 00:22:51,229
是的

391
00:22:54,001 --> 00:23:00,079
哦，这是一个非常好的 问题，所以 有 

392
00:22:58,045 --> 00:23:03,109
，做，这个硬件逻辑 

393
00:23:00,079 --> 00:23:05,167
比较和它的，这就是原因 

394
00:23:04,009 --> 00:23:08,071
作为为作为数 

395
00:23:06,067 --> 00:23:10,072
关联上升这一逻辑得到 

396
00:23:08,071 --> 00:23:13,075
越来越贵好滋味 

397
00:23:11,017 --> 00:23:18,022
一些像你那种做某种类型的 

398
00:23:13,075 --> 00:23:19,108
树搜索的 ，因此， 实际上是 

399
00:23:18,022 --> 00:23:22,093
这就是为什么我的意思是 ，因为在 极限 

400
00:23:20,008 --> 00:23:27,045
一般权利，如果你拿这个去 

401
00:23:22,093 --> 00:23:29,101
极限 这里 只有一组用 

402
00:23:27,045 --> 00:23:31,069
这里还有这是我们称之为 全 

403
00:23:30,001 --> 00:23:35,002
联想缓存，以便有只有 一个 

404
00:23:31,069 --> 00:23:36,115
设置和现在的任何块的块可以去 

405
00:23:35,002 --> 00:23:39,094
任何地方的权利没有限制 

406
00:23:37,015 --> 00:23:42,097
现在，你把块，但

407
00:23:39,094 --> 00:23:45,118
因为那复杂性 

408
00:23:42,097 --> 00:23:49,138
完全关联的搜索那些很 

409
00:23:46,018 --> 00:23:52,027
罕见其实你看到的 将完全看 

410
00:23:50,038 --> 00:23:55,129
联想缓存缓存，但其 

411
00:23:52,027 --> 00:24:00,069
软件缓存好了 ，所以在软件和 

412
00:23:56,029 --> 00:24:06,031
所以在复杂 的硬件和 

413
00:24:00,069 --> 00:24:07,156
那种不不 不它不是 

414
00:24:06,049 --> 00:24:10,075
值得不值得的复杂性 

415
00:24:08,056 --> 00:24:12,127
硬件用于 具有的 惩罚 

416
00:24:10,075 --> 00:24:14,122
较低的联想“钛不错，但也有 

417
00:24:13,027 --> 00:24:18,106
一些系统后，当我们研究了

418
00:24:15,022 --> 00:24:22,033
虚拟存储器中的虚拟存储器 

419
00:24:19,006 --> 00:24:25,039
系统中的DRAM 用作高速缓存 

420
00:24:22,033 --> 00:24:28,039
数据存储在磁盘上，正如我们所看到 

421
00:24:25,039 --> 00:24:30,103
最后一次的惩罚 ，如果你 一个小姐 

422
00:24:28,093 --> 00:24:32,155
对DRAM高速缓存和 你错过和 

423
00:24:31,003 --> 00:24:35,092
你必须去到磁盘 的惩罚是 

424
00:24:33,055 --> 00:24:37,117
巨大的为等 因为如此 

425
00:24:35,092 --> 00:24:41,164
这是值得拥有 很是值得的 

426
00:24:38,017 --> 00:24:45,022
在复杂的搜索搜索算法 

427
00:24:42,064 --> 00:24:47,131
特别是在一个虚拟存储器系统 

428
00:24:45,067 --> 00:24:49,123
该DRAM是实现了充分

429
00:24:48,031 --> 00:24:51,106
相联高速缓存，其中从磁盘块 

430
00:24:50,023 --> 00:24:54,067
可以去任何地方，我们会得到成 

431
00:24:52,006 --> 00:24:55,099
后来 当我们在虚拟 内存，但 

432
00:24:54,067 --> 00:24:57,076
你说的没错，你会在实际 系统 中看到 

433
00:24:55,099 --> 00:24:59,196
如今这个数字上升 右 

434
00:24:58,057 --> 00:25:02,064
因为特征尺寸 的 下降和 

435
00:25:00,096 --> 00:25:06,097
设计师有能力实现更 

436
00:25:03,027 --> 00:25:07,066
昂贵的硬件，但最大 

437
00:25:06,097 --> 00:25:08,135
的

438
00:25:07,309 --> 00:25:12,830
tivity的，我知道的Intel系统 

439
00:25:09,035 --> 00:25:13,133
16路相联L3高速缓存 ，然后 

440
00:25:12,083 --> 00:25:14,087
其余8 路关联 等等 

441
00:25:14,033 --> 00:25:20,099
这就是那种量级的 

442
00:25:15,023 --> 00:25:23,072
这是 最先进的 ，现在好了，所以 

443
00:25:20,099 --> 00:25:26,038
那么一旦我们确定了我们的比赛

444
00:25:23,072 --> 00:25:29,761
使用的设定偏移位在 此情况下 

445
00:25:26,929 --> 00:25:34,490
我们访问了一个短整型所以4是 

446
00:25:30,409 --> 00:25:36,418
这2块内的偏移量

447
00:25:34,049 --> 00:25:39,098
字节短整型，然后我们就可以返回 

448
00:25:36,499 --> 00:25:41,690
到 处理器 好了让我们做 

449
00:25:39,098 --> 00:25:44,647
我们以前做的是相同的 仿真 

450
00:25:41,069 --> 00:25:50,072
但这次与 2路相联 

451
00:25:45,529 --> 00:25:52,555
现在高速缓存存储器系统是相同的，但 

452
00:25:50,072 --> 00:25:56,144
现在 ，而不是一组，我们有两套 

453
00:25:52,789 --> 00:26:00,470
我的意思是我很抱歉，而不是四个 

454
00:25:57,044 --> 00:26:01,993
集我们有两套所以缓存此 

455
00:26:00,047 --> 00:26:04,246
相同大小的缓存，但我们只是

456
00:26:02,389 --> 00:26:06,391
去不同的方式组织它，而不是 

457
00:26:04,669 --> 00:26:09,757
的一种方式 ， 而不是 直接映射 

458
00:26:06,409 --> 00:26:12,740
缓存中含有四个四行 

459
00:26:10,549 --> 00:26:14,620
行每套一条线， 我们要 

460
00:26:12,074 --> 00:26:16,169
实现2路相联缓存

461
00:26:15,259 --> 00:26:20,330
在这里我们有两套两线

462
00:26:17,069 --> 00:26:24,073
每设置好了，所以每一种情况下也仅4 

463
00:26:20,033 --> 00:26:24,037
有总共四个行质疑

464
00:26:26,087 --> 00:26:32,129
样子像哦，使得进来

465
00:26:30,092 --> 00:26:35,185
与请求不知何故居然和我 

466
00:26:33,029 --> 00:26:39,046
不知道的细节，它可能我 

467
00:26:36,085 --> 00:26:40,163
想有这样它可以请您提供 

468
00:26:39,046 --> 00:26:45,095
有可能仅仅是 一个默认的叹息 

469
00:26:41,063 --> 00:26:47,099
也许它永远它总是一个由64 

470
00:26:45,095 --> 00:26:49,133
字，然后将提取物的处理器 

471
00:26:47,099 --> 00:26:52,103
当前位 其实我不 

472
00:26:50,033 --> 00:26:54,119
知道这一点，但 它的细节 或者 

473
00:26:53,003 --> 00:26:56,099
进来的 请求或或有一个 

474
00:26:55,019 --> 00:27:01,061
标准有一个标准尺寸

475
00:26:56,099 --> 00:27:02,141
然后处理器 解析出我们只是 

476
00:27:01,061 --> 00:27:08,135
假设缓存知道木 

477
00:27:03,041 --> 00:27:10,049
尺寸为yes返回你如何决定 

478
00:27:09,035 --> 00:27:12,038
该块你的地方就是这样的 

479
00:27:11,021 --> 00:27:15,029
一个很好的问题， 所以有很多 

480
00:27:12,065 --> 00:27:17,069
不同的算法 的大部分 

481
00:27:15,029 --> 00:27:20,114
最常见的算法或共同 

482
00:27:17,069 --> 00:27:23,084
算法最近最少使用这样的 

483
00:27:21,014 --> 00:27:25,016
地方你要保持你想要的 

484
00:27:23,084 --> 00:27:27,167
保持块是缓存 

485
00:27:25,034 --> 00:27:30,053
被使用了很多，因此，如果一个块不 

486
00:27:28,067 --> 00:27:32,069
由长时间引用

487
00:27:30,053 --> 00:27:35,132
通过排序 的 局部性原理

488
00:27:32,069 --> 00:27:37,163
逆局部性原理很可能

489
00:27:36,032 --> 00:27:41,108
不要 在解决引用 

490
00:27:38,063 --> 00:27:44,102
不久的将来 ， 所以所以这是一个这是一个 

491
00:27:42,008 --> 00:27:47,069
算法，你只是跟踪 

492
00:27:45,002 --> 00:27:49,010
并且，我没有表现出 有需要 

493
00:27:47,069 --> 00:27:51,125
要附加位在线路 

494
00:27:49,082 --> 00:27:54,113
有点像保持那种虚 

495
00:27:52,025 --> 00:27:56,084
时间戳 这一点，但就是这样的一个 

496
00:27:55,013 --> 00:27:59,075
这就是那种 你这样做 的 一般方式 

497
00:27:56,084 --> 00:28:01,115
只是尽量保持属于的东西 

498
00:27:59,075 --> 00:28:05,083
正在 访问 的最块

499
00:28:02,015 --> 00:28:06,019
经常最近是 

500
00:28:08,001 --> 00:28:13,063
还好，问题 是什么决定了 

501
00:28:10,078 --> 00:28:15,130
该年代由预定的块大小 

502
00:28:13,063 --> 00:28:18,148
存储系统的设计， 所以这是一个 

503
00:28:16,003 --> 00:28:21,052
这是这的第六参数 

504
00:28:19,048 --> 00:28:24,055
存储系统，所以当英特尔 

505
00:28:21,079 --> 00:28:27,088
设计师决定把 高速缓冲存储器 

506
00:28:25,018 --> 00:28:36,072
他们的处理器，他们决定

507
00:28:27,088 --> 00:28:35,172
块大小将是64个字节遗憾 

508
00:28:38,028 --> 00:28:46,066
所以块大小来块大小

509
00:28:42,064 --> 00:28:49,108
自带第一，然后再确定如何 

510
00:28:46,066 --> 00:28:52,149
大你希望 你的缓存是可以的， 

511
00:28:50,008 --> 00:28:56,032
那么， 你确定关联 

512
00:28:53,049 --> 00:28:57,124
没关系，然后，一旦你确定 

513
00:28:56,032 --> 00:29:00,046
关联性，你知道有多大的 

514
00:28:58,024 --> 00:29:01,099
缓存然后确定数 

515
00:29:00,046 --> 00:29:12,115
套 好 

516
00:29:01,099 --> 00:29:14,173
所以基本上所有那些的了 

517
00:29:13,015 --> 00:29:17,113
行 数 和猫和 

518
00:29:15,073 --> 00:29:19,078
容量每组线的数量 是 

519
00:29:18,013 --> 00:29:22,069
排序第六高电平参数的

520
00:29:20,023 --> 00:29:25,117
设计参数缓存的大小 

521
00:29:22,069 --> 00:29:27,121
是一个为高电平的设计参数 

522
00:29:26,017 --> 00:29:32,025
然后组数然后是 

523
00:29:28,021 --> 00:29:32,097
从这样行不行是诱导

524
00:29:40,003 --> 00:29:46,004
就是这样的呀怎么所以这 

525
00:29:43,007 --> 00:29:47,015
这就是替换策略 如何做 

526
00:29:46,004 --> 00:29:48,098
它所以问题是怎么做 的时候 

527
00:29:47,087 --> 00:29:50,132
还有多条线路在一组怎么做 

528
00:29:49,034 --> 00:29:53,042
它确定 过度过 右 

529
00:29:51,032 --> 00:29:54,107
那是什么，这 是以前的 

530
00:29:53,042 --> 00:29:57,068
问题 大概 也许我应该有 

531
00:29:55,007 --> 00:30:00,089
重复它，就尽量挑线 

532
00:29:57,068 --> 00:30:03,070
那这是最近最少 使用，因此 

533
00:30:00,089 --> 00:30:04,166
没有被访问的行线

534
00:30:03,007 --> 00:30:07,010
最近都不错的候选人

535
00:30:05,066 --> 00:30:09,071
因为更换，因为那种 

536
00:30:07,073 --> 00:30:11,078
逆局部性原理正确 的 

537
00:30:09,071 --> 00:30:13,088
他们没有被反转引用 

538
00:30:12,023 --> 00:30:19,046
最近，机会是他们不会 

539
00:30:13,088 --> 00:30:19,175
再次引用它哦耶有

540
00:30:19,046 --> 00:30:23,054
额外的位，我不是展示 

541
00:30:20,075 --> 00:30:25,160
在这里 ，你必须 这样，所以当你 

542
00:30:23,054 --> 00:30:28,061
替换一条线在所述一组，如果该数据 

543
00:30:26,006 --> 00:30:30,068
已经改变 ，那么它 已经被 写入 

544
00:30:28,061 --> 00:30:46,112
回到记忆 ，这就是另一个很好的我 

545
00:30:31,022 --> 00:30:50,026
还没有表现出是啊所以所以是这样 

546
00:30:47,012 --> 00:30:52,097
这是 一个真正的，这是 真正棘手 

547
00:30:50,062 --> 00:30:55,079
参数正确这是一个 它是一个高层次 

548
00:30:52,097 --> 00:30:55,156
系统参数就是它的推移

549
00:30:55,079 --> 00:30:58,157
多年 

550
00:30:56,056 --> 00:31:02,117
这样的想法，你想有块

551
00:30:59,057 --> 00:31:03,140
为了利用空间局部性权 

552
00:31:03,017 --> 00:31:06,083
想一想 ，如果你打算去 

553
00:31:04,004 --> 00:31:08,081
如果您在 高速缓存 中的小姐 的烦恼

554
00:31:06,083 --> 00:31:10,088
而你要去的麻烦 

555
00:31:09,017 --> 00:31:14,036
一路去记忆得到一些 

556
00:31:11,033 --> 00:31:16,112
你想 你的数据要分期偿还 

557
00:31:14,036 --> 00:31:19,082
通过获取该数据的费用 

558
00:31:17,012 --> 00:31:22,067
取多个字节这

559
00:31:19,082 --> 00:31:24,146
这对块的动机，因为 

560
00:31:22,067 --> 00:31:30,083
由由局部性原理 

561
00:31:25,046 --> 00:31:32,051
在特定的空间位置 ，如果你 

562
00:31:30,083 --> 00:31:33,110
参考块的内部的字 

563
00:31:32,051 --> 00:31:35,093
机会是你要引用 

564
00:31:34,001 --> 00:31:36,050
附近的话这也将是 一个 

565
00:31:35,093 --> 00:31:38,129
结语

566
00:31:36,059 --> 00:31:41,143
好了，所以块的全部目的 

567
00:31:39,029 --> 00:31:46,638
块是利用空间局部性 

568
00:31:42,043 --> 00:31:49,242
现在，如果你让你的块太小 

569
00:31:46,899 --> 00:31:50,931
那么你就不是你不摊销你 

570
00:31:49,629 --> 00:31:53,666
没有得到相同的权摊销 

571
00:31:51,219 --> 00:31:56,223
你可能得到一个你所带来的块 

572
00:31:53,999 --> 00:31:58,038
所以有你雾参考

573
00:31:56,259 --> 00:31:59,346
你把块有另一个

574
00:31:58,389 --> 00:32:02,424
附近你参考得到一击，因为 

575
00:32:00,129 --> 00:32:04,167
块 是存储器但随后的 下一个 

576
00:32:02,739 --> 00:32:05,817
参考是在不同的块 

577
00:32:04,509 --> 00:32:09,546
因为你的块 大小太小 

578
00:32:06,519 --> 00:32:12,540
让你有种想使块大 

579
00:32:09,879 --> 00:32:13,914
尽可能地大，但没有放缓 

580
00:32:12,729 --> 00:32:15,744
关闭系统，所以如果你做了 

581
00:32:14,229 --> 00:32:20,270
块的大小太大，将只取 

582
00:32:15,879 --> 00:32:22,950
过长 带来的是块加 

583
00:32:20,639 --> 00:32:25,716
再加上现在你块，你的块 

584
00:32:23,589 --> 00:32:27,621
占用位 缓存内存中 ，以便 

585
00:32:26,409 --> 00:32:29,442
现在有没有空间的其它块 

586
00:32:27,909 --> 00:32:32,931
右所以它是一个真正的这是一个非常 

587
00:32:29,739 --> 00:32:34,776
棘手的 设计问题，正确的 ， 我如果 

588
00:32:33,129 --> 00:32:36,580
我们正在做它采取的架构 

589
00:32:35,109 --> 00:32:39,111
类的话，就要将我们 的排序 

590
00:32:36,058 --> 00:32:40,647
潜入你知道如何如何 

591
00:32:39,309 --> 00:32:43,320
建筑师让那些设计决策

592
00:32:41,169 --> 00:32:46,218
但总的来说，这就是它的种 

593
00:32:43,419 --> 00:32:49,451
一个平衡的行为的权利有任何其他 

594
00:32:46,659 --> 00:32:49,667
问题是 

595
00:32:52,088 --> 00:32:54,091
哦

596
00:32:56,063 --> 00:32:59,096
问题是，每次有一个

597
00:32:58,022 --> 00:33:02,026
神话，你必须做你 必须 

598
00:32:59,096 --> 00:33:04,132
选择一个受害线和覆盖它 

599
00:33:02,062 --> 00:33:08,063
是啊，我不 知道任何高速缓存的那 

600
00:33:05,032 --> 00:33:10,127
不这样做，现在我们要 我们 什么时候见 

601
00:33:08,063 --> 00:33:13,079
查看 写入 我们会看到有一个 

602
00:33:11,027 --> 00:33:15,092
我们是否 会只盯着 选项 

603
00:33:13,079 --> 00:33:18,173
读，但现在与写道， 

604
00:33:15,092 --> 00:33:21,170
问题就来了，如果你

605
00:33:19,073 --> 00:33:22,112
等了一对夫妇 的幻灯片，我们会去 的 

606
00:33:22,007 --> 00:33:26,014
过度 

607
00:33:23,012 --> 00:33:27,040
我们去了任何其他问题 

608
00:33:28,018 --> 00:33:34,040
好了，让我们来看看这这种双向 

609
00:33:31,001 --> 00:33:37,082
相联高速缓存现在有有

610
00:33:34,004 --> 00:33:39,050
一个块偏移一点 ，我们只有两个 

611
00:33:37,082 --> 00:33:41,123
集，因此我们只 需要 一个指标 

612
00:33:39,086 --> 00:33:44,153
然后将剩余的两个比特 

613
00:33:42,023 --> 00:33:48,089
贴上标签 ，以让我们 通过 我们的跟踪，这样 

614
00:33:45,053 --> 00:33:52,139
零地址有一组是集零 

615
00:33:48,089 --> 00:33:59,093
就在这里，这是一个 小姐，所以我们加载 

616
00:33:53,039 --> 00:34:03,044
与参照 存储器 

617
00:34:00,029 --> 00:34:05,102
解决一个是在设置零和 

618
00:34:03,044 --> 00:34:09,056
这是一个打击，因为这 是一个字节 

619
00:34:06,002 --> 00:34:12,029
在为我们的块参考 

620
00:34:09,056 --> 00:34:13,103
七等于一个小姐那是在一个组，所以我们 

621
00:34:12,029 --> 00:34:16,091
加载，而我们只是挑选 

622
00:34:14,003 --> 00:34:20,056
随机剔这两个中的一个以上 

623
00:34:16,091 --> 00:34:22,118
正确的，因为他们是缓存为空 

624
00:34:20,056 --> 00:34:25,139
下一个参考 是为了 解决数 

625
00:34:23,018 --> 00:34:28,070
其中八个是集零 ，现在这里的 

626
00:34:26,039 --> 00:34:30,068
这里的直接 的区别 

627
00:34:28,007 --> 00:34:32,015
映射的高速缓存，这为时已晚集

628
00:34:30,068 --> 00:34:37,076
相联高速缓存，当我们的时候，我们 

629
00:34:33,005 --> 00:34:39,098
参考地址8该块 具有 

630
00:34:38,048 --> 00:34:43,145
相应的块已去 

631
00:34:40,043 --> 00:34:46,046
到因为 这个0集合索引 集0 

632
00:34:44,045 --> 00:34:47,126
位，但我们有空间，现在因为我们 

633
00:34:46,073 --> 00:34:51,080
被设置为具有 空间两条线 

634
00:34:48,026 --> 00:34:54,092
而不是 一个，所以当我们加载 在 

635
00:34:51,008 --> 00:34:55,055
那么，如果我们有一个 可用的空闲时隙 

636
00:34:54,092 --> 00:34:57,113
我们把它放在那里，我们不会覆盖

637
00:34:56,027 --> 00:35:01,093
任何事情的权利，所以如果可能 总是试图 

638
00:34:58,013 --> 00:35:04,062
覆盖空的空行 

639
00:35:01,093 --> 00:35:07,174
所以现在我们在这个组已经有了我们已经得到了 

640
00:35:04,062 --> 00:35:11,118
块0和1块8 9所以，当我们得到 

641
00:35:08,074 --> 00:35:14,101
我们参考块地址0 

642
00:35:12,018 --> 00:35:16,054
而在此之前与当我们有一个 

643
00:35:15,001 --> 00:35:19,030
冲突未在直接 映射缓存 

644
00:35:16,054 --> 00:35:21,073
现在我们可以，我们能满足这一说

645
00:35:19,003 --> 00:35:23,065
要求它击中在内存中，我们可以将 

646
00:35:21,073 --> 00:35:28,147
缓存可以从缓存中满足它 

647
00:35:23,092 --> 00:35:38,113
而不是去记忆 OK，这样 

648
00:35:29,047 --> 00:35:40,113
有道理 OK现在 大概 写 什么 ，所以 

649
00:35:39,013 --> 00:35:43,108
有数据的多个副本

650
00:35:41,013 --> 00:35:46,081
对，我们 的子集划分我们动起来 

651
00:35:44,008 --> 00:35:52,075
层次结构，我们正在创建的子集 

652
00:35:46,081 --> 00:35:57,088
在高速缓存 所以我们做什么，如果 数据 

653
00:35:52,075 --> 00:36:02,116
我们做了写一个字块中 

654
00:35:58,051 --> 00:36:05,107
这是目前在缓存 好的，我们有 

655
00:36:03,016 --> 00:36:08,073
我们有两个选择，我们可以写 

656
00:36:06,007 --> 00:36:11,014
立刻 拦截 到 我们 的内存 权 

657
00:36:08,073 --> 00:36:13,107
我们已经有了一个块是如此之大 

658
00:36:11,014 --> 00:36:16,099
我们正在更新 它的一个小块 

659
00:36:14,007 --> 00:36:18,013
所以我们可以，我们可以 做的更新 

660
00:36:16,099 --> 00:36:20,182
然后它立即刷新到存储器 

661
00:36:18,067 --> 00:36:23,068
让记忆总是反映了 

662
00:36:21,082 --> 00:36:27,151
的存储器内容总是反映 

663
00:36:23,068 --> 00:36:30,097
缓存的内容确定 ，但认为是 

664
00:36:28,051 --> 00:36:33,139
贵 权我的意思是，你知道内存 

665
00:36:30,097 --> 00:36:35,119
访问是昂贵的其他所以 

666
00:36:34,039 --> 00:36:36,082
另一种选择是什么什么叫写 

667
00:36:36,019 --> 00:36:39,058
背部

668
00:36:36,082 --> 00:36:42,181
所以在这种情况下，当我们写一个块

669
00:36:39,058 --> 00:36:47,062
在缓存中，我们不不刷新它 

670
00:36:43,081 --> 00:36:49,105
到内存中，直到我们选出特定 

671
00:36:47,062 --> 00:36:53,095
行，那将是一个受害者

672
00:36:50,005 --> 00:36:56,026
覆盖才把只有当 

673
00:36:53,095 --> 00:36:57,123
我们只是我们有点推迟写作 

674
00:36:56,026 --> 00:37:01,120
到内存中，直到最后一分钟 

675
00:36:58,023 --> 00:37:05,038
我们推迟到只是缓存之前 

676
00:37:02,002 --> 00:37:07,033
将覆盖该数据块确定 

677
00:37:05,038 --> 00:37:08,095
所以这就是所谓的 回写和 

678
00:37:07,051 --> 00:37:09,127
写回，你需要有一定的 

679
00:37:08,095 --> 00:37:11,194
在表示线条额外位 

680
00:37:10,027 --> 00:37:15,088
这是否是块被写入 

681
00:37:12,094 --> 00:37:16,192
所以算法就是当现金 

682
00:37:15,088 --> 00:37:20,113
识别特定的线 

683
00:37:17,092 --> 00:37:22,099
覆盖它会检查脏位 

684
00:37:21,013 --> 00:37:29,014
如果它被设置该行 然后将其 写入 

685
00:37:23,062 --> 00:37:30,085
这些数据如果备份到磁盘，如果 

686
00:37:29,014 --> 00:37:32,026
数据还没有，如果该块具有 良好 

687
00:37:30,085 --> 00:37:33,130
写有没有点有没有必要

688
00:37:32,026 --> 00:37:37,033
把它写回，因为它是相同的 

689
00:37:34,003 --> 00:37:42,091
它具有 相同的 值 的副本 

690
00:37:37,033 --> 00:37:44,074
在磁盘上的OK块现在 又怎么样了这么 

691
00:37:43,018 --> 00:37:46,099
这是这里 发生了，如果 现在什么是正确的 

692
00:37:44,074 --> 00:37:50,083
我们 有一个 正确的 错过 ，所以我们正在做一个 

693
00:37:46,099 --> 00:37:53,176
正确 的记忆和我们的字 

694
00:37:51,064 --> 00:37:57,130
写入不包含在任何块 

695
00:37:54,076 --> 00:37:59,080
这是在我们的高速缓存，所以我们有两个 

696
00:37:58,003 --> 00:38:01,042
选项我们 可以做什么叫做写 

697
00:37:59,008 --> 00:38:03,013
分配所以，如果，如果我们可以把它 

698
00:38:01,069 --> 00:38:04,078
有一个小姐，我们可以做排序 的 

699
00:38:03,085 --> 00:38:07,150
我们做了与 它 对称的东西 

700
00:38:05,059 --> 00:38:10,072
命中这 是创建一个新的一个 新的 

701
00:38:08,005 --> 00:38:14,050
线可能覆盖现有 

702
00:38:10,072 --> 00:38:16,147
行，然后 写这样我们就可以，所以我们 

703
00:38:14,095 --> 00:38:18,187
可以创建缓存输入缓存 

704
00:38:17,047 --> 00:38:22,129
行从存储器中取出它，然后做 

705
00:38:19,087 --> 00:38:24,109
然后执行做正确的 确定，所以 这 

706
00:38:23,029 --> 00:38:28,051
是那种对称的 ，以读取正确 的 

707
00:38:25,009 --> 00:38:31,036
所以每一个权利，如果它错过当 

708
00:38:28,051 --> 00:38:33,130
右结束该块将在 

709
00:38:31,036 --> 00:38:36,064
高速缓存，如果我们做一个后续读 

710
00:38:34,003 --> 00:38:40,006
我们得到一击 好了，所以这是这样的 

711
00:38:36,064 --> 00:38:43,161
原因你可能想要做的是， 

712
00:38:40,006 --> 00:38:46,012
另一种 选择是 只是为了不分配 

713
00:38:44,061 --> 00:38:48,100
在缓存中的项目不分配 

714
00:38:47,002 --> 00:38:52,090
新行只写写入数据 

715
00:38:49,000 --> 00:38:54,076
直接内存你并不 真正需要 

716
00:38:53,008 --> 00:38:57,046
理解之间的区别

717
00:38:54,076 --> 00:38:59,173
这两件事情 不同的缓存使用 

718
00:38:57,046 --> 00:39:03,118
为你自己的心理不同的政策 

719
00:39:00,073 --> 00:39:06,124
模型中使用的 一个很好的模式 仅仅是 

720
00:39:04,018 --> 00:39:09,022
假设写回写分配所以才

721
00:39:07,024 --> 00:39:11,062
假设我们不会，我们 不会复制 

722
00:39:09,022 --> 00:39:13,078
数据到磁盘 ，如果有一击，我们不会 

723
00:39:11,062 --> 00:39:16,105
它写回磁盘 ，直到最后 

724
00:39:13,078 --> 00:39:18,082
可能分钟，每有一个时间 

725
00:39:17,005 --> 00:39:21,076
写错过，我们将创建一个 新条目 

726
00:39:19,018 --> 00:39:24,047
缓存 确定，所以这是我认为 

727
00:39:21,076 --> 00:39:25,103
这是那种最简单的模型的 那 

728
00:39:24,047 --> 00:39:27,131
这是一个原因，它是一个合理的模型

729
00:39:26,003 --> 00:39:33,098
你可以不管 用 

730
00:39:28,031 --> 00:39:35,069
现在特别是缓存实现的 

731
00:39:33,098 --> 00:39:36,487
真正的系统到目前为止，我们 只看到 

732
00:39:35,069 --> 00:39:42,071
我们只能假定有一个单一 

733
00:39:37,369 --> 00:39:48,200
缓存，但在 实际系统 中 有 

734
00:39:42,089 --> 00:39:54,148
多个多个缓存 所以现代核心 

735
00:39:48,002 --> 00:39:55,030
英特尔酷睿i7的Haswell架构

736
00:39:55,051 --> 00:40:00,143
包含多个处理器核心，以便4 

737
00:39:59,069 --> 00:40:04,076
对于像 桌面 典型数量 

738
00:40:01,043 --> 00:40:06,131
系统8月8日至12日这是典型 的 

739
00:40:04,076 --> 00:40:08,104
服务器类系统中，这些处理器

740
00:40:07,031 --> 00:40:10,117
内核可以分别执行自己

741
00:40:09,004 --> 00:40:16,009
在独立的指令流

742
00:40:11,017 --> 00:40:19,040
平行并且每个处理器核心罐

743
00:40:16,054 --> 00:40:22,061
包含通用寄存器，其 

744
00:40:19,004 --> 00:40:27,005
这是在缓存0级，然后2 

745
00:40:23,024 --> 00:40:31,025
不同种 的 L1高速缓存 中的数据 

746
00:40:27,041 --> 00:40:33,139
缓存L1D缓存和缓存眼 

747
00:40:31,025 --> 00:40:37,121
将L是指令高速缓冲存储器和

748
00:40:34,039 --> 00:40:39,101
这些是这些都是相当小的32千 

749
00:40:38,021 --> 00:40:42,089
字节他们是八路关联和 

750
00:40:40,001 --> 00:40:47,054
他们可以在一个非常小的访问 

751
00:40:42,089 --> 00:40:50,113
循环 的 下一 级别 的数

752
00:40:47,054 --> 00:40:55,141
层次结构是 L是L2高速缓存 

753
00:40:51,013 --> 00:41:00,017
这仍然是相当小的256千个字节 

754
00:40:56,041 --> 00:41:04,000
同样的关联性 ，它有一个稍微 

755
00:41:00,017 --> 00:41:06,026
访问时间更长，并和它的统一 

756
00:41:04,369 --> 00:41:11,570
在L2高速缓存中包含的意义

757
00:41:07,007 --> 00:41:14,796
数据和指令 确定，所以这是 

758
00:41:11,057 --> 00:41:17,132
都在芯片 上的单核 和 

759
00:41:14,859 --> 00:41:20,180
然后还有芯片，但外部对 

760
00:41:18,032 --> 00:41:23,108
所有的核心，并通过所有的共享

761
00:41:20,018 --> 00:41:28,022
核心是在L3统一高速缓存是 8 

762
00:41:24,008 --> 00:41:32,082
兆字节和16路关联与 

763
00:41:28,022 --> 00:41:37,053
访问时间就像40到75次

764
00:41:32,082 --> 00:41:39,153
所以，如果如果有一个小姐在L1 则 

765
00:41:37,053 --> 00:41:42,066
L1 传感器试图发送一个请求到L2 

766
00:41:40,053 --> 00:41:44,130
尝试，试图找到在L2数据 

767
00:41:42,066 --> 00:41:46,113
因为L2是稍微大一点，也许，也许 

768
00:41:45,003 --> 00:41:50,016
数据还没有被冲洗掉L2的 

769
00:41:47,013 --> 00:41:53,058
但如果他们会-无法找到 它， 它发送 

770
00:41:50,043 --> 00:41:56,049
到L3的请求，看看他们是否能找到 

771
00:41:53,058 --> 00:41:58,071
在L3的数据，如果L3不能找到它，然后 

772
00:41:57,003 --> 00:42:05,007
它放弃它熄灭芯片 

773
00:41:58,071 --> 00:42:08,109
内存是问题是名称的记忆中 

774
00:42:05,007 --> 00:42:11,091
这就是它的内置DRAM芯片DRAM 

775
00:42:09,009 --> 00:42:14,042
这是它的独立是在一个单独的 

776
00:42:11,091 --> 00:42:17,124
在主板上单独设置的芯片 

777
00:42:14,042 --> 00:42:21,063
通过那些I / O桥连接，使得 

778
00:42:18,024 --> 00:42:24,026
我们和总线各种总线 那么 

779
00:42:21,063 --> 00:42:23,144
我们谈到了最后一次 

780
00:42:28,048 --> 00:42:32,056
并为所有不同所有 这些 

781
00:42:31,027 --> 00:42:41,050
不同的缓存块的大小为64 

782
00:42:33,028 --> 00:42:43,081
字节现在 有许多 不同 的 

783
00:42:41,005 --> 00:42:49,030
的方式来 思考的性能 

784
00:42:43,081 --> 00:42:51,118
缓存我的是最普通的方法是使用

785
00:42:49,075 --> 00:42:53,116
一个指标 叫小姐率 等什么 

786
00:42:52,018 --> 00:42:58,096
这是引用的馏分 

787
00:42:54,016 --> 00:43:03,016
小姐所以我们很，所以 我 想， 它的 

788
00:42:58,096 --> 00:43:04,245
1 减去命中率如此典型的 

789
00:43:03,016 --> 00:43:08,092
缓存的工作 那么这个速度必须 是 

790
00:43:05,109 --> 00:43:12,810
相当低和 幸运的，因为 

791
00:43:08,092 --> 00:43:15,139
当地的这些小姐率低 

792
00:43:12,081 --> 00:43:18,630
另一另一个指标是命中时间 

793
00:43:16,039 --> 00:43:21,091
所以，如果如果我们确实有在高速缓存中的命中

794
00:43:19,359 --> 00:43:24,160
多久它 实际上采取排序 

795
00:43:21,091 --> 00:43:24,157
看起来了，你知道做查找到 

796
00:43:24,016 --> 00:43:27,099
确定有一个命中， 然后 

797
00:43:25,057 --> 00:43:32,106
返回值好吗 

798
00:43:27,099 --> 00:43:34,117
所以对于L1 和在英特尔系统中，这 

799
00:43:32,619 --> 00:43:37,716
是4个时钟周期10个时钟周期 

800
00:43:35,017 --> 00:43:41,020
为L2，然后有一个附加

801
00:43:38,589 --> 00:43:42,880
科斯塔斯所以你 总是要付出的命中 

802
00:43:41,002 --> 00:43:47,005
时间正确的命中 时间是最好的你 

803
00:43:42,088 --> 00:43:50,113
可以做，但如果你有一个小姐那么 它的 

804
00:43:47,023 --> 00:43:52,039
你付出的命中时间，因为你必须 

805
00:43:51,013 --> 00:43:53,089
做搜索，最终你 

806
00:43:52,039 --> 00:43:56,080
要回返回字到 

807
00:43:53,089 --> 00:43:57,148
请求者但你有这样的附加 

808
00:43:56,008 --> 00:44:01,042
你必须去这是怎么回事成本

809
00:43:58,048 --> 00:44:04,054
在 内存获取数据那么好 

810
00:44:02,014 --> 00:44:07,102
这是罚失点球是 如此 

811
00:44:04,054 --> 00:44:10,833
所谓的未中损失的量级 

812
00:44:08,002 --> 00:44:13,030
数百周期的主内存 ，但是 

813
00:44:11,319 --> 00:44:15,327
在层次结构中它可以 与其他各级 

814
00:44:13,003 --> 00:44:17,007
是巨大的，因此 命中 损失，如果你要是 

815
00:44:16,119 --> 00:44:20,121
你必须在主内存中缓存

816
00:44:17,007 --> 00:44:23,106
这是上 存储 的缓存块 

817
00:44:20,319 --> 00:44:24,690
磁盘的 缺失 损失是巨大的 

818
00:44:27,054 --> 00:44:34,057
所以这是很有趣，如果你认为 

819
00:44:30,091 --> 00:44:35,119
关于 它 的 性能是该 

820
00:44:34,084 --> 00:44:37,126
这些系统的性能是非常 

821
00:44:36,019 --> 00:44:41,062
在 命中 率更 敏感 

822
00:44:38,026 --> 00:44:47,050
敏感的比你想象中和 

823
00:44:41,062 --> 00:45:07,093
事实上99％的命中率的两倍，一个好 

824
00:44:47,005 --> 00:45:09,103
97％的命中率是啊，他们打这样 

825
00:45:07,093 --> 00:45:11,188
问题是不命中的时间包括：

826
00:45:10,048 --> 00:45:15,069
时间税访问标记是的 

827
00:45:12,088 --> 00:45:18,121
所以命中时间 是花费的时间 

828
00:45:15,069 --> 00:45:23,094
搜索以确定该产品 

829
00:45:19,021 --> 00:45:23,094
是在缓存中， 然后返回它 

830
00:45:33,569 --> 00:45:42,250
所以基本上我们将使用 一个标题 

831
00:45:36,067 --> 00:45:44,226
财产是啊所以啊 所以在 

832
00:45:42,025 --> 00:45:47,026
小姐小姐 点球是 一次 

833
00:45:44,829 --> 00:45:49,900
花费的 现金来获取数据 

834
00:45:47,026 --> 00:45:52,048
从内存中，因此这一切的等待时间 

835
00:45:49,009 --> 00:45:53,478
你知道整个大巴去的时间 

836
00:45:52,048 --> 00:45:56,050
它占用内存向响应 

837
00:45:54,369 --> 00:45:59,230
要求 他取得数据的 时间 

838
00:45:56,068 --> 00:46:01,947
流回了公交车回 了 

839
00:45:59,023 --> 00:46:04,392
缓存等了小姐的时间将会 

840
00:46:02,559 --> 00:46:08,190
是命中时间加上 罚小姐 

841
00:46:04,599 --> 00:46:08,190
说清楚 

842
00:46:08,076 --> 00:46:14,077
所以我的意思是想象假设有命中目标 

843
00:46:12,073 --> 00:46:15,130
一个周期的时间和 一个小姐罚 

844
00:46:14,077 --> 00:46:19,084
100个循环，这些是合理

845
00:46:16,003 --> 00:46:24,037
号码，使平均存取 访问 

846
00:46:20,047 --> 00:46:27,936
时间，如果你有 97％的命中是命中 

847
00:46:24,064 --> 00:46:30,097
时间加上未命中次数的百分比 

848
00:46:28,359 --> 00:46:33,490
小姐罚所以这 四个周期 

849
00:46:30,097 --> 00:46:34,153
对于平均 访问时间，但如果我们 

850
00:46:33,049 --> 00:46:39,618
只是增加两个 命中率 

851
00:46:35,053 --> 00:46:43,862
％的平均访问时间减少 

852
00:46:40,059 --> 00:46:44,087
50％ 的二分之一 

853
00:46:46,018 --> 00:46:50,114
没事为什么这是为什么东西 

854
00:46:49,061 --> 00:46:54,089
重要的为什么你为什么要 在乎 

855
00:46:51,014 --> 00:46:56,063
它使 现金是我们正如我们所看到的 

856
00:46:54,089 --> 00:47:00,133
这些他们自动他们都 

857
00:46:56,063 --> 00:47:03,109
内置的硬件有没有的部分 

858
00:47:01,033 --> 00:47:06,038
排序可见的指令集， 

859
00:47:04,009 --> 00:47:11,015
让你能够操作的缓存和你 

860
00:47:06,083 --> 00:47:12,169
密码子计划 ，使 两者之间 

861
00:47:11,069 --> 00:47:18,080
这一切都发生在幕后 

862
00:47:13,069 --> 00:47:19,124
自动在硬件 ，但如果你 

863
00:47:18,008 --> 00:47:20,102
懂得 关心，如果您知道 有关 

864
00:47:20,024 --> 00:47:23,042
缓存的存在，你有这 

865
00:47:21,074 --> 00:47:25,097
你可以是如何工作的总体思路 如何 

866
00:47:23,042 --> 00:47:29,111
他们的工作，那么你可以编写代码 的 

867
00:47:25,097 --> 00:47:32,138
现金 在这个意义上 友好的 ，你的 

868
00:47:30,011 --> 00:47:36,088
代码将有更高的高命中率 

869
00:47:33,038 --> 00:47:41,092
比代码未 兑现友好 

870
00:47:36,088 --> 00:47:43,097
这样的想法是要重点关注 

871
00:47:41,092 --> 00:47:46,097
使得常见的情况走快不 

872
00:47:44,078 --> 00:47:48,106
把时间花在 代码之类的 

873
00:47:46,097 --> 00:47:51,098
代码没有得到执行非常 

874
00:47:49,006 --> 00:47:54,083
所以看一下最常用 

875
00:47:51,098 --> 00:47:55,136
调用的函数，然后 内的那些 

876
00:47:54,083 --> 00:47:56,144
功能看内环到

877
00:47:56,036 --> 00:47:59,132
这些功能，因为它是内 

878
00:47:57,044 --> 00:48:01,121
正在执行最右边的环

879
00:48:00,032 --> 00:48:04,070
这样你就可以作为第一近似你 

880
00:48:02,021 --> 00:48:06,023
可以忽略那种东西，如果你 

881
00:48:04,007 --> 00:48:08,012
嵌套的循环，你可以忽略 的东西 

882
00:48:06,041 --> 00:48:10,138
这是怎么回事外循环和

883
00:48:08,075 --> 00:48:12,137
只着眼于代码在内部循环 

884
00:48:11,038 --> 00:48:15,061
现在你想要做的是尽力

885
00:48:13,037 --> 00:48:18,095
最小化在内部循环的未命中 

886
00:48:15,061 --> 00:48:21,079
好了，所以多次提到一个 

887
00:48:18,095 --> 00:48:23,099
变量是变量都不错 

888
00:48:21,079 --> 00:48:25,112
特别是如果这些是局部 变量 

889
00:48:23,099 --> 00:48:28,148
右所以记住 ，如果你声明 一个局部 

890
00:48:26,012 --> 00:48:32,015
变量看编译器可以把

891
00:48:29,048 --> 00:48:34,100
为寄存器中的权利，如果你是 

892
00:48:32,042 --> 00:48:36,053
引用全局变量也许不是 

893
00:48:35,000 --> 00:48:39,056
编译器不知道是怎么回事 

894
00:48:36,053 --> 00:48:41,105
上所以 不能把那粗糙的它不能 

895
00:48:39,056 --> 00:48:45,074
把参考以该变量 

896
00:48:42,005 --> 00:48:48,038
下， 在 寄存器还好如此反复 

897
00:48:45,074 --> 00:48:50,093
对局部变量的引用存储在

898
00:48:48,038 --> 00:48:52,109
堆栈是一件好事 ，因为那些会 

899
00:48:50,093 --> 00:48:55,151
得到变成寄存器访问你 

900
00:48:53,009 --> 00:48:58,016
从来不去内存也没关系 一个迈进 

901
00:48:56,051 --> 00:49:00,056
访问两个数组 都不错 

902
00:48:58,079 --> 00:49:02,177
而且他们因为良好

903
00:49:01,001 --> 00:49:05,048
这些块的生存权利，因此 

904
00:49:03,077 --> 00:49:06,115
只有这样，你会知道 ，一个箭步 

905
00:49:05,048 --> 00:49:11,090
引用我们的好是，如果 你知道 

906
00:49:07,015 --> 00:49:14,096
高速缓存具有64字节数据块好了，所以 

907
00:49:11,009 --> 00:49:16,016
他们力争一个 一个参考会 

908
00:49:14,096 --> 00:49:20,153
有小姐率一大步，一半

909
00:49:17,006 --> 00:49:24,008
引用，因为如果你做 步幅 

910
00:49:21,053 --> 00:49:27,092
一个引用第一参照 

911
00:49:24,008 --> 00:49:31,019
字块会错过，但随后 

912
00:49:27,092 --> 00:49:32,156
后续引用会打右

913
00:49:31,091 --> 00:49:34,123
如果你正在做一个箭步一个 ，你会打

914
00:49:33,056 --> 00:49:37,064
参考你要每打 

915
00:49:35,023 --> 00:49:39,101
在该块 ，如果 你的 驱动器的每一个字

916
00:49:38,036 --> 00:49:40,115
如果你正在做跨步 两个引用 

917
00:49:40,001 --> 00:49:43,094
你只是打隔日 

918
00:49:41,015 --> 00:49:45,092
字右所以你只能得到你 

919
00:49:43,094 --> 00:49:53,186
排序的一半，所以你会 在错过 

920
00:49:45,092 --> 00:49:56,099
两倍的速度，因此基本上

921
00:49:54,086 --> 00:49:59,177
点我要让你的是， 我们的 

922
00:49:57,062 --> 00:50:03,101
缓存的理解让 我们整理 

923
00:50:00,077 --> 00:50:04,163
的 量化这定性这个概念 

924
00:50:04,001 --> 00:50:07,100
局部性的，我们开发的最后 

925
00:50:05,063 --> 00:50:09,080
时间右边的最后一次看我们 

926
00:50:08,000 --> 00:50:13,061
说，如果它做跨步一个引用

927
00:50:09,008 --> 00:50:14,102
这是很好的，如果是，如果我们做的，如果 

928
00:50:13,061 --> 00:50:17,144
我们访问了相同的变量 

929
00:50:15,074 --> 00:50:19,151
并在这很好，但如果我们 

930
00:50:18,044 --> 00:50:26,090
了解缓存现在我们可以 量化它 

931
00:50:20,051 --> 00:50:28,082
在命中率方面没事让我们 

932
00:50:26,009 --> 00:50:29,051
完成了我们是班上的 其他同学 

933
00:50:28,082 --> 00:50:33,110
要看看对 性能 的 影响 

934
00:50:30,032 --> 00:50:35,054
您的代码行不行，为什么，为什么缓存

935
00:50:34,001 --> 00:50:38,012
你需要你为什么需要知道 

936
00:50:35,054 --> 00:50:41,120
这些东西和造成的影响 

937
00:50:38,021 --> 00:50:45,056
他们能有那么有一个很 

938
00:50:42,002 --> 00:50:47,027
有趣的功能，这 实际上 是 

939
00:50:45,056 --> 00:50:49,150
绘制你的文本封面 

940
00:50:47,045 --> 00:50:52,061
书中 ， 我们称之为记忆山我 

941
00:50:50,005 --> 00:50:54,071
得知这个情况从研究生 

942
00:50:52,061 --> 00:50:57,116
这里的学生在卡内基梅隆回 

943
00:50:55,016 --> 00:51:01,052
上世纪90年代，所以你发展这个概念有 

944
00:50:58,016 --> 00:51:05,030
汤姆·斯特里克 和它是什么 ， 说 

945
00:51:01,052 --> 00:51:07,124
内存山地块名为措施 

946
00:51:05,003 --> 00:51:09,065
通过放或读取带宽 读取 哪个 

947
00:51:08,024 --> 00:51:11,115
从存储器中 读取的字节 数 

948
00:51:09,092 --> 00:51:14,501
所以，如果你有四个 

949
00:51:12,015 --> 00:51:18,051
有一个循环，你要扫描过 

950
00:51:15,329 --> 00:51:21,260
矢量让你有发言权的向量发言权 

951
00:51:18,051 --> 00:51:22,880
双字和你 读那些 

952
00:51:21,026 --> 00:51:25,089
从一个 向量中的一个元件之后的 

953
00:51:23,339 --> 00:51:27,690
其他的读取吞吐量是多少 

954
00:51:25,089 --> 00:51:29,123
兆字节每秒， 你可以 

955
00:51:27,069 --> 00:51:33,072
您可以在执行这个任务， 

956
00:51:30,023 --> 00:51:36,332
内存地块殷海涛读 

957
00:51:33,072 --> 00:51:40,119
吞吐量时间的函数

958
00:51:36,539 --> 00:51:43,547
在该循环空间局部性好吗 

959
00:51:41,019 --> 00:51:46,070
因此，在某种意义上，它在看一个宽

960
00:51:43,619 --> 00:51:48,900
的局部性选项范围或

961
00:51:46,007 --> 00:51:50,126
在程序的特点和它的

962
00:51:48,009 --> 00:51:53,061
绘图内存的性能

963
00:51:50,819 --> 00:51:56,400
系统上跨该范围是 

964
00:51:54,042 --> 00:51:58,125
二维 功能，因此在某些方面 

965
00:51:56,004 --> 00:52:00,060
内存山是一类的 

966
00:51:59,025 --> 00:52:03,063
指纹右每个系统 都有它的 

967
00:52:00,096 --> 00:52:04,415
自己独特的记忆山， 我们可以 

968
00:52:03,063 --> 00:52:11,127
通过编写 一个简单的衡量权 

969
00:52:05,279 --> 00:52:15,450
程序和这样的想法在这里是 要 

970
00:52:12,027 --> 00:52:18,286
构建存储山 我们写了一个 

971
00:52:15,045 --> 00:52:18,124
程序调用测试 

972
00:52:35,019 --> 00:52:38,019
射击

973
00:52:50,097 --> 00:53:02,103
由于某种 原因，这不是没事 没事 

974
00:53:03,259 --> 00:53:09,260
因此，我们相信，当 我们建立了一个记忆 

975
00:53:05,819 --> 00:53:14,240
山 我们给出一个向量 

976
00:53:09,269 --> 00:53:14,240
由双字的集合

977
00:53:14,093 --> 00:53:21,932
然后我们写一个循环，读取

978
00:53:20,049 --> 00:53:25,064
那些阅读一定数量的话

979
00:53:22,769 --> 00:53:25,640
在这种情况下的话

980
00:53:41,095 --> 00:53:49,504
我们走，所以它读取它 读取 埃兰之 

981
00:53:47,829 --> 00:53:52,460
元素个数权利，使我们有 

982
00:53:50,359 --> 00:53:56,431
每个与这些双字元件 

983
00:53:52,046 --> 00:54:02,575
步幅 一个箭步 好了，如果我们有 一个 

984
00:53:57,079 --> 00:54:05,098
一大步，我知道那些 种 

985
00:54:02,989 --> 00:54:10,940
冗余他 ，所以，如果我们有一个箭步 

986
00:54:05,269 --> 00:54:12,324
一个那么我们将我们将有我们的 环 

987
00:54:10,094 --> 00:54:14,473
车轮将整理 循环 的 通过和 

988
00:54:12,819 --> 00:54:17,890
阅读这些内容，直到我们读过

989
00:54:15,319 --> 00:54:21,370
这些元素中的元素数目没关系 

990
00:54:18,529 --> 00:54:24,410
然后我们将再次和那么做

991
00:54:21,829 --> 00:54:28,640
升温缓存，然后我们再做一次 

992
00:54:24,041 --> 00:54:30,067
做 同样的事情，所以如果 

993
00:54:28,064 --> 00:54:33,523
我们有两个一个箭步这样做

994
00:54:30,067 --> 00:54:42,145
然后我们会阅读我们会读 

995
00:54:34,099 --> 00:54:43,450
这个词零或LM - LM 4 等 

996
00:54:44,559 --> 00:54:49,880
好吧 ，那好吧，我们正在做什么都 

997
00:54:47,509 --> 00:54:54,650
我们只是 为广泛的进步和 

998
00:54:49,088 --> 00:54:57,089
尺寸范围广泛的，我们要扫描 

999
00:54:54,065 --> 00:55:00,065
在这个矢量，只是记录如何 

1000
00:54:57,089 --> 00:55:02,096
多长时间才能做到这一点读，然后 

1001
00:55:00,065 --> 00:55:07,204
转换我们转换到这一点兆字节 

1002
00:55:02,096 --> 00:55:08,120
每秒以我只是想 

1003
00:55:07,789 --> 00:55:11,797
给你看这个，这是我们不需要 

1004
00:55:09,002 --> 00:55:14,551
我们不打算深究细节 

1005
00:55:11,869 --> 00:55:17,690
这一点，但 其实 这是 我怎么 

1006
00:55:14,749 --> 00:55:20,758
所产生的对本书的封面和 

1007
00:55:17,069 --> 00:55:22,168
为了才能使用利用 

1008
00:55:20,839 --> 00:55:24,680
英特尔内部的并行

1009
00:55:22,789 --> 00:55:26,420
像你这样的 处理器 了解过去 

1010
00:55:24,068 --> 00:55:28,147
本周有有很多 平行的 

1011
00:55:26,042 --> 00:55:33,721
为了利用功能单元

1012
00:55:28,759 --> 00:55:36,170
这些III做四轮驱动循环展开 等等 

1013
00:55:34,099 --> 00:55:39,920
我实际上做那种四个在扫描 

1014
00:55:36,017 --> 00:55:42,316
平行，但总的想法是只 

1015
00:55:39,092 --> 00:55:45,451
我在这里向您展示，和本 

1016
00:55:42,469 --> 00:55:48,650
4×4×4这个循环的展开仅仅是一个 

1017
00:55:46,279 --> 00:55:50,281
优化但我想展示给 

1018
00:55:48,065 --> 00:55:50,117
你，因为它 实际上它的确切 

1019
00:55:50,479 --> 00:55:53,270
相同

1020
00:55:51,017 --> 00:55:55,109
原理你了解了上周 

1021
00:55:53,027 --> 00:56:00,044
当布赖恩教授谈到码

1022
00:55:56,009 --> 00:56:02,053
优化所以我们做的是我们我们称之为

1023
00:56:00,044 --> 00:56:06,044
这些不同这个测试功能

1024
00:56:02,053 --> 00:56:08,054
埃兰之和步幅，那么我们的范围

1025
00:56:06,044 --> 00:56:10,082
衡量性能， 我们得到这个 

1026
00:56:08,054 --> 00:56:12,056
美丽的图画这个美丽 

1027
00:56:10,082 --> 00:56:22,124
功能对我来说它的美丽我 不 

1028
00:56:12,074 --> 00:56:27,074
知道是看美女 ，你等 

1029
00:56:23,024 --> 00:56:29,063
在Z我们的Z轴正密谋读 

1030
00:56:27,074 --> 00:56:34,085
吞吐量每秒兆字节 

1031
00:56:29,063 --> 00:56:42,071
范围从 每秒2000兆 

1032
00:56:34,085 --> 00:56:47,147
这种 每秒高达16,000兆字节 

1033
00:56:42,071 --> 00:56:51,080
该轴是测量是步幅

1034
00:56:48,047 --> 00:56:59,066
从步幅1所以往上走阔步12 

1035
00:56:52,061 --> 00:57:02,099
这轴，以便我们为我们增加 

1036
00:56:59,066 --> 00:57:07,075
步幅我们降低空间 

1037
00:57:02,099 --> 00:57:06,175
当地没事 

1038
00:57:08,269 --> 00:57:16,360
这轴是尺寸轴所以我们 

1039
00:57:12,769 --> 00:57:18,844
去从我认为16K的多达128个 

1040
00:57:17,179 --> 00:57:20,266
兆所以这是多少 

1041
00:57:19,519 --> 00:57:28,527
我们要读 通每一个 元素 

1042
00:57:21,049 --> 00:57:32,092
通过这样，我们为我们增加 的 大小 

1043
00:57:29,319 --> 00:57:36,385
我们有点下降的影响 

1044
00:57:32,479 --> 00:57:38,494
时间局部性因为工作 ，因为我们 

1045
00:57:36,979 --> 00:57:40,063
加大尺寸 有越来越 

1046
00:57:38,629 --> 00:57:45,720
在我们的 层次 较少的高速缓存 可以容纳 

1047
00:57:40,819 --> 00:57:48,844
所有这些数据， 因此这使我们有 

1048
00:57:46,539 --> 00:57:50,607
空间局部性这一下降

1049
00:57:49,069 --> 00:57:54,148
方向和时间局部性 

1050
00:57:51,219 --> 00:57:57,223
减少了该方向 ，从而一 

1051
00:57:54,859 --> 00:57:59,920
程序员，你想要做什么，你想 

1052
00:57:57,619 --> 00:58:02,662
要在这里正确的良好的空间 

1053
00:58:00,469 --> 00:58:05,476
当地良好的时间局部性，因为 

1054
00:58:03,049 --> 00:58:09,100
你可以像每秒14千兆字节

1055
00:58:06,169 --> 00:58:12,232
衡量你不希望 希腊吞吐量 

1056
00:58:09,559 --> 00:58:13,630
要到这里这 是只有约100 

1057
00:58:12,799 --> 00:58:15,805
兆字节每秒你在哪里

1058
00:58:14,269 --> 00:58:18,282
读出 的内存权，因此 

1059
00:58:16,399 --> 00:58:22,474
阅读完所有的差异你 

1060
00:58:18,399 --> 00:58:26,401
从 内存中，我们或阅读它 的数据 

1061
00:58:23,149 --> 00:58:28,200
从的某些部分高速缓存是巨大的 

1062
00:58:26,599 --> 00:58:30,688
这是 巨大的 

1063
00:58:28,659 --> 00:58:33,670
确定这样 ，因为你是213级的学生，你会 

1064
00:58:31,489 --> 00:58:37,552
是在这里，所有的学生们 

1065
00:58:33,769 --> 00:58:39,817
没拿213，他们会到 这里和 

1066
00:58:38,119 --> 00:58:43,123
其实我已经有我其实是有 

1067
00:58:40,249 --> 00:58:44,344
人 几个人写回来告诉 

1068
00:58:43,519 --> 00:58:47,542
我自己的经历，你知道 

1069
00:58:45,199 --> 00:58:49,270
实习和就业机会，他们失去了 一个后

1070
00:58:47,749 --> 00:58:52,834
鸸鹋在那里他们得到 了一些代码， 

1071
00:58:49,909 --> 00:58:54,916
这是到这里，这才认出 

1072
00:58:53,599 --> 00:58:57,631
局部性问题，但他们得到了它

1073
00:58:55,609 --> 00:59:00,250
你知道更好地在这里或 在 接近 

1074
00:58:57,919 --> 00:59:04,480
好至少 

1075
00:59:00,025 --> 00:59:05,098
所以这本图画这个所谓的 

1076
00:59:04,048 --> 00:59:07,144
内存 山上有各种 

1077
00:59:05,098 --> 00:59:09,115
有趣的功能首先是 

1078
00:59:08,044 --> 00:59:12,963
有这就是我所说的脊 

1079
00:59:10,015 --> 00:59:14,074
时间局部性其中，这些脊见 

1080
00:59:13,359 --> 00:59:16,210
这些脊线，如果你认为这 

1081
00:59:14,074 --> 00:59:18,953
就像你看到的这一座山 

1082
00:59:16,021 --> 00:59:21,660
山脊线， 你会看到这个 山脊线和 

1083
00:59:19,619 --> 00:59:23,560
这里的另一个脊线， 然后 

1084
00:59:21,849 --> 00:59:25,060
这里有一个在这里的另外一个这些

1085
00:59:23,056 --> 00:59:26,140
对应于不同的水平在 

1086
00:59:25,006 --> 00:59:29,022
层次所以这此之上 棱线 

1087
00:59:27,004 --> 00:59:33,085
在那里你直接读出 L1的 

1088
00:59:29,022 --> 00:59:35,053
它应该是完全平坦的 ，它的 

1089
00:59:34,021 --> 00:59:37,114
如此之快，我们得到像 

1090
00:59:35,053 --> 00:59:41,101
测量抖动性能抖动

1091
00:59:38,014 --> 00:59:43,093
正确的，但它是和这个小 

1092
00:59:42,001 --> 00:59:45,360
下车这里是一个测量伪影 

1093
00:59:43,093 --> 00:59:46,171
它应该不应该在那里 

1094
00:59:45,369 --> 00:59:52,630
应该是它应该是平的，全力以赴 

1095
00:59:47,071 --> 00:59:55,980
一直到墙上回到这里，然后 

1096
00:59:52,063 --> 00:59:58,159
这里本该山脊线就是我们 

1097
00:59:56,619 --> 01:00:02,980
访问L2这就是我们 

1098
00:59:59,059 --> 01:00:05,158
访问L3 和这里就是我们 

1099
01:00:02,098 --> 01:00:07,147
从内存访问主要是让你拥有 

1100
01:00:06,058 --> 01:00:10,093
时间局部性的这些山脊 和 

1101
01:00:08,047 --> 01:00:13,072
那么你有减少这些斜坡

1102
01:00:10,093 --> 01:00:16,512
空间位置，所以你看到的斜率

1103
01:00:13,072 --> 01:00:18,157
这里工作 ，以便我们从移动 

1104
01:00:17,349 --> 01:00:23,980
从斜坡的顶部向下到 

1105
01:00:19,057 --> 01:00:25,093
底部我们减少我们的空间 

1106
01:00:23,098 --> 01:00:27,130
本地所以我们越来越少的好处 

1107
01:00:25,093 --> 01:00:30,124
对于这些块，我们正在引进 

1108
01:00:28,003 --> 01:00:33,312
正确的，所以你可以看到我们得到 

1109
01:00:31,024 --> 01:00:35,092
少了成本效益， 我们 

1110
01:00:33,609 --> 01:00:40,210
通过导入 取 的 去了 

1111
01:00:35,092 --> 01:00:43,521
这些块一旦步幅命中 

1112
01:00:40,021 --> 01:00:46,024
块大小现在每个引用是 

1113
01:00:44,349 --> 01:00:47,740
击中不同的块，因此和

1114
01:00:46,024 --> 01:00:49,039
那么它变平，那么你得到你 

1115
01:00:47,074 --> 01:00:54,118
正从鼻子空间受益 

1116
01:00:49,039 --> 01:00:57,082
局部性和同样这里是哪里 

1117
01:00:55,018 --> 01:01:01,114
这这这斜率就是我们

1118
01:00:57,082 --> 01:01:03,148
从L3阅读和与它变平 

1119
01:01:02,014 --> 01:01:07,108
总是出来，如果他们总是变平的 

1120
01:01:04,048 --> 01:01:09,177
所述块的大小是一个步幅

1121
01:01:08,008 --> 01:01:12,022
这些都是双字右所以它的 

1122
01:01:09,609 --> 01:01:15,160
8步幅

1123
01:01:12,022 --> 01:01:17,074
为64个字节，因此，一旦你超过了一大步 

1124
01:01:15,016 --> 01:01:19,045
八，然后你不再是 你 

1125
01:01:17,074 --> 01:01:23,083
缺少它，每次在不同的

1126
01:01:19,045 --> 01:01:25,099
块有这个有趣的这个 

1127
01:01:24,064 --> 01:01:29,067
一个困扰了我一段时间 

1128
01:01:25,099 --> 01:01:31,152
你可能想知道怎么样来 

1129
01:01:29,067 --> 01:01:36,123
像在这里，我们增加大小 

1130
01:01:32,052 --> 01:01:39,063
我们可以排序的我们有点获得 

1131
01:01:37,023 --> 01:01:41,089
我们都有点像 我们增加大小 

1132
01:01:39,063 --> 01:01:44,071
我们正在做 我们的大部分引用了 

1133
01:01:41,089 --> 01:01:48,091
缓存是在缓存中低 

1134
01:01:44,071 --> 01:01:52,078
层次结构，但是当我们正在做的，除了 

1135
01:01:49,009 --> 01:01:56,083
迈进一个参考，你可以看到所有 

1136
01:01:53,041 --> 01:02:00,118
一直到正确的到底对不对 

1137
01:01:56,083 --> 01:02:04,126
超过 L3的大小 之前 它的 

1138
01:02:01,018 --> 01:02:07,102
平好吗 

1139
01:02:05,026 --> 01:02:09,064
和它的它的运行在L2率和 

1140
01:02:08,002 --> 01:02:11,053
所以这里的L1速率，然后再下降

1141
01:02:09,064 --> 01:02:14,122
关闭， 然后它运行 在一个恒定 

1142
01:02:11,053 --> 01:02:18,085
L2率， 直到数据不再 坐 

1143
01:02:15,022 --> 01:02:22,087
L3 所以我觉得这是 怎么回事 上是 

1144
01:02:18,085 --> 01:02:26,146
在 硬件缓存缓存 

1145
01:02:22,087 --> 01:02:28,174
L2高速缓存硬件识别 或 

1146
01:02:27,046 --> 01:02:31,075
也许这是一个L1但一些一些一些

1147
01:02:29,074 --> 01:02:32,155
逻辑， 在 所述高速缓冲存储器系统 是 

1148
01:02:31,075 --> 01:02:35,161
识别步幅一个参考 

1149
01:02:33,055 --> 01:02:38,137
模式，因为它 认为所有的 

1150
01:02:36,061 --> 01:02:41,080
地址它破坏了它的识别 

1151
01:02:39,037 --> 01:02:45,042
该步幅一个模式，那么它的 

1152
01:02:41,008 --> 01:02:48,094
从L3积极预取到L2 

1153
01:02:45,087 --> 01:02:50,143
使那些因此它是这样一个提前 

1154
01:02:49,066 --> 01:02:53,083
一次它预计 它 说看 

1155
01:02:51,043 --> 01:02:55,090
我已经得到了5个步幅 一个引用 

1156
01:02:53,083 --> 01:02:56,179
在一排我要去抓住一个整体 

1157
01:02:55,009 --> 01:02:59,032
块的串 并加载它们都起来 

1158
01:02:57,079 --> 01:03:03,100
因为空间的原则 

1159
01:03:00,013 --> 01:03:04,096
当地那些块的块 

1160
01:03:04,000 --> 01:03:07,099
要在 不久 的被引用 

1161
01:03:04,096 --> 01:03:08,122
未来所以这 是很整洁，这 

1162
01:03:07,099 --> 01:03:10,126
只有最后几内发生

1163
01:03:09,022 --> 01:03:16,063
年使英特尔的工程师总是 

1164
01:03:11,026 --> 01:03:19,051
努力工作，也许通过时间 

1165
01:03:16,063 --> 01:03:22,069
时间我们做的 下一下一 版 

1166
01:03:19,051 --> 01:03:24,094
内存 山上那些系统会 

1167
01:03:22,069 --> 01:03:27,145
认识步幅2，你知道其他 

1168
01:03:24,094 --> 01:03:29,119
步幅模式 太多，但此 数据 

1169
01:03:28,045 --> 01:03:32,073
看来，它的唯一识别 

1170
01:03:30,019 --> 01:03:32,073
跨度1 

1171
01:03:35,032 --> 01:03:43,064
好了，你可以 真正的，我们可以 提高 

1172
01:03:41,096 --> 01:03:46,108
的空间和时间局部性我们 

1173
01:03:43,064 --> 01:03:49,088
几种不同的方法程序， 

1174
01:03:47,008 --> 01:03:52,016
改善空间局部性的一种方式 

1175
01:03:49,088 --> 01:03:55,139
是重新排列循环和我将使用 

1176
01:03:52,088 --> 01:03:58,187
矩阵乘法作为一个例子，以便 

1177
01:03:56,039 --> 01:04:03,074
这里有一种简单的矩阵 

1178
01:03:59,087 --> 01:04:06,176
乘法在代码中我们 

1179
01:04:03,074 --> 01:04:11,108
相乘的次B 和将其添加 

1180
01:04:07,076 --> 01:04:16,154
我们正在采取 什么在IJ元素 

1181
01:04:12,008 --> 01:04:20,102
的C，然后给我们增加了 

1182
01:04:17,054 --> 01:04:25,133
总结的一排我 的内积 

1183
01:04:21,002 --> 01:04:28,058
行j 行，然后 B的J列

1184
01:04:26,033 --> 01:04:31,094
所以我们要通过和每个IJ 

1185
01:04:28,058 --> 01:04:36,115
在这个矩阵C我们计算 的 

1186
01:04:31,094 --> 01:04:39,101
内积，然后创建总和 

1187
01:04:37,015 --> 01:04:41,021
所以我们实际上可以证明有一个 

1188
01:04:40,064 --> 01:04:44,081
很多不同的方式 做矩阵 

1189
01:04:41,075 --> 01:04:47,171
乘，这是我们可以置换 

1190
01:04:44,081 --> 01:04:50,159
这些这些循环中的任何六个 

1191
01:04:48,071 --> 01:04:53,156
不同的可能的排列所以这 

1192
01:04:51,059 --> 01:04:56,060
是置换它是我跟着 

1193
01:04:54,056 --> 01:05:01,133
用j，其后为K 而其他五个 

1194
01:04:56,069 --> 01:05:03,146
可能性是可行的，所以我们可以 

1195
01:05:02,033 --> 01:05:06,095
其实分析这些不同的那些 

1196
01:05:04,046 --> 01:05:09,137
排列预测哪一个

1197
01:05:06,095 --> 01:05:10,103
有好了，所以什么是最好的性能 

1198
01:05:10,037 --> 01:05:16,043
我们要做的是，我们将看看内环 

1199
01:05:11,075 --> 01:05:18,110
我们将看看的访问 模式 

1200
01:05:16,097 --> 01:05:22,180
内环路， 因为接入 

1201
01:05:19,001 --> 01:05:23,008
在 阵列 上 ℃ 的和 D图案

1202
01:05:24,062 --> 01:05:30,155
好了，让我们来看看IJK 

1203
01:05:29,003 --> 01:05:34,069
实现时，我刚才给你看这么 

1204
01:05:31,055 --> 01:05:38,060
一如既往，我们专注于内环 和 

1205
01:05:34,069 --> 01:05:42,128
如果您发现该内环是做了 

1206
01:05:39,005 --> 01:05:45,098
排列和列的明智访问

1207
01:05:43,028 --> 01:05:49,091
明智的访问对不起连续明智访问 

1208
01:05:45,098 --> 01:05:53,177
阵列的和的列明智访问的

1209
01:05:49,091 --> 01:05:55,163
列B因此行明智明智B的柱的

1210
01:05:54,077 --> 01:05:57,161
我们真的不关心C，因为 

1211
01:05:56,063 --> 01:06:03,071
它的出它不是在内环好吗 

1212
01:05:58,061 --> 01:06:05,137
所以才忽略了 这样给我们的 

1213
01:06:04,043 --> 01:06:09,050
假设我们能在这种情况下举行 

1214
01:06:06,037 --> 01:06:12,101
我们 假设， 我们 可以 容纳四 

1215
01:06:10,013 --> 01:06:16,088
在这些整数元素在一个 

1216
01:06:13,001 --> 01:06:18,008
块，其中有行明智访问

1217
01:06:16,088 --> 01:06:20,159
良好的空间局部性会错过一个 

1218
01:06:18,071 --> 01:06:22,169
每四个访问没关系最先

1219
01:06:21,059 --> 01:06:25,061
参考将无缘再下

1220
01:06:23,069 --> 01:06:26,108
三会打再 下 

1221
01:06:25,079 --> 01:06:29,173
参考后将创出新 

1222
01:06:27,008 --> 01:06:34,010
块好了，所以四个这样一出

1223
01:06:30,073 --> 01:06:35,147
到引用将错过，但因为 

1224
01:06:34,001 --> 01:06:40,049
对于B的访问模式是逐列 

1225
01:06:36,047 --> 01:06:42,116
每每每个引用到B将

1226
01:06:40,058 --> 01:06:44,099
错过好所以平均数 

1227
01:06:43,016 --> 01:06:49,019
每循环迭代未命中是一个点 

1228
01:06:44,099 --> 01:06:51,154
两个五 好第j IIK 版本 

1229
01:06:49,019 --> 01:06:52,054
完全一样的模式 

1230
01:06:54,051 --> 01:07:02,124
KIJ在这里有一点不同我们

1231
01:06:59,004 --> 01:07:05,082
做B和A行 的逐行访问 

1232
01:07:03,024 --> 01:07:07,643
的C明智访问，因此这是很好的权利，使 

1233
01:07:05,082 --> 01:07:10,086
现在我们已经有了一个箭步上访问 

1234
01:07:07,859 --> 01:07:12,860
既BMC和参照 本发明的IS 

1235
01:07:11,022 --> 01:07:17,040
在循环之外 ，所以我们 不关心 

1236
01:07:12,869 --> 01:07:20,550
它那么那么B和C将缺席 

1237
01:07:17,004 --> 01:07:22,005
时间的四分之一好吗 所以 

1238
01:07:20,055 --> 01:07:25,089
平均数量总每循环未命中 

1239
01:07:22,005 --> 01:07:29,030
迭代将是0.5就不错了

1240
01:07:25,089 --> 01:07:31,188
我KJ具有相同的类似行为 

1241
01:07:29,075 --> 01:07:36,164
现在JKI是那种完全相反的 

1242
01:07:32,088 --> 01:07:39,177
JKI做 的逐列访问和 

1243
01:07:37,064 --> 01:07:41,064
章 C所以正确的，我们知道 逐列访问 

1244
01:07:40,077 --> 01:07:45,123
这是一个臭气熏天

1245
01:07:41,064 --> 01:07:48,075
右，我们定性地知道它的

1246
01:07:46,023 --> 01:07:52,044
糟糕，我们可以计算， 它就会错过 

1247
01:07:48,075 --> 01:07:53,684
每次循环迭代，这样一个时间

1248
01:07:52,044 --> 01:07:56,082
将有两个总每2个未命中 

1249
01:07:54,359 --> 01:07:59,730
迭代和KJI具有相同的坏 

1250
01:07:56,082 --> 01:08:03,126
模式好了，所以，如果我们 看一下 所有这些 

1251
01:07:59,073 --> 01:08:10,080
排列你可以看到，IJK 和JI 

1252
01:08:04,026 --> 01:08:14,085
ķ错过1.25 1.25有太太。 ķIJ有0.5 

1253
01:08:10,008 --> 01:08:17,016
缺失和斯基有两个失误使 

1254
01:08:14,085 --> 01:08:19,994
显然，它看起来像 きJ和其 

1255
01:08:17,088 --> 01:08:23,127
弟兄们是最好的选择的唯一

1256
01:08:20,759 --> 01:08:25,760
差 中 Kきj具有这 

1257
01:08:24,027 --> 01:08:27,093
额外的存储 ，以便有可能是一个 

1258
01:08:25,859 --> 01:08:29,957
问题那就是 要创造是 

1259
01:08:27,093 --> 01:08:34,098
这将放慢改革的步伐以及它 

1260
01:08:30,839 --> 01:08:38,040
原来， 在系统和任何种类 

1261
01:08:34,098 --> 01:08:40,122
存储系统的权利更 容易 

1262
01:08:38,004 --> 01:08:44,016
对付他们可以读取它可以你 

1263
01:08:41,022 --> 01:08:45,027
想想为什么，可能是真的如此 

1264
01:08:44,016 --> 01:08:48,020
对你有更多的 灵活性 

1265
01:08:45,072 --> 01:08:47,156
比你做鲁伊斯 

1266
01:08:49,779 --> 01:08:55,500
我的意思是

1267
01:08:56,179 --> 01:09:01,500
这正是让你可以有选择 

1268
01:08:59,759 --> 01:09:04,772
你可以做你可以写回 你推迟 

1269
01:09:01,005 --> 01:09:06,164
可以推迟写作，直到 值 

1270
01:09:04,889 --> 01:09:08,900
你写的实际使用值

1271
01:09:06,659 --> 01:09:10,748
但是当你看一个项目 你被困 

1272
01:09:08,009 --> 01:09:12,908
你不能做什么，直到，直到 你 

1273
01:09:11,549 --> 01:09:15,750
获得这些数据，以便事实证明，这 

1274
01:09:13,799 --> 01:09:17,897
权利并不真的那么这种额外 

1275
01:09:15,075 --> 01:09:21,150
店内并没有真正伤害我们，所以当 

1276
01:09:18,779 --> 01:09:27,150
我们衡量这些现代化的系统，你上 

1277
01:09:22,005 --> 01:09:30,224
可以看出 ， 凯特 KIJ 其中有 

1278
01:09:27,015 --> 01:09:33,524
在数量最少的失误有你 

1279
01:09:30,719 --> 01:09:35,400
看到我们正在像一个错过 哦 什么 

1280
01:09:33,659 --> 01:09:38,040
我们在这里密谋为每内循环

1281
01:09:35,004 --> 01:09:39,473
循环迭代所以每次每次迭代是 

1282
01:09:38,004 --> 01:09:44,025
取约一个 周期，这是真的 

1283
01:09:39,869 --> 01:09:46,904
好这个 我JK模式这是一种 

1284
01:09:44,025 --> 01:09:49,124
中间1.2惦记这是排序 

1285
01:09:47,219 --> 01:09:52,271
在之间和JK 我 有两个 

1286
01:09:49,349 --> 01:09:53,423
每次迭代失误是最糟糕的确定，所以 

1287
01:09:52,739 --> 01:09:56,752
有趣的是，我们 居然 可以 

1288
01:09:54,089 --> 01:09:58,770
只是做 分析 的一点点 

1289
01:09:56,869 --> 01:10:01,320
简单的分析，我们实际上可能 

1290
01:09:58,077 --> 01:10:06,105
预测这是什么这是什么图形会

1291
01:10:01,032 --> 01:10:08,076
看起来像确定在离开最后的 10 

1292
01:10:07,005 --> 01:10:10,082
该类分钟 ，我们要 看看 

1293
01:10:08,076 --> 01:10:12,084
在如何提高 现在 时间局部性 

1294
01:10:10,082 --> 01:10:14,163
所以我们所做的事情与我们

1295
01:10:13,056 --> 01:10:16,127
重新安排我们的循环 中的矩阵 

1296
01:10:15,063 --> 01:10:21,078
乘法我们在做什么是 

1297
01:10:17,027 --> 01:10:22,706
改善我们的空间局部性的权利 ，但 

1298
01:10:21,078 --> 01:10:24,707
我们没有，我们没有做任何事情 

1299
01:10:22,949 --> 01:10:25,958
以 提高时间局部性来 

1300
01:10:25,409 --> 01:10:29,760
提高时间局部性你必须

1301
01:10:26,849 --> 01:10:31,560
使用称为阻断技术和本 

1302
01:10:29,076 --> 01:10:31,161
重要的是要理解 ，因为 

1303
01:10:31,056 --> 01:10:35,061
你会需要它的缓存 

1304
01:10:32,061 --> 01:10:37,155
实验室的一两件事，但它也是一个非常 

1305
01:10:35,061 --> 01:10:39,440
一般的技术 ，任何时候你需要的任何 

1306
01:10:38,055 --> 01:10:45,138
时间您遇到问题的 时间 

1307
01:10:39,989 --> 01:10:48,008
地方好了，所以我们不会去 

1308
01:10:46,038 --> 01:10:52,607
太多的细节这个代码，但什么 

1309
01:10:48,179 --> 01:10:54,000
我做了我重写了矩阵乘法 等等 

1310
01:10:52,949 --> 01:10:55,590
它运行你知道

1311
01:10:54,000 --> 01:10:56,849
二维 矩阵，你可以 

1312
01:10:55,059 --> 01:10:58,125
真的只是把它作为一个连续 

1313
01:10:56,849 --> 01:11:01,380
字节数组，所以我只是重写了这个 

1314
01:10:59,025 --> 01:11:03,090
码到一个连续阵列上操作

1315
01:11:01,038 --> 01:11:06,063
一维 数组，然后我做 

1316
01:11:03,009 --> 01:11:08,070
索引明确这里这么在这里 

1317
01:11:06,063 --> 01:11:10,155
CI X然后 加Ĵ 

1318
01:11:09,051 --> 01:11:14,330
这是一个 N-n 矩阵 我 在做 什么 

1319
01:11:11,055 --> 01:11:16,119
是我，我 访问我的计算 

1320
01:11:14,789 --> 01:11:18,866
当 我扔开始，然后我 

1321
01:11:17,019 --> 01:11:27,428
去 该 行 的第j列 ， 

1322
01:11:19,559 --> 01:11:29,590
然后访问该元素的所有权利，使 

1323
01:11:27,599 --> 01:11:32,605
让我们但它是相同的思路前 

1324
01:11:29,869 --> 01:11:34,925
所以让我们看看命中率本 

1325
01:11:32,659 --> 01:11:38,705
这 只是我们原来这是我们的 

1326
01:11:35,429 --> 01:11:41,340
原始未封端矩阵相乘，从而 

1327
01:11:39,119 --> 01:11:46,136
我们正在做的是我们是我们 

1328
01:11:41,034 --> 01:11:48,075
计算C 0 0和我们正在做的 ，通过 

1329
01:11:46,289 --> 01:11:54,382
取0 行 的内积 和 

1330
01:11:48,075 --> 01:11:57,194
列0哎呀所以如果你看一下 

1331
01:11:55,219 --> 01:11:59,228
我们假定缓存缓存

1332
01:11:57,869 --> 01:12:02,730
块拥有八个双打，而且 

1333
01:12:00,119 --> 01:12:04,198
矩阵要素的双打然后我们 

1334
01:12:02,073 --> 01:12:10,128
会想念时八分之一 

1335
01:12:04,909 --> 01:12:14,760
好了，所以在第一次迭代我们 

1336
01:12:11,028 --> 01:12:15,617
要 错过第一次迭代做 

1337
01:12:14,076 --> 01:12:17,142
这些事情 

1338
01:12:15,869 --> 01:12:22,980
而且，由于我们在缺少ñ超过八 

1339
01:12:18,042 --> 01:12:27,761
就是我们缺少一个块的时间 

1340
01:12:22,098 --> 01:12:29,927
对于每八八引用 

1341
01:12:28,139 --> 01:12:34,187
对于每一个 我们将 第一次迭代 

1342
01:12:30,809 --> 01:12:35,900
错过ñ超过八和因为n值 

1343
01:12:34,619 --> 01:12:42,420
对于每个块，我的每个元素 

1344
01:12:36,719 --> 01:12:43,724
对不起，然后哦，所以这是 多少 

1345
01:12:42,042 --> 01:12:45,111
块和未命中的数目和 

1346
01:12:44,219 --> 01:12:49,219
那么我们有n个元素，使得 

1347
01:12:46,011 --> 01:12:51,048
未命中的总数为 九 在 n 

1348
01:12:49,219 --> 01:12:56,219
八次错过分为 第一 

1349
01:12:51,048 --> 01:12:58,187
迭代还好第二次迭代会 

1350
01:12:56,219 --> 01:13:00,960
具有相同数量的失误， 因为 

1351
01:12:58,619 --> 01:13:03,704
我们约的大小假设 

1352
01:13:00,096 --> 01:13:05,465
此数组所以这个 这些行 是这样 

1353
01:13:04,469 --> 01:13:08,480
太大，不适合在高速缓存中 ，所以我们从来没有 

1354
01:13:06,329 --> 01:13:11,420
得到任何我们没有得到任何时间 

1355
01:13:08,579 --> 01:13:14,666
地方好了，所以总数 

1356
01:13:12,239 --> 01:13:17,010
失误是9种N超过八倍 

1357
01:13:15,449 --> 01:13:18,533
元素的数量，我们正在 更新 

1358
01:13:17,001 --> 01:13:22,001
这是N 的平方 好了，我们的总 

1359
01:13:19,289 --> 01:13:26,480
失误是九的8倍 和 

1360
01:13:22,001 --> 01:13:30,008
在现在立方，让我们重写代码 

1361
01:13:26,048 --> 01:13:32,126
使用阻塞，所以你可以看看 

1362
01:13:30,071 --> 01:13:35,120
此代码后，但它更简单 

1363
01:13:33,026 --> 01:13:39,068
只是，只是看它 形象地 

1364
01:13:36,002 --> 01:13:42,101
所以我们在做什么，而不是 

1365
01:13:39,068 --> 01:13:47,077
同时 ，我们正在更新一个元素 

1366
01:13:43,019 --> 01:13:50,096
更新的子块由B子块中的乙

1367
01:13:47,077 --> 01:13:52,175
和我们正在做的，只是完全 

1368
01:13:50,096 --> 01:13:57,098
类似于当我们 最初的情况下， 

1369
01:13:53,075 --> 01:14:00,107
其中B等于1这个这个乙通过B子 

1370
01:13:58,016 --> 01:14:05,845
在C中的块是通过取一个计算 

1371
01:14:01,007 --> 01:14:10,028
一组的子块的内积

1372
01:14:05,989 --> 01:14:12,950
在与一组子的子块的

1373
01:14:10,028 --> 01:14:14,042
在B 和这些 中的 每一个块

1374
01:14:12,095 --> 01:14:16,130
我们正在做的一点点小矩阵 

1375
01:14:14,042 --> 01:14:20,075
乘法，所以我们正在做我们

1376
01:14:17,003 --> 01:14:24,050
采取这种分块次此子

1377
01:14:20,075 --> 01:14:28,114
块加的第二子块

1378
01:14:24,077 --> 01:14:31,085
倍的B的第二子块加 

1379
01:14:29,014 --> 01:14:35,027
一个 倍第三 的第三子块 

1380
01:14:32,057 --> 01:14:36,119
B的子块等等好了 ，所以我们 

1381
01:14:35,027 --> 01:14:39,029
做相同的内积运算 

1382
01:14:37,019 --> 01:14:41,036
但不是标量，我们正在做的 

1383
01:14:39,029 --> 01:14:46,117
与这些小亚这些一点微小 

1384
01:14:41,036 --> 01:14:49,058
矩阵还好没事那么让我们来看看 

1385
01:14:47,017 --> 01:14:54,035
让我们看看会发生什么情况 小姐 

1386
01:14:49,058 --> 01:15:02,083
速度，我们这样做的时候那么有有 

1387
01:14:54,035 --> 01:15:07,042
Ñ在B嵌段在任何行或列中

1388
01:15:02,083 --> 01:15:11,141
并且因为有'S B方在项目 

1389
01:15:08,005 --> 01:15:17,059
每块B乘以B有'S B平方 

1390
01:15:12,041 --> 01:15:20,850
超过八错过 每个块行不行 

1391
01:15:17,059 --> 01:15:23,105
等再然后因为有

1392
01:15:21,219 --> 01:15:27,290
有n值超过B 嵌段中的每个矩阵 

1393
01:15:24,005 --> 01:15:33,424
并有两个矩阵有 2 - N的 

1394
01:15:27,029 --> 01:15:35,458
在B个时间乙平方超过8个为未命中 

1395
01:15:33,469 --> 01:15:41,494
这第一次迭代，使得工作 

1396
01:15:35,719 --> 01:15:43,880
出 要一个 NB 4 和分 

1397
01:15:41,719 --> 01:15:47,060
第二迭代具有一样的

1398
01:15:43,088 --> 01:15:49,327
同样错过排序相同的命中率，这样的 

1399
01:15:47,006 --> 01:15:53,006
未命中的总数是多少 

1400
01:15:50,119 --> 01:15:59,152
未命中的每个数 

1401
01:15:53,006 --> 01:16:01,067
元件 的迭代x倍的数量 

1402
01:15:59,449 --> 01:16:06,170
看看我们正在更新其没关系 

1403
01:16:01,067 --> 01:16:08,056
为n 乙级以上平方，使 所有作品 

1404
01:16:06,017 --> 01:16:13,094
出来-它仍然在其N立方分 

1405
01:16:08,659 --> 01:16:16,684
通过4 B因此，在我们的第一种情况下，没有 

1406
01:16:13,094 --> 01:16:19,063
阻断尽管该数目 

1407
01:16:16,909 --> 01:16:21,913
失误是渐近相同的，但 

1408
01:16:19,909 --> 01:16:23,630
有这个漂亮的这个大的差异 

1409
01:16:21,949 --> 01:16:26,840
在常数因子所以没有 

1410
01:16:23,063 --> 01:16:28,154
阻止它的9超过8阻止它的 

1411
01:16:26,084 --> 01:16:32,153
1超过40亿，我们现在是我们可以，我们可以只 

1412
01:16:29,054 --> 01:16:34,082
那种开车下来通过增加 

1413
01:16:33,053 --> 01:16:40,079
块大小，因此这给了我们一些 

1414
01:16:34,082 --> 01:16:41,180
一些控制，但我们还是我们，我们 

1415
01:16:40,079 --> 01:16:43,148
不能使块的块太大 

1416
01:16:42,008 --> 01:16:47,104
因为我们需要放到三个块 

1417
01:16:44,048 --> 01:16:48,076
在现金在任何一个时间点 

1418
01:16:49,021 --> 01:16:54,107
好了，所以 这种 情况的 原因 是一个戏剧性的 

1419
01:16:51,739 --> 01:16:58,670
区别权利 ，这样做的原因 

1420
01:16:55,007 --> 01:17:01,052
是做 阻挡我们排序 

1421
01:16:58,067 --> 01:17:02,132
利用一次我们加载一个模块到

1422
01:17:01,052 --> 01:17:04,501
内存我们有点重用其项目

1423
01:17:03,032 --> 01:17:09,061
一遍 又一遍 ，所以我们正在开发 

1424
01:17:04,969 --> 01:17:10,880
更多的时间局部性 和矩阵 

1425
01:17:09,349 --> 01:17:13,426
乘法有这个这个 

1426
01:17:10,088 --> 01:17:15,134
隐地方，因为 

1427
01:17:14,119 --> 01:17:20,200
计算是n阶立方但 

1428
01:17:16,034 --> 01:17:23,108
的数据的大小是 N的平方和，以便因此 

1429
01:17:20,929 --> 01:17:25,760
我们一定要重用一些数据项权

1430
01:17:24,008 --> 01:17:28,027
与我们的缩放方法的问题 

1431
01:17:25,076 --> 01:17:31,139
我们我们，当我们 重新使用 了 

1432
01:17:28,099 --> 01:17:38,700
他们并不在缓存 好吗 

1433
01:17:32,039 --> 01:17:40,107
没事让我想点 

1434
01:17:38,007 --> 01:17:41,088
让你的是，高速缓冲存储器

1435
01:17:41,007 --> 01:17:45,045
虽然他们有几分 

1436
01:17:42,051 --> 01:17:47,148
内置自动硬件 

1437
01:17:45,045 --> 01:17:51,050
存储设备和你不能真正 

1438
01:17:48,048 --> 01:17:53,126
控制他们，如果你了解他们，你 

1439
01:17:51,005 --> 01:17:56,067
可以把 你 的 知识 优势 ， 

1440
01:17:54,026 --> 01:17:59,109
开发利用他们，让你的代码 

1441
01:17:57,012 --> 01:18:04,067
运行速度很好，而且你这样做的方法 

1442
01:18:00,009 --> 01:18:04,067
就像我说的重点 放在内循环 

1443
01:18:04,007 --> 01:18:11,061
尝试去做做尝试访问我们的 

1444
01:18:08,079 --> 01:18:13,152
一个迈进，并试图最大限度地 向 

1445
01:18:12,024 --> 01:18:17,037
最大限度地提高空间局部性，并尝试 

1446
01:18:14,052 --> 01:18:18,105
通过最大限度地重用时间局部性 

1447
01:18:17,037 --> 01:18:22,071
局部变量，然后可以放 

1448
01:18:19,005 --> 01:18:24,066
到寄存器好了，这就是它 

1449
01:18:22,071 --> 01:18:26,133
今天的好运与你的攻击，如果实验室 

1450
01:18:24,066 --> 01:18:28,101
您还没有完成它，不要忘了 

1451
01:18:27,033 --> 01:18:31,037
要获得 高速缓存的实验室就这样 开始 了 

1452
01:18:29,001 --> 01:18:31,037
周末

