1
00:00:00,000 --> 00:00:05,091
这来自这将是最后一次演讲

2
00:00:02,076 --> 00:00:07,134
在机器语言的 我们叫它 

3
00:00:05,091 --> 00:00:12,650
高级的主题，但认为它更像 

4
00:00:08,034 --> 00:00:14,079
杂项议题，我认为最 让 

5
00:00:13,469 --> 00:00:15,990
你当然知道 你们的炸弹 

6
00:00:14,079 --> 00:00:18,081
实验室是由于今晚 

7
00:00:15,099 --> 00:00:21,150
所以你在这里最可能以及 成 

8
00:00:18,099 --> 00:00:23,166
或希望通过它，然后在 

9
00:00:22,005 --> 00:00:26,064
今晚午夜下一个web会 

10
00:00:24,066 --> 00:00:28,265
出被称为粘性的实验室，有 

11
00:00:27,009 --> 00:00:32,055
是关于昨天朗诵但 

12
00:00:28,859 --> 00:00:35,940
这是这样一个实验室，是新 课程 

13
00:00:32,055 --> 00:00:37,101
这是一个类似于一个 我们用来 

14
00:00:35,094 --> 00:00:40,116
在这一点上在使用过程中使用，但它的 

15
00:00:38,001 --> 00:00:46,550
被更新，并在显著改变 

16
00:00:41,016 --> 00:00:48,845
方式，所以我们实际上是当你有 

17
00:00:46,559 --> 00:00:50,561
像我们的实验室在这个过程中和这事 

18
00:00:48,989 --> 00:00:53,190
很多学生有很多的东西

19
00:00:50,579 --> 00:00:55,530
是去可以去错了 ，所以我们要 

20
00:00:53,019 --> 00:00:57,051
密切关注 的事情是如何 

21
00:00:55,053 --> 00:00:58,119
打算 ，但我 只 建议您在 

22
00:00:57,051 --> 00:01:02,780
有一个半星期要做到这一点 未来 

23
00:00:59,019 --> 00:01:05,025
网络得到很快，部分由开始 

24
00:01:03,239 --> 00:01:07,290
有一些人开始越早，你会 

25
00:01:05,025 --> 00:01:10,107
开始摔东西给我们 ，我们可以 

26
00:01:07,029 --> 00:01:14,468
所以今天我们将讨论追查

27
00:01:11,007 --> 00:01:16,011
大约是一对夫妇就像我说的 

28
00:01:14,729 --> 00:01:19,710
杂项议题，但重要 

29
00:01:16,047 --> 00:01:22,131
话题之一是排序的哪里是什么呢 

30
00:01:19,071 --> 00:01:26,120
内存的外观，当你运行像 

31
00:01:23,031 --> 00:01:28,910
86 64周的方案，另一个是一个 非常 

32
00:01:26,759 --> 00:01:31,140
对安全的重要课题

33
00:01:29,189 --> 00:01:33,420
漏洞称为缓冲区溢出

34
00:01:31,014 --> 00:01:36,383
而事实上，在一个协同合作，我们会 

35
00:01:33,042 --> 00:01:38,067
正是利用这些安全 

36
00:01:36,509 --> 00:01:40,574
漏洞，然后我们将看看 

37
00:01:38,067 --> 00:01:43,556
联盟到目前为止，你已经看了阵列和

38
00:01:41,159 --> 00:01:49,208
结构以及他们是如何组织的，我 

39
00:01:44,159 --> 00:01:52,166
想比较， 为工会让我们 

40
00:01:49,649 --> 00:01:53,720
说说内存，则正如我 在 说 

41
00:01:52,229 --> 00:01:56,820
在课程开始初期 

42
00:01:53,072 --> 00:02:00,159
从概念上来说，记忆是 只是一个大 

43
00:01:56,082 --> 00:02:03,084
的字节和该阵列的该视图 

44
00:02:01,059 --> 00:02:04,113
机器级的程序员，即使 

45
00:02:04,002 --> 00:02:07,451
它不是 实际执行 

46
00:02:05,013 --> 00:02:10,232
有一个整体的一部分，我们将讨论 

47
00:02:07,469 --> 00:02:12,550
关于后来 在这个过程中是 

48
00:02:10,349 --> 00:02:15,100
所谓虚拟内存 

49
00:02:12,055 --> 00:02:16,129
这个组织是非常简单的 

50
00:02:15,001 --> 00:02:19,009
组织，而是底层 

51
00:02:17,029 --> 00:02:22,048
实现这个复杂 

52
00:02:19,018 --> 00:02:26,031
各种不同的内存管理

53
00:02:22,048 --> 00:02:30,091
从磁盘存储器固态类型

54
00:02:26,031 --> 00:02:32,122
磁盘到什么叫做DRAM 其中 

55
00:02:30,091 --> 00:02:37,105
代表动态RAM的，当你购买 

56
00:02:33,022 --> 00:02:40,110
内存为您的处理器是DRAM 哦，这么 

57
00:02:38,005 --> 00:02:45,016
如您在x86的64知道我们有工作 

58
00:02:41,001 --> 00:02:48,016
机器， 名义上是有 

59
00:02:45,016 --> 00:02:50,044
地址可以 是高达 64位长，并 

60
00:02:48,025 --> 00:02:51,103
如果你的工作 号码记住我 

61
00:02:50,044 --> 00:02:54,127
告诉你在课程开始 

62
00:02:52,003 --> 00:02:58,078
您可以估算有多大了 许多像 

63
00:02:55,027 --> 00:03:01,102
到64是通过记住一个 

64
00:02:58,078 --> 00:03:03,112
千24和一千非常

65
00:03:02,002 --> 00:03:07,050
相互接近，从而两到第十 

66
00:03:04,012 --> 00:03:11,074
是大致相同的10到第三 

67
00:03:07,005 --> 00:03:14,053
所以你拿64，你 认为 60所以如何 

68
00:03:11,074 --> 00:03:18,160
大是2到 60嗯，这是6倍 

69
00:03:14,098 --> 00:03:22,105
10，因此 它的6倍3是 

70
00:03:19,006 --> 00:03:26,011
像10到18，然后你加入 

71
00:03:23,068 --> 00:03:29,107
4到这是2到第4和第16， 

72
00:03:27,001 --> 00:03:36,013
这是约16次，每次 10至18 

73
00:03:30,007 --> 00:03:40,066
打 所以如果你是走下车，并期待 

74
00:03:36,022 --> 00:03:43,057
在亚马逊网上的DRAM芯片，并尝试 

75
00:03:40,066 --> 00:03:46,165
买那么多的内存，你会发现 

76
00:03:43,057 --> 00:03:49,144
你花了很多钱超过 

77
00:03:47,065 --> 00:03:52,132
你不 知道的数字，但 它 

78
00:03:50,044 --> 00:03:55,123
将是一个很大的内存钱等 

79
00:03:53,032 --> 00:04:03,106
你基本上不能做到这一点现在倾向于 

80
00:03:56,023 --> 00:04:06,088
至所以现在 的 机器 

81
00:04:04,006 --> 00:04:12,013
限制你实际上 只有47位等值 

82
00:04:06,088 --> 00:04:13,150
在地址空间和地址，以便 2的

83
00:04:12,013 --> 00:04:18,019
到 47 再工作了这一点这是 

84
00:04:14,005 --> 00:04:22,090
像10到12倍256倍10 

85
00:04:18,073 --> 00:04:24,139
到12所以它的256兆兆字节和 

86
00:04:23,035 --> 00:04:25,123
你知道你现在可以买一个磁盘驱动器

87
00:04:25,039 --> 00:04:27,088
有8 

88
00:04:26,023 --> 00:04:29,029
jeribai所以它似乎并不像 

89
00:04:27,088 --> 00:04:31,162
很多，但如果你想 购买 那么多 

90
00:04:29,083 --> 00:04:38,155
DRAM再次你必须 有一个漂亮的 

91
00:04:32,062 --> 00:04:41,125
大信用卡限制，所以即使这 

92
00:04:39,055 --> 00:04:43,141
数量庞大的现代超级计算机 

93
00:04:42,025 --> 00:04:46,054
在实际情况下，将有近 

94
00:04:44,041 --> 00:04:50,041
这么大的内存，但问题是， 

95
00:04:46,054 --> 00:04:53,083
今天的 硬件 限制到了 47 

96
00:04:50,041 --> 00:04:56,065
位等值地址的，但是这不是 

97
00:04:53,083 --> 00:04:58,135
真正 的方面有真正的限制

98
00:04:56,065 --> 00:05:01,066
实际的机器 ，会发生什么是 

99
00:04:59,035 --> 00:05:03,094
是内存的价格越来越便宜和

100
00:05:01,075 --> 00:05:05,083
技术变得更好 ，他们会慢慢地 

101
00:05:03,094 --> 00:05:08,140
开始添加的后代 

102
00:05:06,055 --> 00:05:12,087
的处理器一起去让你拥有 

103
00:05:09,004 --> 00:05:19,030
越来越大范围的地址，以便 

104
00:05:12,087 --> 00:05:21,112
所有这就是说，这就是为什么这个 

105
00:05:19,066 --> 00:05:29,134
数显示 出来，其是七 

106
00:05:22,012 --> 00:05:31,111
其次是11S我可以告诉我需要 

107
00:05:30,034 --> 00:05:34,036
涂抹一些数字 你们都没有 

108
00:05:32,011 --> 00:05:39,102
只是说号码空气不 

109
00:05:34,054 --> 00:05:39,102
在这里工作，所以让我们尝试 

110
00:05:52,639 --> 00:06:00,701
好的 

111
00:05:54,032 --> 00:06:09,090
所以记得我 之前 说 264是关于 

112
00:06:01,259 --> 00:06:19,259
等于16倍10 到 18 -到 

113
00:06:09,009 --> 00:06:21,101
第47次是128倍10 到 12，以便 

114
00:06:19,259 --> 00:06:22,820
这是128兆兆字节

115
00:06:28,449 --> 00:06:38,505
有啥数 万亿字节 后 

116
00:06:31,025 --> 00:06:42,043
你知道10至15日有多少，但肯定 

117
00:06:39,009 --> 00:06:42,430
PB的右

118
00:06:44,019 --> 00:06:50,033
你知道什么10V 18是 exha 

119
00:06:52,049 --> 00:07:01,125
所以只是作为参考这样的公司 

120
00:06:57,069 --> 00:07:05,078
谷歌大概 它可能是一个总 

121
00:07:02,025 --> 00:07:09,064
在整个企业存储

122
00:07:05,699 --> 00:07:14,610
在一些小 数目的X字节 测量 

123
00:07:09,289 --> 00:07:16,770
它每天都越来越数 

124
00:07:14,061 --> 00:07:19,460
PB的我不知道的数字是 

125
00:07:16,077 --> 00:07:22,140
当然秘密，但也许10个千兆兆字节 

126
00:07:20,009 --> 00:07:26,190
或每新数据的一天， 它更

127
00:07:23,004 --> 00:07:29,004
摄取到它的系统，这些 

128
00:07:26,019 --> 00:07:30,081
数字是相当巨大的，但不只是 

129
00:07:29,004 --> 00:07:35,303
完全关闭的图表 ，你知道是什么 

130
00:07:30,081 --> 00:07:39,149
10到21是它被称为 

131
00:07:35,699 --> 00:07:40,490
泽字节有两个 T的 

132
00:07:40,094 --> 00:07:45,095
如果你 把所有 的它的估计

133
00:07:43,088 --> 00:07:47,150
在获得世界数字内容 

134
00:07:46,004 --> 00:07:52,085
创建每个人的手机摄像头 

135
00:07:48,005 --> 00:07:55,007
任何人在任何地方采取的所有每个视频

136
00:07:52,085 --> 00:07:57,143
一年之久 的一对夫妇一泽字节的 

137
00:07:55,052 --> 00:08:00,070
一年所以这将是一个虽然 我们之前 

138
00:07:58,043 --> 00:08:04,048
真的有对付那种 

139
00:08:00,007 --> 00:08:08,081
内存所以才只给你一个想法 ， 所以 

140
00:08:04,093 --> 00:08:12,095
128兆兆字节是在地址界限 

141
00:08:09,044 --> 00:08:15,089
这些系统和所以这就是为什么你有 

142
00:08:12,095 --> 00:08:18,187
以有七个 ，因为 你还记得 

143
00:08:15,089 --> 00:08:22,127
这是一二三，然后有公司的 F 

144
00:08:19,087 --> 00:08:28,121
但有他们的11，这是 一个 

145
00:08:23,027 --> 00:08:33,976
一个一个次11，这是44一和 

146
00:08:29,021 --> 00:08:40,660
这是三一，这就是你在哪里 

147
00:08:34,219 --> 00:08:44,450
得到47，这就是在地址 

148
00:08:40,849 --> 00:08:46,730
Linux的这就是他们把 堆栈 

149
00:08:44,045 --> 00:08:48,143
在高达地址 空间 的最顶端 

150
00:08:46,073 --> 00:08:50,141
我应该告诉 你这幅画 是 

151
00:08:49,043 --> 00:08:53,074
不是所有 它 的规模 将是 

152
00:08:51,041 --> 00:08:55,130
不可能得出这个画面缩放 

153
00:08:53,074 --> 00:08:58,166
例如，它示出了堆 

154
00:08:56,003 --> 00:09:03,020
在顶部开始一路 上扬 ，并 记 

155
00:08:59,066 --> 00:09:05,147
堆栈增长到较小的地址时， 

156
00:09:03,047 --> 00:09:08,060
你推，也是我们展示他们 

157
00:09:06,047 --> 00:09:14,075
倒挂只是使一切 

158
00:09:08,006 --> 00:09:16,010
混乱使堆栈从那里开始

159
00:09:14,075 --> 00:09:18,131
和它的增长向低地址 ， 

160
00:09:17,000 --> 00:09:22,013
一个典型的系统上，将被限制 

161
00:09:19,031 --> 00:09:27,065
到8兆 ，你可以告诉大家，在 

162
00:09:22,013 --> 00:09:33,086
Linux系统至少与该 

163
00:09:27,065 --> 00:09:35,126
限制这曾经是多个命令

164
00:09:33,086 --> 00:09:37,088
有趣的是，它现在是 

165
00:09:36,026 --> 00:09:40,061
因为很多 东西是无限的 

166
00:09:37,088 --> 00:09:42,176
但是你看它说栈的大小 

167
00:09:40,061 --> 00:09:47,083
有限8192 千字节 为千字节 ，以便 

168
00:09:43,076 --> 00:09:47,083
这是8兆字节 

169
00:09:49,529 --> 00:10:00,350
而这是什么意思是，如果你想 

170
00:09:53,072 --> 00:09:59,135
经由栈指针访问任意存储 

171
00:10:00,074 --> 00:10:07,463
这是 这 8 的范围之外 

172
00:10:06,072 --> 00:10:11,861
兆字节的范围内，你会得到一个分割

173
00:10:08,129 --> 00:10:15,167
故障 再往下 在低位地址 

174
00:10:12,509 --> 00:10:17,490
是什么进来什么被投入 

175
00:10:15,509 --> 00:10:19,800
你的程序是代码的部分 

176
00:10:17,049 --> 00:10:22,068
这是前来 可执行 的出 

177
00:10:19,008 --> 00:10:23,597
档案等有一个 部分，我们会 

178
00:10:22,068 --> 00:10:26,087
聊得更多，当我们 谈论链接 

179
00:10:24,389 --> 00:10:29,402
其实关于出路内存 

180
00:10:26,699 --> 00:10:31,718
和 它但对于不同地区 

181
00:10:29,519 --> 00:10:33,575
他们称，他们那里的一些模糊的原因 

182
00:10:31,889 --> 00:10:37,620
该代码是坐在可执行 

183
00:10:34,079 --> 00:10:39,930
程序文本段 ，我不知道 

184
00:10:37,062 --> 00:10:42,251
为什么这是真的，但它的事情是这样的 

185
00:10:39,093 --> 00:10:44,792
多 台机器 ，然后将 网 

186
00:10:42,809 --> 00:10:47,843
数据首先是那里将是一个

187
00:10:45,629 --> 00:10:50,693
对于已分配其数据段

188
00:10:48,149 --> 00:10:54,149
节目开始，因此任何全球 

189
00:10:51,269 --> 00:10:58,350
你已经声明的变量会 

190
00:10:54,149 --> 00:11:01,470
在该部分中，然后将热是 

191
00:10:58,035 --> 00:11:03,524
内存部分是 X分配 

192
00:11:01,047 --> 00:11:06,416
通过调用函数malloc或与其相关的一个

193
00:11:03,839 --> 00:11:08,924
功能和，使得动态地改变

194
00:11:06,839 --> 00:11:12,480
在程序运行时就开始了与 一 

195
00:11:09,689 --> 00:11:12,778
非常小的 分配，你每一次 

196
00:11:12,048 --> 00:11:17,777
调用malloc

197
00:11:13,579 --> 00:11:20,430
如果你不释放内存等你 

198
00:11:18,209 --> 00:11:24,480
内存需求保持增长它会 

199
00:11:20,043 --> 00:11:26,822
折痕跟上连升更大， 

200
00:11:24,048 --> 00:11:29,267
更大的地址，然后在某处 

201
00:11:27,209 --> 00:11:32,303
代码 -并且这可以通过改变系统 

202
00:11:29,699 --> 00:11:35,550
是 获取带来的代码

203
00:11:33,149 --> 00:11:38,180
代表库函数的东西 

204
00:11:35,055 --> 00:11:40,394
喜欢漂亮的malloc本身我们自己 

205
00:11:38,459 --> 00:11:43,350
库代码他们在磁盘上存储关闭 

206
00:11:40,889 --> 00:11:44,891
他们得到带来了他们获取链接

207
00:11:43,035 --> 00:11:47,204
到你的程序第一次启动时，它 

208
00:11:45,089 --> 00:11:49,133
通过被 称为动态 处理执行

209
00:11:47,519 --> 00:11:52,562
联，我们将在后面 讨论 

210
00:11:49,529 --> 00:11:54,571
课程 -与链接什么 

211
00:11:52,949 --> 00:11:57,300
你会发现在一般的是， 

212
00:11:54,949 --> 00:12:00,000
分配将趋于无论是在 

213
00:11:57,003 --> 00:12:01,075
这些非常低的地址或这些非常

214
00:12:00,000 --> 00:12:07,066
高地址

215
00:12:02,002 --> 00:12:11,026
为你的程序作为一个如此只是运行 

216
00:12:07,066 --> 00:12:13,075
这里的例子是一些 代码，这只是 

217
00:12:11,026 --> 00:12:15,915
价值是向您展示 不同的地方 

218
00:12:13,075 --> 00:12:18,106
事情变得位于所以你会看到我 

219
00:12:16,149 --> 00:12:23,020
分配一些相当大的数组

220
00:12:19,006 --> 00:12:27,079
这里这个是有一切烦恼 ，但 

221
00:12:23,002 --> 00:12:31,093
这是2到第24次，以便16兆字节 

222
00:12:27,079 --> 00:12:36,148
阵列和这个人是2到第31次，从而 

223
00:12:31,093 --> 00:12:40,442
这是2千兆字节数组值得我找到了

224
00:12:37,048 --> 00:12:46,467
如果我试图分配较大的 

225
00:12:41,279 --> 00:12:49,341
该程序将无法运行，我也做 

226
00:12:46,899 --> 00:12:53,620
一些在这里只是一种全球 

227
00:12:49,899 --> 00:12:54,993
变量，这里是一个函数，然后 

228
00:12:53,062 --> 00:12:57,073
这里有一个单一的功能与一些 

229
00:12:55,839 --> 00:12:58,920
局部变量， 这将是 

230
00:12:57,073 --> 00:13:01,132
在栈上分配的地方和 

231
00:12:59,649 --> 00:13:05,020
再 有就是多次 打电话给一些奶 

232
00:13:02,032 --> 00:13:07,045
这些都是一些非常小的块

233
00:13:05,002 --> 00:13:10,311
的存储器并且类似地，其中一些 

234
00:13:07,045 --> 00:13:13,063
记忆，所以我们非常大的块

235
00:13:10,329 --> 00:13:16,380
可以运行这个程序， 看看有什么 

236
00:13:13,063 --> 00:13:20,068
地址蹦出 它， 你会 是什么 

237
00:13:16,839 --> 00:13:23,470
看到 的是堆栈这个局部变量 

238
00:13:20,068 --> 00:13:25,105
了在地址某处

239
00:13:23,047 --> 00:13:27,079
堆栈的范围内，您将看到7 

240
00:13:26,005 --> 00:13:30,007
一对夫妇的FS，然后它去 

241
00:13:27,079 --> 00:13:32,086
别的东西，你还可以看到 

242
00:13:30,007 --> 00:13:36,100
有趣的是，该 编解码器 和 

243
00:13:33,049 --> 00:13:39,648
然后低头看着 这个 底部 

244
00:13:37,000 --> 00:13:42,049
黄色的事情被 降级 

245
00:13:40,089 --> 00:13:45,790
文段的主要功能和 

246
00:13:42,049 --> 00:13:48,100
这个功能我打电话给我叫宣 

247
00:13:45,079 --> 00:13:52,087
无用然后将预定义的阵列 

248
00:13:49,000 --> 00:13:55,027
那 名换句话说全球 

249
00:13:52,087 --> 00:13:57,174
宣布不malloc的他们宣布

250
00:13:55,027 --> 00:14:02,070
声明为程序本身的一部分

251
00:13:58,074 --> 00:14:05,095
在这里倒在这个数据部分 ， 

252
00:14:02,007 --> 00:14:06,016
因为它是一个非常大阵的巨大 

253
00:14:05,095 --> 00:14:09,142
数组你实际上得到一些相当大的 

254
00:14:07,006 --> 00:14:13,037
地址，并十分有趣 

255
00:14:10,042 --> 00:14:16,130
或者我不知道为什么它是有趣的，但 

256
00:14:13,091 --> 00:14:19,184
对于某种 原因 它发生 

257
00:14:17,003 --> 00:14:23,060
该存储器的更小的块 

258
00:14:20,084 --> 00:14:24,137
分配是到这里的地址 

259
00:14:23,087 --> 00:14:27,179
这 其实只是一点点 

260
00:14:25,037 --> 00:14:30,086
上面的粉红色部分和右 

261
00:14:28,079 --> 00:14:36,083
类似的真正的大大块

262
00:14:30,086 --> 00:14:43,103
分配内存的方式在这里附近 

263
00:14:36,083 --> 00:14:44,159
该堆栈限制，他们等 

264
00:14:44,003 --> 00:14:47,030
他们在那里和一般的有什么

265
00:14:45,059 --> 00:14:50,087
发生的事情是，如果我就是要尝试 和 

266
00:14:47,003 --> 00:14:53,024
在这个空引用的存储器地址 

267
00:14:50,087 --> 00:14:55,186
范围内我会得到一个分段错误 是 

268
00:14:53,051 --> 00:14:58,094
在其位方面的有效地址 

269
00:14:56,086 --> 00:15:00,140
性能，但它 实际上并没有 

270
00:14:58,094 --> 00:15:03,137
建立和分配由内存 

271
00:15:01,004 --> 00:15:06,080
虚拟内存分配器所以在任何 给定 

272
00:15:04,037 --> 00:15:09,074
时间的有效地址， 只是那些 

273
00:15:07,016 --> 00:15:12,038
在下部或上部 

274
00:15:09,074 --> 00:15:13,163
他的 地址范围和的部分

275
00:15:12,038 --> 00:15:16,070
中间是那种没有人的土地，然后 

276
00:15:14,063 --> 00:15:19,130
发生的事情是 你 保持分配更多 

277
00:15:16,007 --> 00:15:21,092
使用malloc，它会挑战极限 

278
00:15:20,003 --> 00:15:26,087
什么是可寻址的对着它 

279
00:15:22,055 --> 00:15:30,074
原则上，如果你曾经有 太多的 

280
00:15:27,014 --> 00:15:33,062
如果这两个会打一个内存请求 

281
00:15:30,074 --> 00:15:35,087
对方如果你米勒 会 

282
00:15:33,062 --> 00:15:39,071
在这一点上返回零，但它 

283
00:15:35,087 --> 00:15:42,109
高度 不太可能， 因为你有128 

284
00:15:40,052 --> 00:15:45,053
内存地址范围太字节这里 

285
00:15:43,009 --> 00:15:48,065
所以这只是你可能见过 

286
00:15:45,053 --> 00:15:50,054
这个当你运行你正在寻找 

287
00:15:48,065 --> 00:15:52,082
在使用gdb反汇编代码你 

288
00:15:50,063 --> 00:15:55,070
看到一些地址是一路上扬 

289
00:15:52,082 --> 00:15:57,175
这里有七个和一些情节或 

290
00:15:55,007 --> 00:16:00,068
堆栈地址， 你看到这些四肢 

291
00:15:58,075 --> 00:16:02,132
你知道很多 零和一些四肢 的 

292
00:16:01,031 --> 00:16:06,073
这些往往是其中的代码是 怎么回事 

293
00:16:03,032 --> 00:16:06,073
质疑 

294
00:16:08,005 --> 00:16:12,080
所以为什么不热继续在一个 

295
00:16:10,085 --> 00:16:14,180
方向其实我 不知道我会 

296
00:16:13,025 --> 00:16:17,066
只是观察， 它是有一个战略 

297
00:16:15,008 --> 00:16:18,047
这里把 大事小 

298
00:16:17,066 --> 00:16:20,105
这里的东西， 它可能使用 

299
00:16:19,019 --> 00:16:24,043
不同略有不同的管理

300
00:16:21,005 --> 00:16:24,043
对于 那些 两种 策略 

301
00:16:32,629 --> 00:16:37,680
还好使，但我认为你会 发现 

302
00:16:35,819 --> 00:16:38,876
那种非常有用 的一些感觉 

303
00:16:37,068 --> 00:16:41,027
当你看到的时候你在 

304
00:16:39,389 --> 00:16:43,560
运行GDB它有助于只是有一些 

305
00:16:41,639 --> 00:16:46,651
这是怎么回事，当你在的想法

306
00:16:43,056 --> 00:16:48,141
看着这些 不同的地址 

307
00:16:46,759 --> 00:16:53,100
现在没事了，让我们来谈谈 缓冲 

308
00:16:49,041 --> 00:16:55,160
溢出，我们将开始这个你

309
00:16:53,001 --> 00:16:57,006
记得非常一流 的，我 

310
00:16:55,529 --> 00:17:00,360
想我们可能 已对部分 

311
00:16:57,006 --> 00:17:02,435
沿着路我们发现 了一些 这个例子 

312
00:17:00,036 --> 00:17:07,355
在那里，如果你做一个节目

313
00:17:03,029 --> 00:17:09,780
外的边界 基准，写 

314
00:17:07,679 --> 00:17:14,130
值的出特别界 

315
00:17:09,078 --> 00:17:16,080
我只有两个元素的数组这里 

316
00:17:14,013 --> 00:17:20,013
不过这个功能需要任意 

317
00:17:16,098 --> 00:17:23,163
我的价值和分配一些神奇的数字 

318
00:17:20,013 --> 00:17:29,432
到omotte i中的阵列的并且它具有 

319
00:17:24,063 --> 00:17:32,722
我们的可能性， 看到 你 的时候 

320
00:17:29,549 --> 00:17:38,220
这样做，如果我得到过大，会先 

321
00:17:33,289 --> 00:17:40,289
腐败是存储部分双 

322
00:17:38,022 --> 00:17:43,101
该结构的， 然后当它 得到 

323
00:17:40,289 --> 00:17:46,110
大似乎没有 任何效果 

324
00:17:44,001 --> 00:17:48,800
直到它变得太大， 然后你开始 

325
00:17:46,011 --> 00:17:52,011
腐败存储器所以基本点是 

326
00:17:48,809 --> 00:17:55,500
它很容易在 C 程序 

327
00:17:52,011 --> 00:17:58,023
方案特别涉及一种参考 

328
00:17:55,005 --> 00:18:04,067
内存不是那种的一部分

329
00:17:58,023 --> 00:18:07,065
该计划的目的，这可以 

330
00:18:05,012 --> 00:18:11,109
发生在节目 中不正确 

331
00:18:07,065 --> 00:18:13,071
撰文 指出 ， 和它成为一个安全 

332
00:18:12,009 --> 00:18:20,034
漏洞 ，如果有一些 方法为 

333
00:18:14,025 --> 00:18:21,072
局外人溢出了缓冲器 

334
00:18:20,034 --> 00:18:23,043
例如，如果有某种方式为 

335
00:18:21,072 --> 00:18:26,100
外人给我更大的价值 ， 

336
00:18:24,024 --> 00:18:29,076
问该值 存储在那里 它 

337
00:18:27,000 --> 00:18:31,038
能使整个程序崩溃，因此在 

338
00:18:29,076 --> 00:18:32,127
一般来说，当你在代码编写你尝试 

339
00:18:31,038 --> 00:18:36,045
想想你知道我可以信任这个 

340
00:18:33,027 --> 00:18:38,306
值是这个是一直值 

341
00:18:36,045 --> 00:18:40,098
我的计划计算，我敢肯定，

342
00:18:38,549 --> 00:18:41,490
它的范围内或者是它的东西 

343
00:18:40,098 --> 00:18:42,527
那 

344
00:18:41,049 --> 00:18:46,110
所以来自外部 源 和 

345
00:18:43,409 --> 00:18:50,610
那里的是一个危险的潜在 

346
00:18:47,001 --> 00:18:52,092
漏洞某某特别 

347
00:18:50,061 --> 00:18:55,149
有很多 巨大的错误类 

348
00:18:53,001 --> 00:19:00,024
具有与 缓冲器 溢出做 

349
00:18:56,049 --> 00:19:02,055
哪里哪里，他们正试图存储 

350
00:19:00,024 --> 00:19:07,122
某种类型的字符串已经读过 

351
00:19:03,009 --> 00:19:10,062
从消息和 在 不知道 

352
00:19:08,022 --> 00:19:13,038
推进它有多大这个字符串是很 

353
00:19:10,062 --> 00:19:15,371
可能，这将是太大了 

354
00:19:13,038 --> 00:19:17,040
缓冲区一个已经 分配 等一个 

355
00:19:15,929 --> 00:19:23,014
元凶是有一个全班 

356
00:19:17,058 --> 00:19:25,137
的库函数，让 你 

357
00:19:23,779 --> 00:19:29,070
存储的东西串的地方 

358
00:19:26,037 --> 00:19:32,046
没有任何一种界限，甚至检查 

359
00:19:29,007 --> 00:19:35,846
是可能因此是 最糟糕 的 一个 

360
00:19:33,027 --> 00:19:38,036
一个叫得到 F和目的 

361
00:19:35,909 --> 00:19:42,935
让小号通常它被用来 读取 

362
00:19:38,279 --> 00:19:44,730
从一个终端的输入串

363
00:19:43,169 --> 00:19:47,130
输入的东西，有人在打字 

364
00:19:44,073 --> 00:19:49,110
到 终端，因此它在做什么 

365
00:19:47,013 --> 00:19:52,095
是它的扫描 这个输入字符串和 

366
00:19:50,001 --> 00:19:56,200
寻找代表一个字符

367
00:19:52,095 --> 00:19:59,100
该行的 末尾 ，我们在写 

368
00:19:56,299 --> 00:20:05,610
CEA的是反斜杠n 和它有 

369
00:20:00,000 --> 00:20:08,058
在零 等 十六进制字符代码

370
00:20:05,061 --> 00:20:09,860
得到F该 是 有点近似的 

371
00:20:08,058 --> 00:20:13,083
什么代码forgetteth版本 

372
00:20:10,409 --> 00:20:15,422
看起来像它作为参数 

373
00:20:13,083 --> 00:20:17,088
它只是给出其中目的地 

374
00:20:15,539 --> 00:20:20,627
存储 结果，它 是 所有 

375
00:20:18,033 --> 00:20:23,762
它一次长相读取一个字符 

376
00:20:21,419 --> 00:20:27,433
对于到文件的意思是输入

377
00:20:24,059 --> 00:20:30,090
流被关闭或结束线 

378
00:20:27,559 --> 00:20:33,600
但只要它，直到它发现它 

379
00:20:30,009 --> 00:20:40,061
只是不断 添加更多的东西到最后 

380
00:20:33,006 --> 00:20:40,007
此缓冲液中，因此通常

381
00:20:43,139 --> 00:20:49,690
当有人打电话让我们，他们会通过 

382
00:20:46,179 --> 00:20:52,278
它的指针一定的缓冲，他们已经 

383
00:20:49,069 --> 00:20:54,148
但分配功能，它会

384
00:20:53,169 --> 00:20:58,240
只是让我们 ，我们将只需填写该 缓冲区 

385
00:20:55,048 --> 00:21:00,049
了，但它可能只是不停 

386
00:20:58,024 --> 00:21:02,313
去没有什么作用 

387
00:21:00,049 --> 00:21:06,073
甚至还有没有参数传递给 

388
00:21:02,529 --> 00:21:08,592
函数， 告诉功能时 

389
00:21:06,073 --> 00:21:10,992
当它停止时，它达到 

390
00:21:09,159 --> 00:21:14,172
它的上限，从而使其被写 了 

391
00:21:11,649 --> 00:21:16,240
实际上得到的是，如果你尝试 编译 

392
00:21:14,289 --> 00:21:18,297
代码将让我们将闪了一大 

393
00:21:16,024 --> 00:21:19,108
警告说，这是一个真正的 

394
00:21:18,369 --> 00:21:24,396
不安全的功能，你可能不应该

395
00:21:20,008 --> 00:21:28,084
甚至可以使用它，因为它有 它 

396
00:21:24,639 --> 00:21:30,681
写在一个时代在20世纪70年代时， 

397
00:21:28,084 --> 00:21:32,253
早期 UNIX分布，未来 

398
00:21:31,059 --> 00:21:35,130
出人们只是不担心 

399
00:21:33,009 --> 00:21:39,018
有关安全漏洞和他们 

400
00:21:35,769 --> 00:21:42,834
只是假设， 如果你分配一个大 

401
00:21:39,909 --> 00:21:45,490
足够的缓冲区，有没有理由 

402
00:21:43,419 --> 00:21:49,491
字符串应大于什么 

403
00:21:45,049 --> 00:21:52,358
你已经分配，这就是实际 

404
00:21:50,139 --> 00:21:58,200
真正与 像搅 复制 等 功能 

405
00:21:52,799 --> 00:22:03,090
你还记得 搅拌副本有两个 参数 

406
00:21:58,749 --> 00:22:06,220
原谅我的目的地和源和 

407
00:22:03,009 --> 00:22:09,046
其目的是字符串 的 复制 

408
00:22:06,022 --> 00:22:10,941
源到 目标和方式 

409
00:22:09,046 --> 00:22:12,015
它确定字符串的末尾和 

410
00:22:11,139 --> 00:22:15,177
源是当它击中空 

411
00:22:12,429 --> 00:22:18,820
字符只是 不断复制一个 

412
00:22:15,519 --> 00:22:20,535
一面墙上，直到它击中它，但它没有 

413
00:22:18,082 --> 00:22:22,311
办法知道有没有什么 

414
00:22:20,679 --> 00:22:25,686
多少信息有多大 

415
00:22:23,049 --> 00:22:29,110
在缓冲的分配 

416
00:22:26,379 --> 00:22:31,434
目的地，因此它很容易 溢出 

417
00:22:29,011 --> 00:22:34,012
一个类似的一个叫猫轰动其中 

418
00:22:31,929 --> 00:22:38,350
用来连接 两个字符串 

419
00:22:34,021 --> 00:22:43,024
将它们复制到另一个目的地和 

420
00:22:38,035 --> 00:22:44,098
也有可能在 scanf 函数 

421
00:22:43,024 --> 00:22:48,453
格式字符串可以 给 

422
00:22:44,098 --> 00:22:50,194
％的 ˚F 指令格式字符串 

423
00:22:48,669 --> 00:22:53,130
它说读取一个字符串，并将其存储 

424
00:22:51,094 --> 00:22:54,159
某个地方

425
00:22:53,013 --> 00:22:57,542
并且它没有说多久字符串 

426
00:22:55,059 --> 00:22:59,258
被限制为，并没有 说如何 

427
00:22:57,659 --> 00:23:02,220
多少内存可用在 

428
00:22:59,789 --> 00:23:05,840
目的地，又可以 很容易只 

429
00:23:02,022 --> 00:23:08,711
写了一个 缓冲器，这些都是 

430
00:23:06,299 --> 00:23:11,700
真正的漏洞， 我们就会讨论 

431
00:23:08,909 --> 00:23:14,070
一分钟 待会儿你如何 作为 

432
00:23:11,007 --> 00:23:16,846
程序员可以 聪明 一点 

433
00:23:14,007 --> 00:23:20,596
比这个，但在他们的原始形式的诉讼 

434
00:23:17,539 --> 00:23:24,360
所呈现他们有这样的

435
00:23:20,659 --> 00:23:27,746
漏洞给他们，让我们来看看 

436
00:23:24,036 --> 00:23:30,935
什么这样的例子可以什么都可以 

437
00:23:28,529 --> 00:23:35,070
碰巧有这么想象， 例如 ，我们 

438
00:23:31,259 --> 00:23:36,326
想要实现回声功能，所以一 

439
00:23:35,007 --> 00:23:39,069
回声功能是一个你 只需要输入 

440
00:23:36,929 --> 00:23:41,942
东西和它打印回来了

441
00:23:39,069 --> 00:23:43,048
这是除了很无趣功能 

442
00:23:42,059 --> 00:23:47,070
它展示的东西非常有用 

443
00:23:43,669 --> 00:23:49,110
这样的想法是有这个小缓冲区 

444
00:23:47,007 --> 00:23:53,007
它只够容纳四个字符 

445
00:23:49,011 --> 00:23:56,022
它 造成木屐 来读取一个字符串 

446
00:23:53,007 --> 00:24:01,085
输入，然后调用放 S的 

447
00:23:56,022 --> 00:24:01,085
简单地写回了输出和 

448
00:24:08,079 --> 00:24:15,080
所以让我 下载这个不 

449
00:24:12,045 --> 00:24:15,080
非常有趣的功能 

450
00:24:20,031 --> 00:24:28,039
所以我在这里 把 它 的buff演示- NST意思 

451
00:24:26,089 --> 00:24:30,151
它 没有堆栈保护 ，我们会看到 

452
00:24:29,011 --> 00:24:33,073
在一分钟内什么的甲板保护者，但 

453
00:24:31,051 --> 00:24:45,073
你看，如果你键入一个合理的抽烟

454
00:24:33,073 --> 00:24:48,079
强大的小弦非常罕见的 它可以 

455
00:24:45,073 --> 00:24:49,150
处理四个以上的居然 

456
00:24:48,079 --> 00:24:51,133
写它不能处理超过三个 

457
00:24:50,005 --> 00:25:02,014
正确的，因为应该有余地

458
00:24:52,033 --> 00:25:04,060
空字符-在终结所以 

459
00:25:02,059 --> 00:25:09,124
原来，这个特殊的，如果我

460
00:25:04,006 --> 00:25:12,009
键入24个字符的字符串， 它会 

461
00:25:10,024 --> 00:25:12,063
没关系 

462
00:25:21,004 --> 00:25:28,019
但如果我在 24 String类型 

463
00:25:24,002 --> 00:25:30,076
字符将创下分割

464
00:25:28,055 --> 00:25:30,076
故障 

465
00:25:32,003 --> 00:25:37,025
所以在哪里这些数字23和24来

466
00:25:35,069 --> 00:25:40,069
在好这件事情，我们可以 通过 学习 

467
00:25:37,052 --> 00:25:40,069
看汇编代码 

468
00:25:55,072 --> 00:26:02,150
所以这里的，我们将通过代码 

469
00:25:59,014 --> 00:26:07,058
所以首先这是代码 

470
00:26:03,005 --> 00:26:13,052
回声，然后你看到的回声调用get 

471
00:26:07,058 --> 00:26:15,065
S和它要求把它和这里的 

472
00:26:13,097 --> 00:26:18,143
部分的代码，你可以告诉如何 

473
00:26:16,028 --> 00:26:36,076
多少内存得到分配的缓冲区 

474
00:26:19,043 --> 00:26:36,076
和X18就是十进制X 24 右 

475
00:26:37,003 --> 00:26:45,020
你刚才看到 实际的东西 

476
00:26:41,003 --> 00:26:46,096
SEG故障与24一个输入字符串，所以 

477
00:26:45,047 --> 00:26:49,112
我们会看到， 在一分钟内 

478
00:26:46,096 --> 00:26:53,168
但不管怎么说，你可以在这里看到它 

479
00:26:50,012 --> 00:27:01,064
在堆栈上分配的24的区域

480
00:26:54,068 --> 00:27:02,117
字节，它复制到这RDI 

481
00:27:01,064 --> 00:27:04,157
这当然是参数 

482
00:27:03,017 --> 00:27:11,038
forgetteth所以得到我们被称为 

483
00:27:05,057 --> 00:27:13,124
的指针的大小24 的 缓冲 

484
00:27:11,038 --> 00:27:16,063
最大24 即使你看到了 

485
00:27:14,024 --> 00:27:24,071
原申报只有 4对 

486
00:27:16,063 --> 00:27:27,092
所有然后调用得到 秒，然后得到 

487
00:27:24,071 --> 00:27:31,127
我们做这件事只是一个最后的 小 

488
00:27:27,092 --> 00:27:38,117
位牢记的是 ，我们会回来 

489
00:27:32,027 --> 00:27:40,088
他们哦， 是的，记住反响 ， 

490
00:27:39,017 --> 00:27:42,091
有一个函数调用调用回声 

491
00:27:40,088 --> 00:27:45,113
这是调用回音的事情， 

492
00:27:42,091 --> 00:27:49,148
只是要记住这个读是 

493
00:27:46,013 --> 00:27:53,017
呼叫回波地址，这就是 

494
00:27:50,048 --> 00:27:53,053
将是重要的 

495
00:27:55,008 --> 00:28:04,063
所以我们看到的又是什么内存布局 

496
00:27:58,033 --> 00:28:07,072
是的buff通常足够大 的 

497
00:28:04,063 --> 00:28:09,145
四个字符 有一种20 

498
00:28:07,072 --> 00:28:12,088
这里的闲置或浪费的空间字节 

499
00:28:10,045 --> 00:28:15,067
那么实际的返回地址是 

500
00:28:12,088 --> 00:28:23,110
的返回地址回叫回声 

501
00:28:15,067 --> 00:28:26,706
被存储在 栈上，所以当这个 

502
00:28:24,001 --> 00:28:29,068
程序 INT开始运行时，回声 

503
00:28:27,309 --> 00:28:33,550
开始运行，我们会发现，这是 

504
00:28:29,077 --> 00:28:39,124
栈 为返回 的值 

505
00:28:33,055 --> 00:28:44,064
指针，如果我们在一个 字符串的视 型 

506
00:28:40,024 --> 00:28:47,026
这里的23个字符 ，你会看到，它 

507
00:28:44,559 --> 00:28:51,460
使用了 这个整个缓冲区和记忆 

508
00:28:47,026 --> 00:28:53,122
一个字符串终止于0 0，但它 

509
00:28:51,046 --> 00:28:55,135
仍然没有它仍然是内 

510
00:28:54,022 --> 00:29:00,022
这是在栈上分配的区域 

511
00:28:56,035 --> 00:29:04,069
对于这样它刚好 适合的 

512
00:29:00,022 --> 00:29:06,061
堆栈，这就是为什么我们在技术上 

513
00:29:04,069 --> 00:29:07,153
我们溢出的缓冲区，但我们没有 

514
00:29:06,061 --> 00:29:11,130
真正造成任何伤害，因为有 

515
00:29:08,053 --> 00:29:13,132
可用 ，所以这就是这个额外的空间 

516
00:29:11,679 --> 00:29:18,940
为什么我能在23字符串类型

517
00:29:14,032 --> 00:29:22,090
字符，它工作得很好 ，但 

518
00:29:18,094 --> 00:29:24,713
现在如果我在这个类型是一个例子 

519
00:29:22,009 --> 00:29:24,668
展示 

520
00:29:28,015 --> 00:29:38,104
其实我 25个字符， 所以一旦我走 

521
00:29:34,081 --> 00:29:39,160
超过23个字符加空

522
00:29:39,004 --> 00:29:46,030
性格你就会明白我 慢慢地 

523
00:29:40,006 --> 00:29:48,052
开始做的是损坏了 的 

524
00:29:46,003 --> 00:29:51,040
返回的字节表示

525
00:29:49,006 --> 00:29:54,049
地址等什么， 例如发生 

526
00:29:51,067 --> 00:29:58,075
这里要说的是，而不是试图 

527
00:29:54,049 --> 00:29:59,104
返回到 哪里通话回声 

528
00:29:58,075 --> 00:30:01,168
应该到它应该去 

529
00:30:00,004 --> 00:30:06,007
回到它可以追溯到 其它部分 

530
00:30:02,068 --> 00:30:08,095
你的代码 可能会或可能不会是一个 

531
00:30:06,007 --> 00:30:10,051
有效的地址或可能不会有什么 

532
00:30:08,095 --> 00:30:13,153
做你想要的程序 

533
00:30:10,051 --> 00:30:17,067
跑那么这个例子显示了它，如果我 

534
00:30:14,053 --> 00:30:17,067
键入24 

535
00:30:21,002 --> 00:30:28,008
让我们来看看我得到它 像 之前运行 

536
00:30:26,001 --> 00:30:32,010
这一点，你知道这件事情依赖于 

537
00:30:28,026 --> 00:30:41,073
会发生什么代码是如何发生的，以获取 

538
00:30:32,019 --> 00:30:45,081
编译哦，是这么好了，其实你 

539
00:30:41,073 --> 00:30:47,115
看到这里我输入这个第一个字符串 

540
00:30:45,081 --> 00:30:51,105
其实24个字符长加 

541
00:30:48,015 --> 00:30:54,063
空指针所以，我们会看到为什么 

542
00:30:52,005 --> 00:30:56,088
没有它应该崩溃，因为我们 

543
00:30:54,063 --> 00:30:59,070
其实 在我写 的低位字节 

544
00:30:56,088 --> 00:31:01,164
返回地址在这里我们键入 

545
00:31:00,033 --> 00:31:03,096
这是25个字符，所以这是 

546
00:31:02,064 --> 00:31:06,078
一个我刚才给它真正 

547
00:31:03,096 --> 00:31:08,148
疲惫不堪返回 的两个字节 

548
00:31:06,078 --> 00:31:11,121
解决所以在这里，我们实际上做了溢出 

549
00:31:09,048 --> 00:31:15,129
缓冲，让我们试着 找出 

550
00:31:12,021 --> 00:31:23,025
为什么不存在损害程序 

551
00:31:16,029 --> 00:31:24,051
执行我看到一个问题，是的， 它可能 

552
00:31:23,025 --> 00:31:26,034
已经有多种其他的东西可以 

553
00:31:24,051 --> 00:31:28,113
有没有什么它击中

554
00:31:27,015 --> 00:31:30,072
分段错误 ，因为它 可能 

555
00:31:29,013 --> 00:31:32,052
到 了代码 的一些奇怪的一部分 ， 

556
00:31:30,072 --> 00:31:34,158
刚刚开始执行一些随机的东西 

557
00:31:32,052 --> 00:31:37,104
它刚刚得到自己变成 麻烦，但 

558
00:31:35,058 --> 00:31:39,099
这就是问题所在是它的不可预测的 

559
00:31:38,004 --> 00:31:42,020
究竟会 发生 什么 ，当你做 

560
00:31:39,099 --> 00:31:41,120
这个 

561
00:31:51,076 --> 00:31:55,147
所以这是的例子 是什么 

562
00:31:54,043 --> 00:31:58,129
当我实际发生的第一次 

563
00:31:56,047 --> 00:32:01,072
键入在有24个字符的字符串

564
00:31:59,029 --> 00:32:04,104
所以在最后这个空字节 

565
00:32:01,072 --> 00:32:08,089
实际损坏的返回地址

566
00:32:05,004 --> 00:32:13,057
所以它应该回到返回 

567
00:32:08,089 --> 00:32:17,101
这个地址400 6F6和相反，它会 

568
00:32:13,057 --> 00:32:19,093
返回到地址 400 600， 

569
00:32:18,001 --> 00:32:22,036
恰好是在其他一些怪异 

570
00:32:19,093 --> 00:32:25,147
功能的存在，它只是排序 

571
00:32:22,036 --> 00:32:29,053
在一些地方 降落 在这里，它的 

572
00:32:26,047 --> 00:32:32,068
做各种事情 ，但不知何故， 

573
00:32:29,053 --> 00:32:33,061
没有真的没有程序崩溃

574
00:32:32,068 --> 00:32:36,073
这就是的 令人沮丧的事情 一个 

575
00:32:34,033 --> 00:32:40,105
这个是事情都可能出错 

576
00:32:37,018 --> 00:32:43,039
在程序 中 ，他们并不总是引起 

577
00:32:41,005 --> 00:32:45,034
崩溃，并且经常错误这是 

578
00:32:43,039 --> 00:32:50,131
工作有可能会做一些奇怪的 

579
00:32:45,034 --> 00:32:54,051
的东西，你甚至不 知道这么 

580
00:32:51,031 --> 00:32:58,033
这是所有的罚款，如果它只是一个方式 

581
00:32:54,051 --> 00:32:59,089
崩溃的程序，我的意思是这不是

582
00:32:58,033 --> 00:33:03,091
伟大的，如果它控制你的心脏起搏器 

583
00:32:59,089 --> 00:33:05,104
或类似 的 东西 ，但如果它只是 

584
00:33:03,091 --> 00:33:11,092
家庭作业就好像不是一个

585
00:33:06,004 --> 00:33:15,066
大不了所以 呵，但究竟和 

586
00:33:11,092 --> 00:33:18,160
这是那种只发生以来 

587
00:33:15,066 --> 00:33:22,090
进攻成为一种正常的活动，其 

588
00:33:19,006 --> 00:33:24,013
至今只有近30 年来 的是， 

589
00:33:22,009 --> 00:33:29,016
它提供了一个机会，让 黑客 或 

590
00:33:25,003 --> 00:33:32,011
一个攻击者将代码注入的

591
00:33:29,097 --> 00:33:35,146
程序并执行它，那是什么 

592
00:33:33,001 --> 00:33:39,028
所谓的代码注入攻击等 

593
00:33:36,046 --> 00:33:41,053
它的总体方案 是我 

594
00:33:39,037 --> 00:33:43,123
该缓冲区 ，我可以填补 

595
00:33:41,053 --> 00:33:45,145
无论字节我想他们喂养 

596
00:33:44,023 --> 00:33:49,042
获得S或任何功能，这样做 

597
00:33:46,045 --> 00:33:52,099
复制和我能做些什么，然后 设置 

598
00:33:49,042 --> 00:33:55,111
并传递给它 的实际一些字节 

599
00:33:52,099 --> 00:33:57,142
编码可执行一点点 

600
00:33:56,011 --> 00:34:00,085
可执行代码，你见过一个对象 

601
00:33:58,042 --> 00:34:02,128
转储它打印出这些 字节码 

602
00:34:00,085 --> 00:34:04,183
指令表示这样 

603
00:34:03,028 --> 00:34:09,121
想象一下，你说其中一些字节 

604
00:34:05,083 --> 00:34:13,108
为您的字符串你在编码它们

605
00:34:10,021 --> 00:34:18,045
您 传递字符串让我们再 

606
00:34:14,008 --> 00:34:21,034
您可能 需要添加 更多的 排序 

607
00:34:18,045 --> 00:34:23,059
填充字符的字符，其 

608
00:34:21,034 --> 00:34:27,093
值不会为了之至然后 

609
00:34:23,059 --> 00:34:28,153
得到一个数字回到位置 

610
00:34:27,399 --> 00:34:32,500
在返回指针应该 

611
00:34:29,053 --> 00:34:34,075
是还等什么的调用号 B很 

612
00:34:32,005 --> 00:34:37,164
将是一个地址，这些的人之一 

613
00:34:34,075 --> 00:34:40,156
与你知道代表 

614
00:34:37,659 --> 00:34:44,740
堆位置和值 B然后是 

615
00:34:41,056 --> 00:34:46,144
缓冲区的起始地址，其 

616
00:34:44,074 --> 00:34:48,151
恰好是在您的攻击代码 

617
00:34:47,044 --> 00:34:53,493
记住这仅仅是可执行文件 

618
00:34:49,051 --> 00:34:55,080
指令是如此，现在存放在这里

619
00:34:53,889 --> 00:35:02,380
会发生什么是程序 

620
00:34:55,008 --> 00:35:04,027
没有它的回报在这里它应该 

621
00:35:02,038 --> 00:35:07,277
回到返回无论它得到了所谓的 

622
00:35:04,099 --> 00:35:06,728
与P 

623
00:35:10,071 --> 00:35:23,073
这是 一个错字p拨打。q 没有到目前为止它的 

624
00:35:18,048 --> 00:35:25,074
本来要返回 P和 我们 

625
00:35:23,091 --> 00:35:25,152
和地址的返回地址是 

626
00:35:25,074 --> 00:35:27,156
存储在这里

627
00:35:26,052 --> 00:35:31,071
但现在我已经 被覆盖时返回 

628
00:35:28,056 --> 00:35:34,113
用该缓冲液位置，从而解决

629
00:35:31,071 --> 00:35:36,470
会发生什么是程序 

630
00:35:35,013 --> 00:35:39,066
计数器会很乐意跳转到这个地方 

631
00:35:37,109 --> 00:35:41,880
看看开始执行不管它

632
00:35:39,066 --> 00:35:44,088
遭遇它们是指令

633
00:35:41,088 --> 00:35:47,169
你已经插入并通过手段 

634
00:35:44,088 --> 00:35:50,142
那么你可以将代码注入机器

635
00:35:48,069 --> 00:35:52,143
潜在的地方了在 互联网 

636
00:35:51,042 --> 00:35:56,139
如果你能建立 这样 的方案 

637
00:35:53,043 --> 00:35:59,222
这将养活这些字节成 

638
00:35:57,039 --> 00:36:01,101
机 ，它会与阅读 

639
00:35:59,609 --> 00:36:04,050
功能一样让我们，然后它会 

640
00:36:02,001 --> 00:36:06,830
尝试做它的回报，但它会启动

641
00:36:04,005 --> 00:36:09,066
执行你的代码， 所以 这是 

642
00:36:06,839 --> 00:36:11,910
经典代码注入攻击和 

643
00:36:09,066 --> 00:36:14,070
事实上，在这个实验中，你会 

644
00:36:11,091 --> 00:36:16,188
它开始在 半夜 叫 出来 

645
00:36:14,007 --> 00:36:23,906
攻击实验，因为你要 

646
00:36:17,088 --> 00:36:25,089
该 实验室 的一部分，这样做你自己， 

647
00:36:24,599 --> 00:36:33,300
我想你会很找到它 

648
00:36:25,098 --> 00:36:37,179
有趣所以这曾经是一个巨大的 

649
00:36:33,003 --> 00:36:42,062
上节目 又 那么当你的问题

650
00:36:38,079 --> 00:36:44,121
试图取代阅读我要确保 

651
00:36:42,359 --> 00:36:47,700
新提交的阅读将覆盖

652
00:36:45,021 --> 00:36:49,113
也正是这就是盖的一部分 

653
00:36:47,007 --> 00:36:50,082
被黑客 你 的网 必须做出 

654
00:36:50,013 --> 00:36:53,076
确保它在正确的 位置 

655
00:36:51,045 --> 00:36:56,091
但 它实际上是比较容易的一个 

656
00:36:53,076 --> 00:37:00,150
部分因为比如说我们知道你 

657
00:36:56,091 --> 00:37:03,770
必须知道的二进制代码， 能够 

658
00:37:01,005 --> 00:37:05,088
要做到这一点还是能 猜到这样的 

659
00:37:04,589 --> 00:37:08,580
例如，在以前的一个 我可以 

660
00:37:06,033 --> 00:37:11,040
告诉它被分配24个字节 

661
00:37:08,058 --> 00:37:12,827
该缓冲区，因此，如果我只是确信 

662
00:37:11,004 --> 00:37:17,007
我的长度攻击代码加

663
00:37:13,349 --> 00:37:18,990
填充为24个字节，然后右后 

664
00:37:17,043 --> 00:37:20,064
这涉及到的返回地址，以便 

665
00:37:18,099 --> 00:37:20,107
这其实很 容易做到有 

666
00:37:20,064 --> 00:37:22,093
是 

667
00:37:21,007 --> 00:37:25,063
当然多少内存的 程序呃没有 

668
00:37:22,093 --> 00:37:30,166
您有权访问 你有 什么 

669
00:37:25,063 --> 00:37:32,125
为什么这个工作 的 原因 是它的工作原理，如果 

670
00:37:31,066 --> 00:37:34,105
您有 足够 的 知识 

671
00:37:33,025 --> 00:37:36,121
多数民众赞成在运行的操作系统 

672
00:37:35,005 --> 00:37:40,042
另一端，例如，你知道这是 

673
00:37:37,021 --> 00:37:43,090
Linux下，你知道，你可以看看 

674
00:37:40,042 --> 00:37:45,079
无论是什么GCC往往要分配给它 

675
00:37:43,009 --> 00:37:50,103
你会莫名其妙地获得 信息 

676
00:37:45,079 --> 00:37:51,084
有关代码本身可以让你做到 这一点 

677
00:37:55,084 --> 00:38:00,089
所以反正这里曾经是一个巨大的 

678
00:37:58,016 --> 00:38:04,019
问题并开始，早 在1988年 

679
00:38:00,089 --> 00:38:07,148
第一网络攻击被称为 

680
00:38:04,019 --> 00:38:11,024
Morris蠕虫病毒，它在当时 

681
00:38:08,048 --> 00:38:12,074
互联网是 不是一个非常 大的地方 ，它 

682
00:38:11,024 --> 00:38:15,032
基本上放倒了巨大的分数

683
00:38:12,074 --> 00:38:15,172
这是对 机器 

684
00:38:15,032 --> 00:38:20,036
互联网在当时 

685
00:38:16,072 --> 00:38:21,137
有趣的是CMU 不降 

686
00:38:20,072 --> 00:38:25,073
受害者受到这种攻击，因为我们会 

687
00:38:22,037 --> 00:38:32,042
修补已经是漏洞 

688
00:38:25,073 --> 00:38:33,137
这个特定的程序开发和 

689
00:38:32,042 --> 00:38:35,084
这是原因，该软件 

690
00:38:34,037 --> 00:38:37,121
工程学院的运行 

691
00:38:35,084 --> 00:38:40,100
组织称为证书的计算机 

692
00:38:38,021 --> 00:38:44,120
应急队伍和 团队 

693
00:38:41,000 --> 00:38:50,033
在 回应 设立这种攻击 

694
00:38:45,002 --> 00:38:52,058
Morris蠕虫病毒的攻击 也将看到一个 

695
00:38:50,033 --> 00:38:55,088
两者之间的有趣的例子 

696
00:38:52,076 --> 00:38:58,129
公司在信息服务和 

697
00:38:55,088 --> 00:39:01,127
许多人它已经的那种

698
00:38:59,029 --> 00:39:04,082
标准的攻击机制多年 

699
00:39:02,027 --> 00:39:07,055
幸运的是现在有几个 

700
00:39:04,082 --> 00:39:09,134
的事情，使较少的攻击

701
00:39:07,055 --> 00:39:12,056
可能是成功的，所以它不是 

702
00:39:10,034 --> 00:39:13,109
因为它曾经是一个巨大的问题，但 

703
00:39:12,056 --> 00:39:20,057
它仍然是许多的来源 

704
00:39:14,009 --> 00:39:22,085
在程序漏洞， 让我们看看 

705
00:39:20,066 --> 00:39:23,066
我不会过多谈论 这一点，但它 

706
00:39:22,085 --> 00:39:25,087
以前是

707
00:39:23,066 --> 00:39:28,157
在原 执行 

708
00:39:25,087 --> 00:39:30,164
还有，大多数系统都有一个命令 

709
00:39:29,057 --> 00:39:33,061
现在禁用，你可以用手指你 

710
00:39:31,064 --> 00:39:35,135
横跨有关信息能

711
00:39:33,061 --> 00:39:37,106
有人在一些偏远的 位置，它 

712
00:39:36,035 --> 00:39:41,132
将消息发送到该位置 

713
00:39:38,006 --> 00:39:44,075
然后它会在回信中，它使用 

714
00:39:42,032 --> 00:39:47,078
得到实际的原始 资产 

715
00:39:44,075 --> 00:39:50,084
实施名为get s 到 读 

716
00:39:47,078 --> 00:39:52,105
从输入字符串被发送到 

717
00:39:50,084 --> 00:39:52,105
它 

718
00:39:55,015 --> 00:40:00,019
然后有一个有趣的 你 

719
00:39:57,999 --> 00:40:04,032
男人不记得通讯即时 

720
00:40:00,019 --> 00:40:05,898
消息，但之前曾经是 

721
00:40:04,329 --> 00:40:09,160
人们 会 互相 交谈 他们的 

722
00:40:06,069 --> 00:40:12,090
通过发送某种 信息的计算机

723
00:40:09,016 --> 00:40:15,039
就像你今天发短信，但 

724
00:40:12,279 --> 00:40:19,331
还有一个有趣的事情， 

725
00:40:15,039 --> 00:40:22,248
还有的公司依然 存在，但 它是一个 

726
00:40:19,799 --> 00:40:24,855
它的前自已的阴影称为AOL 

727
00:40:22,599 --> 00:40:26,664
跑最流行的互联网 

728
00:40:25,359 --> 00:40:29,950
服务和有最流行

729
00:40:27,249 --> 00:40:32,920
即时通讯程序和Microsoft

730
00:40:29,095 --> 00:40:33,444
推出了它自己的客户自己的 

731
00:40:32,092 --> 00:40:36,171
你可以在运行程序的

732
00:40:34,299 --> 00:40:40,180
机 和交流给其他人 

733
00:40:36,999 --> 00:40:41,650
此消息系统上，因此将

734
00:40:40,018 --> 00:40:44,092
微软的源代码上正在运行的

735
00:40:41,065 --> 00:40:47,274
机器，但它会使用服务器 

736
00:40:44,092 --> 00:40:52,171
，正在通过 AOL 运行 管理 

737
00:40:47,859 --> 00:40:59,859
此消息流量和搞笑 

738
00:40:53,071 --> 00:41:02,370
故事结束了这个微软 

739
00:40:59,859 --> 00:41:05,170
程序会工作得很好 ，你可以 

740
00:41:03,009 --> 00:41:07,044
与您的朋友谁了 沟通 

741
00:41:05,017 --> 00:41:09,576
不同的消息客户端，这一切 

742
00:41:07,359 --> 00:41:10,452
似乎兼容，但随后突然 

743
00:41:09,729 --> 00:41:13,690
人们都 在 运行 Microsoft 

744
00:41:11,289 --> 00:41:15,940
该软件的版本， 它是行不通的 

745
00:41:13,069 --> 00:41:17,988
然后微软人想通了

746
00:41:15,094 --> 00:41:18,903
如何修补它，然后它会工作 

747
00:41:18,609 --> 00:41:21,675
一会儿 ，然后它不会工作 

748
00:41:19,749 --> 00:41:25,450
和发生了什么事的方式是一个 Ø/升 

749
00:41:22,269 --> 00:41:29,271
使用中的错误在自己的代码是 

750
00:41:25,045 --> 00:41:32,874
能够确定谁是基本上偷看 

751
00:41:29,469 --> 00:41:36,555
为在客户端的机器 

752
00:41:33,279 --> 00:41:38,355
并做了缓冲区溢出攻击 你的 

753
00:41:37,329 --> 00:41:41,343
代码是 你运行你的 

754
00:41:39,039 --> 00:41:44,680
机器，然后基本上围绕偷看 

755
00:41:41,469 --> 00:41:45,477
看看， 这看起来像AOL编码器 

756
00:41:44,068 --> 00:41:48,115
它的东西， 或者是一些国外 

757
00:41:46,269 --> 00:41:53,295
码等， 基本上能够使用其 

758
00:41:49,015 --> 00:41:57,624
自身的安全漏洞，找出这个

759
00:41:53,529 --> 00:42:03,537
信息 和得到了由公开 

760
00:41:57,759 --> 00:42:07,930
排序从 别人滑稽的消息是谁 

761
00:42:04,329 --> 00:42:08,382
称自己充满buckin，这是 

762
00:42:07,093 --> 00:42:10,117
确定 

763
00:42:08,859 --> 00:42:17,470
该邮件来自某处 

764
00:42:11,017 --> 00:42:18,876
在微软内部，从而反正是，和 

765
00:42:17,047 --> 00:42:21,088
你可以阅读 更多关于 它的书 

766
00:42:19,029 --> 00:42:23,710
绕滑动如此有趣的故事所以在 

767
00:42:21,088 --> 00:42:24,717
一般在安全 的世界你 

768
00:42:23,071 --> 00:42:26,116
本来的想法来区分

769
00:42:25,509 --> 00:42:28,509
蠕虫和病毒，虽然人 

770
00:42:27,016 --> 00:42:31,021
是不是 在这样做 非常好 

771
00:42:28,509 --> 00:42:33,561
这样的蠕虫是可以在运行程序的 

772
00:42:31,066 --> 00:42:36,094
拥有并从一个地方传播自身 

773
00:42:34,029 --> 00:42:39,910
其他复制的病毒样 

774
00:42:36,094 --> 00:42:41,763
生物病毒 并不住在 

775
00:42:39,091 --> 00:42:44,010
其自身的工作原理，攻击 程序 

776
00:42:42,609 --> 00:42:53,440
基本上修改 程序 

777
00:42:44,829 --> 00:42:55,450
行为，以便能够看到的基本概念 

778
00:42:53,044 --> 00:42:57,363
的缓冲区溢出，你会看到它 

779
00:42:55,045 --> 00:43:01,104
更多的第一手资料 ，以便让我们来看看 

780
00:42:57,759 --> 00:43:03,765
该机器可以使用技巧

781
00:43:01,509 --> 00:43:06,540
避免让自己不那么脆弱 

782
00:43:03,819 --> 00:43:09,822
这些攻击 以及首先你 

783
00:43:06,819 --> 00:43:11,892
该应用程序或 在作家 

784
00:43:10,119 --> 00:43:16,150
服务器端可以编写代码，更 

785
00:43:12,549 --> 00:43:18,594
确保因此，例如，你在做什么 

786
00:43:16,015 --> 00:43:21,624
应该做的， 而不是让 驴作为使用 

787
00:43:18,999 --> 00:43:25,002
一个称F功能让我们 一个 F GETTA 

788
00:43:21,759 --> 00:43:27,880
拥有它 传递一个 属性 

789
00:43:25,029 --> 00:43:31,056
参数，其是的最大 数量 

790
00:43:27,088 --> 00:43:34,197
字节程序应该读和 

791
00:43:31,299 --> 00:43:38,325
它还有比这在更多的字节

792
00:43:34,989 --> 00:43:41,680
输入它只会截断输入，所以 

793
00:43:38,559 --> 00:43:44,637
对你真的应该使用 F取得 

794
00:43:41,068 --> 00:43:46,123
我们，给一个限制同样stur副本 

795
00:43:45,339 --> 00:43:49,434
有一种叫船尾版本

796
00:43:47,023 --> 00:43:53,047
副本，你可以给一个极限值，并与 

797
00:43:50,289 --> 00:43:55,338
一个scanf函数你应该要小心 

798
00:43:53,047 --> 00:43:57,091
有关使用百分比S和有 

799
00:43:55,779 --> 00:44:02,170
甚至一个术语，你可以说 百分之 

800
00:43:57,091 --> 00:44:02,173
给一个数字的最大长度 

801
00:44:02,017 --> 00:44:05,071
它应该阅读等等这些字符串

802
00:44:03,073 --> 00:44:08,582
不同的地方，你可以保护你的代码 

803
00:44:05,071 --> 00:44:12,088
以 确保它不会溢出缓冲区 

804
00:44:09,239 --> 00:44:16,390
不幸的是，很多代码已经 

805
00:44:12,088 --> 00:44:17,757
你把它硬化它已经人

806
00:44:16,039 --> 00:44:20,047
已经 通过它 走了 ，这是一个很大的 

807
00:44:18,549 --> 00:44:22,210
工作，因为有一个 在很多地方 

808
00:44:20,047 --> 00:44:22,088
计划在那里你复制串 

809
00:44:22,021 --> 00:44:24,640
从一个点 

810
00:44:22,088 --> 00:44:25,142
另一个有很多真正的 

811
00:44:24,829 --> 00:44:30,907
细微之处，当你像转换

812
00:44:26,042 --> 00:44:32,099
从Unicode到字节等 那 

813
00:44:31,609 --> 00:44:36,140
你来回之间 

814
00:44:32,099 --> 00:44:37,678
不同的字符编码但 

815
00:44:36,014 --> 00:44:40,693
在很大程度上和 这些工具 的 

816
00:44:38,569 --> 00:44:43,576
代码开发者已经创建了帮助 

817
00:44:40,819 --> 00:44:45,874
追踪这些bug，所以它成为了 

818
00:44:44,269 --> 00:44:48,890
点点的安全在那里，但有 

819
00:44:46,369 --> 00:44:51,500
仍然漏洞所以后来有

820
00:44:48,089 --> 00:44:53,141
其他地方，你只尝试建立 

821
00:44:51,005 --> 00:44:56,314
在保障进入系统，将

822
00:44:54,041 --> 00:44:58,124
使它更难做一个缓冲 

823
00:44:56,809 --> 00:45:01,910
溢出攻击像我向您 和 

824
00:44:59,024 --> 00:45:04,363
所以他们中的一个被 称为栈 

825
00:45:01,091 --> 00:45:11,092
随机或它的推移更 

826
00:45:04,579 --> 00:45:18,230
多数民众赞成简称ASLR总称

827
00:45:11,092 --> 00:45:19,144
它代表的地址空间布局 

828
00:45:18,023 --> 00:45:20,044
随机

829
00:45:24,004 --> 00:45:31,017
那 就是这个想法让它所以每 

830
00:45:27,049 --> 00:45:35,107
时间程序运行地址 变更 

831
00:45:31,017 --> 00:45:38,050
一点点还是很多，所以你不能 

832
00:45:36,007 --> 00:45:41,008
可靠地知道事情会 

833
00:45:38,005 --> 00:45:43,014
在 代码 这样想象例如 

834
00:45:41,008 --> 00:45:47,062
它的实施和方式是 

835
00:45:44,004 --> 00:45:49,096
之前在排序的运行你的 

836
00:45:47,062 --> 00:45:53,077
程序时， 它首先启动，但 

837
00:45:50,032 --> 00:45:56,038
在你的主程序被调用时， 

838
00:45:53,077 --> 00:45:57,139
只会做的堆栈分配 

839
00:45:56,038 --> 00:46:00,120
字节 和存储 的一些随机数 

840
00:45:58,039 --> 00:46:03,094
相当数量的像，也许一兆字节 

841
00:46:01,002 --> 00:46:06,085
的大致存储，其确切的

842
00:46:03,094 --> 00:46:09,121
号码是随机选择和什么 

843
00:46:07,003 --> 00:46:13,006
手段是，堆叠的着装 

844
00:46:10,021 --> 00:46:16,090
所有不同 位置的你 

845
00:46:13,033 --> 00:46:19,045
耳朵所有堆栈上 的本地 存储 

846
00:46:16,009 --> 00:46:23,043
从一个运行转向向上和向下 

847
00:46:19,045 --> 00:46:27,144
另外，我们可以清楚地看到，在 

848
00:46:24,024 --> 00:46:28,026
这个例子我展示 

849
00:46:32,839 --> 00:46:39,540
所以我有一个程序， 在这里 它不是 一个非常 

850
00:46:36,042 --> 00:46:42,089
有趣的节目，我会告诉你，除了 

851
00:46:39,054 --> 00:46:42,089
证明这些想法 

852
00:46:44,849 --> 00:46:51,160
所有它做的是有一些代码，它的

853
00:46:48,609 --> 00:46:52,704
基于这样一个我已经表现出码 

854
00:46:51,016 --> 00:46:57,100
找到，但这个有一个全球 

855
00:46:53,559 --> 00:47:00,160
变量 有一些功能 有 

856
00:46:58,000 --> 00:47:03,369
这被通过的malloc分配的东西

857
00:47:00,016 --> 00:47:05,098
这里面的东西， 是一个本地 

858
00:47:03,369 --> 00:47:08,170
变量保存在栈 还 等什么 的 

859
00:47:05,098 --> 00:47:10,150
我会做的是，在展会地址 

860
00:47:08,017 --> 00:47:14,053
选择这个变量的地址，然后 

861
00:47:11,005 --> 00:47:17,094
将是一个堆栈地址的本地的 

862
00:47:14,053 --> 00:47:19,842
局部变量全球将是这一个 

863
00:47:17,589 --> 00:47:23,020
这被全球分配的堆 

864
00:47:20,319 --> 00:47:26,440
一些使用malloc，然后分配

865
00:47:23,002 --> 00:47:31,098
在这个函数无用将算作 

866
00:47:26,044 --> 00:47:31,098
代码的地址，现在当我运行 

867
00:47:33,569 --> 00:47:38,500
你会看到从一个运行到另一 

868
00:47:36,049 --> 00:47:40,120
如果其中的一些保持不变，一些 

869
00:47:38,005 --> 00:47:45,084
其中尤其 是 如此改变 

870
00:47:41,002 --> 00:47:52,611
全局变量是相同的600 102℃ 

871
00:47:45,579 --> 00:47:56,650
和代码是用于双O 5相同的

872
00:47:52,809 --> 00:47:59,530
900是每一个 执行 相同的 ，但 

873
00:47:56,065 --> 00:48:02,079
你会看到这个局部变量是在 

874
00:47:59,053 --> 00:48:04,129
堆栈地址，但你看到更低 

875
00:48:02,079 --> 00:48:08,628
半打左右的自行车实际上是

876
00:48:05,029 --> 00:48:16,117
从一个运行转换到另一种1 2 3 4 

877
00:48:09,339 --> 00:48:21,010
5，以5个字节， 但5个十六进制数字我 

878
00:48:17,017 --> 00:48:23,038
抱歉，所以这是2到20大致如此

879
00:48:21,001 --> 00:48:26,023
变化一兆字节是 怎么回事 

880
00:48:23,038 --> 00:48:28,042
堆栈地址有， 同样 

881
00:48:26,023 --> 00:48:32,023
你会看到堆地址 

882
00:48:28,078 --> 00:48:33,142
还从一个 从改变到另一个 

883
00:48:32,023 --> 00:48:36,088
一个执行到另一个这样的malloc具有 

884
00:48:34,042 --> 00:48:40,045
内置到它 的随机性 一定量 

885
00:48:36,088 --> 00:48:43,167
在其分配等什么 ，为什么SETEC 

886
00:48:40,072 --> 00:48:47,079
你知道那是什么 井 的目的 

887
00:48:44,067 --> 00:48:52,236
我告诉你，这个代码注入 

888
00:48:47,079 --> 00:48:54,172
脆弱性依赖于一个事实， 即 

889
00:48:52,839 --> 00:48:57,380
您可以您可以加载了这个缓冲带 

890
00:48:55,072 --> 00:49:00,155
一些可执行代码

891
00:48:57,038 --> 00:49:04,073
但不知为何，你必须 知道如何获得 

892
00:49:01,055 --> 00:49:07,058
该代码的 开始 ，这是 

893
00:49:04,073 --> 00:49:08,150
依托攻击是依靠 

894
00:49:07,058 --> 00:49:14,114
事实上，它可以以某种方式预测什么 

895
00:49:09,005 --> 00:49:16,034
缓冲区的这个地址等

896
00:49:15,014 --> 00:49:19,031
它可以将其存储在右部 

897
00:49:16,079 --> 00:49:20,081
字符串的把它放在编码 

898
00:49:19,031 --> 00:49:22,034
字符串的右边部分， 因此会显示 

899
00:49:20,081 --> 00:49:24,164
了在返回指针应该

900
00:49:22,034 --> 00:49:27,131
是和并 使其 跃升到 

901
00:49:25,064 --> 00:49:32,090
的位置，但现在有了这个随机 

902
00:49:28,031 --> 00:49:35,114
这个数字是相当多的不同

903
00:49:32,009 --> 00:49:37,061
排序万元以上的范围的

904
00:49:36,014 --> 00:49:40,097
万个左右的值，所以没有办法 

905
00:49:38,042 --> 00:49:42,050
提前即使我有完全相同的副本 

906
00:49:40,097 --> 00:49:46,133
代码 甚至没有给接入 

907
00:49:43,022 --> 00:49:48,107
系统本身可以运行它，我不能 

908
00:49:47,033 --> 00:49:51,122
从一个运行预测到下一个地方 

909
00:49:49,007 --> 00:49:55,085
它会是这样，给 它排序 

910
00:49:52,022 --> 00:50:01,039
堡这个特殊 的攻击，以 

911
00:49:55,085 --> 00:50:00,139
使用这张随机它

912
00:50:02,077 --> 00:50:08,093
另一个想法相当简单 

913
00:50:07,004 --> 00:50:14,051
但它花了很长时间 的硬件 

914
00:50:08,093 --> 00:50:15,116
人们去实现，这是很好为什么为什么 

915
00:50:14,051 --> 00:50:17,129
在那里应该是代码的 

916
00:50:16,016 --> 00:50:20,042
堆叠在第一位置是不是 代码 

917
00:50:18,029 --> 00:50:23,078
应该是位于倒在文本 

918
00:50:20,042 --> 00:50:26,051
细分市场，它可以被起诉尤其 

919
00:50:23,078 --> 00:50:30,140
确定为可执行所以在

920
00:50:27,032 --> 00:50:34,073
原来的x86有一个为一个一位标志， 

921
00:50:31,004 --> 00:50:38,045
内存 句话 的每一个区域是它 

922
00:50:34,073 --> 00:50:41,147
其实-一个位标志 之一是可以这样 

923
00:50:38,081 --> 00:50:43,154
写入，这样就可以防止 

924
00:50:42,047 --> 00:50:48,110
覆盖所以像串 

925
00:50:44,054 --> 00:50:51,128
常数等，然后将 另 一种是 

926
00:50:49,001 --> 00:50:54,044
我是我可以阅读和阅读方式访问 

927
00:50:52,028 --> 00:50:56,045
这些 字节，它被解释为 

928
00:50:54,053 --> 00:50:59,096
可读和可执行是相同

929
00:50:56,045 --> 00:51:04,052
事我可以读它， 我可以执行它， 

930
00:50:59,096 --> 00:51:06,101
那是在一个排序的最后10规则 

931
00:51:04,052 --> 00:51:09,146
年左右 ，与AMD 和 启动第一 

932
00:51:07,046 --> 00:51:12,119
那么英特尔已经增加了第三位的是 

933
00:51:10,046 --> 00:51:14,144
说的是这不是可执行类似 

934
00:51:13,019 --> 00:51:17,096
在权限你有一个文件 

935
00:51:15,044 --> 00:51:19,130
UNIX是它可写可读可执行 

936
00:51:17,096 --> 00:51:23,102
这些三个单独的许可位

937
00:51:20,003 --> 00:51:27,050
是单独所以通过简单的标记的 

938
00:51:24,056 --> 00:51:29,081
堆栈是不是可执行程序，它还会端口 

939
00:51:27,077 --> 00:51:31,088
这种特殊的攻击，因为我有 

940
00:51:29,081 --> 00:51:34,129
可以，因为我已经执行这些字节 

941
00:51:31,088 --> 00:51:34,129
注入系统 

942
00:51:36,059 --> 00:51:41,147
再有就是最终的想法是 

943
00:51:39,065 --> 00:51:44,102
实际上是相当有效的 -他们 

944
00:51:42,047 --> 00:51:45,125
叫他们建成了一个金丝雀

945
00:51:45,002 --> 00:51:47,096
栈和你们中的一些实际

946
00:51:46,025 --> 00:51:49,061
已经遇到了这个代码 和 

947
00:51:47,096 --> 00:51:52,124
看着你的炸弹，因为我们已经 

948
00:51:49,061 --> 00:51:56,095
得到 关于它 的一些问题， 所以让 

949
00:51:53,024 --> 00:51:56,095
我只是给你 在这里 的 例子 

950
00:52:04,076 --> 00:52:09,078
而这一次的所谓的buff演示- SP 

951
00:52:07,089 --> 00:52:16,188
因为它被编译什么 

952
00:52:09,096 --> 00:52:19,155
他们调用堆栈保护这一个 

953
00:52:17,088 --> 00:52:21,125
现在是相同的代码之前，它是 

954
00:52:20,055 --> 00:52:24,099
刚刚编译略有不同 

955
00:52:22,025 --> 00:52:28,104
你会 发现，我可以给一个字符串 

956
00:52:24,099 --> 00:52:34,173
长度为8，而不是有一个问题，但 

957
00:52:29,004 --> 00:52:37,098
如果我现在有9个字符将倾倒 

958
00:52:35,073 --> 00:52:45,074
出这个很奇怪退出错误 

959
00:52:37,098 --> 00:52:48,105
消息，是它的指示

960
00:52:45,074 --> 00:52:50,139
检测到的尝试破坏堆栈所以 

961
00:52:49,068 --> 00:52:54,093
缓冲区溢出有时也被称为 

962
00:52:51,039 --> 00:52:57,051
栈砸所以它以某种方式检测到

963
00:52:54,093 --> 00:53:00,099
即使我在我的代码仍然是 

964
00:52:57,051 --> 00:53:02,109
从一个前老蹩脚的代码 

965
00:53:00,099 --> 00:53:05,157
很小的缓冲区分配和无

966
00:53:03,009 --> 00:53:11,013
保护莫名其妙的系统 

967
00:53:06,057 --> 00:53:13,098
从我自己的保护我，这是一个 

968
00:53:11,013 --> 00:53:18,084
通过相对简单的窍门对于 

969
00:53:13,098 --> 00:53:21,192
相当聪明的，虽然他们称之为一步 

970
00:53:18,084 --> 00:53:25,086
金丝雀，这样的术语来金丝雀 

971
00:53:22,092 --> 00:53:28,179
从煤炭开采天背背

972
00:53:26,004 --> 00:53:31,089
老之前， 他们有很好的途径 

973
00:53:29,079 --> 00:53:34,083
测量的东西，他们采取 了下来鸟 

974
00:53:31,089 --> 00:53:37,163
与他们关在笼子里和金丝雀是一种 

975
00:53:34,083 --> 00:53:42,138
属性，它是非常容易

976
00:53:38,063 --> 00:53:45,069
如果死亡没有什么，如果有 

977
00:53:43,038 --> 00:53:47,061
本甲烷气体所以，这些矿工 

978
00:53:46,023 --> 00:53:50,097
是那里 工作， 他们会 

979
00:53:47,061 --> 00:53:52,148
看到自己的鸟龙骨过来，说哦，我们 

980
00:53:50,097 --> 00:53:54,195
有一个问题在这里得到什么了 这么 快 

981
00:53:53,048 --> 00:53:57,072
这就是为什么他们称之为的金丝雀 

982
00:53:55,095 --> 00:53:58,176
煤矿有时某种警告 

983
00:53:57,072 --> 00:54:03,150
发出信号的东西不是不 

984
00:53:59,076 --> 00:54:07,101
这里和一般我们看到了GCC 

985
00:54:04,005 --> 00:54:11,031
如果你有一个堆栈保护调用它

986
00:54:08,001 --> 00:54:13,045
时下是默认 所以即使 

987
00:54:11,076 --> 00:54:18,094
没有你说什么 

988
00:54:13,045 --> 00:54:20,107
这个代码将获得内置到它，所以 

989
00:54:18,094 --> 00:54:21,753
让我们来看看这是什么金丝雀代码 

990
00:54:21,007 --> 00:54:24,013
貌似和 它是 如何 做的事情 

991
00:54:22,599 --> 00:54:26,622
这是 因为我说的真的很漂亮聪明 

992
00:54:24,067 --> 00:54:30,090
你们当中有些人已经观察到了这种 

993
00:54:26,829 --> 00:54:33,460
怪样的内存引用

994
00:54:30,009 --> 00:54:35,014
注册代码和参考 

995
00:54:33,046 --> 00:54:37,093
BOM的实验室，因为 它与编译 

996
00:54:35,095 --> 00:54:40,096
这种限制对甲板启用，因为 

997
00:54:37,093 --> 00:54:44,101
这是默认的 ，因此特别 

998
00:54:40,096 --> 00:54:48,142
这 是什么 代码显示了它是 作为分配 

999
00:54:45,073 --> 00:54:51,100
之前在堆栈上的24个字节，但现在

1000
00:54:49,042 --> 00:54:54,097
它得到一些号码，我们将讨论 

1001
00:54:52,000 --> 00:55:00,046
在第二个是什么意思和存储 

1002
00:54:54,097 --> 00:55:01,956
它在位置8处从堆栈 偏移 

1003
00:55:00,046 --> 00:55:05,065
指针，然后 将代码 的其余部分 

1004
00:55:02,829 --> 00:55:08,740
然后归零出来，这 并不是 

1005
00:55:05,065 --> 00:55:10,102
担心然后它看起来像你的 

1006
00:55:08,074 --> 00:55:12,933
上面的代码，它的传递

1007
00:55:11,002 --> 00:55:18,351
指针堆栈的 顶部 

1008
00:55:13,599 --> 00:55:20,625
堆栈的说法让我们，让 

1009
00:55:18,369 --> 00:55:23,380
我们它被调用，然后把就会越来越 

1010
00:55:20,859 --> 00:55:26,890
所谓的，但现在有一些更多的代码 

1011
00:55:23,038 --> 00:55:29,007
这里是它涉及到 这 

1012
00:55:26,089 --> 00:55:30,103
奇怪的注册，然后

1013
00:55:29,349 --> 00:55:37,374
有一些类型的测试，然后如果 

1014
00:55:31,003 --> 00:55:40,015
该测试失败，将调用此代码 

1015
00:55:37,599 --> 00:55:44,200
你 刚才看到打印出来这个错误 

1016
00:55:40,015 --> 00:55:49,224
消息让我们看看这 一切手段 

1017
00:55:44,002 --> 00:55:52,006
这是什么意思是，它从偏移8 

1018
00:55:49,359 --> 00:55:56,800
它投入8堆栈指针 

1019
00:55:52,024 --> 00:56:01,105
的价值，它的检索 从 字节 

1020
00:55:56,008 --> 00:56:04,012
专用寄存器所以FS是一个参考 

1021
00:56:02,005 --> 00:56:08,014
到已创建的类型寄存器的 

1022
00:56:05,002 --> 00:56:10,003
对于最初的8086和现在 

1023
00:56:08,014 --> 00:56:12,097
完全过时，但它仍然存在

1024
00:56:10,021 --> 00:56:15,055
为了向后 兼容模式 ，但什么 

1025
00:56:12,097 --> 00:56:16,476
它是，我实际上我 看着和 

1026
00:56:15,055 --> 00:56:19,120
我从来没有完全能够找到 

1027
00:56:17,349 --> 00:56:22,810
它的文档是能够读取 

1028
00:56:20,002 --> 00:56:27,057
从存储器的 设置值的 一部分 

1029
00:56:22,081 --> 00:56:31,099
你 不能以其他方式得到 

1030
00:56:27,075 --> 00:56:34,081
所以高棉 金丝雀越来越 

1031
00:56:31,099 --> 00:56:36,178
一个莫名其妙的抓八个字节 

1032
00:56:34,081 --> 00:56:41,158
地方把它作为这个金丝雀

1033
00:56:37,078 --> 00:56:45,127
值，然后如果你给像七 

1034
00:56:42,058 --> 00:56:48,058
字符输入，所以你会影响到 

1035
00:56:46,027 --> 00:56:54,094
金丝雀等会发生什么时 

1036
00:56:48,058 --> 00:56:57,085
从两个调用返回的让我们 

1037
00:56:54,094 --> 00:57:01,099
并把我们退出就是它的前

1038
00:56:57,085 --> 00:57:04,122
尝试检测是有什么，因为这 

1039
00:57:01,099 --> 00:57:07,102
缓冲区溢出莫名其妙和 

1040
00:57:05,022 --> 00:57:09,120
在潜在的腐败风险

1041
00:57:08,029 --> 00:57:12,070
堆栈的一些其他部件以便 

1042
00:57:10,002 --> 00:57:17,023
基本上它是它检索 

1043
00:57:12,007 --> 00:57:19,069
从堆栈后面什么是当前 

1044
00:57:17,041 --> 00:57:23,095
该金丝雀 的价值和它的比较 

1045
00:57:20,032 --> 00:57:25,129
它应该是 通过检索什么

1046
00:57:23,095 --> 00:57:29,137
从这个 特殊的区域是背部和 

1047
00:57:26,029 --> 00:57:32,035
如果他们是平等的 ，它说正常，但如果 

1048
00:57:30,037 --> 00:57:33,112
他们不是等于它的检测 

1049
00:57:32,035 --> 00:57:34,120
它被 损坏 所以就像 

1050
00:57:34,012 --> 00:57:37,105
金丝雀在 煤矿 

1051
00:57:35,002 --> 00:57:40,006
如果这些字节被损坏，以任何形式 

1052
00:57:38,005 --> 00:57:45,082
这是一个迹象表明，出事 

1053
00:57:40,024 --> 00:57:48,112
错了，现在例子表明，如果我 

1054
00:57:45,082 --> 00:57:51,178
有七个字符串那么我 

1055
00:57:49,012 --> 00:57:54,040
不会破坏金丝雀但 你 

1056
00:57:52,078 --> 00:58:00,169
请注意我 只是一个八逃走了 

1057
00:57:54,004 --> 00:58:04,008
字符串，所以让我只看到 

1058
00:58:01,069 --> 00:58:04,080
什么是怎么回事 

1059
00:58:30,002 --> 00:58:38,023
我赢得了一个 字符串的权利哦，请 

1060
00:58:35,075 --> 00:58:37,123
最近

1061
00:58:42,092 --> 00:58:47,971
所以我要看看我没有代码 

1062
00:58:45,479 --> 00:58:48,511
在我面前让我不得不看 

1063
00:58:52,099 --> 00:59:00,196
所以反正这里的地方它的减 

1064
00:58:57,759 --> 00:59:02,854
24 从 堆栈指针 ，然后将 

1065
00:59:01,069 --> 00:59:05,930
下一条指令检索 该 

1066
00:59:03,709 --> 00:59:09,880
金丝雀值， 所以让我们弄清楚什么 

1067
00:59:05,093 --> 00:59:08,188
金丝雀是正确的，现在我们正处于

1068
00:59:16,109 --> 00:59:29,156
72F所以我们在第一条指令

1069
00:59:19,003 --> 00:59:29,552
在这里让我们做另一步 

1070
00:59:39,031 --> 00:59:47,063
所以这是一只金丝雀，还有 它，你会看到 

1071
00:59:45,349 --> 00:59:49,700
实际上，当100人获得

1072
00:59:47,063 --> 00:59:50,072
它不同的值 ，因此这是 完全 

1073
00:59:49,007 --> 00:59:53,015
摆在那里的方式， 它是 

1074
00:59:51,053 --> 00:59:55,115
不可预测 的一件事，你会 

1075
00:59:54,005 --> 01:00:00,044
通知是低位字节 

1076
00:59:56,015 --> 01:00:02,944
零所以 他们显然知道 

1077
01:00:00,089 --> 01:00:04,018
它是如此常见的有这么 断接一个 

1078
01:00:03,079 --> 01:00:07,190
与字符串错误，你不

1079
01:00:04,819 --> 01:00:08,060
对于空分配足够的空间 

1080
01:00:07,019 --> 01:00:11,063
终结者 

1081
01:00:08,006 --> 01:00:13,052
他们说好，而不是一 

1082
01:00:11,063 --> 01:00:14,114
金丝雀， 将检测字节是 

1083
01:00:13,052 --> 01:00:17,138
损坏我们就有点给 该 

1084
01:00:15,014 --> 01:00:21,098
字节 路程 ，所以这就是为什么它让 

1085
01:00:18,038 --> 01:00:24,487
我输入八个字符，它的 

1086
01:00:21,098 --> 01:00:27,101
压倒一切的这个低位字节 

1087
01:00:24,829 --> 01:00:29,907
金丝雀稍后但是这不会 

1088
01:00:28,001 --> 01:00:30,600
有 什么 影响 

1089
01:00:52,049 --> 01:00:58,388
但让我们给它9个字符10 

1090
01:00:56,022 --> 01:01:00,116
字符训练的9个字符 

1091
01:00:58,829 --> 01:01:01,160
串

1092
01:01:15,039 --> 01:01:17,039
哦

1093
01:01:48,088 --> 01:01:50,088
啊

1094
01:01:51,091 --> 01:02:03,950
哦，我没有找到它，我 

1095
01:01:59,005 --> 01:02:04,274
认为这将是 哦， 反正 这个意愿 

1096
01:02:06,075 --> 01:02:11,334
裁剪 此甲板，但我是你展示 

1097
01:02:10,059 --> 01:02:13,720
其主要 思想是金丝雀一定的 价值 

1098
01:02:12,009 --> 01:02:16,020
这被拔出，它会改变 

1099
01:02:13,072 --> 01:02:17,661
从一次到 下一个，它的 

1100
01:02:16,119 --> 01:02:20,890
让你脱身八 

1101
01:02:18,309 --> 01:02:22,990
字符加上空终止 ，但 

1102
01:02:20,089 --> 01:02:24,758
再说 了 ，它会检测 

1103
01:02:22,099 --> 01:02:24,668
腐败 

1104
01:02:38,002 --> 01:02:43,024
好吧，现在我们已经看到了三种不同 

1105
01:02:40,068 --> 01:02:47,122
保护好一个是写出更好 

1106
01:02:43,024 --> 01:02:49,096
代码，但有三个防即 

1107
01:02:48,022 --> 01:02:54,051
通过什么 都没有 系统完成

1108
01:02:49,096 --> 01:02:53,151
做你的代码正确的是 

1109
01:02:54,099 --> 01:02:59,104
随机堆积 位置所以它的 

1110
01:02:58,039 --> 01:03:02,092
很难 找出其中的开始 

1111
01:03:00,004 --> 01:03:05,038
地址是第二个是使 

1112
01:03:02,092 --> 01:03:07,138
栈，所以它不是可执行的，所以你 

1113
01:03:05,038 --> 01:03:09,127
不能把代码上，然后 

1114
01:03:08,038 --> 01:03:12,133
第三是使用本甲板金丝雀或

1115
01:03:10,027 --> 01:03:16,105
其他机制来检测潜在的 

1116
01:03:13,033 --> 01:03:18,106
在源所以现在缓冲区溢出 

1117
01:03:17,005 --> 01:03:23,088
还有，这是另一次攻击 

1118
01:03:19,006 --> 01:03:23,088
响应发展到其中的一些 

1119
01:03:24,036 --> 01:03:30,061
这仍然是经常成功的是 

1120
01:03:28,000 --> 01:03:32,011
所谓的回报arted编程和 

1121
01:03:30,061 --> 01:03:33,109
你的攻击实验中，您打算 做 

1122
01:03:32,011 --> 01:03:35,104
这些攻击过，这就是为什么解决 

1123
01:03:34,009 --> 01:03:39,013
AB比的旧的方式不同 

1124
01:03:36,004 --> 01:03:40,093
旧的Web justed代码注入漏洞 

1125
01:03:39,013 --> 01:03:44,104
现在你在 做两个代码 注入 

1126
01:03:40,093 --> 01:03:49,096
和返回导向编程使 

1127
01:03:45,004 --> 01:03:53,026
这个想法是，如果你是你是一个黑客

1128
01:03:50,023 --> 01:03:55,080
沮丧，因为这些这三个 

1129
01:03:53,026 --> 01:03:58,114
技术 堆栈随机 

1130
01:03:55,008 --> 01:04:00,019
非可执行堆栈和金丝雀我很好 

1131
01:03:59,014 --> 01:04:03,483
不能修复的金丝雀问题

1132
01:04:00,091 --> 01:04:04,179
实际上金丝雀是一个非常安全的 

1133
01:04:03,609 --> 01:04:08,634
的 

1134
01:04:05,079 --> 01:04:12,106
技术有很我从来没有见过

1135
01:04:08,859 --> 01:04:15,100
任何人都可以绕过 STET金丝雀 但 

1136
01:04:13,006 --> 01:04:18,058
另外两个，你可以用这个做 

1137
01:04:15,001 --> 01:04:21,070
技术和策略，所以我们 

1138
01:04:18,058 --> 01:04:24,085
不知道在哪里堆栈，但我们

1139
01:04:21,079 --> 01:04:26,107
仍然但是我们知道在哪里的代码

1140
01:04:24,085 --> 01:04:30,097
是因为你在例子中看到的 

1141
01:04:27,007 --> 01:04:32,104
代码我的布局随机化

1142
01:04:30,097 --> 01:04:34,156
移在堆栈位置

1143
01:04:33,004 --> 01:04:40,023
位置，但它并没有任何变化 

1144
01:04:35,056 --> 01:04:43,132
全局变量或或代码本身 

1145
01:04:40,023 --> 01:04:47,029
所以，如果我能找到什么一些代码，

1146
01:04:44,032 --> 01:04:49,104
的排序已经 存在 的现有 

1147
01:04:47,083 --> 01:04:53,124
该计划的一部分

1148
01:04:50,004 --> 01:04:57,051
并使用我自己的代码 ， 而不是 

1149
01:04:54,024 --> 01:04:59,046
我已经注入和一般课程 

1150
01:04:57,051 --> 01:05:00,135
你不会 找到确切地躺在 

1151
01:04:59,046 --> 01:05:03,138
还有你要在严格程序

1152
01:05:01,035 --> 01:05:07,038
执行 将导致什么危害 

1153
01:05:04,038 --> 01:05:09,075
你打算这样做，因为它不是

1154
01:05:07,038 --> 01:05:11,070
通常编译成最的方案，但 

1155
01:05:09,075 --> 01:05:17,094
如果我能梳理串在一起 

1156
01:05:11,007 --> 01:05:20,016
代码段少，不知怎么放 

1157
01:05:17,094 --> 01:05:23,100
在一起的一系列小序列的 

1158
01:05:21,006 --> 01:05:26,007
代码也许我可以得到一些有用的东西 

1159
01:05:24,000 --> 01:05:29,094
做，所以这是这个想法 

1160
01:05:26,007 --> 01:05:31,014
返回导向编程和想法 

1161
01:05:29,094 --> 01:05:34,101
它是寻找所谓的 

1162
01:05:32,004 --> 01:05:38,052
小工具和小 工具 是一个序列 

1163
01:05:35,064 --> 01:05:40,158
那些字节表示的部分 

1164
01:05:38,088 --> 01:05:44,187
可执行程序，其中最后一个字节 

1165
01:05:41,058 --> 01:05:48,120
这是86讲在这里有一个十六进制值

1166
01:05:45,087 --> 01:05:51,092
C3这是怎么RET 指令 

1167
01:05:49,002 --> 01:06:00,006
返回指令在编码的x86 

1168
01:05:52,037 --> 01:06:03,126
两个IA-32和x64等作为 例子 

1169
01:06:00,006 --> 01:06:08,025
在简单的情况是有一些 

1170
01:06:04,026 --> 01:06:10,119
功能，它实现 了一些 

1171
01:06:08,079 --> 01:06:12,162
我可能会发现作为一个有用的操作

1172
01:06:11,019 --> 01:06:16,104
攻击者能够 例如这样做 

1173
01:06:13,062 --> 01:06:19,083
该功能 计算倍乙 

1174
01:06:17,004 --> 01:06:22,059
加C，如果我看 刚刚过去的 

1175
01:06:19,083 --> 01:06:24,152
从那里 他们 中的 一个两个指令 

1176
01:06:22,059 --> 01:06:29,103
被一拉被执行相加与 

1177
01:06:25,052 --> 01:06:31,146
另一种是做一回这样我就可以 

1178
01:06:30,003 --> 01:06:37,011
想到这本好老五铺位 

1179
01:06:32,046 --> 01:06:40,089
字节块是一种方式，如果我能得到一些 

1180
01:06:37,011 --> 01:06:43,014
在寄存器R二和RDX然后数据I 

1181
01:06:40,089 --> 01:06:44,160
可以计算它们的总和，并坚持在

1182
01:06:43,041 --> 01:06:47,079
在RAS所以想象一下你的程序 

1183
01:06:45,006 --> 01:06:48,102
你想执行和打破它 

1184
01:06:47,079 --> 01:06:51,114
成这些 小片段 ，你 

1185
01:06:49,056 --> 01:06:53,091
要以某种方式找到的有点堵

1186
01:06:52,014 --> 01:06:56,037
码的地方来实现各 

1187
01:06:53,091 --> 01:06:57,189
这些片段，然后有趣 

1188
01:06:56,037 --> 01:07:03,039
部分是因为它们在的C 3各端 

1189
01:06:58,089 --> 01:07:02,182
这个回报率是很好，让 我去 

1190
01:07:03,057 --> 01:07:05,092
那

1191
01:07:03,082 --> 01:07:08,107
一分钟 ，这样的排序明显 

1192
01:07:05,092 --> 01:07:10,111
你拉出来 这种 方式 是 

1193
01:07:09,007 --> 01:07:14,023
此外， 你会期望，因为 这 

1194
01:07:11,011 --> 01:07:17,038
在原来的C代码，但这里是一个 

1195
01:07:14,023 --> 01:07:19,090
例如一个小工具， 有 什么可 

1196
01:07:17,038 --> 01:07:23,079
做与原来 的 C代码，它只是 

1197
01:07:19,009 --> 01:07:28,036
碰巧的咬模式 相匹配 

1198
01:07:23,079 --> 01:07:31,081
一些现有的代码，所以此功能 

1199
01:07:29,017 --> 01:07:36,070
似乎没有做任何事情太可怕 

1200
01:07:31,099 --> 01:07:37,153
从黑客有用的角度来看，但如果 

1201
01:07:36,007 --> 01:07:39,106
你看看这个特定字节 

1202
01:07:38,053 --> 01:07:44,068
序列发生编码 

1203
01:07:40,069 --> 01:07:48,070
指令移动Q为一个 X至R二和C 

1204
01:07:44,068 --> 01:07:52,159
3个编码repped所以，你可以看到，如果 

1205
01:07:48,007 --> 01:07:58,105
这是地址49这对 D中 的 

1206
01:07:53,059 --> 01:08:02,085
DB 直流所以解决 400如果DC 

1207
01:07:59,068 --> 01:08:05,077
你可以从这里开始执行，将

1208
01:08:02,085 --> 01:08:08,146
首先做一个举动， 然后 它会做 

1209
01:08:05,077 --> 01:08:11,101
返回所以我有点趁着 

1210
01:08:09,046 --> 01:08:15,117
在x86的事实，它说的 做 

1211
01:08:12,001 --> 01:08:20,050
是，如果我有点指令序列和

1212
01:08:16,017 --> 01:08:24,052
熄灭对齐的指令，我可以 

1213
01:08:20,005 --> 01:08:25,099
经常会发现有用的东西，这样做，这是 

1214
01:08:24,052 --> 01:08:27,151
什么叫做小工具，你可能会问 

1215
01:08:26,044 --> 01:08:29,098
还有什么特别之处让他们 

1216
01:08:28,051 --> 01:08:32,113
结束返回

1217
01:08:29,098 --> 01:08:35,104
想像我可以填补我的缓冲区 

1218
01:08:33,013 --> 01:08:38,017
而不是可执行代码我可以 

1219
01:08:36,058 --> 01:08:42,061
一系列小工具的填充它

1220
01:08:38,053 --> 01:08:44,101
地址，以便每个小工具则是一些 

1221
01:08:42,088 --> 01:08:51,153
一系列字节的，其中最终咬合是

1222
01:08:45,001 --> 01:08:55,075
C3和我实际上这个位置作为 

1223
01:08:52,053 --> 01:08:57,067
不是反对派在一些地方 

1224
01:08:55,075 --> 01:09:00,684
在那里你究竟要做到 

1225
01:08:57,067 --> 01:09:04,090
从最初的返回指令

1226
01:09:01,359 --> 01:09:09,310
之前， 所以如果 我能以某种方式获取 

1227
01:09:04,009 --> 01:09:11,071
程序返回执行休息权 

1228
01:09:09,031 --> 01:09:14,119
现在它要做的是回归将挑 

1229
01:09:12,052 --> 01:09:17,065
从堆栈 弹出一个的地址

1230
01:09:15,019 --> 01:09:19,024
地址并开始执行

1231
01:09:17,065 --> 01:09:21,067
因此，将启动该代码执行 

1232
01:09:19,069 --> 01:09:24,115
它会击中 C3的RET 

1233
01:09:21,085 --> 01:09:26,994
在结束指令其将再次 

1234
01:09:25,015 --> 01:09:30,058
取地址弹出它从堆栈和 

1235
01:09:27,759 --> 01:09:32,830
开始执行，从而开始执行 

1236
01:09:30,058 --> 01:09:34,081
第二小工具，所以你会看到什么 

1237
01:09:32,083 --> 01:09:36,160
将发生的情况 是，我们是有效的 

1238
01:09:34,081 --> 01:09:39,160
串联这些作品的代码 

1239
01:09:37,006 --> 01:09:42,052
如果加上它的使用RET得到 

1240
01:09:40,006 --> 01:09:44,044
从一个第一部分的小工具的端部到 

1241
01:09:43,006 --> 01:09:46,021
接下来的开始，因此这 

1242
01:09:44,098 --> 01:09:47,173
什么叫做面向回报 

1243
01:09:46,021 --> 01:09:50,670
编程等 ， 而不是 

1244
01:09:48,073 --> 01:09:52,392
使用程序测序计划

1245
01:09:50,859 --> 01:09:56,080
计数器就像你通常做 你的 

1246
01:09:53,049 --> 01:09:59,820
使用排序 的测序计划

1247
01:09:56,008 --> 01:10:04,042
这个特殊的x86的奇特行为

1248
01:09:59,082 --> 01:10:06,130
回报如何在程序中工作并 

1249
01:10:04,042 --> 01:10:09,048
记得有足够的x86那里 

1250
01:10:07,003 --> 01:10:14,031
如果我能找到一种方法来 攻击他们 

1251
01:10:09,048 --> 01:10:17,059
我很漂亮，我在一个漂亮的好地方 

1252
01:10:14,058 --> 01:10:18,139
它也可以攻击其他 

1253
01:10:17,059 --> 01:10:23,062
处理器这种方式 - 它只是

1254
01:10:19,039 --> 01:10:24,121
特别好的在x86所以这是

1255
01:10:23,062 --> 01:10:27,139
回报对编程思想和 

1256
01:10:25,021 --> 01:10:30,115
你会，你会做你自己，你会

1257
01:10:28,039 --> 01:10:35,080
找到小工具 把它们串起来做 

1258
01:10:31,015 --> 01:10:39,103
在攻击 灯不同的东西，但 

1259
01:10:35,008 --> 01:10:46,008
我要指出的是，这还不

1260
01:10:40,003 --> 01:10:50,010
所以，这堆金丝雀想法还是

1261
01:10:46,008 --> 01:10:52,015
成功检测到缓冲区溢出 

1262
01:10:50,001 --> 01:10:56,029
相当有效地使你的粘性实验室 

1263
01:10:53,005 --> 01:10:59,044
例如我们精心编制的 

1264
01:10:56,038 --> 01:11:03,357
代码， 使其 容易受到这些 

1265
01:10:59,089 --> 01:11:05,164
攻击否则这将是 一个很大 

1266
01:11:03,699 --> 01:11:09,726
更难的网络一样，如果你能 做到这一点，你 

1267
01:11:06,064 --> 01:11:17,103
很可能进入 黑暗的世界 

1268
01:11:09,969 --> 01:11:20,050
和和是非常成功的，但如此如此 

1269
01:11:17,679 --> 01:11:23,140
我们实际上有点暴露 

1270
01:11:20,005 --> 01:11:25,009
漏洞，但在第一部分 

1271
01:11:23,014 --> 01:11:27,052
该实验室的你使用代码注入 

1272
01:11:25,009 --> 01:11:30,102
攻击所以我们不得不禁用堆栈 

1273
01:11:27,052 --> 01:11:34,067
随机化，也使组X 

1274
01:11:31,002 --> 01:11:38,088
可切割，所以我们不得不进行排序 按钮的 

1275
01:11:34,067 --> 01:11:41,088
回报规划，我们认为重新启用 

1276
01:11:38,088 --> 01:11:44,181
从而使堆栈不可执行它 

1277
01:11:41,088 --> 01:11:46,155
不断随机 跳来跳去 了，但 

1278
01:11:45,081 --> 01:11:48,132
我们已经关闭了堆栈加那利群岛这样 

1279
01:11:47,055 --> 01:11:53,082
你就可以溢出缓冲区 

1280
01:11:49,032 --> 01:11:57,099
并把你的小工具地址， 

1281
01:11:53,082 --> 01:11:58,179
建立了这种方式 ，所以我觉得 一个文本 

1282
01:11:57,099 --> 01:12:00,156
您将通过实际 去做，你会 发现 

1283
01:11:59,079 --> 01:12:04,167
学习 比你可以通过只 多 了很多 

1284
01:12:01,056 --> 01:12:07,101
听到 这种 事情 ， 哦，你可能会问为什么 

1285
01:12:05,067 --> 01:12:08,148
我们教你这个东西的权利，如果我们 

1286
01:12:08,001 --> 01:12:12,027
应该教你是好事，而不是 

1287
01:12:09,048 --> 01:12:13,139
邪恶的以及有一对夫妇的原因之一 

1288
01:12:12,027 --> 01:12:18,036
是你会学到很多 

1289
01:12:14,039 --> 01:12:20,040
机程序的执行以及如何堆栈 

1290
01:12:18,036 --> 01:12:22,077
工作和如何字节指令

1291
01:12:20,049 --> 01:12:25,068
编码和类似的东西，你会使用 

1292
01:12:22,077 --> 01:12:27,099
该工具GB对象转储和所有那些 

1293
01:12:25,068 --> 01:12:30,090
甚至比你做了与炸弹 网页 

1294
01:12:27,099 --> 01:12:33,102
所以你会学到很多东西， 另一个 是我们 

1295
01:12:30,009 --> 01:12:36,108
假设你会为部队工作 

1296
01:12:34,002 --> 01:12:39,060
很好，但是是一个很好的人，你也 

1297
01:12:37,089 --> 01:12:44,100
知道什么 赌注必须知道什么 

1298
01:12:39,006 --> 01:12:50,085
坏人做它的一部分 是成为 

1299
01:12:45,000 --> 01:12:53,064
更有效的为善的力量好 

1300
01:12:51,039 --> 01:12:57,042
所以最后一件事说说今天 

1301
01:12:53,064 --> 01:12:59,151
是工会和有关观察

1302
01:12:57,069 --> 01:13:02,127
用C工会的声明，它 

1303
01:13:00,051 --> 01:13:04,113
看起来很像一个struct那里的 

1304
01:13:03,027 --> 01:13:06,102
这种 不同的领域，他们命名 

1305
01:13:05,013 --> 01:13:09,111
他们可以有不同的类型和 

1306
01:13:07,002 --> 01:13:12,069
可以有指向工会和所有

1307
01:13:10,011 --> 01:13:15,048
那东西，但 它们实际上是完全 

1308
01:13:12,069 --> 01:13:16,137
不同的他们你还记得 它 

1309
01:13:15,048 --> 01:13:19,101
结构，因为它埃拉·卡茨会发生什么

1310
01:13:17,037 --> 01:13:23,109
足够的内存为 所有领域 

1311
01:13:20,001 --> 01:13:29,007
共存并潜在地添加填充 

1312
01:13:24,009 --> 01:13:32,013
什么工会 所做的就是只有千 字节 

1313
01:13:29,061 --> 01:13:33,069
分配足够的存储空间最大 

1314
01:13:32,013 --> 01:13:35,085
领域它，它假设你 

1315
01:13:34,041 --> 01:13:38,043
只有将要使用的一个 

1316
01:13:35,085 --> 01:13:41,097
可能的领域，它会 从字面上 

1317
01:13:38,043 --> 01:13:44,076
在这些领域的顶级商店获取存储 

1318
01:13:41,097 --> 01:13:47,142
在彼此的顶部，这样 ，如果你 

1319
01:13:44,076 --> 01:13:48,535
尝试使用多个字段，你可以乱 

1320
01:13:48,042 --> 01:13:51,084
事情 

1321
01:13:49,219 --> 01:13:53,282
这不是做的这个目的 

1322
01:13:51,084 --> 01:13:55,613
多个值是为目的 

1323
01:13:53,849 --> 01:13:59,400
例如，如果我知道我只打算 

1324
01:13:56,369 --> 01:14:01,463
使用 其中的一个 或它的 另一个也是一个 

1325
01:13:59,004 --> 01:14:03,803
方法基本上创建一个别名 

1326
01:14:02,309 --> 01:14:09,210
会让你在引用内存 

1327
01:14:04,199 --> 01:14:13,980
不同的方式，使例如在您 

1328
01:14:09,021 --> 01:14:15,370
数据网络浏览器使用你 

1329
01:14:13,098 --> 01:14:16,337
操纵位水平

1330
01:14:15,559 --> 01:14:20,610
浮点交涉 

1331
01:14:17,219 --> 01:14:23,400
数字和我们的代码，然后将 

1332
01:14:20,061 --> 01:14:28,119
将其转换成我们使用 的实际浮动 

1333
01:14:23,004 --> 01:14:31,073
工会在 联盟要么 

1334
01:14:29,019 --> 01:14:36,050
查看的四个字节这个字段是一个 

1335
01:14:31,469 --> 01:14:36,500
无符号或是一个浮子，所以我可以 

1336
01:14:37,013 --> 01:14:42,812
从无符号转换成 其浮动 

1337
01:14:39,989 --> 01:14:46,031
通过仅存储表示

1338
01:14:42,929 --> 01:14:49,440
在这个联盟无符号值和 

1339
01:14:46,409 --> 01:14:51,260
检索它，就好像它是浮动和

1340
01:14:49,044 --> 01:14:53,079
这是一个根本不同

1341
01:14:51,026 --> 01:14:55,032
操作比铸造 ，因为你 

1342
01:14:53,079 --> 01:14:57,111
还记得当你把 一个无符号值 

1343
01:14:55,086 --> 01:14:59,345
你将它转换为一个浮动你实际上 

1344
01:14:58,011 --> 01:15:02,210
改位，改变成的 

1345
01:15:00,119 --> 01:15:07,170
浮点数是 最接近的 一个 

1346
01:15:02,309 --> 01:15:08,820
符合这一特定数量会 

1347
01:15:07,017 --> 01:15:10,100
是功能相当于你 

1348
01:15:08,082 --> 01:15:12,881
实行浮动下划线 你到F 

1349
01:15:11,000 --> 01:15:16,059
但是这一次实际上不会改变 

1350
01:15:13,619 --> 01:15:19,530
位，它只是改变 了数值 

1351
01:15:16,059 --> 01:15:21,102
改变颇有几分所以这是一个非常有用 

1352
01:15:19,053 --> 01:15:24,128
技术要 去做那些能够 

1353
01:15:22,002 --> 01:15:29,055
覆盖类型系统 ， 并获得 

1354
01:15:25,028 --> 01:15:31,050
表示 这实际上变成 

1355
01:15:29,055 --> 01:15:33,584
出是地方 的 地方 之一 

1356
01:15:31,005 --> 01:15:37,874
字节顺序将在计划显示

1357
01:15:34,079 --> 01:15:41,084
如果你不小心， 特别 是 

1358
01:15:38,369 --> 01:15:44,940
这个联盟，我可以查看块 

1359
01:15:41,579 --> 01:15:48,593
八个字节为任一八个字符 

1360
01:15:44,094 --> 01:15:51,143
为短裤通过一个长和英寸 

1361
01:15:48,719 --> 01:15:54,900
在64位机器上像在此示出 

1362
01:15:51,989 --> 01:15:58,260
其中一起 是64位 ，你会看到， 

1363
01:15:54,009 --> 01:16:00,018
你是你能 

1364
01:15:58,026 --> 01:16:05,085
让事情无论是作为个人 

1365
01:16:01,008 --> 01:16:07,077
叮咬补差或更长一些 

1366
01:16:05,085 --> 01:16:09,120
这些 字节的聚集，你会 

1367
01:16:08,049 --> 01:16:12,072
实际上发现， 取决于 什么 

1368
01:16:10,002 --> 01:16:15,033
机器运行它，你会得到一个

1369
01:16:12,072 --> 01:16:17,091
不同的结果，因为字节 

1370
01:16:15,051 --> 01:16:20,073
不同机器的顺序，使 

1371
01:16:17,091 --> 01:16:22,146
这个经过它时 会发生什么 

1372
01:16:20,073 --> 01:16:24,126
你在不同的机器上运行

1373
01:16:23,046 --> 01:16:29,109
但你会，你会特别注意

1374
01:16:25,026 --> 01:16:34,125
一个 32机 上 的32位的 

1375
01:16:30,009 --> 01:16:40,047
机 它的脱落，在此 字节 

1376
01:16:35,025 --> 01:16:43,098
图案F 3 F 2 F 1个F 0 和在Sun 

1377
01:16:40,047 --> 01:16:45,078
回来时，他们的存在，你会得到 

1378
01:16:43,098 --> 01:16:52,179
相反成为字节顺序

1379
01:16:45,078 --> 01:16:58,119
现在在x86 64，在一个长为64 

1380
01:16:53,079 --> 01:17:00,081
位你得到一个8字节，你也可以

1381
01:16:59,019 --> 01:17:03,051
从这个判断，如果你看 

1382
01:17:00,081 --> 01:17:04,086
小心，它在它的一点点 

1383
01:17:03,051 --> 01:17:08,067
endian顺序，因为这是最 

1384
01:17:05,031 --> 01:17:14,094
显著字节为 F 0，这是 

1385
01:17:08,067 --> 01:17:16,122
第一个字节F0 所以它也是一种 方式来 获得 

1386
01:17:14,094 --> 01:17:17,166
低电平字节，但是当你使用 

1387
01:17:17,022 --> 01:17:22,115
这种 事情你是那种 

1388
01:17:18,066 --> 01:17:25,068
故意告诉C编译器 

1389
01:17:23,015 --> 01:17:28,020
相信我，我知道 我在做什么你 不 

1390
01:17:25,068 --> 01:17:29,115
要保护我快乐所以如果 

1391
01:17:28,065 --> 01:17:31,068
你不小心，你 可以编写代码 

1392
01:17:30,015 --> 01:17:32,091
其中， 因为字节顺序问题 

1393
01:17:31,095 --> 01:17:37,119
或 类似的 东西 

1394
01:17:32,091 --> 01:17:40,095
不会 在一些机器上 正常运行 ，从而 

1395
01:17:38,019 --> 01:17:43,050
只是总结那么，我们看着它 

1396
01:17:41,031 --> 01:17:45,110
我们已经在三个复合放在眼里 

1397
01:17:43,005 --> 01:17:48,048
类型C，可聚合的方法

1398
01:17:46,001 --> 01:17:51,017
较小的类型成大即可

1399
01:17:48,093 --> 01:17:53,124
使相同 的元件 的阵列

1400
01:17:51,026 --> 01:17:56,055
由多个位置索引，并 

1401
01:17:54,024 --> 01:17:58,032
通常变成某种 

1402
01:17:56,055 --> 01:18:01,131
按比例计算得到的 

1403
01:17:59,004 --> 01:18:06,006
我们所看到的结构特别的地方

1404
01:18:02,031 --> 01:18:07,086
它是一个固定数量的字段，但 

1405
01:18:06,006 --> 01:18:10,020
该字段可以是不同的 类型和 

1406
01:18:07,086 --> 01:18:11,086
通过他们的名字和参考 

1407
01:18:10,002 --> 01:18:13,006
通常变成某种类型的 

1408
01:18:11,086 --> 01:18:17,110
它的位置 离原来的 

1409
01:18:13,006 --> 01:18:21,025
位置，然后工会只是一种方式 

1410
01:18:18,001 --> 01:18:24,070
在一个地方的 那种 堆砌 

1411
01:18:21,079 --> 01:18:26,107
什么是许多不同的领域等等 

1412
01:18:24,079 --> 01:18:29,718
所有它委托的最大数量 

1413
01:18:27,007 --> 01:18:32,011
的字节为，并且不产生 

1414
01:18:30,429 --> 01:18:37,800
足够的空间，他们都 在那里，在 

1415
01:18:32,011 --> 01:18:37,080
同时 还行就是这样今天 

1416
01:18:37,084 --> 01:18:39,097
[掌声]

