1
00:00:00,000 --> 00:00:05,091
this comes this will be the last lecture

2
00:00:02,076 --> 00:00:07,134
on machine level programming we call it

3
00:00:05,091 --> 00:00:12,650
advanced topics but think of it more as

4
00:00:08,034 --> 00:00:14,079
miscellaneous topics and I think most to

5
00:00:13,469 --> 00:00:15,990
you of course you know that your bomb

6
00:00:14,079 --> 00:00:18,081
labs are due tonight

7
00:00:15,099 --> 00:00:21,150
so you most here probably well into that

8
00:00:18,099 --> 00:00:23,166
or hopefully through it and then at

9
00:00:22,005 --> 00:00:26,064
midnight tonight the next web will come

10
00:00:24,066 --> 00:00:28,265
out which is called a tack lab and there

11
00:00:27,009 --> 00:00:32,055
is a recitation about that yesterday but

12
00:00:28,859 --> 00:00:35,940
this is a lab that are new to the course

13
00:00:32,055 --> 00:00:37,101
it's a similar to one that we used to

14
00:00:35,094 --> 00:00:40,116
use at this point in the course but it's

15
00:00:38,001 --> 00:00:46,550
been updated and changed in significant

16
00:00:41,016 --> 00:00:48,845
ways so we're actually when you have

17
00:00:46,559 --> 00:00:50,561
labs like we do in this course with this

18
00:00:48,989 --> 00:00:53,190
many students there's a lot of things

19
00:00:50,579 --> 00:00:55,530
that go can go wrong so we're going to

20
00:00:53,019 --> 00:00:57,051
keep a close eye on on how things are

21
00:00:55,053 --> 00:00:58,119
going but I'd encourage you you only

22
00:00:57,051 --> 00:01:02,780
have a week and a half to do this next

23
00:00:59,019 --> 00:01:05,025
web to get started soon and partly by

24
00:01:03,239 --> 00:01:07,290
having some people start sooner you'll

25
00:01:05,025 --> 00:01:10,107
start breaking things for us that we can

26
00:01:07,029 --> 00:01:14,468
track down so today what we'll talk

27
00:01:11,007 --> 00:01:16,011
about is a couple like I said it's

28
00:01:14,729 --> 00:01:19,710
miscellaneous topics but important

29
00:01:16,047 --> 00:01:22,131
topics one is to sort of where what does

30
00:01:19,071 --> 00:01:26,120
the memory look like when you're running

31
00:01:23,031 --> 00:01:28,910
x86 64 programs the other is a very

32
00:01:26,759 --> 00:01:31,140
important topic on security

33
00:01:29,189 --> 00:01:33,420
vulnerability called buffer overflows

34
00:01:31,014 --> 00:01:36,383
and in fact at a collab we'll be

35
00:01:33,042 --> 00:01:38,067
precisely exploiting those security

36
00:01:36,509 --> 00:01:40,574
vulnerabilities and then we'll look at

37
00:01:38,067 --> 00:01:43,556
Union so far you've looked at arrays and

38
00:01:41,159 --> 00:01:49,208
structs and how they're organized and I

39
00:01:44,159 --> 00:01:52,166
want to compare that to unions so let's

40
00:01:49,649 --> 00:01:53,720
talk about memory then as I said at the

41
00:01:52,229 --> 00:01:56,820
beginning early in the course

42
00:01:53,072 --> 00:02:00,159
conceptually a memory is just a big

43
00:01:56,082 --> 00:02:03,084
array of bytes and that the view of this

44
00:02:01,059 --> 00:02:04,113
machine level programmer even though

45
00:02:04,002 --> 00:02:07,451
it's not the actual implementation

46
00:02:05,013 --> 00:02:10,232
there's a whole part that we'll talk

47
00:02:07,469 --> 00:02:12,550
about later in the course of this is

48
00:02:10,349 --> 00:02:15,100
called virtual memory

49
00:02:12,055 --> 00:02:16,129
this organization is very simple

50
00:02:15,001 --> 00:02:19,009
organization but the underlying

51
00:02:17,029 --> 00:02:22,048
implementation is this complex

52
00:02:19,018 --> 00:02:26,031
management of various different memory

53
00:02:22,048 --> 00:02:30,091
types from disk memories to solid state

54
00:02:26,031 --> 00:02:32,122
disks and to what's called DRAM which

55
00:02:30,091 --> 00:02:37,105
stands for dynamic Ram the when you buy

56
00:02:33,022 --> 00:02:40,110
memory for your processor is DRAM oh so

57
00:02:38,005 --> 00:02:45,016
as you know in x86 64 we're working with

58
00:02:41,001 --> 00:02:48,016
machines that nominally are have

59
00:02:45,016 --> 00:02:50,044
addresses can be up to 64 bits long and

60
00:02:48,025 --> 00:02:51,103
if you work out the numbers remember I

61
00:02:50,044 --> 00:02:54,127
told you at the beginning of the course

62
00:02:52,003 --> 00:02:58,078
you can estimate how big a number like

63
00:02:55,027 --> 00:03:01,102
to the 64 is by remembering that a

64
00:02:58,078 --> 00:03:03,112
thousand 24 and a thousand are very

65
00:03:02,002 --> 00:03:07,050
close to each other so two to the tenth

66
00:03:04,012 --> 00:03:11,074
is roughly the same as 10 to the third

67
00:03:07,005 --> 00:03:14,053
so you take 64 and you think 60 so how

68
00:03:11,074 --> 00:03:18,160
big is 2 to the 60 well that's 6 times

69
00:03:14,098 --> 00:03:22,105
10 and therefore it's 6 times 3 it's

70
00:03:19,006 --> 00:03:26,011
like 10 to the 18th and then you add the

71
00:03:23,068 --> 00:03:29,107
4 to that that's 2 to the 4th and 16 so

72
00:03:27,001 --> 00:03:36,013
it's around 16 times 10 to the 18th

73
00:03:30,007 --> 00:03:40,066
fight so if you were to go off and look

74
00:03:36,022 --> 00:03:43,057
online on Amazon for DRAM chips and try

75
00:03:40,066 --> 00:03:46,165
to buy that much memory you'd find

76
00:03:43,057 --> 00:03:49,144
you're spending a lot of money more than

77
00:03:47,065 --> 00:03:52,132
you I don't know the numbers but it

78
00:03:50,044 --> 00:03:55,123
would be a lot of memory money and so

79
00:03:53,032 --> 00:04:03,106
you basically can't do it nowadays tend

80
00:03:56,023 --> 00:04:06,088
to the and so right now the machines

81
00:04:04,006 --> 00:04:12,013
limit you to actually only 47 bits worth

82
00:04:06,088 --> 00:04:13,150
of address in the address space and so 2

83
00:04:12,013 --> 00:04:18,019
to the 47th again work that out that's

84
00:04:14,005 --> 00:04:22,090
like 10 to the 12th times 256 times 10

85
00:04:18,073 --> 00:04:24,139
to the 12th so it's 256 terabytes and as

86
00:04:23,035 --> 00:04:25,123
you know you can buy a disk drive now

87
00:04:25,039 --> 00:04:27,088
that has 8

88
00:04:26,023 --> 00:04:29,029
jeribai so it doesn't seem like that

89
00:04:27,088 --> 00:04:31,162
much but if you tried to buy that much

90
00:04:29,083 --> 00:04:38,155
DRAM again you'd have to have a pretty

91
00:04:32,062 --> 00:04:41,125
big credit-card limit and so even that's

92
00:04:39,055 --> 00:04:43,141
a huge number and modern supercomputer

93
00:04:42,025 --> 00:04:46,054
in situations actually will have almost

94
00:04:44,041 --> 00:04:50,041
that much memory but the point is that

95
00:04:46,054 --> 00:04:53,083
the hardware of today limits you to 47

96
00:04:50,041 --> 00:04:56,065
bits worth of address but that's not

97
00:04:53,083 --> 00:04:58,135
really a real limitation in terms of of

98
00:04:56,065 --> 00:05:01,066
actual machines and what will happen is

99
00:04:59,035 --> 00:05:03,094
is memory prices get cheaper and the

100
00:05:01,075 --> 00:05:05,083
technology gets better they'll slowly

101
00:05:03,094 --> 00:05:08,140
start adding as succeeding generations

102
00:05:06,055 --> 00:05:12,087
of processors come along let you have

103
00:05:09,004 --> 00:05:19,030
bigger and bigger range of addresses so

104
00:05:12,087 --> 00:05:21,112
all that is to say that's why this

105
00:05:19,066 --> 00:05:29,134
number shows up which is a seven

106
00:05:22,012 --> 00:05:31,111
followed by 11s I can tell I need to

107
00:05:30,034 --> 00:05:34,036
scribble some numbers you guys aren't

108
00:05:32,011 --> 00:05:39,102
just saying numbers in the air is not

109
00:05:34,054 --> 00:05:39,102
working here so let's try

110
00:05:52,639 --> 00:06:00,701
okay

111
00:05:54,032 --> 00:06:09,090
so remember I said before 264 is about

112
00:06:01,259 --> 00:06:19,259
equal to 16 times 10 to the 18th - to

113
00:06:09,009 --> 00:06:21,101
the 47th is 128 times 10 to the 12th so

114
00:06:19,259 --> 00:06:22,820
it's 128 terabytes

115
00:06:28,449 --> 00:06:38,505
so what's the number after a terabyte

116
00:06:31,025 --> 00:06:42,043
you know 10 to the 15th how many but yes

117
00:06:39,009 --> 00:06:42,430
petabytes right

118
00:06:44,019 --> 00:06:50,033
and you know what 10v 18th is exha

119
00:06:52,049 --> 00:07:01,125
so just as a reference a company like

120
00:06:57,069 --> 00:07:05,078
Google roughly it's probably a total

121
00:07:02,025 --> 00:07:09,064
storage across the whole enterprises

122
00:07:05,699 --> 00:07:14,610
measured in some small number of X bytes

123
00:07:09,289 --> 00:07:16,770
and it every day is getting several

124
00:07:14,061 --> 00:07:19,460
petabytes I don't know the numbers are

125
00:07:16,077 --> 00:07:22,140
of course secret but maybe 10 petabytes

126
00:07:20,009 --> 00:07:26,190
or more per day of new data that it's

127
00:07:23,004 --> 00:07:29,004
ingesting into its system so these

128
00:07:26,019 --> 00:07:30,081
numbers are pretty huge but not just

129
00:07:29,004 --> 00:07:35,303
totally off the charts do you know what

130
00:07:30,081 --> 00:07:39,149
10 to the 21st is it's called a

131
00:07:35,699 --> 00:07:40,490
zettabyte with two t's

132
00:07:40,094 --> 00:07:45,095
and it's estimated if you add up all the

133
00:07:43,088 --> 00:07:47,150
digital content in the world that gets

134
00:07:46,004 --> 00:07:52,085
created everybody's cell phone camera

135
00:07:48,005 --> 00:07:55,007
every video taken by anyone anywhere all

136
00:07:52,085 --> 00:07:57,143
year long is a couple of zettabytes a

137
00:07:55,052 --> 00:08:00,070
year so it'll be a while before we're

138
00:07:58,043 --> 00:08:04,048
really having to deal with that kind of

139
00:08:00,007 --> 00:08:08,081
memory so just just give you an idea so

140
00:08:04,093 --> 00:08:12,095
128 terabytes is the address limit on

141
00:08:09,044 --> 00:08:15,089
these systems and so that's why you have

142
00:08:12,095 --> 00:08:18,187
to have seven because you remember

143
00:08:15,089 --> 00:08:22,127
that's one two three and then there's F

144
00:08:19,087 --> 00:08:28,121
but there's 11 of them and this is one

145
00:08:23,027 --> 00:08:33,976
one one times 11 so that's 44 ones and

146
00:08:29,021 --> 00:08:40,660
this is three one and that's where you

147
00:08:34,219 --> 00:08:44,450
get 47 and that's the address of the in

148
00:08:40,849 --> 00:08:46,730
Linux that's where they put the stack is

149
00:08:44,045 --> 00:08:48,143
up at the very top of the address space

150
00:08:46,073 --> 00:08:50,141
and I should tell you this picture is

151
00:08:49,043 --> 00:08:53,074
not at all to scale it would be

152
00:08:51,041 --> 00:08:55,130
impossible to draw this picture to scale

153
00:08:53,074 --> 00:08:58,166
for example it shows that the stack

154
00:08:56,003 --> 00:09:03,020
starts way up at the top and remember

155
00:08:59,066 --> 00:09:05,147
stacks grow to smaller addresses when

156
00:09:03,047 --> 00:09:08,060
you're pushing and also we show the them

157
00:09:06,047 --> 00:09:14,075
upside down just to make everything

158
00:09:08,006 --> 00:09:16,010
confusing so the the stack starts there

159
00:09:14,075 --> 00:09:18,131
and it grows towards lower addresses and

160
00:09:17,000 --> 00:09:22,013
on a typical system it will be limited

161
00:09:19,031 --> 00:09:27,065
to 8 megabytes and you can tell that on

162
00:09:22,013 --> 00:09:33,086
a Linux system at least with the the

163
00:09:27,065 --> 00:09:35,126
limit command which used to be more

164
00:09:33,086 --> 00:09:37,088
interesting that it was it is now

165
00:09:36,026 --> 00:09:40,061
because a lot of things are unlimited

166
00:09:37,088 --> 00:09:42,176
but you see it says the stack size is

167
00:09:40,061 --> 00:09:47,083
limited 8192 K bytes to kilobytes so

168
00:09:43,076 --> 00:09:47,083
it's 8 megabytes

169
00:09:49,529 --> 00:10:00,350
and what that means is if you tried to

170
00:09:53,072 --> 00:09:59,135
access any memory via the stack pointer

171
00:10:00,074 --> 00:10:07,463
that was outside of the range of this 8

172
00:10:06,072 --> 00:10:11,861
megabyte range you'd get a segmentation

173
00:10:08,129 --> 00:10:15,167
fault and then down at the lower address

174
00:10:12,509 --> 00:10:17,490
is what comes in of what gets put into

175
00:10:15,509 --> 00:10:19,800
your program are the parts of the code

176
00:10:17,049 --> 00:10:22,068
that that come out of the executable

177
00:10:19,008 --> 00:10:23,597
file and so there's a section and we'll

178
00:10:22,068 --> 00:10:26,087
talk more when we talk about linking

179
00:10:24,389 --> 00:10:29,402
actually about the way out of the memory

180
00:10:26,699 --> 00:10:31,718
and the different regions of it but for

181
00:10:29,519 --> 00:10:33,575
some obscure reason they they call where

182
00:10:31,889 --> 00:10:37,620
the code is sitting the executable

183
00:10:34,079 --> 00:10:39,930
program the text segment I don't know

184
00:10:37,062 --> 00:10:42,251
why that's true but it's the way it is

185
00:10:39,093 --> 00:10:44,792
nets across many machines and then the

186
00:10:42,809 --> 00:10:47,843
data is first of all there'll be a

187
00:10:45,629 --> 00:10:50,693
section for the data that's allocated it

188
00:10:48,149 --> 00:10:54,149
the program begins so any global

189
00:10:51,269 --> 00:10:58,350
variables that you've declared will be

190
00:10:54,149 --> 00:11:01,470
in that section and then the heat is the

191
00:10:58,035 --> 00:11:03,524
part of memory that is X is allocated

192
00:11:01,047 --> 00:11:06,416
via call to malloc or one of its related

193
00:11:03,839 --> 00:11:08,924
functions and so that varies dynamically

194
00:11:06,839 --> 00:11:12,480
as the program runs it starts off with a

195
00:11:09,689 --> 00:11:12,778
very small allocation and every time you

196
00:11:12,048 --> 00:11:17,777
call malloc

197
00:11:13,579 --> 00:11:20,430
if you're not freeing memory and so your

198
00:11:18,209 --> 00:11:24,480
memory requirements keep growing it will

199
00:11:20,043 --> 00:11:26,822
crease keep up moving up larger and

200
00:11:24,048 --> 00:11:29,267
larger addresses and then somewhere in

201
00:11:27,209 --> 00:11:32,303
the code - and this can vary by system

202
00:11:29,699 --> 00:11:35,550
is the code that gets brought in that

203
00:11:33,149 --> 00:11:38,180
represents the library functions things

204
00:11:35,055 --> 00:11:40,394
like pretty and malloc itself our own

205
00:11:38,459 --> 00:11:43,350
library code they're stored off on disk

206
00:11:40,889 --> 00:11:44,891
and they get brought in they get linked

207
00:11:43,035 --> 00:11:47,204
into your program when it first starts

208
00:11:45,089 --> 00:11:49,133
executing by a process known as dynamic

209
00:11:47,519 --> 00:11:52,562
linking which we'll talk about later in

210
00:11:49,529 --> 00:11:54,571
the course - with the linking and what

211
00:11:52,949 --> 00:11:57,300
you'll find in general is that

212
00:11:54,949 --> 00:12:00,000
allocations will tend to be either at

213
00:11:57,003 --> 00:12:01,075
these very low addresses or these very

214
00:12:00,000 --> 00:12:07,066
high addresses

215
00:12:02,002 --> 00:12:11,026
as your program is running so just as an

216
00:12:07,066 --> 00:12:13,075
example here is some code that it's only

217
00:12:11,026 --> 00:12:15,915
value is to show you different where

218
00:12:13,075 --> 00:12:18,106
things get located and so you'll see I

219
00:12:16,149 --> 00:12:23,020
allocated some a fairly large arrays

220
00:12:19,006 --> 00:12:27,079
here this one is there all cares but

221
00:12:23,002 --> 00:12:31,093
this is 2 to the 24th so 16 a mega byte

222
00:12:27,079 --> 00:12:36,148
array and this one is 2 to the 31st so

223
00:12:31,093 --> 00:12:40,442
it's 2 gigabytes worth of array I found

224
00:12:37,048 --> 00:12:46,467
that if I tried to allocate larger ones

225
00:12:41,279 --> 00:12:49,341
the program wouldn't run and I also do

226
00:12:46,899 --> 00:12:53,620
some here's just a sort of global

227
00:12:49,899 --> 00:12:54,993
variable and here's a function and then

228
00:12:53,062 --> 00:12:57,073
there's a single function here with some

229
00:12:55,839 --> 00:12:58,920
local variable and that will be

230
00:12:57,073 --> 00:13:01,132
allocated somewhere on the stack and

231
00:12:59,649 --> 00:13:05,020
then there's several calls to milk some

232
00:13:02,032 --> 00:13:07,045
of which are for some very small chunks

233
00:13:05,002 --> 00:13:10,311
of memory and similarly where for some

234
00:13:07,045 --> 00:13:13,063
very large chunks of memory and so we

235
00:13:10,329 --> 00:13:16,380
can run this program and see what

236
00:13:13,063 --> 00:13:20,068
addresses pop out of it and what you'll

237
00:13:16,839 --> 00:13:23,470
see is the stack this local variable is

238
00:13:20,068 --> 00:13:25,105
somewhere up with an address in the

239
00:13:23,047 --> 00:13:27,079
range of the stack and you see the 7 and

240
00:13:26,005 --> 00:13:30,007
a couple FS and then it goes to

241
00:13:27,079 --> 00:13:32,086
something else and you'll see also

242
00:13:30,007 --> 00:13:36,100
interestingly enough that the codec and

243
00:13:33,049 --> 00:13:39,648
then looking down at the bottom of this

244
00:13:37,000 --> 00:13:42,049
yellow color is things get relegated to

245
00:13:40,089 --> 00:13:45,790
the text segment the main function and

246
00:13:42,049 --> 00:13:48,100
this function I called I declared called

247
00:13:45,079 --> 00:13:52,087
useless and then the predefined arrays

248
00:13:49,000 --> 00:13:55,027
that were in other words globally

249
00:13:52,087 --> 00:13:57,174
declared not declared by malloc they're

250
00:13:55,027 --> 00:14:02,070
declared as part of the program itself

251
00:13:58,074 --> 00:14:05,095
are down here in this data section and

252
00:14:02,007 --> 00:14:06,016
because it's a very large array the huge

253
00:14:05,095 --> 00:14:09,142
array you actually get some fairly large

254
00:14:07,006 --> 00:14:13,037
addresses and then interestingly enough

255
00:14:10,042 --> 00:14:16,130
or I don't know why it's interesting but

256
00:14:13,091 --> 00:14:19,184
for one reason or another it happens

257
00:14:17,003 --> 00:14:23,060
that the smaller chunks of memory

258
00:14:20,084 --> 00:14:24,137
allocations are down here at addresses

259
00:14:23,087 --> 00:14:27,179
that are actually just a little bit

260
00:14:25,037 --> 00:14:30,086
above the the pink section right and

261
00:14:28,079 --> 00:14:36,083
similarly the really big chunks of

262
00:14:30,086 --> 00:14:43,103
memory allocated are way up here near

263
00:14:36,083 --> 00:14:44,159
the the stack limit and they and so

264
00:14:44,003 --> 00:14:47,030
they're there and in general what's

265
00:14:45,059 --> 00:14:50,087
happening is if I were to try and

266
00:14:47,003 --> 00:14:53,024
reference a memory address in this empty

267
00:14:50,087 --> 00:14:55,186
range I'd get a segmentation fault it's

268
00:14:53,051 --> 00:14:58,094
a valid address in terms of its bit of

269
00:14:56,086 --> 00:15:00,140
properties but it hasn't actually been

270
00:14:58,094 --> 00:15:03,137
set up and allocated by the memory the

271
00:15:01,004 --> 00:15:06,080
virtual memory allocator so at any given

272
00:15:04,037 --> 00:15:09,074
time the valid addresses are just those

273
00:15:07,016 --> 00:15:12,038
in the lower portion or the upper

274
00:15:09,074 --> 00:15:13,163
portion of his address ranges and the

275
00:15:12,038 --> 00:15:16,070
middle is sort of no-man's land and then

276
00:15:14,063 --> 00:15:19,130
what happens is you keep allocating more

277
00:15:16,007 --> 00:15:21,092
with malloc and it will push the limits

278
00:15:20,003 --> 00:15:26,087
of what's addressable in toward it and

279
00:15:22,055 --> 00:15:30,074
in principle if you ever got too much of

280
00:15:27,014 --> 00:15:33,062
a memory request if these two would hit

281
00:15:30,074 --> 00:15:35,087
each other and if you and melech would

282
00:15:33,062 --> 00:15:39,071
return zero at that point but it's

283
00:15:35,087 --> 00:15:42,109
highly unlikely given that you have 128

284
00:15:40,052 --> 00:15:45,053
terabytes of memory address range here

285
00:15:43,009 --> 00:15:48,065
so that's just and you've probably seen

286
00:15:45,053 --> 00:15:50,054
this when you're running you're looking

287
00:15:48,065 --> 00:15:52,082
at disassembled code with gdb you're

288
00:15:50,063 --> 00:15:55,070
seeing some addresses that are way up

289
00:15:52,082 --> 00:15:57,175
here with the seven and some episodes or

290
00:15:55,007 --> 00:16:00,068
stack addresses and you see these fours

291
00:15:58,075 --> 00:16:02,132
you know a lot of zeros and some fours

292
00:16:01,031 --> 00:16:06,073
those tend to be where the code is going

293
00:16:03,032 --> 00:16:06,073
to question

294
00:16:08,005 --> 00:16:12,080
so why doesn't the heat proceed in one

295
00:16:10,085 --> 00:16:14,180
direction I actually don't know I'll

296
00:16:13,025 --> 00:16:17,066
just observe that it was had a strategy

297
00:16:15,008 --> 00:16:18,047
of putting big things here in small

298
00:16:17,066 --> 00:16:20,105
things here and it probably uses

299
00:16:19,019 --> 00:16:24,043
different slightly different management

300
00:16:21,005 --> 00:16:24,043
strategies for those two

301
00:16:32,629 --> 00:16:37,680
okay so that but I think you'll find

302
00:16:35,819 --> 00:16:38,876
that kind of useful to have some sense

303
00:16:37,068 --> 00:16:41,027
when you're looking at when you're

304
00:16:39,389 --> 00:16:43,560
running gdb it helps to just have some

305
00:16:41,639 --> 00:16:46,651
idea of what's going on when you're

306
00:16:43,056 --> 00:16:48,141
looking at these different addresses

307
00:16:46,759 --> 00:16:53,100
okay now let's talk about buffer

308
00:16:49,041 --> 00:16:55,160
overflow and we'll start this you

309
00:16:53,001 --> 00:16:57,006
remember on the very first class and I

310
00:16:55,529 --> 00:17:00,360
think we might have reviewed this part

311
00:16:57,006 --> 00:17:02,435
way along we showed this example of some

312
00:17:00,036 --> 00:17:07,355
programs where if you do an

313
00:17:03,029 --> 00:17:09,780
out-of-bounds reference and write a

314
00:17:07,679 --> 00:17:14,130
value that's out of bounds in particular

315
00:17:09,078 --> 00:17:16,080
I only have a array of two elements here

316
00:17:14,013 --> 00:17:20,013
but this function will take an arbitrary

317
00:17:16,098 --> 00:17:23,163
value of I and assign some magic number

318
00:17:20,013 --> 00:17:29,432
to omotte i of the array and it has the

319
00:17:24,063 --> 00:17:32,722
possibility of and we saw that when you

320
00:17:29,549 --> 00:17:38,220
do that if I get too big it will first

321
00:17:33,289 --> 00:17:40,289
corrupt the double that stored as part

322
00:17:38,022 --> 00:17:43,101
of the struct and then when it gets

323
00:17:40,289 --> 00:17:46,110
bigger it seems to not have any effect

324
00:17:44,001 --> 00:17:48,800
until it gets too big and then you start

325
00:17:46,011 --> 00:17:52,011
corrupting memory so the basic point is

326
00:17:48,809 --> 00:17:55,500
that it's very easy in a program of C

327
00:17:52,011 --> 00:17:58,023
program in particular to a reference

328
00:17:55,005 --> 00:18:04,067
memory that's not part of the sort of

329
00:17:58,023 --> 00:18:07,065
intent of the program and this can

330
00:18:05,012 --> 00:18:11,109
happen in programs that aren't properly

331
00:18:07,065 --> 00:18:13,071
written that and it becomes a security

332
00:18:12,009 --> 00:18:20,034
vulnerability if there's some way for an

333
00:18:14,025 --> 00:18:21,072
outsider to overflow a buffer for

334
00:18:20,034 --> 00:18:23,043
example if there is some way for an

335
00:18:21,072 --> 00:18:26,100
outsider to give a larger value of I and

336
00:18:24,024 --> 00:18:29,076
ask that that value be stored there it

337
00:18:27,000 --> 00:18:31,038
could crash the program and so in

338
00:18:29,076 --> 00:18:32,127
general when you write in code you try

339
00:18:31,038 --> 00:18:36,045
to think about you know can I trust this

340
00:18:33,027 --> 00:18:38,306
value is this a value that's been

341
00:18:36,045 --> 00:18:40,098
computed by my program and I'm sure that

342
00:18:38,549 --> 00:18:41,490
it's within bounds or is it something

343
00:18:40,098 --> 00:18:42,527
that

344
00:18:41,049 --> 00:18:46,110
so come from an external source and

345
00:18:43,409 --> 00:18:50,610
there's potentially at risk of being a

346
00:18:47,001 --> 00:18:52,092
vulnerability so and so in particular

347
00:18:50,061 --> 00:18:55,149
there's a lot a huge class of errors

348
00:18:53,001 --> 00:19:00,024
that have to do with overflowing buffers

349
00:18:56,049 --> 00:19:02,055
where where they're trying to store a

350
00:19:00,024 --> 00:19:07,122
string of some type that's been read

351
00:19:03,009 --> 00:19:10,062
from a message and without knowing in

352
00:19:08,022 --> 00:19:13,038
advance how big that string is it's

353
00:19:10,062 --> 00:19:15,371
possible that it will be too big for the

354
00:19:13,038 --> 00:19:17,040
buffer that's been allocated and so one

355
00:19:15,929 --> 00:19:23,014
of the culprits is there's a whole class

356
00:19:17,058 --> 00:19:25,137
of of library functions that let you

357
00:19:23,779 --> 00:19:29,070
store something a string somewhere

358
00:19:26,037 --> 00:19:32,046
without any kind of bounds checking even

359
00:19:29,007 --> 00:19:35,846
being possible so the sort of worst one

360
00:19:33,027 --> 00:19:38,036
is one called get F and the purpose of

361
00:19:35,909 --> 00:19:42,935
get S is normally it's used to read a

362
00:19:38,279 --> 00:19:44,730
string from an input from a terminal

363
00:19:43,169 --> 00:19:47,130
input something that somebody's typed

364
00:19:44,073 --> 00:19:49,110
into a terminal and so what it's doing

365
00:19:47,013 --> 00:19:52,095
is it's scanning this input string and

366
00:19:50,001 --> 00:19:56,200
looking for a character that represents

367
00:19:52,095 --> 00:19:59,100
the end of the line which we write in of

368
00:19:56,299 --> 00:20:05,610
CEA's is backslash n and it has the

369
00:20:00,000 --> 00:20:08,058
character code in hex of zero a and so

370
00:20:05,061 --> 00:20:09,860
get F this is sort of an approximate

371
00:20:08,058 --> 00:20:13,083
version of what the code forgetteth

372
00:20:10,409 --> 00:20:15,422
looks like that and it as an argument

373
00:20:13,083 --> 00:20:17,088
it's just given a destination of where

374
00:20:15,539 --> 00:20:20,627
to store the result and all it does is

375
00:20:18,033 --> 00:20:23,762
it reads one character at a time looks

376
00:20:21,419 --> 00:20:27,433
for an into file meaning that the input

377
00:20:24,059 --> 00:20:30,090
stream is closed or an end-of-line

378
00:20:27,559 --> 00:20:33,600
but as long as it until it sees that it

379
00:20:30,009 --> 00:20:40,061
just keeps adding more things to the end

380
00:20:33,006 --> 00:20:40,007
of this buffer and so typically

381
00:20:43,139 --> 00:20:49,690
when somebody calls get us they'll pass

382
00:20:46,179 --> 00:20:52,278
it a pointer to some buffer that they've

383
00:20:49,069 --> 00:20:54,148
allocated but the function and it will

384
00:20:53,169 --> 00:20:58,240
just get us we'll just fill that buffer

385
00:20:55,048 --> 00:21:00,049
up but it can potentially just keep

386
00:20:58,024 --> 00:21:02,313
going there is nothing in the function

387
00:21:00,049 --> 00:21:06,073
there's not even an argument to the

388
00:21:02,529 --> 00:21:08,592
function that tells the function when

389
00:21:06,073 --> 00:21:10,992
when it has to stop when it's reached

390
00:21:09,159 --> 00:21:14,172
the limit of it so it was written that

391
00:21:11,649 --> 00:21:16,240
actually get at is if you try to compile

392
00:21:14,289 --> 00:21:18,297
code would get us it will flash up a big

393
00:21:16,024 --> 00:21:19,108
warning that says this is really an

394
00:21:18,369 --> 00:21:24,396
unsafe function you probably shouldn't

395
00:21:20,008 --> 00:21:28,084
even be using it because it it has it

396
00:21:24,639 --> 00:21:30,681
was written in an era in the 1970s when

397
00:21:28,084 --> 00:21:32,253
the early UNIX distributions were coming

398
00:21:31,059 --> 00:21:35,130
out where people just weren't worried

399
00:21:33,009 --> 00:21:39,018
about security vulnerabilities and they

400
00:21:35,769 --> 00:21:42,834
just assumed that if you allocated a big

401
00:21:39,909 --> 00:21:45,490
enough buffer that there's no reason why

402
00:21:43,419 --> 00:21:49,491
a string should be bigger than what

403
00:21:45,049 --> 00:21:52,358
you've allocated and that's actually

404
00:21:50,139 --> 00:21:58,200
true with other functions like stir copy

405
00:21:52,799 --> 00:22:03,090
you recall stir copy has two arguments

406
00:21:58,749 --> 00:22:06,220
excuse me a destination and a source and

407
00:22:03,009 --> 00:22:09,046
its purpose is to copy the string at the

408
00:22:06,022 --> 00:22:10,941
source into the destination and the way

409
00:22:09,046 --> 00:22:12,015
it determines the end of the string and

410
00:22:11,139 --> 00:22:15,177
the source is when it hits a null

411
00:22:12,429 --> 00:22:18,820
character that just keeps copying one by

412
00:22:15,519 --> 00:22:20,535
one wall until it hits it but it has no

413
00:22:18,082 --> 00:22:22,311
way of knowing there's nothing no

414
00:22:20,679 --> 00:22:25,686
information there about how much how big

415
00:22:23,049 --> 00:22:29,110
is the buffer allocated at the

416
00:22:26,379 --> 00:22:31,434
destination and so it can easily overrun

417
00:22:29,011 --> 00:22:34,012
that a similar one called stir cat which

418
00:22:31,929 --> 00:22:38,350
is used to concatenate two strings and

419
00:22:34,021 --> 00:22:43,024
copy them to another destination and the

420
00:22:38,035 --> 00:22:44,098
scanf function of also have possible in

421
00:22:43,024 --> 00:22:48,453
the format string you can give the

422
00:22:44,098 --> 00:22:50,194
percent F directive to the format string

423
00:22:48,669 --> 00:22:53,130
which says read in a string and store it

424
00:22:51,094 --> 00:22:54,159
someplace

425
00:22:53,013 --> 00:22:57,542
and it doesn't say how long the string

426
00:22:55,059 --> 00:22:59,258
is limited to be and it doesn't say how

427
00:22:57,659 --> 00:23:02,220
much memory is available at the

428
00:22:59,789 --> 00:23:05,840
destination so again it can easily just

429
00:23:02,022 --> 00:23:08,711
write over that a buffer so these are

430
00:23:06,299 --> 00:23:11,700
real vulnerabilities and we will talk in

431
00:23:08,909 --> 00:23:14,070
a minute a little later about how you as

432
00:23:11,007 --> 00:23:16,846
a programmer can be a little smarter

433
00:23:14,007 --> 00:23:20,596
than this but in their suit of raw form

434
00:23:17,539 --> 00:23:24,360
as presented they have this

435
00:23:20,659 --> 00:23:27,746
vulnerability to them so let's look at

436
00:23:24,036 --> 00:23:30,935
an example of what this can what can

437
00:23:28,529 --> 00:23:35,070
happen there so imagine for example we

438
00:23:31,259 --> 00:23:36,326
want a to implement echo function so an

439
00:23:35,007 --> 00:23:39,069
echo function is one that you just type

440
00:23:36,929 --> 00:23:41,942
something in and it prints it back out

441
00:23:39,069 --> 00:23:43,048
it's very uninteresting function except

442
00:23:42,059 --> 00:23:47,070
it's very useful to demonstrate things

443
00:23:43,669 --> 00:23:49,110
so the idea is it has this little buffer

444
00:23:47,007 --> 00:23:53,007
it's only enough to hold four characters

445
00:23:49,011 --> 00:23:56,022
it caused geta to read a string from the

446
00:23:53,007 --> 00:24:01,085
input and then it calls put s which

447
00:23:56,022 --> 00:24:01,085
simply writes back out the output and

448
00:24:08,079 --> 00:24:15,080
and so let me just download this not

449
00:24:12,045 --> 00:24:15,080
very interesting function

450
00:24:20,031 --> 00:24:28,039
so I call it here buff demo - NST mean

451
00:24:26,089 --> 00:24:30,151
it has no stack protector and we'll see

452
00:24:29,011 --> 00:24:33,073
in a minute what its deck protectors but

453
00:24:31,051 --> 00:24:45,073
you see if you type a reasonably smoke

454
00:24:33,073 --> 00:24:48,079
strong small string very rare it can

455
00:24:45,073 --> 00:24:49,150
handle more than four actually as

456
00:24:48,079 --> 00:24:51,133
written it can't handle more than three

457
00:24:50,005 --> 00:25:02,014
right because there should be room for

458
00:24:52,033 --> 00:25:04,060
the null character - on terminator so it

459
00:25:02,059 --> 00:25:09,124
turns out with this particular one if I

460
00:25:04,006 --> 00:25:12,009
type in a string of 24 characters it'll

461
00:25:10,024 --> 00:25:12,063
be okay

462
00:25:21,004 --> 00:25:28,019
but if I type in a string of 24

463
00:25:24,002 --> 00:25:30,076
characters it will hit a segmentation

464
00:25:28,055 --> 00:25:30,076
fault

465
00:25:32,003 --> 00:25:37,025
so where do those numbers 23 and 24 come

466
00:25:35,069 --> 00:25:40,069
in well that's something we can learn by

467
00:25:37,052 --> 00:25:40,069
looking at the assembly code

468
00:25:55,072 --> 00:26:02,150
so here's and we'll go through the code

469
00:25:59,014 --> 00:26:07,058
so first of all this is the code for

470
00:26:03,005 --> 00:26:13,052
echo then and you see the echo calls get

471
00:26:07,058 --> 00:26:15,065
s and it calls put it and here's the

472
00:26:13,097 --> 00:26:18,143
part of the code where you can tell how

473
00:26:16,028 --> 00:26:36,076
much memory got allocated for the buffer

474
00:26:19,043 --> 00:26:36,076
and x18 is what in decimal X 24 right

475
00:26:37,003 --> 00:26:45,020
and you just saw that the thing actually

476
00:26:41,003 --> 00:26:46,096
seg faults with a input string of 24 so

477
00:26:45,047 --> 00:26:49,112
we'll see that in a minute

478
00:26:46,096 --> 00:26:53,168
but anyways you can see here that it's

479
00:26:50,012 --> 00:27:01,064
allocating on the stack a region of 24

480
00:26:54,068 --> 00:27:02,117
bytes and it's copying that into RDI

481
00:27:01,064 --> 00:27:04,157
which is of course the argument

482
00:27:03,017 --> 00:27:11,038
forgetteth so get us is being called

483
00:27:05,057 --> 00:27:13,124
with a pointer to a buffer of size 24

484
00:27:11,038 --> 00:27:16,063
maximum 24 even though you saw the

485
00:27:14,024 --> 00:27:24,071
original declaration was just four for

486
00:27:16,063 --> 00:27:27,092
all and then it calls get s and then get

487
00:27:24,071 --> 00:27:31,127
us does it thing in just one last little

488
00:27:27,092 --> 00:27:38,117
bit to keep in mind is we'll get back to

489
00:27:32,027 --> 00:27:40,088
them oh yes and remember echo that

490
00:27:39,017 --> 00:27:42,091
there's a function called call echo

491
00:27:40,088 --> 00:27:45,113
which is the thing that calls echo and

492
00:27:42,091 --> 00:27:49,148
just to keep in mind this read is the

493
00:27:46,013 --> 00:27:53,017
return address for call echo and that's

494
00:27:50,048 --> 00:27:53,053
going to be important

495
00:27:55,008 --> 00:28:04,063
so what we see then is the memory layout

496
00:27:58,033 --> 00:28:07,072
is the buff is normally big enough for

497
00:28:04,063 --> 00:28:09,145
four characters there's a sort of 20

498
00:28:07,072 --> 00:28:12,088
bytes of unused or wasted space here and

499
00:28:10,045 --> 00:28:15,067
then the actual return address which is

500
00:28:12,088 --> 00:28:23,110
the return address for back to call echo

501
00:28:15,067 --> 00:28:26,706
is stored on the stack so when this

502
00:28:24,001 --> 00:28:29,068
program int begins running when echo

503
00:28:27,309 --> 00:28:33,550
starts to run we'll find that this is

504
00:28:29,077 --> 00:28:39,124
the value on the stack for the return

505
00:28:33,055 --> 00:28:44,064
pointer and if we type in a string of up

506
00:28:40,024 --> 00:28:47,026
here of 23 characters you'll see that it

507
00:28:44,559 --> 00:28:51,460
uses up this entire buffer and remember

508
00:28:47,026 --> 00:28:53,122
a string is terminated with a 0 0 but it

509
00:28:51,046 --> 00:28:55,135
still hasn't it's still within the

510
00:28:54,022 --> 00:29:00,022
region that was allocated on the stack

511
00:28:56,035 --> 00:29:04,069
for that so it just barely fits into the

512
00:29:00,022 --> 00:29:06,061
the stack and that's why we technically

513
00:29:04,069 --> 00:29:07,153
we overflowed the buffer but we didn't

514
00:29:06,061 --> 00:29:11,130
really cause any harm because there was

515
00:29:08,053 --> 00:29:13,132
this extra space available and so that's

516
00:29:11,679 --> 00:29:18,940
why I could type in that string of 23

517
00:29:14,032 --> 00:29:22,090
characters and and it worked fine but

518
00:29:18,094 --> 00:29:24,713
now if I type in this is an example

519
00:29:22,009 --> 00:29:24,668
showing

520
00:29:28,015 --> 00:29:38,104
I actually 25 characters so once I go

521
00:29:34,081 --> 00:29:39,160
beyond the 23 characters plus the null

522
00:29:39,004 --> 00:29:46,030
character you'll see what I'm slowly

523
00:29:40,006 --> 00:29:48,052
starting to do is is corrupt the the the

524
00:29:46,003 --> 00:29:51,040
byte representation of the return

525
00:29:49,006 --> 00:29:54,049
address and so what happens for example

526
00:29:51,067 --> 00:29:58,075
here is that rather than trying to

527
00:29:54,049 --> 00:29:59,104
return back to the where call echo was

528
00:29:58,075 --> 00:30:01,168
supposed to where it was supposed to go

529
00:30:00,004 --> 00:30:06,007
back to it goes back to some other part

530
00:30:02,068 --> 00:30:08,095
of your code that may or may not be a

531
00:30:06,007 --> 00:30:10,051
valid address or might not have anything

532
00:30:08,095 --> 00:30:13,153
to do with the program you're trying to

533
00:30:10,051 --> 00:30:17,067
run so this example shows it and if I

534
00:30:14,053 --> 00:30:17,067
typed in the 24

535
00:30:21,002 --> 00:30:28,008
let's see before I got it to run like

536
00:30:26,001 --> 00:30:32,010
this you know this thing depends on the

537
00:30:28,026 --> 00:30:41,073
what happens how the code happens to get

538
00:30:32,019 --> 00:30:45,081
compiled oh yeah so okay so actually you

539
00:30:41,073 --> 00:30:47,115
see here this first string I typed is

540
00:30:45,081 --> 00:30:51,105
actually 24 characters long plus the

541
00:30:48,015 --> 00:30:54,063
null pointer so and we'll see why it

542
00:30:52,005 --> 00:30:56,088
didn't it should have crashed because we

543
00:30:54,063 --> 00:30:59,070
actually over I wrote the low order byte

544
00:30:56,088 --> 00:31:01,164
of the return address here we typed in

545
00:31:00,033 --> 00:31:03,096
this is 25 characters and so that's the

546
00:31:02,064 --> 00:31:06,078
one I just showed where it really

547
00:31:03,096 --> 00:31:08,148
whacked the two bytes of the return

548
00:31:06,078 --> 00:31:11,121
address so here we actually did overflow

549
00:31:09,048 --> 00:31:15,129
the buffer and let's try and figure out

550
00:31:12,021 --> 00:31:23,025
why that didn't harm the the program

551
00:31:16,029 --> 00:31:24,051
execution I see a question yes it could

552
00:31:23,025 --> 00:31:26,034
have been various other things could

553
00:31:24,051 --> 00:31:28,113
have there's nothing it hit a

554
00:31:27,015 --> 00:31:30,072
segmentation fault because it probably

555
00:31:29,013 --> 00:31:32,052
went to some weird part of the code and

556
00:31:30,072 --> 00:31:34,158
just started executing some random stuff

557
00:31:32,052 --> 00:31:37,104
and it just got itself into trouble but

558
00:31:35,058 --> 00:31:39,099
that's the point is it's not predictable

559
00:31:38,004 --> 00:31:42,020
exactly what will happen when you do

560
00:31:39,099 --> 00:31:41,120
this

561
00:31:51,076 --> 00:31:55,147
so this is that the example of what

562
00:31:54,043 --> 00:31:58,129
actually happened the first time when I

563
00:31:56,047 --> 00:32:01,072
typed in a string that had 24 characters

564
00:31:59,029 --> 00:32:04,104
and so this null byte at the end

565
00:32:01,072 --> 00:32:08,089
actually corrupted the return address

566
00:32:05,004 --> 00:32:13,057
and so it was supposed to return back to

567
00:32:08,089 --> 00:32:17,101
this address 400 6f6 and instead it will

568
00:32:13,057 --> 00:32:19,093
return back to the address 400 600 which

569
00:32:18,001 --> 00:32:22,036
happens to be in some other weird

570
00:32:19,093 --> 00:32:25,147
function that's there and it just sort

571
00:32:22,036 --> 00:32:29,053
of landed at some place here and it's

572
00:32:26,047 --> 00:32:32,068
doing various things but somehow it

573
00:32:29,053 --> 00:32:33,061
didn't really didn't crash the program

574
00:32:32,068 --> 00:32:36,073
and that's one of the frustrating things

575
00:32:34,033 --> 00:32:40,105
about this is that things can go wrong

576
00:32:37,018 --> 00:32:43,039
in a program and they don't always cause

577
00:32:41,005 --> 00:32:45,034
a crash and so often a bug that's

578
00:32:43,039 --> 00:32:50,131
working there might be doing some weird

579
00:32:45,034 --> 00:32:54,051
stuff that you don't even know about so

580
00:32:51,031 --> 00:32:58,033
that's all a fine if it's just a way of

581
00:32:54,051 --> 00:32:59,089
crashing programs and I mean that's not

582
00:32:58,033 --> 00:33:03,091
great if it's controlling your pacemaker

583
00:32:59,089 --> 00:33:05,104
or something like that but if it's just

584
00:33:03,091 --> 00:33:11,092
a homework assignment it's like not a

585
00:33:06,004 --> 00:33:15,066
big deal so uh but what actually and

586
00:33:11,092 --> 00:33:18,160
this is sort of only happened since

587
00:33:15,066 --> 00:33:22,090
attacking became a normal activity which

588
00:33:19,006 --> 00:33:24,013
has only been the last 30 years is that

589
00:33:22,009 --> 00:33:29,016
it gives an opportunity for a hacker or

590
00:33:25,003 --> 00:33:32,011
a attacker to inject code into the

591
00:33:29,097 --> 00:33:35,146
program and execute it and that's what's

592
00:33:33,001 --> 00:33:39,028
called a code injection attack and so

593
00:33:36,046 --> 00:33:41,053
the the general scheme of it is I have

594
00:33:39,037 --> 00:33:43,123
this buffer that I can fill up with

595
00:33:41,053 --> 00:33:45,145
whatever bytes I want by feeding them to

596
00:33:44,023 --> 00:33:49,042
get s or whatever function is doing this

597
00:33:46,045 --> 00:33:52,099
copying and what I can do then is set up

598
00:33:49,042 --> 00:33:55,111
and pass to it some bytes of actually

599
00:33:52,099 --> 00:33:57,142
that encode an executable a little bit

600
00:33:56,011 --> 00:34:00,085
of executable code you've seen an object

601
00:33:58,042 --> 00:34:02,128
dump it's printing out these bytecode

602
00:34:00,085 --> 00:34:04,183
representations of instructions so

603
00:34:03,028 --> 00:34:09,121
imagine you said some of those byte

604
00:34:05,083 --> 00:34:13,108
into your string you encoded them in the

605
00:34:10,021 --> 00:34:18,045
string that you pass to get us and then

606
00:34:14,008 --> 00:34:21,034
you might have to add some more sort of

607
00:34:18,045 --> 00:34:23,059
padding characters that characters whose

608
00:34:21,034 --> 00:34:27,093
value doesn't matter in order to then

609
00:34:23,059 --> 00:34:28,153
get a number back into the position

610
00:34:27,399 --> 00:34:32,500
where the return pointer is supposed to

611
00:34:29,053 --> 00:34:34,075
be and so what's call that number B it's

612
00:34:32,005 --> 00:34:37,164
going to be an address one of these ones

613
00:34:34,075 --> 00:34:40,156
with the you know that represents a

614
00:34:37,659 --> 00:34:44,740
stack location and that value B then is

615
00:34:41,056 --> 00:34:46,144
the starting address of the buffer which

616
00:34:44,074 --> 00:34:48,151
happens to be where your exploit code

617
00:34:47,044 --> 00:34:53,493
remember this is just executable

618
00:34:49,051 --> 00:34:55,080
instructions of were stored here so now

619
00:34:53,889 --> 00:35:02,380
what will happen is when the program

620
00:34:55,008 --> 00:35:04,027
does its return here it was supposed to

621
00:35:02,038 --> 00:35:07,277
return back to wherever it got called

622
00:35:04,099 --> 00:35:06,728
from P

623
00:35:10,071 --> 00:35:23,073
this is a typo P calls Q not far so it's

624
00:35:18,048 --> 00:35:25,074
supposed to return back to P and we're

625
00:35:23,091 --> 00:35:25,152
and the address the return address was

626
00:35:25,074 --> 00:35:27,156
stored here

627
00:35:26,052 --> 00:35:31,071
but now I've overwritten that return

628
00:35:28,056 --> 00:35:34,113
address with this buffer position so

629
00:35:31,071 --> 00:35:36,470
what will happen is the the program

630
00:35:35,013 --> 00:35:39,066
counter will happily jump to this spot

631
00:35:37,109 --> 00:35:41,880
and see start executing whatever it

632
00:35:39,066 --> 00:35:44,088
encounters which are the instructions

633
00:35:41,088 --> 00:35:47,169
that you've inserted and by that means

634
00:35:44,088 --> 00:35:50,142
then you can inject code into a machine

635
00:35:48,069 --> 00:35:52,143
potentially somewhere up in the Internet

636
00:35:51,042 --> 00:35:56,139
if you could set up a scheme like this

637
00:35:53,043 --> 00:35:59,222
that would feed these bytes into that

638
00:35:57,039 --> 00:36:01,101
machine and it would read it in with a

639
00:35:59,609 --> 00:36:04,050
function like get us and then it would

640
00:36:02,001 --> 00:36:06,830
try to do its return but it would start

641
00:36:04,005 --> 00:36:09,066
executing your code so that's the

642
00:36:06,839 --> 00:36:11,910
classic code injection attack and in

643
00:36:09,066 --> 00:36:14,070
fact in this lab that you're going to

644
00:36:11,091 --> 00:36:16,188
start it comes out at midnight called

645
00:36:14,007 --> 00:36:23,906
the attack lab because you're going to

646
00:36:17,088 --> 00:36:25,089
do this yourself for part of the lab and

647
00:36:24,599 --> 00:36:33,300
I think you'll find it pretty

648
00:36:25,098 --> 00:36:37,179
interesting so this used to be a huge

649
00:36:33,003 --> 00:36:42,062
problem on programs yet so when you're

650
00:36:38,079 --> 00:36:44,121
trying to replace read I make sure that

651
00:36:42,359 --> 00:36:47,700
your new submitted read overrides that

652
00:36:45,021 --> 00:36:49,113
exactly well that's part of the cover

653
00:36:47,007 --> 00:36:50,082
nets of being a hacker you have to make

654
00:36:50,013 --> 00:36:53,076
sure it's in the right spot

655
00:36:51,045 --> 00:36:56,091
but it's actually one of the easier

656
00:36:53,076 --> 00:37:00,150
parts because for example we do know you

657
00:36:56,091 --> 00:37:03,770
have to know the binary code to be able

658
00:37:01,005 --> 00:37:05,088
to do this or be able to guess so for

659
00:37:04,589 --> 00:37:08,580
example in that previous one I could

660
00:37:06,033 --> 00:37:11,040
tell that it was allocating 24 bytes for

661
00:37:08,058 --> 00:37:12,827
that buffer and so if I just made sure

662
00:37:11,004 --> 00:37:17,007
that the length of my exploit code plus

663
00:37:13,349 --> 00:37:18,990
the padding is 24 bytes then right after

664
00:37:17,043 --> 00:37:20,064
that comes to the return address so

665
00:37:18,099 --> 00:37:20,107
that's actually pretty easy to do there

666
00:37:20,064 --> 00:37:22,093
was

667
00:37:21,007 --> 00:37:25,063
certainly how much memory programs uh no

668
00:37:22,093 --> 00:37:30,166
you have to have access you have to what

669
00:37:25,063 --> 00:37:32,125
the reason why this works is it works if

670
00:37:31,066 --> 00:37:34,105
you have enough knowledge about the

671
00:37:33,025 --> 00:37:36,121
operating system that's running at the

672
00:37:35,005 --> 00:37:40,042
other end for example you know it's

673
00:37:37,021 --> 00:37:43,090
Linux you know that you can look at

674
00:37:40,042 --> 00:37:45,079
either what GCC tends to allocate for it

675
00:37:43,009 --> 00:37:50,103
you somehow have access to information

676
00:37:45,079 --> 00:37:51,084
about the code itself lets you do this

677
00:37:55,084 --> 00:38:00,089
so anyways this used to be a huge

678
00:37:58,016 --> 00:38:04,019
problem and it started way back in 1988

679
00:38:00,089 --> 00:38:07,148
the first internet attack was called the

680
00:38:04,019 --> 00:38:11,024
Morris worm and it at the time the

681
00:38:08,048 --> 00:38:12,074
internet was not a very big place and it

682
00:38:11,024 --> 00:38:15,032
basically brought down a huge fraction

683
00:38:12,074 --> 00:38:15,172
of the machines that were on the

684
00:38:15,032 --> 00:38:20,036
internet at the time

685
00:38:16,072 --> 00:38:21,137
interestingly enough CMU did not fall

686
00:38:20,072 --> 00:38:25,073
victim to this attack because we'd

687
00:38:22,037 --> 00:38:32,042
patched already the vulnerabilities that

688
00:38:25,073 --> 00:38:33,137
this particular program exploited and

689
00:38:32,042 --> 00:38:35,084
that was the cause that the software

690
00:38:34,037 --> 00:38:37,121
engineering Institute runs an

691
00:38:35,084 --> 00:38:40,100
organization called cert the computer

692
00:38:38,021 --> 00:38:44,120
emergency response team and that team

693
00:38:41,000 --> 00:38:50,033
was set up in response to this attack

694
00:38:45,002 --> 00:38:52,058
the Morris worm attack will also see an

695
00:38:50,033 --> 00:38:55,088
interesting example between two

696
00:38:52,076 --> 00:38:58,129
companies in in messaging services and

697
00:38:55,088 --> 00:39:01,127
many others it's been the sort of

698
00:38:59,029 --> 00:39:04,082
standard attack mechanism for many years

699
00:39:02,027 --> 00:39:07,055
and fortunately nowadays there's a few

700
00:39:04,082 --> 00:39:09,134
things that make the attacking of less

701
00:39:07,055 --> 00:39:12,056
likely to be successful and so it's not

702
00:39:10,034 --> 00:39:13,109
as huge a problem as it used to be but

703
00:39:12,056 --> 00:39:20,057
still it's a source of many

704
00:39:14,009 --> 00:39:22,085
vulnerabilities in programs so let's see

705
00:39:20,066 --> 00:39:23,066
I won't talk too much about this but it

706
00:39:22,085 --> 00:39:25,087
used to be

707
00:39:23,066 --> 00:39:28,157
in the original implementation of

708
00:39:25,087 --> 00:39:30,164
there's a command that most systems have

709
00:39:29,057 --> 00:39:33,061
now disabled that you could finger you

710
00:39:31,064 --> 00:39:35,135
could across the information about

711
00:39:33,061 --> 00:39:37,106
somebody in some remote location it

712
00:39:36,035 --> 00:39:41,132
would send a message to that location

713
00:39:38,006 --> 00:39:44,075
and then it would reply back and it used

714
00:39:42,032 --> 00:39:47,078
get assets on the actual original

715
00:39:44,075 --> 00:39:50,084
implementation called get s to read the

716
00:39:47,078 --> 00:39:52,105
input string from that was being sent to

717
00:39:50,084 --> 00:39:52,105
it

718
00:39:55,015 --> 00:40:00,019
and then there is an interesting one you

719
00:39:57,999 --> 00:40:04,032
guys don't remember messaging instant

720
00:40:00,019 --> 00:40:05,898
messaging but before it used to be that

721
00:40:04,329 --> 00:40:09,160
people would talk to each other on their

722
00:40:06,069 --> 00:40:12,090
computers by sending messages sort of

723
00:40:09,016 --> 00:40:15,039
like you send text messages today but

724
00:40:12,279 --> 00:40:19,331
there is an interesting thing that

725
00:40:15,039 --> 00:40:22,248
there's a company still exist but it's a

726
00:40:19,799 --> 00:40:24,855
shadow of its former self called AOL

727
00:40:22,599 --> 00:40:26,664
which ran the most popular Internet

728
00:40:25,359 --> 00:40:29,950
services and had the most popular

729
00:40:27,249 --> 00:40:32,920
instant messaging program and Microsoft

730
00:40:29,095 --> 00:40:33,444
came out with its own client its own

731
00:40:32,092 --> 00:40:36,171
program that you could run on your

732
00:40:34,299 --> 00:40:40,180
machine and communicate to other people

733
00:40:36,999 --> 00:40:41,650
on this messaging system so the

734
00:40:40,018 --> 00:40:44,092
Microsoft code was running on your

735
00:40:41,065 --> 00:40:47,274
machine but it would use the servers

736
00:40:44,092 --> 00:40:52,171
that were being run by AOL to manage

737
00:40:47,859 --> 00:40:59,859
this messaging traffic and the funny

738
00:40:53,071 --> 00:41:02,370
story was over that the this Microsoft

739
00:40:59,859 --> 00:41:05,170
program would work fine you can

740
00:41:03,009 --> 00:41:07,044
communicate with your friends who had

741
00:41:05,017 --> 00:41:09,576
different messaging clients and it all

742
00:41:07,359 --> 00:41:10,452
seemed compatible but then suddenly the

743
00:41:09,729 --> 00:41:13,690
people that were running the Microsoft

744
00:41:11,289 --> 00:41:15,940
version of the software it wouldn't work

745
00:41:13,069 --> 00:41:17,988
and then Microsoft people figured out

746
00:41:15,094 --> 00:41:18,903
how to patch it and then it would work

747
00:41:18,609 --> 00:41:21,675
for a while and then it wouldn't work

748
00:41:19,749 --> 00:41:25,450
and the way what was happening was a o/l

749
00:41:22,269 --> 00:41:29,271
was using a bug in its own code to be

750
00:41:25,045 --> 00:41:32,874
able to determine who's basically peek

751
00:41:29,469 --> 00:41:36,555
into the the machines on the client side

752
00:41:33,279 --> 00:41:38,355
and do a buffer overflow attack on your

753
00:41:37,329 --> 00:41:41,343
code that were you running on your

754
00:41:39,039 --> 00:41:44,680
machine and then basically peek around

755
00:41:41,469 --> 00:41:45,477
and see does this look like AOL coders

756
00:41:44,068 --> 00:41:48,115
it's something or is it some foreign

757
00:41:46,269 --> 00:41:53,295
code and so is basically able to use its

758
00:41:49,015 --> 00:41:57,624
own security weakness to figure out this

759
00:41:53,529 --> 00:42:03,537
information and that got disclosed by a

760
00:41:57,759 --> 00:42:07,930
sort of funny message from somebody who

761
00:42:04,329 --> 00:42:08,382
called himself filled buckin and it was

762
00:42:07,093 --> 00:42:10,117
determined that

763
00:42:08,859 --> 00:42:17,470
this email originated from somewhere

764
00:42:11,017 --> 00:42:18,876
within Microsoft so anyways that the and

765
00:42:17,047 --> 00:42:21,088
you can read more about it in the book

766
00:42:19,029 --> 00:42:23,710
around the slide so fun stories so in

767
00:42:21,088 --> 00:42:24,717
general in the security world you're

768
00:42:23,071 --> 00:42:26,116
supposed to distinguish between the idea

769
00:42:25,509 --> 00:42:28,509
of a worm and a virus although people

770
00:42:27,016 --> 00:42:31,021
aren't very good at doing that

771
00:42:28,509 --> 00:42:33,561
so worm is a program that can run on its

772
00:42:31,066 --> 00:42:36,094
own and propagate itself from one place

773
00:42:34,029 --> 00:42:39,910
to the other replicated a virus is like

774
00:42:36,094 --> 00:42:41,763
a biological virus it doesn't live on

775
00:42:39,091 --> 00:42:44,010
its own it works by attacking a program

776
00:42:42,609 --> 00:42:53,440
and basically modifying that program's

777
00:42:44,829 --> 00:42:55,450
behavior so that can see the basic idea

778
00:42:53,044 --> 00:42:57,363
of buffer overflows and you'll see it

779
00:42:55,045 --> 00:43:01,104
more first hand so let's look at

780
00:42:57,759 --> 00:43:03,765
techniques that machines can use to

781
00:43:01,509 --> 00:43:06,540
avoid to make themselves less vulnerable

782
00:43:03,819 --> 00:43:09,822
to these attacks well first of all you

783
00:43:06,819 --> 00:43:11,892
the application or the writer on the

784
00:43:10,119 --> 00:43:16,150
server side can write code that's more

785
00:43:12,549 --> 00:43:18,594
secure so for example what you're

786
00:43:16,015 --> 00:43:21,624
supposed to do instead of get ass as use

787
00:43:18,999 --> 00:43:25,002
a function called F get us an F getta

788
00:43:21,759 --> 00:43:27,880
has the property that it passes a

789
00:43:25,029 --> 00:43:31,056
parameter which is the maximum number of

790
00:43:27,088 --> 00:43:34,197
bytes that the program should read and

791
00:43:31,299 --> 00:43:38,325
it's there's more bytes than that in the

792
00:43:34,989 --> 00:43:41,680
input it will just truncate the input so

793
00:43:38,559 --> 00:43:44,637
on you're really supposed to use F get

794
00:43:41,068 --> 00:43:46,123
us and give a limit similarly stur copy

795
00:43:45,339 --> 00:43:49,434
there is a version of it called stern

796
00:43:47,023 --> 00:43:53,047
copy where you can give a limit and with

797
00:43:50,289 --> 00:43:55,338
a scanf you're supposed to be careful

798
00:43:53,047 --> 00:43:57,091
about using the percent s and there's

799
00:43:55,779 --> 00:44:02,170
even a terminology you can say percent

800
00:43:57,091 --> 00:44:02,173
give a number that the maximum length of

801
00:44:02,017 --> 00:44:05,071
the string it should read so these

802
00:44:03,073 --> 00:44:08,582
various places you can protect your code

803
00:44:05,071 --> 00:44:12,088
to make sure it won't overflow buffers

804
00:44:09,239 --> 00:44:16,390
unfortunately and a lot of code has been

805
00:44:12,088 --> 00:44:17,757
you'd call it hardening it's been people

806
00:44:16,039 --> 00:44:20,047
have gone through it and it's a lot of

807
00:44:18,549 --> 00:44:22,210
work because there's a lot of places in

808
00:44:20,047 --> 00:44:22,088
programs where you're copying strings

809
00:44:22,021 --> 00:44:24,640
from one point

810
00:44:22,088 --> 00:44:25,142
to another and there are a lot of real

811
00:44:24,829 --> 00:44:30,907
subtleties like when you're converting

812
00:44:26,042 --> 00:44:32,099
from Unicode to bytes and so forth that

813
00:44:31,609 --> 00:44:36,140
you're going back and forth between

814
00:44:32,099 --> 00:44:37,678
different character encodings but for

815
00:44:36,014 --> 00:44:40,693
the large part and these tools that the

816
00:44:38,569 --> 00:44:43,576
code developers have created to help

817
00:44:40,819 --> 00:44:45,874
track down these bugs so it's become a

818
00:44:44,269 --> 00:44:48,890
little bit safer out there but there's

819
00:44:46,369 --> 00:44:51,500
still vulnerabilities so then there's

820
00:44:48,089 --> 00:44:53,141
other parts where you just try to build

821
00:44:51,005 --> 00:44:56,314
in safeguards into the system that would

822
00:44:54,041 --> 00:44:58,124
make it much harder to do a buffer

823
00:44:56,809 --> 00:45:01,910
overflow exploit like I showed you and

824
00:44:59,024 --> 00:45:04,363
so one of them is called stack

825
00:45:01,091 --> 00:45:11,092
randomization or it goes by a more

826
00:45:04,579 --> 00:45:18,230
general term that's abbreviated aslr

827
00:45:11,092 --> 00:45:19,144
which stands for address space layout

828
00:45:18,023 --> 00:45:20,044
randomization

829
00:45:24,004 --> 00:45:31,017
and the idea that is to make it so every

830
00:45:27,049 --> 00:45:35,107
time a program run the addresses change

831
00:45:31,017 --> 00:45:38,050
a little bit or a lot so that you can't

832
00:45:36,007 --> 00:45:41,008
reliably know where things are going to

833
00:45:38,005 --> 00:45:43,014
be in the code so imagine for example

834
00:45:41,008 --> 00:45:47,062
the and the way it's implemented is

835
00:45:44,004 --> 00:45:49,096
before in the sort of run-up of your

836
00:45:47,062 --> 00:45:53,077
program when it first starts up but

837
00:45:50,032 --> 00:45:56,038
before your main routine gets called it

838
00:45:53,077 --> 00:45:57,139
will just do allocation on the stack of

839
00:45:56,038 --> 00:46:00,120
some random number of bytes and storage

840
00:45:58,039 --> 00:46:03,094
a fair amount like maybe a megabyte

841
00:46:01,002 --> 00:46:06,085
roughly of storage where the exact

842
00:46:03,094 --> 00:46:09,121
number is randomly chosen and what that

843
00:46:07,003 --> 00:46:13,006
means is that the the dress of the stack

844
00:46:10,021 --> 00:46:16,090
of all the different positions of your

845
00:46:13,033 --> 00:46:19,045
ear all the local storage on the stack

846
00:46:16,009 --> 00:46:23,043
will shift up and down from one run to

847
00:46:19,045 --> 00:46:27,144
another and we can actually see that in

848
00:46:24,024 --> 00:46:28,026
this example I showed

849
00:46:32,839 --> 00:46:39,540
so I have a program here it's not a very

850
00:46:36,042 --> 00:46:42,089
interesting program I'll show you except

851
00:46:39,054 --> 00:46:42,089
to demonstrate these ideas

852
00:46:44,849 --> 00:46:51,160
all it's doing is there's some code it's

853
00:46:48,609 --> 00:46:52,704
based on that one I already showed code

854
00:46:51,016 --> 00:46:57,100
locate but this one there's a global

855
00:46:53,559 --> 00:47:00,160
variable there's some functions there's

856
00:46:58,000 --> 00:47:03,369
something that gets allocated by malloc

857
00:47:00,016 --> 00:47:05,098
and there's something that is a local

858
00:47:03,369 --> 00:47:08,170
variable stored on the stack and so what

859
00:47:05,098 --> 00:47:10,150
I'll do is show addresses that are

860
00:47:08,017 --> 00:47:14,053
chosen the address of this variable then

861
00:47:11,005 --> 00:47:17,094
will be a stack address a local of a

862
00:47:14,053 --> 00:47:19,842
local variable global will be this one

863
00:47:17,589 --> 00:47:23,020
that gets allocated globally the heap is

864
00:47:20,319 --> 00:47:26,440
something allocated with malloc and then

865
00:47:23,002 --> 00:47:31,098
the this function useless will count as

866
00:47:26,044 --> 00:47:31,098
a code address and now when I run it

867
00:47:33,569 --> 00:47:38,500
you'll see from one run to another that

868
00:47:36,049 --> 00:47:40,120
if some of these stay the same and some

869
00:47:38,005 --> 00:47:45,084
of them change so in particular the

870
00:47:41,002 --> 00:47:52,611
global variable is the same 600 102 C

871
00:47:45,579 --> 00:47:56,650
and the code is the same for double O 5

872
00:47:52,809 --> 00:47:59,530
900 is the same every execution but

873
00:47:56,065 --> 00:48:02,079
you'll see this local variable it's on a

874
00:47:59,053 --> 00:48:04,129
stack address but you see that the lower

875
00:48:02,079 --> 00:48:08,628
half dozen or so bikes are actually

876
00:48:05,029 --> 00:48:16,117
changing from one run to another 1 2 3 4

877
00:48:09,339 --> 00:48:21,010
5 so 5 bytes of it but 5 hex digits I'm

878
00:48:17,017 --> 00:48:23,038
sorry so that's 2 to the 20th so roughly

879
00:48:21,001 --> 00:48:26,023
a megabyte of variation is going on in

880
00:48:23,038 --> 00:48:28,042
stack addresses there and similarly

881
00:48:26,023 --> 00:48:32,023
you'll see that the heap addresses are

882
00:48:28,078 --> 00:48:33,142
also varying from one to another from

883
00:48:32,023 --> 00:48:36,088
one execution to the other so malloc has

884
00:48:34,042 --> 00:48:40,045
built into it some amount of randomness

885
00:48:36,088 --> 00:48:43,167
to in its allocation so what why setec

886
00:48:40,072 --> 00:48:47,079
you know what's the purpose of that well

887
00:48:44,067 --> 00:48:52,236
as I told you this code injection

888
00:48:47,079 --> 00:48:54,172
vulnerability relies on the fact that

889
00:48:52,839 --> 00:48:57,380
you can you can load up this buffer with

890
00:48:55,072 --> 00:49:00,155
some executable code

891
00:48:57,038 --> 00:49:04,073
but somehow you have to know how to get

892
00:49:01,055 --> 00:49:07,058
to the start of that code and this is

893
00:49:04,073 --> 00:49:08,150
relying the attack is relying on the

894
00:49:07,058 --> 00:49:14,114
fact that it can somehow predict what

895
00:49:09,005 --> 00:49:16,034
the this address of the buffer is and so

896
00:49:15,014 --> 00:49:19,031
that it can store it in the right part

897
00:49:16,079 --> 00:49:20,081
of the string put it encoded in the

898
00:49:19,031 --> 00:49:22,034
right part of the string so it will show

899
00:49:20,081 --> 00:49:24,164
up where the return pointer is supposed

900
00:49:22,034 --> 00:49:27,131
to be and and have it jumped to that

901
00:49:25,064 --> 00:49:32,090
location but now with this randomization

902
00:49:28,031 --> 00:49:35,114
this number is varying by quite a bit

903
00:49:32,009 --> 00:49:37,061
sort of million over a range of a

904
00:49:36,014 --> 00:49:40,097
million or so values so there's no way

905
00:49:38,042 --> 00:49:42,050
in advance even if I have an exact copy

906
00:49:40,097 --> 00:49:46,133
of the code not even had access to the

907
00:49:43,022 --> 00:49:48,107
system itself and could run it I can't

908
00:49:47,033 --> 00:49:51,122
predict from one run to the next where

909
00:49:49,007 --> 00:49:55,085
it's going to be so that gives it sort

910
00:49:52,022 --> 00:50:01,039
of fort this particular attack to to

911
00:49:55,085 --> 00:50:00,139
make it using this randomization

912
00:50:02,077 --> 00:50:08,093
another idea that fairly straightforward

913
00:50:07,004 --> 00:50:14,051
but it took a long time for the hardware

914
00:50:08,093 --> 00:50:15,116
people to implement this is well why why

915
00:50:14,051 --> 00:50:17,129
is there supposed to be code on the

916
00:50:16,016 --> 00:50:20,042
stack in the first place isn't the code

917
00:50:18,029 --> 00:50:23,078
supposed to be located down in the text

918
00:50:20,042 --> 00:50:26,051
segment where it can be sued especially

919
00:50:23,078 --> 00:50:30,140
identified as being executable so in the

920
00:50:27,032 --> 00:50:34,073
original x86 there's a one bit flag for

921
00:50:31,004 --> 00:50:38,045
each region of memory saying is it

922
00:50:34,073 --> 00:50:41,147
actually - one bit flags one is can this

923
00:50:38,081 --> 00:50:43,154
be written to so that you can prevent

924
00:50:42,047 --> 00:50:48,110
overwrite so things like string

925
00:50:44,054 --> 00:50:51,128
constants and so and then the other is

926
00:50:49,001 --> 00:50:54,044
am I can I read it and read means access

927
00:50:52,028 --> 00:50:56,045
those bytes and it was interpreted that

928
00:50:54,053 --> 00:50:59,096
readable and executable were the same

929
00:50:56,045 --> 00:51:04,052
thing I can read it I can execute it and

930
00:50:59,096 --> 00:51:06,101
that was the rule in a sort of last 10

931
00:51:04,052 --> 00:51:09,146
years or so starting first with AMD and

932
00:51:07,046 --> 00:51:12,119
then Intel have added a third bit that

933
00:51:10,046 --> 00:51:14,144
says is this executable or not similarly

934
00:51:13,019 --> 00:51:17,096
to the permissions you have on a file on

935
00:51:15,044 --> 00:51:19,130
UNIX is it readable writable executable

936
00:51:17,096 --> 00:51:23,102
those are three separate permission bits

937
00:51:20,003 --> 00:51:27,050
that are alone so by simply marking the

938
00:51:24,056 --> 00:51:29,081
stack is not executable it'll also port

939
00:51:27,077 --> 00:51:31,088
this particular attack because I have to

940
00:51:29,081 --> 00:51:34,129
be able to execute these bytes as I've

941
00:51:31,088 --> 00:51:34,129
injected into the system

942
00:51:36,059 --> 00:51:41,147
and then there's the final idea which is

943
00:51:39,065 --> 00:51:44,102
actually fairly effective - which they

944
00:51:42,047 --> 00:51:45,125
call a canary that they built into the

945
00:51:45,002 --> 00:51:47,096
stack and some of you actually

946
00:51:46,025 --> 00:51:49,061
encountered this code already and

947
00:51:47,096 --> 00:51:52,124
looking at your bombs because we've been

948
00:51:49,061 --> 00:51:56,095
getting some questions about it so let

949
00:51:53,024 --> 00:51:56,095
me just give you an example here

950
00:52:04,076 --> 00:52:09,078
and this one's called buff demo - SP

951
00:52:07,089 --> 00:52:16,188
because it's been compiled with what

952
00:52:09,096 --> 00:52:19,155
they call stack protector and this one

953
00:52:17,088 --> 00:52:21,125
now it's the same code as before it's

954
00:52:20,055 --> 00:52:24,099
just compiled a little bit differently

955
00:52:22,025 --> 00:52:28,104
what you'll find is I can give a string

956
00:52:24,099 --> 00:52:34,173
of length 8 and not have a problem but

957
00:52:29,004 --> 00:52:37,098
if I now have 9 characters it will dump

958
00:52:35,073 --> 00:52:45,074
out with this very strange exit error

959
00:52:37,098 --> 00:52:48,105
message that is an indication that it

960
00:52:45,074 --> 00:52:50,139
detected a attempt to smash the stack so

961
00:52:49,068 --> 00:52:54,093
buffer overflow is sometimes called

962
00:52:51,039 --> 00:52:57,051
stack smashing so it detected somehow

963
00:52:54,093 --> 00:53:00,099
that even though I my code was still the

964
00:52:57,051 --> 00:53:02,109
same old crappy code from before of a

965
00:53:00,099 --> 00:53:05,157
very small buffer allocation and no

966
00:53:03,009 --> 00:53:11,013
protection somehow the the system

967
00:53:06,057 --> 00:53:13,098
protected me from myself and that's a

968
00:53:11,013 --> 00:53:18,084
via a relatively simple trick that's

969
00:53:13,098 --> 00:53:21,192
fairly clever though what they call step

970
00:53:18,084 --> 00:53:25,086
canary so that the term canary comes

971
00:53:22,092 --> 00:53:28,179
back from a back in the coal mining days

972
00:53:26,004 --> 00:53:31,089
of old before they had very good ways of

973
00:53:29,079 --> 00:53:34,083
measuring things they take a bird down

974
00:53:31,089 --> 00:53:37,163
with them in a cage and a canary is a

975
00:53:34,083 --> 00:53:42,138
property that's very susceptible to

976
00:53:38,063 --> 00:53:45,069
dying if there's nothing if there's

977
00:53:43,038 --> 00:53:47,061
methane gas present so these miners

978
00:53:46,023 --> 00:53:50,097
would be down there working and they'd

979
00:53:47,061 --> 00:53:52,148
see their bird keel over and say oh we

980
00:53:50,097 --> 00:53:54,195
got a problem here what get out fast so

981
00:53:53,048 --> 00:53:57,072
that's why they call it a canary in a

982
00:53:55,095 --> 00:53:58,176
coal mine sometimes some kind of warning

983
00:53:57,072 --> 00:54:03,150
signal that that something's not not

984
00:53:59,076 --> 00:54:07,101
right here and in general we see a GCC

985
00:54:04,005 --> 00:54:11,031
if you invoke it with a stack protector

986
00:54:08,001 --> 00:54:13,045
nowadays that's the default so even

987
00:54:11,076 --> 00:54:18,094
without you saying anything

988
00:54:13,045 --> 00:54:20,107
this code will get built into it and so

989
00:54:18,094 --> 00:54:21,753
let's look at what that canary code

990
00:54:21,007 --> 00:54:24,013
looks like and how it does its thing

991
00:54:22,599 --> 00:54:26,622
it's really pretty clever as I said and

992
00:54:24,067 --> 00:54:30,090
some of you have already observed this

993
00:54:26,829 --> 00:54:33,460
strange kind of memory reference in a

994
00:54:30,009 --> 00:54:35,014
register reference in the code and your

995
00:54:33,046 --> 00:54:37,093
BOM labs because it it was compiled with

996
00:54:35,095 --> 00:54:40,096
this deck protecting enabled because

997
00:54:37,093 --> 00:54:44,101
that's the default and so in particular

998
00:54:40,096 --> 00:54:48,142
what this code shows is it allocating as

999
00:54:45,073 --> 00:54:51,100
before 24 bytes on the stack but now

1000
00:54:49,042 --> 00:54:54,097
it's getting some number and we'll talk

1001
00:54:52,000 --> 00:55:00,046
in a second what that means and storing

1002
00:54:54,097 --> 00:55:01,956
it at position 8 offset from the stack

1003
00:55:00,046 --> 00:55:05,065
pointer and then the rest of the code

1004
00:55:02,829 --> 00:55:08,740
and then it zeros it out that's not to

1005
00:55:05,065 --> 00:55:10,102
worry and then it looks like the your

1006
00:55:08,074 --> 00:55:12,933
previous code that it's passing a

1007
00:55:11,002 --> 00:55:18,351
pointer to the stack the top of the

1008
00:55:13,599 --> 00:55:20,625
stack as the argument to get us and get

1009
00:55:18,369 --> 00:55:23,380
us it gets called and then put s gets

1010
00:55:20,859 --> 00:55:26,890
called but now there's some more code

1011
00:55:23,038 --> 00:55:29,007
here that is it involves this

1012
00:55:26,089 --> 00:55:30,103
strange-looking register and then

1013
00:55:29,349 --> 00:55:37,374
there's some kind of test and then if

1014
00:55:31,003 --> 00:55:40,015
that tests fail it will call this a code

1015
00:55:37,599 --> 00:55:44,200
that you just saw printed out this error

1016
00:55:40,015 --> 00:55:49,224
message so let's see what that all means

1017
00:55:44,002 --> 00:55:52,006
what that means is that it offset 8 from

1018
00:55:49,359 --> 00:55:56,800
the stack pointer it's putting in 8

1019
00:55:52,024 --> 00:56:01,105
bytes of value that it's retrieving from

1020
00:55:56,008 --> 00:56:04,012
a special register so FS is a reference

1021
00:56:02,005 --> 00:56:08,014
to a type of register that was created

1022
00:56:05,002 --> 00:56:10,003
for the original 8086 and is now

1023
00:56:08,014 --> 00:56:12,097
completely obsolete but it's still there

1024
00:56:10,021 --> 00:56:15,055
for backward compatibility mode but what

1025
00:56:12,097 --> 00:56:16,476
it is is and I actually I looked and

1026
00:56:15,055 --> 00:56:19,120
I've never fully been able to find the

1027
00:56:17,349 --> 00:56:22,810
documentation on it it's able to read

1028
00:56:20,002 --> 00:56:27,057
from a part of memory a set of values

1029
00:56:22,081 --> 00:56:31,099
that you can't otherwise get to

1030
00:56:27,075 --> 00:56:34,081
and so that the Khmer canary is getting

1031
00:56:31,099 --> 00:56:36,178
a somehow its grabbing eight bytes from

1032
00:56:34,081 --> 00:56:41,158
somewhere storing it as this canary

1033
00:56:37,078 --> 00:56:45,127
value and then if you give like a seven

1034
00:56:42,058 --> 00:56:48,058
character input so you would affect the

1035
00:56:46,027 --> 00:56:54,094
canary and so what happens when it

1036
00:56:48,058 --> 00:56:57,085
returns from the two calls from get us

1037
00:56:54,094 --> 00:57:01,099
and put us before it exits what it's

1038
00:56:57,085 --> 00:57:04,122
trying to detect is has anything as this

1039
00:57:01,099 --> 00:57:07,102
buffer somehow overflowed and

1040
00:57:05,022 --> 00:57:09,120
potentially at risk of of corrupting

1041
00:57:08,029 --> 00:57:12,070
some other part of the stack so

1042
00:57:10,002 --> 00:57:17,023
basically what it does is it retrieves

1043
00:57:12,007 --> 00:57:19,069
back from the stack what is the current

1044
00:57:17,041 --> 00:57:23,095
value of this canary and it's comparing

1045
00:57:20,032 --> 00:57:25,129
it to what it should be by retrieving

1046
00:57:23,095 --> 00:57:29,137
that back from this special region and

1047
00:57:26,029 --> 00:57:32,035
if they're equal it says fine but if

1048
00:57:30,037 --> 00:57:33,112
they're not equal it's detecting that

1049
00:57:32,035 --> 00:57:34,120
it's got corrupted so just like the

1050
00:57:34,012 --> 00:57:37,105
canary in the coalmine

1051
00:57:35,002 --> 00:57:40,006
if these bytes get corrupted in any form

1052
00:57:38,005 --> 00:57:45,082
it's an indication that something went

1053
00:57:40,024 --> 00:57:48,112
wrong now that example shows that if I

1054
00:57:45,082 --> 00:57:51,178
have a seven character string then I'm

1055
00:57:49,012 --> 00:57:54,040
not going to corrupt the canary but you

1056
00:57:52,078 --> 00:58:00,169
notice I just got away with an eight

1057
00:57:54,004 --> 00:58:04,008
character string so let me just see

1058
00:58:01,069 --> 00:58:04,080
what's going on here

1059
00:58:30,002 --> 00:58:38,023
I won a character string right oh please

1060
00:58:35,075 --> 00:58:37,123
lately

1061
00:58:42,092 --> 00:58:47,971
so I have to look I don't have the code

1062
00:58:45,479 --> 00:58:48,511
in front of me so I have to look at

1063
00:58:52,099 --> 00:59:00,196
so anyways here's where it's subtracting

1064
00:58:57,759 --> 00:59:02,854
24 from the stack pointer and then the

1065
00:59:01,069 --> 00:59:05,930
next instruction is retrieving this

1066
00:59:03,709 --> 00:59:09,880
canary values so let's figure out what

1067
00:59:05,093 --> 00:59:08,188
the canary is right now we are at

1068
00:59:16,109 --> 00:59:29,156
72f so we're at the first instruction

1069
00:59:19,003 --> 00:59:29,552
here let's do another step

1070
00:59:39,031 --> 00:59:47,063
so this is the canary and it you'll see

1071
00:59:45,349 --> 00:59:49,700
actually when from 100 others get a

1072
00:59:47,063 --> 00:59:50,072
different value of it so it's perfectly

1073
00:59:49,007 --> 00:59:53,015
put in there in a way that it's

1074
00:59:51,053 --> 00:59:55,115
unpredictable the one thing you'll

1075
00:59:54,005 --> 01:00:00,044
notice is that the low order byte is

1076
00:59:56,015 --> 01:00:02,944
zeroes and so apparently they knew that

1077
01:00:00,089 --> 01:00:04,018
it's so common to have so to off-by-one

1078
01:00:03,079 --> 01:00:07,190
bugs with strings where you don't

1079
01:00:04,819 --> 01:00:08,060
allocate enough space for the null

1080
01:00:07,019 --> 01:00:11,063
terminator

1081
01:00:08,006 --> 01:00:13,052
that they said well rather than having a

1082
01:00:11,063 --> 01:00:14,114
canary that will detect that byte being

1083
01:00:13,052 --> 01:00:17,138
corrupted we'll just sort of give that

1084
01:00:15,014 --> 01:00:21,098
byte away and so that's why it's letting

1085
01:00:18,038 --> 01:00:24,487
me type in eight characters and it's

1086
01:00:21,098 --> 01:00:27,101
overriding this low order byte of the

1087
01:00:24,829 --> 01:00:29,907
canary later on but that's not going to

1088
01:00:28,001 --> 01:00:30,600
affect anything

1089
01:00:52,049 --> 01:00:58,388
but let's give it 9 characters 10

1090
01:00:56,022 --> 01:01:00,116
characters to training a 9 character

1091
01:00:58,829 --> 01:01:01,160
string

1092
01:01:15,039 --> 01:01:17,039
Oh

1093
01:01:48,088 --> 01:01:50,088
ah

1094
01:01:51,091 --> 01:02:03,950
oh well I'm not finding it where I

1095
01:01:59,005 --> 01:02:04,274
thought it would be anyways oh this will

1096
01:02:06,075 --> 01:02:11,334
crop this deck but what I is showing you

1097
01:02:10,059 --> 01:02:13,720
the main idea is the canary some value

1098
01:02:12,009 --> 01:02:16,020
that gets pulled out and it will vary

1099
01:02:13,072 --> 01:02:17,661
from one time to the next and it's

1100
01:02:16,119 --> 01:02:20,890
letting you get away with eight

1101
01:02:18,309 --> 01:02:22,990
characters plus the null terminator but

1102
01:02:20,089 --> 01:02:24,758
anything more and it will detect that

1103
01:02:22,099 --> 01:02:24,668
corruption

1104
01:02:38,002 --> 01:02:43,024
okay so now we've seen three different

1105
01:02:40,068 --> 01:02:47,122
protections well for one is write better

1106
01:02:43,024 --> 01:02:49,096
code but there's three protections that

1107
01:02:48,022 --> 01:02:54,051
are done by the system that have nothing

1108
01:02:49,096 --> 01:02:53,151
to do with your code right one is to

1109
01:02:54,099 --> 01:02:59,104
randomize the stack position so it's

1110
01:02:58,039 --> 01:03:02,092
harder to figure out where the start

1111
01:03:00,004 --> 01:03:05,038
addresses are the second is to make the

1112
01:03:02,092 --> 01:03:07,138
stack so it's not executable so you

1113
01:03:05,038 --> 01:03:09,127
can't put code on that and then the

1114
01:03:08,038 --> 01:03:12,133
third is to use this deck canary or

1115
01:03:10,027 --> 01:03:16,105
other mechanisms to detect a potential

1116
01:03:13,033 --> 01:03:18,106
buffer overflow at the source so now

1117
01:03:17,005 --> 01:03:23,088
there's another attack that was

1118
01:03:19,006 --> 01:03:23,088
developed in response to some of these

1119
01:03:24,036 --> 01:03:30,061
that is still often successful it's

1120
01:03:28,000 --> 01:03:32,011
called return arted programming and for

1121
01:03:30,061 --> 01:03:33,109
your attack lab you're going to be doing

1122
01:03:32,011 --> 01:03:35,104
these attacks too that's why the tackle

1123
01:03:34,009 --> 01:03:39,013
AB is different than the old way of the

1124
01:03:36,004 --> 01:03:40,093
old web justed code injection exploits

1125
01:03:39,013 --> 01:03:44,104
now you're doing both code injections

1126
01:03:40,093 --> 01:03:49,096
and return oriented programming so the

1127
01:03:45,004 --> 01:03:53,026
idea this is if you are a hacker you're

1128
01:03:50,023 --> 01:03:55,080
frustrated because of these these three

1129
01:03:53,026 --> 01:03:58,114
techniques stack randomization

1130
01:03:55,008 --> 01:04:00,019
non-executable stack and Canaries well I

1131
01:03:59,014 --> 01:04:03,483
can't fix the canary problem that

1132
01:04:00,091 --> 01:04:04,179
actually the canary is a pretty secure

1133
01:04:03,609 --> 01:04:08,634
of

1134
01:04:05,079 --> 01:04:12,106
technique there's very I've never seen

1135
01:04:08,859 --> 01:04:15,100
anyone able to bypass a stet canary but

1136
01:04:13,006 --> 01:04:18,058
the other two you can do it using this

1137
01:04:15,001 --> 01:04:21,070
technique and the strategy is so we

1138
01:04:18,058 --> 01:04:24,085
don't know where the stack is but we

1139
01:04:21,079 --> 01:04:26,107
could still but we know where the code

1140
01:04:24,085 --> 01:04:30,097
is because you saw in that example the

1141
01:04:27,007 --> 01:04:32,104
code my layout randomization was

1142
01:04:30,097 --> 01:04:34,156
shifting the stack positions in the heap

1143
01:04:33,004 --> 01:04:40,023
positions but it wasn't changing either

1144
01:04:35,056 --> 01:04:43,132
global variables or or the code itself

1145
01:04:40,023 --> 01:04:47,029
so what if I can find some code that

1146
01:04:44,032 --> 01:04:49,104
sort of already there in the existing

1147
01:04:47,083 --> 01:04:53,124
part of the program

1148
01:04:50,004 --> 01:04:57,051
and use that instead of my own code that

1149
01:04:54,024 --> 01:04:59,046
I've injected and of course in general

1150
01:04:57,051 --> 01:05:00,135
you're not going to find exactly lying

1151
01:04:59,046 --> 01:05:03,138
there the exact program you want to

1152
01:05:01,035 --> 01:05:07,038
execute that will cause whatever harm

1153
01:05:04,038 --> 01:05:09,075
you intend to do because it's not

1154
01:05:07,038 --> 01:05:11,070
usually compiled into most programs but

1155
01:05:09,075 --> 01:05:17,094
if I could sort of string together

1156
01:05:11,007 --> 01:05:20,016
little segments of code and somehow put

1157
01:05:17,094 --> 01:05:23,100
together a series of little sequences of

1158
01:05:21,006 --> 01:05:26,007
code maybe I can get something useful

1159
01:05:24,000 --> 01:05:29,094
done and so that's the idea of this

1160
01:05:26,007 --> 01:05:31,014
return oriented programming and the idea

1161
01:05:29,094 --> 01:05:34,101
of it is to find what are known as

1162
01:05:32,004 --> 01:05:38,052
gadgets and a gadget is a sequence of

1163
01:05:35,064 --> 01:05:40,158
bytes that are represent part of the

1164
01:05:38,088 --> 01:05:44,187
executable program where the last byte

1165
01:05:41,058 --> 01:05:48,120
this is x86 talking here has a hex value

1166
01:05:45,087 --> 01:05:51,092
c3 which is how the RET instruction the

1167
01:05:49,002 --> 01:06:00,006
return instruction is encoded in x86

1168
01:05:52,037 --> 01:06:03,126
both ia-32 and x64 and so as an example

1169
01:06:00,006 --> 01:06:08,025
on the easy case is where there's some

1170
01:06:04,026 --> 01:06:10,119
function and it implements some

1171
01:06:08,079 --> 01:06:12,162
operation that I might find useful as an

1172
01:06:11,019 --> 01:06:16,104
attacker to be able to do so for example

1173
01:06:13,062 --> 01:06:19,083
this function is computing a times B

1174
01:06:17,004 --> 01:06:22,059
plus C and if I look at just the last

1175
01:06:19,083 --> 01:06:24,152
two instructions from there one of them

1176
01:06:22,059 --> 01:06:29,103
is a la which is performing addition and

1177
01:06:25,052 --> 01:06:31,146
the other is doing a return so I can

1178
01:06:30,003 --> 01:06:37,011
think of this this good old five bunk

1179
01:06:32,046 --> 01:06:40,089
byte chunk is a way if I could get some

1180
01:06:37,011 --> 01:06:43,014
data in registers R di and RDX then I

1181
01:06:40,089 --> 01:06:44,160
could compute their sum and stick it in

1182
01:06:43,041 --> 01:06:47,079
the RAS so imagine taking your program

1183
01:06:45,006 --> 01:06:48,102
you're trying to execute and breaking it

1184
01:06:47,079 --> 01:06:51,114
up into these little fragments and you

1185
01:06:49,056 --> 01:06:53,091
want to somehow find little block of

1186
01:06:52,014 --> 01:06:56,037
code somewhere to implement each of

1187
01:06:53,091 --> 01:06:57,189
these fragments and then the interesting

1188
01:06:56,037 --> 01:07:03,039
part is because they each end in C 3

1189
01:06:58,089 --> 01:07:02,182
this return as is it well let me get to

1190
01:07:03,057 --> 01:07:05,092
that

1191
01:07:03,082 --> 01:07:08,107
a minute so that's sort of the obvious

1192
01:07:05,092 --> 01:07:10,111
way that you pull out this is an

1193
01:07:09,007 --> 01:07:14,023
addition which you'd expect because that

1194
01:07:11,011 --> 01:07:17,038
was in the original C code but here's an

1195
01:07:14,023 --> 01:07:19,090
example of a gadget that has nothing to

1196
01:07:17,038 --> 01:07:23,079
do with the original C code it just

1197
01:07:19,009 --> 01:07:28,036
happens to match the bite pattern of

1198
01:07:23,079 --> 01:07:31,081
some existing code so this function

1199
01:07:29,017 --> 01:07:36,070
seems to not do anything too terribly

1200
01:07:31,099 --> 01:07:37,153
useful from hackers point of view but if

1201
01:07:36,007 --> 01:07:39,106
you look at this particular byte

1202
01:07:38,053 --> 01:07:44,068
sequence that happens to encode the

1203
01:07:40,069 --> 01:07:48,070
instruction move Q are a X to R di and C

1204
01:07:44,068 --> 01:07:52,159
3 encodes repped so and you can see if

1205
01:07:48,007 --> 01:07:58,105
this is at address 49 that's for D a for

1206
01:07:53,059 --> 01:08:02,085
DB for DC so it address 400 for DC if

1207
01:07:59,068 --> 01:08:05,077
you could start executing here it would

1208
01:08:02,085 --> 01:08:08,146
first do a move and then it would do a

1209
01:08:05,077 --> 01:08:11,101
return so I'm sort of taking advantage

1210
01:08:09,046 --> 01:08:15,117
of the fact in x86 it says by doing it

1211
01:08:12,001 --> 01:08:20,050
is instruction sequence and if I sort of

1212
01:08:16,017 --> 01:08:24,052
go off the aligned instructions I can

1213
01:08:20,005 --> 01:08:25,099
often find useful things to do so that's

1214
01:08:24,052 --> 01:08:27,151
what's called a gadget and you might ask

1215
01:08:26,044 --> 01:08:29,098
well what's so special about having them

1216
01:08:28,051 --> 01:08:32,113
end in a return

1217
01:08:29,098 --> 01:08:35,104
well imagine I could fill up my buffer

1218
01:08:33,013 --> 01:08:38,017
instead of with executable code I could

1219
01:08:36,058 --> 01:08:42,061
fill it up with a series of gadget

1220
01:08:38,053 --> 01:08:44,101
addresses so each gadget then is some

1221
01:08:42,088 --> 01:08:51,153
series of bytes where the final bite is

1222
01:08:45,001 --> 01:08:55,075
c3 and I'll actually position this as

1223
01:08:52,053 --> 01:08:57,067
not the oppositionists at some place

1224
01:08:55,075 --> 01:09:00,684
where you're actually going to do the

1225
01:08:57,067 --> 01:09:04,090
initial return instruction of from from

1226
01:09:01,359 --> 01:09:09,310
before so if I can somehow get the

1227
01:09:04,009 --> 01:09:11,071
program to return execute a rest right

1228
01:09:09,031 --> 01:09:14,119
now what it will do is return will pick

1229
01:09:12,052 --> 01:09:17,065
an address off of the stack pop an

1230
01:09:15,019 --> 01:09:19,024
address and begin execute

1231
01:09:17,065 --> 01:09:21,067
so that will start this code executing

1232
01:09:19,069 --> 01:09:24,115
and it will hit the c3 the RET

1233
01:09:21,085 --> 01:09:26,994
instruction at the end which will again

1234
01:09:25,015 --> 01:09:30,058
take a address pop it off the stack and

1235
01:09:27,759 --> 01:09:32,830
begin executing so start executing the

1236
01:09:30,058 --> 01:09:34,081
second gadget and so you'll see what

1237
01:09:32,083 --> 01:09:36,160
will happen is we're effectively

1238
01:09:34,081 --> 01:09:39,160
concatenating these pieces of code

1239
01:09:37,006 --> 01:09:42,052
together where it's using a ret to get

1240
01:09:40,006 --> 01:09:44,044
from one part the end of one gadget to

1241
01:09:43,006 --> 01:09:46,021
the start of the next and so that's

1242
01:09:44,098 --> 01:09:47,173
what's called return oriented

1243
01:09:46,021 --> 01:09:50,670
programming to wait instead of

1244
01:09:48,073 --> 01:09:52,392
sequencing programs using a program

1245
01:09:50,859 --> 01:09:56,080
counter like you normally do your

1246
01:09:53,049 --> 01:09:59,820
sequencing programs using the sort of

1247
01:09:56,008 --> 01:10:04,042
peculiar behavior of this particular x86

1248
01:09:59,082 --> 01:10:06,130
how returns work in in that program and

1249
01:10:04,042 --> 01:10:09,048
remember there's enough x86 out there

1250
01:10:07,003 --> 01:10:14,031
that if I can find a way to attack them

1251
01:10:09,048 --> 01:10:17,059
I'm in pretty I'm in a pretty good place

1252
01:10:14,058 --> 01:10:18,139
it's also possible to attack other

1253
01:10:17,059 --> 01:10:23,062
processors this way - it's just

1254
01:10:19,039 --> 01:10:24,121
particularly nice on x86 so that's the

1255
01:10:23,062 --> 01:10:27,139
idea of return on in programming and

1256
01:10:25,021 --> 01:10:30,115
you'll you'll do this yourself you'll

1257
01:10:28,039 --> 01:10:35,080
find gadgets string them together to do

1258
01:10:31,015 --> 01:10:39,103
different things in the attack lamp but

1259
01:10:35,008 --> 01:10:46,008
I'll point out that this still doesn't

1260
01:10:40,003 --> 01:10:50,010
so that this stack canary idea is still

1261
01:10:46,008 --> 01:10:52,015
successful detecting a buffer overflows

1262
01:10:50,001 --> 01:10:56,029
fairly effectively so in your tack lab

1263
01:10:53,005 --> 01:10:59,044
for example we've carefully compiled the

1264
01:10:56,038 --> 01:11:03,357
code to make it vulnerable to these

1265
01:10:59,089 --> 01:11:05,164
attacks otherwise it would be a lot

1266
01:11:03,699 --> 01:11:09,726
harder web like if you could do this you

1267
01:11:06,064 --> 01:11:17,103
could probably go into the dark world

1268
01:11:09,969 --> 01:11:20,050
and and be very successful so but so

1269
01:11:17,679 --> 01:11:23,140
we're actually sort of exposing the

1270
01:11:20,005 --> 01:11:25,009
vulnerability but in the the first part

1271
01:11:23,014 --> 01:11:27,052
of the lab you're using code injection

1272
01:11:25,009 --> 01:11:30,102
attacks so we've had to disable stack

1273
01:11:27,052 --> 01:11:34,067
randomization and also make the stack X

1274
01:11:31,002 --> 01:11:38,088
cutable so we had to sort of button the

1275
01:11:34,067 --> 01:11:41,088
return on programming we reenable that

1276
01:11:38,088 --> 01:11:44,181
so that the stack is not executable it

1277
01:11:41,088 --> 01:11:46,155
keeps jumping around randomly up but

1278
01:11:45,081 --> 01:11:48,132
we've turned off the stack Canaries so

1279
01:11:47,055 --> 01:11:53,082
you'll be able to overflow the buffer

1280
01:11:49,032 --> 01:11:57,099
and put in your gadget addresses and

1281
01:11:53,082 --> 01:11:58,179
build up a text that way so I think

1282
01:11:57,099 --> 01:12:00,156
you'll find by actually doing it you'll

1283
01:11:59,079 --> 01:12:04,167
learn a lot more than you can by just

1284
01:12:01,056 --> 01:12:07,101
hearing about it oh you might ask why do

1285
01:12:05,067 --> 01:12:08,148
we teach you this stuff right and if we

1286
01:12:08,001 --> 01:12:12,027
supposed to teach you to be good and not

1287
01:12:09,048 --> 01:12:13,139
evil well there's a couple reasons one

1288
01:12:12,027 --> 01:12:18,036
is you're going to learn a lot about

1289
01:12:14,039 --> 01:12:20,040
machine program execution and how stacks

1290
01:12:18,036 --> 01:12:22,077
work and how byte instructions are

1291
01:12:20,049 --> 01:12:25,068
encoded and stuff like that you'll use

1292
01:12:22,077 --> 01:12:27,099
the tools gb object dump and all those

1293
01:12:25,068 --> 01:12:30,090
even more than you did with the bomb web

1294
01:12:27,099 --> 01:12:33,102
so you'll learn a lot the other is we

1295
01:12:30,009 --> 01:12:36,108
assume that you will work for forces of

1296
01:12:34,002 --> 01:12:39,060
good but to be a good person you also

1297
01:12:37,089 --> 01:12:44,100
know what the bet have to know what the

1298
01:12:39,006 --> 01:12:50,085
bad people do so part of it is to become

1299
01:12:45,000 --> 01:12:53,064
more effective as a force for good okay

1300
01:12:51,039 --> 01:12:57,042
so the final thing to talk about today

1301
01:12:53,064 --> 01:12:59,151
is unions and the observation about a

1302
01:12:57,069 --> 01:13:02,127
union in C is the declaration that it

1303
01:13:00,051 --> 01:13:04,113
looks a lot like a struct where there's

1304
01:13:03,027 --> 01:13:06,102
this different fields and they're named

1305
01:13:05,013 --> 01:13:09,111
and they can have different types and

1306
01:13:07,002 --> 01:13:12,069
there can be pointers to unions and all

1307
01:13:10,011 --> 01:13:15,048
that stuff but they're actually totally

1308
01:13:12,069 --> 01:13:16,137
different what they do you recall it a

1309
01:13:15,048 --> 01:13:19,101
struct what happens as it Ella Cates

1310
01:13:17,037 --> 01:13:23,109
enough memory for all the fields to

1311
01:13:20,001 --> 01:13:29,007
coexist and potentially adding padding

1312
01:13:24,009 --> 01:13:32,013
bytes for what a union does is it only K

1313
01:13:29,061 --> 01:13:33,069
allocates enough storage for the maximum

1314
01:13:32,013 --> 01:13:35,085
field in it and it assumes that you're

1315
01:13:34,041 --> 01:13:38,043
only going to be using one of the

1316
01:13:35,085 --> 01:13:41,097
possible fields and it will literally a

1317
01:13:38,043 --> 01:13:44,076
store on top of these fields get stored

1318
01:13:41,097 --> 01:13:47,142
on top of each other so that if you

1319
01:13:44,076 --> 01:13:48,535
try to use multiple fields you can mess

1320
01:13:48,042 --> 01:13:51,084
things up

1321
01:13:49,219 --> 01:13:53,282
and it's not for that purpose of doing

1322
01:13:51,084 --> 01:13:55,613
multiple values it's for the purpose of

1323
01:13:53,849 --> 01:13:59,400
for example if I know I'm only going to

1324
01:13:56,369 --> 01:14:01,463
use one of these or it's another also a

1325
01:13:59,004 --> 01:14:03,803
way to create essentially an alias that

1326
01:14:02,309 --> 01:14:09,210
will let you reference memory in

1327
01:14:04,199 --> 01:14:13,980
different ways so for example in your

1328
01:14:09,021 --> 01:14:15,370
data web viewer using you were

1329
01:14:13,098 --> 01:14:16,337
manipulating the bit level

1330
01:14:15,559 --> 01:14:20,610
representations of floating point

1331
01:14:17,219 --> 01:14:23,400
numbers and in our code that would then

1332
01:14:20,061 --> 01:14:28,119
convert that to an actual float we used

1333
01:14:23,004 --> 01:14:31,073
a union where the Union is either to

1334
01:14:29,019 --> 01:14:36,050
view this field of four bytes is an

1335
01:14:31,469 --> 01:14:36,500
unsigned or is a float and so I can

1336
01:14:37,013 --> 01:14:42,812
convert from unsigned to its float

1337
01:14:39,989 --> 01:14:46,031
representation by just storing the

1338
01:14:42,929 --> 01:14:49,440
unsigned value in this Union and

1339
01:14:46,409 --> 01:14:51,260
retrieving it as if it were float and

1340
01:14:49,044 --> 01:14:53,079
this is a fundamentally different

1341
01:14:51,026 --> 01:14:55,032
operation than casting because you

1342
01:14:53,079 --> 01:14:57,111
recall when you take an unsigned value

1343
01:14:55,086 --> 01:14:59,345
and you cast it to a float you actually

1344
01:14:58,011 --> 01:15:02,210
change the bit to change it into the

1345
01:15:00,119 --> 01:15:07,170
floating point number that the closest a

1346
01:15:02,309 --> 01:15:08,820
match to this particular number it would

1347
01:15:07,017 --> 01:15:10,100
be the equivalent of the function you

1348
01:15:08,082 --> 01:15:12,881
implemented float underscore you to F

1349
01:15:11,000 --> 01:15:16,059
but this one actually doesn't change

1350
01:15:13,619 --> 01:15:19,530
bits it just changes the numeric value

1351
01:15:16,059 --> 01:15:21,102
changes quite a bit so it's a useful

1352
01:15:19,053 --> 01:15:24,128
technique to do that to be able to

1353
01:15:22,002 --> 01:15:29,055
override the the type system and get to

1354
01:15:25,028 --> 01:15:31,050
representations and this actually turns

1355
01:15:29,055 --> 01:15:33,584
out to be one of the places to where

1356
01:15:31,005 --> 01:15:37,874
byte ordering will show up in programs

1357
01:15:34,079 --> 01:15:41,084
if you're not careful so in particular

1358
01:15:38,369 --> 01:15:44,940
with this Union I can view a block of

1359
01:15:41,579 --> 01:15:48,593
eight bytes as either eight characters

1360
01:15:44,094 --> 01:15:51,143
for shorts to inch through one long and

1361
01:15:48,719 --> 01:15:54,900
on a 64-bit machine like is shown here

1362
01:15:51,989 --> 01:15:58,260
where along is 64 bits you'll see that

1363
01:15:54,009 --> 01:16:00,018
you're you're able to

1364
01:15:58,026 --> 01:16:05,085
get things as either as a the individual

1365
01:16:01,008 --> 01:16:07,077
bites making it up or some longer

1366
01:16:05,085 --> 01:16:09,120
aggregation of those bytes and you'll

1367
01:16:08,049 --> 01:16:12,072
actually find that depending on what

1368
01:16:10,002 --> 01:16:15,033
machine you run it on you'll get a

1369
01:16:12,072 --> 01:16:17,091
different result because of the byte

1370
01:16:15,051 --> 01:16:20,073
ordering of the different machines so

1371
01:16:17,091 --> 01:16:22,146
this goes through it what happens when

1372
01:16:20,073 --> 01:16:24,126
you run on different machines

1373
01:16:23,046 --> 01:16:29,109
but you'll you'll notice in particular

1374
01:16:25,026 --> 01:16:34,125
that on a thirty-two machine a 32-bit

1375
01:16:30,009 --> 01:16:40,047
machine it's coming off in in this byte

1376
01:16:35,025 --> 01:16:43,098
pattern F 3 F 2 F 1 F 0 and on a Sun

1377
01:16:40,047 --> 01:16:45,078
back when they existed you'd get the

1378
01:16:43,098 --> 01:16:52,179
opposite becomes in the byte ordering

1379
01:16:45,078 --> 01:16:58,119
and now on an x86 64 where a long is 64

1380
01:16:53,079 --> 01:17:00,081
bits you get a 8 byte and you can also

1381
01:16:59,019 --> 01:17:03,051
determine from this if you look

1382
01:17:00,081 --> 01:17:04,086
carefully that it's in it's a little

1383
01:17:03,051 --> 01:17:08,067
endian order because this is the least

1384
01:17:05,031 --> 01:17:14,094
significant byte is F 0 which is the

1385
01:17:08,067 --> 01:17:16,122
first byte f0 so it's also a way to get

1386
01:17:14,094 --> 01:17:17,166
to the low level bytes but when you use

1387
01:17:17,022 --> 01:17:22,115
this kind of thing you're sort of

1388
01:17:18,066 --> 01:17:25,068
intentionally telling the the C compiler

1389
01:17:23,015 --> 01:17:28,020
trust me I know what I'm doing you don't

1390
01:17:25,068 --> 01:17:29,115
have to protect me from myself and so if

1391
01:17:28,065 --> 01:17:31,068
you're not careful you can write code

1392
01:17:30,015 --> 01:17:32,091
where because of a byte ordering problem

1393
01:17:31,095 --> 01:17:37,119
or something like that

1394
01:17:32,091 --> 01:17:40,095
won't run properly on some machines so

1395
01:17:38,019 --> 01:17:43,050
just to summarize then we looked on it

1396
01:17:41,031 --> 01:17:45,110
we've looked down at the three compound

1397
01:17:43,005 --> 01:17:48,048
types in C the ways you can aggregate

1398
01:17:46,001 --> 01:17:51,017
smaller types into larger ones you can

1399
01:17:48,093 --> 01:17:53,124
make an array of identical elements

1400
01:17:51,026 --> 01:17:56,055
indexed by a number the position and

1401
01:17:54,024 --> 01:17:58,032
that usually turns into some kind of

1402
01:17:56,055 --> 01:18:01,131
scaled computation to get to the

1403
01:17:59,004 --> 01:18:06,006
particular place we've seen structures

1404
01:18:02,031 --> 01:18:07,086
where it's a fixed number of fields but

1405
01:18:06,006 --> 01:18:10,020
the fields can be of different type and

1406
01:18:07,086 --> 01:18:11,086
the reference by their names and that

1407
01:18:10,002 --> 01:18:13,006
usually turns into some type of

1408
01:18:11,086 --> 01:18:17,110
it's placement off of the original

1409
01:18:13,006 --> 01:18:21,025
position and then a union is just a way

1410
01:18:18,001 --> 01:18:24,070
of sort of piling up in one place of

1411
01:18:21,079 --> 01:18:26,107
what a number of different fields and so

1412
01:18:24,079 --> 01:18:29,718
all it does delegate the maximum number

1413
01:18:27,007 --> 01:18:32,011
of bytes for that and doesn't create

1414
01:18:30,429 --> 01:18:37,800
enough space for them all to be there at

1415
01:18:32,011 --> 01:18:37,080
the same time okay that's it for today

1416
01:18:37,084 --> 01:18:39,097
[Applause]

