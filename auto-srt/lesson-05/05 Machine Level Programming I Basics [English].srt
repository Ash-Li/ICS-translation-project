1
00:00:01,002 --> 00:00:07,101
good afternoon everyone so now we're

2
00:00:06,033 --> 00:00:09,075
going to jump into the part of the

3
00:00:08,001 --> 00:00:13,040
course that I'd call the real core of

4
00:00:09,075 --> 00:00:14,121
the course where we go into machine

5
00:00:13,049 --> 00:00:18,000
level programming and by the term

6
00:00:15,021 --> 00:00:20,106
machine level programming I mean when

7
00:00:18,000 --> 00:00:23,022
you're actually considering the the

8
00:00:21,006 --> 00:00:25,011
individual instructions to get executed

9
00:00:23,022 --> 00:00:27,090
by the machine in response to your

10
00:00:25,056 --> 00:00:30,057
program and there's really two forms of

11
00:00:27,009 --> 00:00:32,037
machine programs one is the actual

12
00:00:30,057 --> 00:00:35,100
object code that runs on the computer

13
00:00:33,018 --> 00:00:38,055
and as we'll see that a series of bytes

14
00:00:36,000 --> 00:00:41,085
that encode instructions that the

15
00:00:38,055 --> 00:00:44,112
processor executes but well because it's

16
00:00:41,085 --> 00:00:46,092
hard to look at byte and understand them

17
00:00:45,012 --> 00:00:50,025
there's various text forms to make it

18
00:00:47,055 --> 00:00:53,094
more clear and one of those is assembly

19
00:00:50,025 --> 00:00:55,107
code that it used to be that tell people

20
00:00:53,094 --> 00:00:57,162
program machines and nowadays it's what

21
00:00:56,007 --> 00:01:00,015
the target of a compiler is is to

22
00:00:58,062 --> 00:01:02,103
generate assembly code and I'll use

23
00:01:00,087 --> 00:01:05,106
those terms when I say machine code I

24
00:01:03,003 --> 00:01:08,085
sort of interchangeably mean object code

25
00:01:06,006 --> 00:01:11,495
the binary form or assembly code the

26
00:01:08,085 --> 00:01:12,102
text version of it interchangeably

27
00:01:11,549 --> 00:01:16,710
because there really is a one-to-one

28
00:01:13,002 --> 00:01:19,011
mapping between them but in case I sort

29
00:01:16,071 --> 00:01:21,075
of used a term like assembly code when I

30
00:01:19,092 --> 00:01:22,101
instead of consistently saying machine

31
00:01:22,011 --> 00:01:28,056
code it's because they're really the

32
00:01:23,082 --> 00:01:33,084
same general idea so this is sort of one

33
00:01:28,056 --> 00:01:35,097
place where this course 213 513 takes a

34
00:01:34,002 --> 00:01:39,491
particular perspective that's very

35
00:01:35,097 --> 00:01:41,786
different from done ever elsewhere in

36
00:01:39,509 --> 00:01:44,520
the bad old days of computing you would

37
00:01:42,659 --> 00:01:45,810
be required to take a course it was

38
00:01:44,052 --> 00:01:47,127
typically called assembly level

39
00:01:45,081 --> 00:01:50,100
programming the way you actually learned

40
00:01:48,027 --> 00:01:52,104
to write programs in assembler and your

41
00:01:51,000 --> 00:01:58,095
assignments would be to do things like

42
00:01:53,004 --> 00:02:00,653
to sort a array of numbers or set up

43
00:01:58,095 --> 00:02:02,139
some kind of linked list data structure

44
00:02:00,689 --> 00:02:05,040
just sort of low-level programming that

45
00:02:03,039 --> 00:02:08,128
nowadays you wouldn't even think of

46
00:02:05,004 --> 00:02:11,010
wanting to write an assembly code and so

47
00:02:08,479 --> 00:02:12,270
people didn't really enjoy those courses

48
00:02:11,064 --> 00:02:13,080
very well

49
00:02:12,027 --> 00:02:15,102
and so they got sort of our

50
00:02:13,008 --> 00:02:18,009
we cut out of the curriculum but what

51
00:02:16,002 --> 00:02:21,081
our version of it is is this is pretty

52
00:02:18,009 --> 00:02:24,018
important stuff to know as the sort of

53
00:02:21,081 --> 00:02:26,124
gateway between what's how you write

54
00:02:24,099 --> 00:02:28,185
your programs say and C or any other

55
00:02:27,024 --> 00:02:33,048
language and how those programs actually

56
00:02:29,085 --> 00:02:34,134
execute on a machine so machine code it

57
00:02:33,048 --> 00:02:36,120
sort of the intermediate form there the

58
00:02:35,034 --> 00:02:38,112
intermediate language and you need to

59
00:02:37,002 --> 00:02:42,011
understand that to understand better

60
00:02:39,012 --> 00:02:46,110
what your programs are trying to do and

61
00:02:42,029 --> 00:02:48,081
what the machine is trying to do so as a

62
00:02:47,001 --> 00:02:51,003
result of that our perspective will be

63
00:02:48,081 --> 00:02:52,155
we won't actually write except in very

64
00:02:51,003 --> 00:02:55,074
very small amount we're not going to

65
00:02:53,055 --> 00:02:57,144
actually sit down and write assembly

66
00:02:56,001 --> 00:03:00,036
programs in this course but what you'll

67
00:02:58,044 --> 00:03:02,136
do is you're going to look at a lot of

68
00:03:00,036 --> 00:03:07,101
code that was generated by a C compiler

69
00:03:03,036 --> 00:03:09,120
GCC and try to see how does that what

70
00:03:08,001 --> 00:03:12,066
came out of that compiler relate to what

71
00:03:10,002 --> 00:03:15,078
went into it how does this low-level

72
00:03:12,066 --> 00:03:19,145
code implement the higher-level

73
00:03:15,096 --> 00:03:22,137
of constructs that I was trying to

74
00:03:19,739 --> 00:03:26,370
express my program in how our procedures

75
00:03:23,037 --> 00:03:28,041
functions implemented in machine

76
00:03:26,037 --> 00:03:30,078
language how our data structures such as

77
00:03:28,041 --> 00:03:33,114
arrays and structs how are those

78
00:03:30,078 --> 00:03:35,109
implemented in machine code so we're

79
00:03:34,014 --> 00:03:38,088
going to learn all of that stuff and it

80
00:03:36,009 --> 00:03:41,016
takes a significant chunk of this course

81
00:03:38,088 --> 00:03:41,169
and a fair number of lectures to get

82
00:03:41,016 --> 00:03:46,092
through all that material because it's

83
00:03:42,069 --> 00:03:48,078
really quite a bit but I think it's like

84
00:03:46,092 --> 00:03:53,181
I said I think this is suitable core of

85
00:03:48,078 --> 00:03:55,164
where this course is and as you know in

86
00:03:54,081 --> 00:04:00,084
this course we only look at one

87
00:03:56,064 --> 00:04:02,115
particular classes of machines even

88
00:04:00,084 --> 00:04:05,139
though there's many more different

89
00:04:03,015 --> 00:04:09,018
machine level programming possibilities

90
00:04:06,039 --> 00:04:11,082
out there and we've chosen the Intel the

91
00:04:09,045 --> 00:04:14,864
64-bit version of the Intel instruction

92
00:04:11,082 --> 00:04:16,811
set so I'll go through a little bit of

93
00:04:15,269 --> 00:04:20,880
the history behind Intel and how it got

94
00:04:17,549 --> 00:04:23,250
to where it is we'll look at through

95
00:04:20,088 --> 00:04:25,157
this idea of how does C code relate to

96
00:04:23,025 --> 00:04:27,874
assembly code machine code and so forth

97
00:04:25,949 --> 00:04:30,011
we'll go through certainly the low-level

98
00:04:28,099 --> 00:04:33,146
basics that you need to understand the

99
00:04:30,569 --> 00:04:35,610
of what assembly cut machine code looks

100
00:04:33,569 --> 00:04:38,460
like and then we'll actually take on and

101
00:04:35,061 --> 00:04:43,090
look at some real code focusing

102
00:04:38,046 --> 00:04:45,935
specifically on arithmetic operations so

103
00:04:43,639 --> 00:04:48,707
x86 is the sort of colloquial term for

104
00:04:46,349 --> 00:04:51,433
Intel processors and the reason is that

105
00:04:49,319 --> 00:04:55,385
the first one was called the 8086 and

106
00:04:52,189 --> 00:05:01,190
then they kind of skipped 81 but then

107
00:04:55,979 --> 00:05:04,979
they went to 80 to 86 and so forth 83 86

108
00:05:01,289 --> 00:05:08,330
so the one thing in common was 86 and so

109
00:05:04,979 --> 00:05:10,013
people just call it x86 and one thing

110
00:05:08,699 --> 00:05:12,743
that's important to this and it will

111
00:05:10,319 --> 00:05:16,385
have influence on what the programs look

112
00:05:13,139 --> 00:05:20,430
like is x86 is a language like English

113
00:05:16,979 --> 00:05:23,063
that it's been an accrual and evolution

114
00:05:20,043 --> 00:05:26,061
of different features layered on top of

115
00:05:23,819 --> 00:05:29,822
each other and not always the most

116
00:05:26,061 --> 00:05:32,300
elegant way so just like English there's

117
00:05:29,849 --> 00:05:34,500
all these sort of quirky things that how

118
00:05:32,849 --> 00:05:35,912
you write it is very different from how

119
00:05:34,005 --> 00:05:38,594
you pronounce it and there's all these

120
00:05:36,479 --> 00:05:39,551
irregular cases and it doesn't make

121
00:05:39,089 --> 00:05:43,020
sense it's not sort of a

122
00:05:40,199 --> 00:05:45,930
purpose-designed language it's the same

123
00:05:43,002 --> 00:05:48,036
with x86 it's a language that just got

124
00:05:45,093 --> 00:05:49,125
there because of a bunch of decisions

125
00:05:48,036 --> 00:05:51,081
that locally were probably the right

126
00:05:50,025 --> 00:05:53,034
thing to do but globally were not

127
00:05:51,081 --> 00:05:55,130
there's other instruction sets that are

128
00:05:54,015 --> 00:05:59,564
much cleaner and easier to understand

129
00:05:56,003 --> 00:06:01,029
but we figure it's just the same reason

130
00:05:59,699 --> 00:06:02,780
that you learn English instead of

131
00:06:01,056 --> 00:06:05,061
learning Esperanto or something like

132
00:06:03,509 --> 00:06:10,574
that that it's a much more useful

133
00:06:05,061 --> 00:06:13,083
language x86 is what sometimes was

134
00:06:11,159 --> 00:06:18,810
called a Sisk there is a big thing in

135
00:06:13,083 --> 00:06:20,072
the early 80s 80s in general called risk

136
00:06:18,081 --> 00:06:22,460
versus Sisk Sisk

137
00:06:20,819 --> 00:06:24,900
a well risk was a new relatively new

138
00:06:23,189 --> 00:06:27,900
idea what they called a reduced

139
00:06:24,009 --> 00:06:29,768
instruction set computer and it was all

140
00:06:27,009 --> 00:06:32,738
the rage and nobody had a name for what

141
00:06:30,659 --> 00:06:35,744
came before but the risk people named

142
00:06:33,629 --> 00:06:38,130
what came before a Sisk for a complex

143
00:06:36,509 --> 00:06:39,240
instruction set computer with the

144
00:06:38,013 --> 00:06:43,013
obvious

145
00:06:39,024 --> 00:06:45,063
a pejorative nature to that title and so

146
00:06:43,013 --> 00:06:47,046
intelligent of the the classic Fisk

147
00:06:45,063 --> 00:06:49,322
architecture meaning it has a ton of

148
00:06:47,046 --> 00:06:51,138
features we're not going to even scratch

149
00:06:49,889 --> 00:06:56,130
the surface if you want it the the

150
00:06:52,038 --> 00:06:58,074
manual for it is two big fat books which

151
00:06:56,013 --> 00:07:00,452
nowadays you do with PDF documents but

152
00:06:58,074 --> 00:07:04,253
it's still a huge amount of stuff and

153
00:07:00,569 --> 00:07:08,430
some 500 or more instructions everything

154
00:07:04,919 --> 00:07:10,016
from doing decimal arithmetic to even

155
00:07:08,043 --> 00:07:13,128
decimal floating point and all kinds of

156
00:07:10,889 --> 00:07:16,440
goofy stuff in there but it turns out

157
00:07:14,028 --> 00:07:18,407
that you can kind of get a pretty good

158
00:07:16,044 --> 00:07:21,105
handle on it by focusing more on just

159
00:07:18,659 --> 00:07:23,735
what does the code look like that GCC is

160
00:07:22,005 --> 00:07:28,994
generating for the kind of programs that

161
00:07:24,419 --> 00:07:35,447
you typically write and you should also

162
00:07:29,039 --> 00:07:39,270
realize that it many levels of this

163
00:07:35,699 --> 00:07:41,711
should not have been the successful

164
00:07:39,027 --> 00:07:44,052
design because as I said it just got

165
00:07:41,819 --> 00:07:47,460
lots of stuff on there but Intel has

166
00:07:44,052 --> 00:07:50,291
been such a powerful company and had so

167
00:07:47,046 --> 00:07:52,074
much market and since better technology

168
00:07:50,759 --> 00:07:54,840
as far as semiconductors than its

169
00:07:52,074 --> 00:07:58,107
competitors that's been able to kind of

170
00:07:54,084 --> 00:08:03,413
keep this thing alive for almost 40

171
00:07:59,007 --> 00:08:06,033
years this is pretty admirable so just

172
00:08:04,169 --> 00:08:09,173
to give you a suit of timescale as I

173
00:08:06,033 --> 00:08:11,372
mentioned the 8086 was the first one of

174
00:08:09,569 --> 00:08:15,440
the first single chip 16-bit

175
00:08:11,669 --> 00:08:17,762
microprocessors it came out in 78 and a

176
00:08:15,044 --> 00:08:20,893
slight variation on it was a very basis

177
00:08:18,599 --> 00:08:26,550
for the original IBM PC which I know

178
00:08:21,289 --> 00:08:28,370
predates most of you your lives but it

179
00:08:26,055 --> 00:08:31,544
was a sort of a the big breakthrough

180
00:08:29,099 --> 00:08:35,198
that put computers on the desktops of

181
00:08:32,039 --> 00:08:37,082
many people and there's been many many

182
00:08:36,089 --> 00:08:40,020
generations I'm just giving you the

183
00:08:37,469 --> 00:08:43,140
highlights from that are relevant to

184
00:08:40,002 --> 00:08:46,029
this particular class the 386 which

185
00:08:43,014 --> 00:08:47,112
dates back to 1985 was the one that

186
00:08:46,029 --> 00:08:49,116
really made the transition from these

187
00:08:48,012 --> 00:08:52,019
being personal computers that could run

188
00:08:50,016 --> 00:08:54,089
not very interesting at

189
00:08:52,019 --> 00:08:57,047
locations - ones that could actually run

190
00:08:54,089 --> 00:08:59,165
something like a UNIX or Linux machine

191
00:08:57,047 --> 00:09:02,056
and the reason is they extended it to 32

192
00:09:00,065 --> 00:09:04,163
bits and they removed some of the weird

193
00:09:03,037 --> 00:09:07,079
addressing stuff that used to be in

194
00:09:05,063 --> 00:09:10,136
there so that these look like sort of a

195
00:09:07,079 --> 00:09:12,128
generic processor and that was clear

196
00:09:11,036 --> 00:09:17,060
back in 85 and that was what sometimes

197
00:09:13,028 --> 00:09:23,090
called ia32 intel architecture 32 which

198
00:09:17,006 --> 00:09:25,067
was the dominant way of code up told

199
00:09:23,009 --> 00:09:28,088
just even a few years ago so even up as

200
00:09:26,021 --> 00:09:34,064
recently as this past summer this course

201
00:09:29,069 --> 00:09:36,095
was teaching I a 32 and then there and

202
00:09:34,064 --> 00:09:39,161
I'll talk about it more later there was

203
00:09:36,095 --> 00:09:43,148
a reason in a strange story behind the

204
00:09:40,061 --> 00:09:47,153
extension from 32 to 64 bits which kind

205
00:09:44,048 --> 00:09:50,096
of was sneaked in by Intel and an odd

206
00:09:48,053 --> 00:09:55,109
model the Pentium 4 II but you see it

207
00:09:50,096 --> 00:09:57,104
was only about 10 years ago and one of

208
00:09:56,009 --> 00:10:00,074
the smart things they did would that is

209
00:09:58,004 --> 00:10:04,082
that the machines that can run the

210
00:10:00,074 --> 00:10:06,098
64-bit code can also run 32-bit code so

211
00:10:04,082 --> 00:10:08,123
they were able to sort of bring out all

212
00:10:06,098 --> 00:10:10,133
these machines without everybody having

213
00:10:09,023 --> 00:10:14,068
to change over their software and it's

214
00:10:11,033 --> 00:10:17,042
taken about that amount of time for the

215
00:10:14,068 --> 00:10:25,102
software to largely transition away from

216
00:10:17,042 --> 00:10:28,136
32-bit code to 64-bit code and then for

217
00:10:26,002 --> 00:10:32,015
actually fairly interesting reasons you

218
00:10:29,036 --> 00:10:34,058
could map how fast a single processor

219
00:10:32,015 --> 00:10:39,029
would run and it was climbing up at a

220
00:10:34,058 --> 00:10:41,075
pretty steady pace until around 2004 and

221
00:10:39,029 --> 00:10:43,052
then Intel got and all the companies got

222
00:10:41,075 --> 00:10:44,174
into serious trouble with the power

223
00:10:43,052 --> 00:10:48,113
consumption of their chips they're

224
00:10:45,074 --> 00:10:50,087
approaching 100 watt so imagine a 100

225
00:10:49,013 --> 00:10:53,021
watt light bulb and how much heat that

226
00:10:50,087 --> 00:10:55,166
generates inside of a box that you try

227
00:10:53,093 --> 00:10:58,121
to blow a fan on really hard to keep it

228
00:10:56,066 --> 00:11:00,080
from getting too hot and they were

229
00:10:59,021 --> 00:11:03,089
reaching the point where they really

230
00:11:00,008 --> 00:11:04,015
couldn't go much beyond a hundred watts

231
00:11:03,089 --> 00:11:06,157
and so they sort of got

232
00:11:05,005 --> 00:11:08,071
to a power budget problem and as a

233
00:11:07,057 --> 00:11:11,062
result they haven't been able to scale

234
00:11:09,016 --> 00:11:14,020
up the frequency how fast the inner

235
00:11:11,062 --> 00:11:20,071
clock that drives this thing is beyond

236
00:11:14,056 --> 00:11:22,135
just a few gigahertz since 2004 so what

237
00:11:20,071 --> 00:11:24,169
happened was they said well we can't

238
00:11:23,035 --> 00:11:26,134
make any single processor faster but we

239
00:11:25,069 --> 00:11:28,141
can put a bunch of processors on a

240
00:11:27,034 --> 00:11:32,035
single chip and those are referred to

241
00:11:29,041 --> 00:11:35,086
cores or multi-core so most of you with

242
00:11:32,044 --> 00:11:38,056
laptops probably have two cores on those

243
00:11:35,086 --> 00:11:41,161
and a laptop processor and a server

244
00:11:38,056 --> 00:11:44,082
might have up to 16 cores so those are

245
00:11:42,061 --> 00:11:48,130
independent processors that are all

246
00:11:44,082 --> 00:11:52,101
reside on a single chip the shark

247
00:11:49,003 --> 00:11:56,004
machines date back to 2008 and they are

248
00:11:53,001 --> 00:11:59,034
each have four cores on them

249
00:11:56,004 --> 00:12:00,013
the shark machines the one thing about

250
00:11:59,034 --> 00:12:01,105
computers haven't really gotten that

251
00:12:01,003 --> 00:12:04,039
much faster

252
00:12:02,005 --> 00:12:08,005
of in the meantime so there's still

253
00:12:04,066 --> 00:12:09,139
fairways and they were in their day a

254
00:12:08,005 --> 00:12:15,013
very high performance machine so they're

255
00:12:10,039 --> 00:12:21,040
still pretty decent this shows a picture

256
00:12:15,085 --> 00:12:24,085
of the chip that makes up a I think the

257
00:12:21,049 --> 00:12:26,125
the sharp machines or approximately that

258
00:12:24,085 --> 00:12:28,146
same era and you'll see that as the

259
00:12:27,025 --> 00:12:32,050
picture shows these four cores are

260
00:12:29,046 --> 00:12:34,072
integrated onto one chip and then down

261
00:12:32,005 --> 00:12:36,019
at the bottom is what they call a cache

262
00:12:34,072 --> 00:12:39,171
and we'll learn a lot about cache memory

263
00:12:36,064 --> 00:12:42,160
but it's it's basically a temporary

264
00:12:40,071 --> 00:12:44,167
memory used to hold the most recently

265
00:12:43,006 --> 00:12:47,104
accessed data so that you can get to it

266
00:12:45,067 --> 00:12:52,162
more quickly and you'll see that that

267
00:12:48,058 --> 00:12:55,066
shared across the four cores so if you

268
00:12:53,062 --> 00:12:58,147
look at the latest if you were to go off

269
00:12:55,066 --> 00:13:00,070
shopping on in the catalog the latest

270
00:12:59,047 --> 00:13:03,073
instance and I don't have any chip

271
00:13:01,006 --> 00:13:07,030
pictures of it is a model they called a

272
00:13:03,073 --> 00:13:09,078
Broadwell model and you'll see that on a

273
00:13:07,003 --> 00:13:12,010
single chip they have multiple cores

274
00:13:10,023 --> 00:13:16,048
forfor a serious standard desktop model

275
00:13:13,000 --> 00:13:18,079
eight for a server class machine and

276
00:13:16,048 --> 00:13:20,125
then built around the perimeter

277
00:13:18,079 --> 00:13:23,128
there are various connections to the

278
00:13:21,025 --> 00:13:26,028
rest of the world so DDR is the way you

279
00:13:24,028 --> 00:13:30,109
connect to the main memory what's called

280
00:13:26,028 --> 00:13:33,030
DRAM dynamic ram pci is the connection

281
00:13:31,009 --> 00:13:36,073
to peripheral devices

282
00:13:33,048 --> 00:13:42,055
SATA is a connection to different types

283
00:13:36,073 --> 00:13:45,109
of discs and USB well you know it USB is

284
00:13:42,055 --> 00:13:51,058
and then the ethernet is the connection

285
00:13:46,009 --> 00:13:53,086
also to a network connection so that's

286
00:13:51,085 --> 00:13:55,162
all integrated onto a single chip is not

287
00:13:53,086 --> 00:13:59,113
just the processor itself but a lot of

288
00:13:56,062 --> 00:14:02,149
logic that glues that processor into a

289
00:14:00,013 --> 00:14:05,071
larger system and one interesting thing

290
00:14:03,049 --> 00:14:06,051
you'll notice is that the desktop model

291
00:14:05,071 --> 00:14:09,160
is a higher power

292
00:14:06,069 --> 00:14:11,167
65 watts versus the server is 45 watts

293
00:14:10,006 --> 00:14:14,062
when you put a lot of computers in a

294
00:14:12,067 --> 00:14:17,073
room turns out power is the biggest

295
00:14:15,016 --> 00:14:18,027
issue you have to deal with

296
00:14:20,032 --> 00:14:25,117
so intelligent the only company in this

297
00:14:23,035 --> 00:14:29,062
game they're sort of historic competitor

298
00:14:26,017 --> 00:14:33,246
is a company called AMD and AMD was

299
00:14:29,062 --> 00:14:36,085
always sort of number two behind Intel

300
00:14:33,399 --> 00:14:44,620
in although I gave us his number two

301
00:14:36,085 --> 00:14:46,087
behind her but the they had a little

302
00:14:44,062 --> 00:14:49,461
burst in time when they kind of got out

303
00:14:46,087 --> 00:14:52,806
ahead of Intel because Intel had wasted

304
00:14:50,019 --> 00:14:54,970
their time on some bad ideas and they

305
00:14:53,589 --> 00:14:57,606
actually were the one that came up with

306
00:14:54,097 --> 00:15:01,446
the 64-bit extension to Intel that we

307
00:14:57,759 --> 00:15:02,798
use right now though AMD is not just

308
00:15:02,319 --> 00:15:05,415
doing very well

309
00:15:03,149 --> 00:15:08,166
Intel sort of realized that it had to

310
00:15:06,279 --> 00:15:13,540
get its act together and it did and it

311
00:15:08,319 --> 00:15:14,980
is more or less crushed AMD but and I

312
00:15:13,054 --> 00:15:17,793
should mention that they had these

313
00:15:14,098 --> 00:15:18,181
ferocious patent suits many years ago

314
00:15:18,279 --> 00:15:22,630
and the result of that was across

315
00:15:19,081 --> 00:15:26,040
licensing deal that allows AMD to

316
00:15:22,063 --> 00:15:28,069
produce x86 processors - now it's

317
00:15:26,769 --> 00:15:32,110
interesting story behind Intel in 64

318
00:15:29,023 --> 00:15:33,612
bits they decided to make this radical

319
00:15:32,011 --> 00:15:39,088
shift to an architecture that they

320
00:15:33,819 --> 00:15:42,550
called the they called ia-64

321
00:15:39,088 --> 00:15:44,179
at the time and it was based on a whole

322
00:15:42,055 --> 00:15:47,116
new concept that looked really good on

323
00:15:45,079 --> 00:15:48,094
paper and initial results looked

324
00:15:48,016 --> 00:15:50,062
promising

325
00:15:48,094 --> 00:15:52,126
they invested a lot of money in this

326
00:15:50,062 --> 00:15:54,891
stuff they formed a joint operation with

327
00:15:53,026 --> 00:15:56,122
Hewlett Packard on this and it turned

328
00:15:55,449 --> 00:16:01,110
out not to work it was much too

329
00:15:57,022 --> 00:16:02,113
aggressive it assumed miraculous

330
00:16:01,011 --> 00:16:05,610
optimization capabilities by the

331
00:16:03,013 --> 00:16:08,014
compiler and so it was a from a

332
00:16:05,709 --> 00:16:09,714
technically idea it was very interesting

333
00:16:08,023 --> 00:16:12,085
technology but in the marketplace it

334
00:16:10,209 --> 00:16:16,215
didn't work and this was sort of a

335
00:16:12,085 --> 00:16:17,184
branch off that Intel pursued and felt

336
00:16:16,269 --> 00:16:19,356
obligated to keep it up because they'd

337
00:16:17,949 --> 00:16:22,240
invested so much in it and Along Came

338
00:16:20,139 --> 00:16:24,040
AMD and they said well we don't have to

339
00:16:22,024 --> 00:16:27,100
do this radical shift we'll just sort of

340
00:16:24,004 --> 00:16:30,303
do the obvious thing of adding making

341
00:16:28,000 --> 00:16:33,031
the registers bigger making things go

342
00:16:30,339 --> 00:16:34,120
from 32 to 64 bits and they came along

343
00:16:33,031 --> 00:16:37,042
with that

344
00:16:34,012 --> 00:16:40,080
and got a and were successful and so

345
00:16:37,042 --> 00:16:43,123
Intel kind of had to just sheepishly

346
00:16:40,008 --> 00:16:46,030
follow behind AMD on this but they could

347
00:16:44,023 --> 00:16:48,094
because of their cross licensing deal so

348
00:16:47,002 --> 00:16:52,045
nowadays as I mentioned hardware-wise

349
00:16:48,094 --> 00:16:54,151
just about every processor that is in a

350
00:16:52,045 --> 00:16:57,052
laptop in a desktop even your cell

351
00:16:55,051 --> 00:17:05,077
phones of recent generation are all

352
00:16:57,052 --> 00:17:07,117
64-bit processors so what we'll talk

353
00:17:05,077 --> 00:17:09,756
about then we used to teach ia32 but

354
00:17:08,017 --> 00:17:13,060
that's gone this is the first term where

355
00:17:10,449 --> 00:17:16,990
we're skipping it all together so we're

356
00:17:13,006 --> 00:17:18,010
using what we'll call x86 - 64 there's

357
00:17:16,099 --> 00:17:21,163
various ways this is named but this is

358
00:17:19,000 --> 00:17:24,072
sort of the Linux way of naming it if

359
00:17:22,063 --> 00:17:26,128
you're interested in AI 32 there's a

360
00:17:24,072 --> 00:17:28,153
document on the web associated with the

361
00:17:27,028 --> 00:17:31,030
book called a web aside that goes

362
00:17:29,053 --> 00:17:32,149
through at least some of the basics of

363
00:17:31,003 --> 00:17:35,086
it but to really read that you need to

364
00:17:33,049 --> 00:17:39,058
learn the 64 bit because it assumes you

365
00:17:36,013 --> 00:17:42,076
kind of already know that okay so let's

366
00:17:40,039 --> 00:17:44,134
go in and I should mention - if just for

367
00:17:42,076 --> 00:17:46,171
general interest the other major class

368
00:17:45,034 --> 00:17:50,119
of processor in common use today are

369
00:17:47,071 --> 00:17:54,076
called arm so arm actually is an acronym

370
00:17:51,019 --> 00:17:56,110
for acorn RISC machine I just told you

371
00:17:55,021 --> 00:17:59,098
what risk means it means risk reduced

372
00:17:57,001 --> 00:18:01,096
instruction set computer an acorn means

373
00:17:59,098 --> 00:18:03,139
like you know the seed of an oak tree it

374
00:18:02,005 --> 00:18:08,068
was a British company

375
00:18:04,039 --> 00:18:10,045
and that decide to make its own personal

376
00:18:08,068 --> 00:18:11,134
computers in the early days of it and

377
00:18:10,045 --> 00:18:13,060
they said we're not going to buy those

378
00:18:12,034 --> 00:18:14,110
chips from Intel we're going to make

379
00:18:13,006 --> 00:18:17,014
them ourselves so they designed and

380
00:18:15,001 --> 00:18:19,060
manufactured their own chips well as a

381
00:18:17,068 --> 00:18:22,069
company a computer manufacturer it was a

382
00:18:19,069 --> 00:18:24,097
complete bust but it turned out that

383
00:18:22,069 --> 00:18:27,073
they'd come up with a fairly good

384
00:18:24,097 --> 00:18:29,193
instruction set that was sufficiently

385
00:18:28,009 --> 00:18:34,087
simple that it could be put on chips and

386
00:18:30,093 --> 00:18:36,109
better yet it could be customized so arm

387
00:18:34,087 --> 00:18:38,115
is now a company of its own

388
00:18:37,009 --> 00:18:41,035
headquartered in Cambridge England and

389
00:18:39,015 --> 00:18:43,078
the reason why part of the reason

390
00:18:41,035 --> 00:18:45,111
they're successful therefore is because

391
00:18:43,078 --> 00:18:48,085
it tends to be a lower power

392
00:18:46,011 --> 00:18:50,110
requirements than an x86 machine because

393
00:18:48,085 --> 00:18:52,152
it's simpler but the other is that they

394
00:18:51,001 --> 00:18:56,065
don't actually sell processors they sell

395
00:18:53,052 --> 00:18:59,074
companies the rights the licensing

396
00:18:56,074 --> 00:19:02,155
rights to use their designs and so if

397
00:18:59,074 --> 00:19:05,080
you look at like a cellphone processor

398
00:19:03,055 --> 00:19:07,141
the actual ARM processor is a little

399
00:19:05,008 --> 00:19:09,036
tiny part of it on the chip and then

400
00:19:08,041 --> 00:19:12,103
they'll have other stuff to make the

401
00:19:10,008 --> 00:19:16,015
graphics go better to improve your phone

402
00:19:13,003 --> 00:19:18,028
calls and so forth and so they're really

403
00:19:16,015 --> 00:19:22,030
selling what intellectual property is

404
00:19:18,028 --> 00:19:23,035
opposed to chips and so people we've

405
00:19:22,003 --> 00:19:25,081
gotten various inquiries when are you

406
00:19:23,098 --> 00:19:26,173
going to start talking about arm in your

407
00:19:26,008 --> 00:19:30,043
book or your course or something and we

408
00:19:27,073 --> 00:19:31,138
go it would be another book to write to

409
00:19:30,043 --> 00:19:36,049
do justice to arm it would be like a

410
00:19:32,038 --> 00:19:37,134
whole redo of the thing and we were not

411
00:19:36,049 --> 00:19:40,105
inclined to do that right now

412
00:19:38,034 --> 00:19:44,065
but just so you know there's sort of a

413
00:19:41,005 --> 00:19:47,070
two worlds out there x86 and arm are the

414
00:19:44,065 --> 00:19:47,070
dominant players right now

415
00:19:48,049 --> 00:19:51,131
so let's talk some terminology and

416
00:19:51,038 --> 00:19:54,041
you've probably heard some of these

417
00:19:52,031 --> 00:19:56,117
terms before but let's make it clear so

418
00:19:54,041 --> 00:20:00,077
when we talk about the instructions the

419
00:19:57,017 --> 00:20:03,065
instruction set that's the the target of

420
00:20:00,077 --> 00:20:04,139
a compiler to give you a series of

421
00:20:03,065 --> 00:20:09,089
instructions that tell the Machine

422
00:20:05,039 --> 00:20:11,054
exactly what to do but it turns out that

423
00:20:09,089 --> 00:20:12,142
the hardware people will figure out all

424
00:20:11,054 --> 00:20:16,097
kinds of clever ways to implement

425
00:20:13,042 --> 00:20:19,076
instructions some of them are really

426
00:20:16,097 --> 00:20:20,162
fast but take a lot of hardware some are

427
00:20:19,076 --> 00:20:23,090
pretty slow but don't take much hardware

428
00:20:21,062 --> 00:20:26,105
at all and so they managed to create

429
00:20:23,009 --> 00:20:28,016
this this abstraction that's called the

430
00:20:27,005 --> 00:20:31,052
instruction set architecture which is

431
00:20:28,097 --> 00:20:32,168
what the target of a compiler should be

432
00:20:31,052 --> 00:20:35,105
and then let the hardware people figure

433
00:20:33,068 --> 00:20:37,112
out how best to implement it and then

434
00:20:36,005 --> 00:20:42,008
the low so that that's a concept

435
00:20:38,012 --> 00:20:46,028
actually it came along in the 1960s so

436
00:20:42,008 --> 00:20:49,082
that's even before my time as far as a

437
00:20:46,028 --> 00:20:52,034
computer person but it's a very

438
00:20:49,082 --> 00:20:53,090
important concept in the world of

439
00:20:52,034 --> 00:20:56,057
computers and then what they call the

440
00:20:54,062 --> 00:20:56,150
lower level stuff how it actually gets

441
00:20:56,057 --> 00:20:58,061
implemented is called the

442
00:20:57,005 --> 00:21:00,050
microarchitecture

443
00:20:58,061 --> 00:21:03,074
we will talk very very little about

444
00:21:00,095 --> 00:21:04,154
microarchitecture in this course and as

445
00:21:03,074 --> 00:21:07,130
I mentioned machine code in sort of a

446
00:21:05,054 --> 00:21:10,109
generic term that incorporates both the

447
00:21:08,003 --> 00:21:13,010
actual bit the bytes that are operated

448
00:21:11,009 --> 00:21:15,106
executing as well as the assembly level

449
00:21:13,037 --> 00:21:15,106
version of it

450
00:21:17,043 --> 00:21:23,141
and as I mentioned you can think of from

451
00:21:20,007 --> 00:21:28,050
instruction set point of view so ia32

452
00:21:24,041 --> 00:21:31,053
x86 64 and what's called Itanium or this

453
00:21:28,005 --> 00:21:34,061
not very successful Intel thing those

454
00:21:31,053 --> 00:21:34,106
are all in some ways different

455
00:21:35,015 --> 00:21:40,041
instruction set architectures arm

456
00:21:37,035 --> 00:21:41,133
actually similar to Intel has gone

457
00:21:40,041 --> 00:21:43,104
through various different generations so

458
00:21:42,033 --> 00:21:48,033
there's various different generations of

459
00:21:44,004 --> 00:21:50,046
its instruction sets so from a

460
00:21:48,033 --> 00:21:52,056
programmer machine level programmers

461
00:21:50,046 --> 00:21:55,134
perspective things are a bit different

462
00:21:52,056 --> 00:21:58,104
than you see when you write C code first

463
00:21:56,034 --> 00:22:00,120
of all there is some very visible parts

464
00:21:59,004 --> 00:22:04,011
of the instruction the Machine State

465
00:22:01,002 --> 00:22:07,014
that you can examine and test and

466
00:22:04,011 --> 00:22:09,033
operate on and you must in fact that you

467
00:22:07,032 --> 00:22:11,121
would never understand what those are if

468
00:22:09,033 --> 00:22:14,100
you're just thinking in terms of C so in

469
00:22:12,021 --> 00:22:17,088
particular there's some sort of a

470
00:22:15,000 --> 00:22:21,006
program counter to tells you what what

471
00:22:17,088 --> 00:22:22,110
address is the instruction that you're

472
00:22:21,006 --> 00:22:27,042
going to execute next where is that

473
00:22:23,001 --> 00:22:31,002
located in memory and then there's a set

474
00:22:27,042 --> 00:22:33,063
of registers which are part of the that

475
00:22:31,011 --> 00:22:36,033
the programmer actually makes use of you

476
00:22:33,063 --> 00:22:37,155
can think of them as as a very small

477
00:22:36,033 --> 00:22:41,037
number of memory locations but rather

478
00:22:38,055 --> 00:22:43,104
than giving an address from 0 up to n

479
00:22:41,073 --> 00:22:47,142
minus 1 or something you actually give

480
00:22:44,004 --> 00:22:50,082
them by name specifically and then

481
00:22:48,042 --> 00:22:52,083
there's another sort of state that's

482
00:22:50,082 --> 00:22:56,103
just a few bits worth of state that

483
00:22:52,083 --> 00:22:59,106
talked about what what are the results

484
00:22:57,003 --> 00:23:02,010
of some recent instructions where they

485
00:23:00,006 --> 00:23:03,087
did it produce a value of 0 did it

486
00:23:02,001 --> 00:23:05,049
produce a negative or a positive value

487
00:23:03,087 --> 00:23:06,135
and those are used to implement

488
00:23:05,058 --> 00:23:10,074
conditional branching which we'll look

489
00:23:07,035 --> 00:23:12,123
at later as we go and then the other

490
00:23:10,074 --> 00:23:14,100
part of it so that sort of the processor

491
00:23:13,023 --> 00:23:20,082
and then the other part of it is the

492
00:23:15,000 --> 00:23:22,077
memory and as I mentioned in the one of

493
00:23:20,082 --> 00:23:24,099
the first lectures the memory is you can

494
00:23:22,077 --> 00:23:27,143
think of logically as just an array of

495
00:23:24,099 --> 00:23:30,164
bytes and that's what the

496
00:23:28,043 --> 00:23:32,135
machine level programmer C's and it's

497
00:23:31,064 --> 00:23:34,130
actually kind of a fiction in in

498
00:23:33,035 --> 00:23:36,107
different ways as I mentioned before

499
00:23:35,003 --> 00:23:38,047
they're sort of a collaboration between

500
00:23:37,007 --> 00:23:42,011
the operating system and the hardware

501
00:23:38,074 --> 00:23:43,115
what they call virtual memory to make it

502
00:23:42,011 --> 00:23:48,053
look like each program running on a

503
00:23:44,015 --> 00:23:51,053
processor has its own independent array

504
00:23:48,053 --> 00:23:54,110
of bytes that it can access even though

505
00:23:51,053 --> 00:23:56,080
they actually share values within the

506
00:23:55,001 --> 00:23:59,099
the physical memory itself and

507
00:23:56,008 --> 00:24:01,055
furthermore you heard the term cache the

508
00:24:00,008 --> 00:24:05,012
idea of a cache is not visible here at

509
00:24:02,027 --> 00:24:08,054
all because it just is automatically

510
00:24:05,012 --> 00:24:10,063
loaded with recent stuff and the only

511
00:24:08,054 --> 00:24:12,125
thing that will look different is if you

512
00:24:10,063 --> 00:24:14,102
access that memory it will go faster

513
00:24:13,025 --> 00:24:17,108
than it would if it hadn't been cached

514
00:24:15,002 --> 00:24:20,036
but it's not visible in terms of there's

515
00:24:18,008 --> 00:24:23,081
no instructions to manipulate the cache

516
00:24:20,036 --> 00:24:28,085
there's no way you can directly access

517
00:24:23,081 --> 00:24:30,125
the cache so you already see that it's

518
00:24:28,085 --> 00:24:34,121
already abstract it's got some more

519
00:24:31,025 --> 00:24:36,122
details of real Hardware but underneath

520
00:24:35,021 --> 00:24:39,025
it that sort of microarchitecture level

521
00:24:37,022 --> 00:24:43,061
has some features built into it that

522
00:24:39,061 --> 00:24:47,075
you're not operating on you're not

523
00:24:43,061 --> 00:24:50,092
making use of direct way yeah when you

524
00:24:47,075 --> 00:24:50,092
write machine level programs

525
00:24:52,013 --> 00:24:58,107
so if you have a program then say and

526
00:24:56,073 --> 00:25:00,114
see it would typically on a larger

527
00:24:59,007 --> 00:25:04,032
program that will include multiple files

528
00:25:01,014 --> 00:25:07,059
and it will make use of some library

529
00:25:04,032 --> 00:25:10,083
code and so the process of compilation

530
00:25:07,059 --> 00:25:12,141
is actually a series of steps that will

531
00:25:10,083 --> 00:25:15,129
take what you've written for code turn

532
00:25:13,041 --> 00:25:19,098
it into machine code combine it with the

533
00:25:16,029 --> 00:25:22,073
compiled compiler generated code for the

534
00:25:19,098 --> 00:25:24,195
libraries and produce finally a in a

535
00:25:22,073 --> 00:25:27,171
file that's your actual executable

536
00:25:25,095 --> 00:25:30,180
program and svet shown here in this

537
00:25:28,071 --> 00:25:33,090
picture that the first step is to take C

538
00:25:31,008 --> 00:25:36,021
and actually generate assembly code from

539
00:25:33,009 --> 00:25:37,104
it and then the next is to run that

540
00:25:36,093 --> 00:25:41,106
through an assembler which takes the

541
00:25:38,085 --> 00:25:42,093
text representation of instructions and

542
00:25:42,006 --> 00:25:45,078
turns it into the actual byte level

543
00:25:43,065 --> 00:25:49,074
representation we'll look at all this

544
00:25:45,078 --> 00:25:51,165
shortly and then there's a program

545
00:25:49,074 --> 00:25:55,089
called a linker which merges together

546
00:25:52,065 --> 00:25:58,101
all the different files for both your

547
00:25:55,089 --> 00:26:01,094
individual file their their compiled

548
00:25:59,001 --> 00:26:05,058
versions and for the library code and

549
00:26:01,094 --> 00:26:06,108
then finally there's a even once you run

550
00:26:05,058 --> 00:26:09,153
a program there's actually some

551
00:26:07,008 --> 00:26:14,073
libraries that get imported dynamically

552
00:26:10,053 --> 00:26:16,101
when the program first begins so it's a

553
00:26:14,073 --> 00:26:18,138
sort of many layered set of activities

554
00:26:17,001 --> 00:26:24,015
and I'll go through some of these

555
00:26:19,038 --> 00:26:27,045
one-by-one for you so for example here's

556
00:26:24,015 --> 00:26:29,061
a not very interesting function in terms

557
00:26:27,045 --> 00:26:31,076
of doing anything useful but it sort of

558
00:26:29,061 --> 00:26:34,113
demonstrates two basic ideas of

559
00:26:31,076 --> 00:26:37,113
compilation and if I run this through a

560
00:26:35,013 --> 00:26:40,020
C compiler I get something that looks

561
00:26:38,013 --> 00:26:43,068
like what's shown on the right and

562
00:26:40,083 --> 00:26:44,175
that's the sembly code and just to give

563
00:26:43,068 --> 00:26:46,152
you an idea of what it is it looks like

564
00:26:45,075 --> 00:26:49,107
a sort of strange language the first

565
00:26:47,052 --> 00:26:52,080
time you see it but you'll see those

566
00:26:50,007 --> 00:26:55,008
percent are something those are the

567
00:26:52,008 --> 00:26:56,019
actual names of registers remember I

568
00:26:55,008 --> 00:27:00,060
told you there's registers that you give

569
00:26:56,091 --> 00:27:01,188
by name and then those instructions are

570
00:27:00,006 --> 00:27:04,071
telling it to do something push cue

571
00:27:02,088 --> 00:27:07,092
means push something onto a stack

572
00:27:05,025 --> 00:27:10,083
move means move copy it from one place

573
00:27:08,028 --> 00:27:14,100
to another call means to call some

574
00:27:10,083 --> 00:27:18,084
procedure pop is the counterpart to push

575
00:27:15,000 --> 00:27:21,006
and then rep is exit return out of this

576
00:27:18,093 --> 00:27:22,158
particular function so you see each of

577
00:27:21,006 --> 00:27:26,007
those is an instruction and it's written

578
00:27:23,058 --> 00:27:29,079
in text but each of those will turn into

579
00:27:26,007 --> 00:27:33,054
one actual instruction in the object

580
00:27:29,079 --> 00:27:35,088
code representation so I should tell you

581
00:27:33,054 --> 00:27:37,083
that this is actually a slightly cleaned

582
00:27:35,088 --> 00:27:38,169
up version of what really happens so let

583
00:27:37,083 --> 00:27:46,179
me show you the reality because you'll

584
00:27:39,069 --> 00:27:49,161
be experiencing that a bit more - they

585
00:27:47,079 --> 00:27:52,103
had this bigger before let me make it

586
00:27:50,061 --> 00:27:52,103
bigger

587
00:27:59,085 --> 00:28:01,139
and

588
00:28:04,009 --> 00:28:12,100
pull this up so that you can see it set

589
00:28:10,049 --> 00:28:17,140
can you see it in the back they're

590
00:28:13,000 --> 00:28:18,004
bigger better

591
00:28:22,081 --> 00:28:26,107
and let me get the other one

592
00:28:39,012 --> 00:28:42,012
in

593
00:28:49,429 --> 00:28:59,010
and they've already logged into a fish

594
00:28:54,929 --> 00:29:01,650
machine to get here so this is a file

595
00:28:59,001 --> 00:29:04,026
then you see it's called some dot C and

596
00:29:01,065 --> 00:29:07,134
I'll mention that all of these programs

597
00:29:04,026 --> 00:29:11,825
are available you can see the whole well

598
00:29:08,034 --> 00:29:13,493
slash AFS is my own personal and all

599
00:29:12,059 --> 00:29:16,740
that first stuff is my own personal

600
00:29:13,799 --> 00:29:22,080
links but once you get to the class web

601
00:29:16,074 --> 00:29:23,109
page awwh code slash and then it's all

602
00:29:22,008 --> 00:29:26,100
given by which particular lecture it is

603
00:29:24,009 --> 00:29:29,728
I think these are linked on the homepage

604
00:29:27,000 --> 00:29:32,004
too and you can see various files there

605
00:29:29,809 --> 00:29:36,390
that are used for the demonstration the

606
00:29:32,004 --> 00:29:39,060
C files are obviously the programs that

607
00:29:36,039 --> 00:29:41,133
we typed in and then one to have an S at

608
00:29:39,096 --> 00:29:44,100
the end that's assembly code one that Rd

609
00:29:42,033 --> 00:29:52,121
R what's called disassembly so anyways

610
00:29:45,036 --> 00:29:59,105
if I say GCC - Bo - - Muslim sir - fo G

611
00:29:53,021 --> 00:30:02,028
minus s capital some dot C that what I

612
00:29:59,429 --> 00:30:05,100
did was just tell the compiler to take

613
00:30:02,028 --> 00:30:07,547
the C code and turn it into assembly

614
00:30:05,001 --> 00:30:10,014
code so when you invoke GCC you're

615
00:30:07,799 --> 00:30:12,890
actually invoking it's not just one

616
00:30:10,023 --> 00:30:15,212
program but a whole sequence of programs

617
00:30:12,089 --> 00:30:17,258
that do various stages of the

618
00:30:15,419 --> 00:30:21,360
compilation and by giving it this minus

619
00:30:18,059 --> 00:30:23,084
capital F switch I'm saying stop I'll

620
00:30:21,036 --> 00:30:28,115
just do the first part C to assembly

621
00:30:23,309 --> 00:30:30,395
code and the - Oh little G is a

622
00:30:29,015 --> 00:30:33,033
specification of what kind of

623
00:30:31,169 --> 00:30:37,207
optimization I want the compiler to do

624
00:30:33,033 --> 00:30:40,044
so if you don't say anything - just

625
00:30:37,549 --> 00:30:42,840
ignite

626
00:30:40,044 --> 00:30:45,111
an optimized code and it's actually very

627
00:30:42,084 --> 00:30:50,109
hard to read that code it's very tedious

628
00:30:46,011 --> 00:30:54,045
the way it works if you say - oh one

629
00:30:51,009 --> 00:30:56,010
which is what you used to do - turn on

630
00:30:54,045 --> 00:30:58,053
the optimizer it

631
00:30:56,001 --> 00:31:00,006
turns out that as GCC as they've gotten

632
00:30:58,053 --> 00:31:03,090
more advanced it does a lot of

633
00:31:00,006 --> 00:31:05,085
optimizations now that for the purpose

634
00:31:03,009 --> 00:31:08,103
of this course make the code pretty hard

635
00:31:06,039 --> 00:31:11,948
to understand so it just with one of the

636
00:31:09,084 --> 00:31:15,141
most recent generations of GCC came out

637
00:31:12,299 --> 00:31:20,460
with this level called G for debugging

638
00:31:16,041 --> 00:31:21,138
that's a nice for this course purpose of

639
00:31:20,046 --> 00:31:24,054
this course a nice level that it sort of

640
00:31:22,038 --> 00:31:27,102
does the obvious kind of optimizations

641
00:31:25,026 --> 00:31:31,077
to make the code readable without being

642
00:31:28,002 --> 00:31:33,015
sort of extravagant in trying to rewrite

643
00:31:31,077 --> 00:31:35,088
your whole program in a way that would

644
00:31:33,015 --> 00:31:37,664
make it a lot different and hopefully

645
00:31:35,088 --> 00:31:39,153
more efficient so that's what we'll use

646
00:31:37,799 --> 00:31:42,150
in this course it's only exists in the

647
00:31:40,053 --> 00:31:43,442
recent versions of the GCC it's

648
00:31:42,015 --> 00:31:50,057
non-standard across other compilers

649
00:31:43,919 --> 00:31:56,960
question no it's an O capital o

650
00:31:50,057 --> 00:31:58,140
it stands for optimize so what that

651
00:31:56,096 --> 00:32:03,173
command just did was produce a file

652
00:31:59,004 --> 00:32:04,037
called some dot F so let me show you

653
00:32:06,044 --> 00:32:12,089
what some dot s is and let me show you

654
00:32:09,539 --> 00:32:12,890
the function some store

655
00:32:15,028 --> 00:32:20,086
can you see that then okay

656
00:32:27,065 --> 00:32:34,071
so this is the code it says some store

657
00:32:31,059 --> 00:32:35,133
and then you'll see you'll recognize

658
00:32:34,071 --> 00:32:38,157
those instructions I mentioned before

659
00:32:36,033 --> 00:32:42,039
the push the move to call the must move

660
00:32:39,057 --> 00:32:47,064
the pop and the rest but you also see

661
00:32:42,039 --> 00:32:50,058
other junk there that that we edited out

662
00:32:48,027 --> 00:32:53,061
for the presentation and even in the

663
00:32:50,058 --> 00:32:54,153
book it got edited out and the reason is

664
00:32:53,061 --> 00:32:56,154
these are various directives that aren't

665
00:32:55,053 --> 00:33:00,081
really directly part of the code itself

666
00:32:57,054 --> 00:33:01,119
the fact they start with a period is an

667
00:33:00,081 --> 00:33:03,120
indication that these aren't actually

668
00:33:02,019 --> 00:33:07,103
instructions there's something else and

669
00:33:04,002 --> 00:33:11,016
they all are related to what the

670
00:33:08,003 --> 00:33:14,016
information that needs to be fed to a

671
00:33:11,034 --> 00:33:17,058
debugger for it to be able to locate

672
00:33:14,016 --> 00:33:19,074
various parts of the program and some

673
00:33:17,058 --> 00:33:21,087
information for the linker to tell it

674
00:33:19,074 --> 00:33:23,112
that this is a globally defined function

675
00:33:21,087 --> 00:33:26,121
and various other things that you don't

676
00:33:24,012 --> 00:33:30,105
really need to rethink about initially

677
00:33:27,021 --> 00:33:32,043
so we sort of take those out of the

678
00:33:31,005 --> 00:33:35,079
program just to make them more readable

679
00:33:32,043 --> 00:33:37,056
but if you ever do this yourself you'll

680
00:33:35,079 --> 00:33:38,160
find this crud in there and we don't

681
00:33:37,056 --> 00:33:40,101
want you to get like oh my gosh this

682
00:33:39,006 --> 00:33:49,061
wasn't in the book I don't know what to

683
00:33:41,001 --> 00:33:50,015
do with it so let's go back

684
00:33:57,083 --> 00:34:02,132
the other thing is people are learning

685
00:33:59,033 --> 00:34:05,090
on data web is sharp versus non charkh

686
00:34:03,032 --> 00:34:10,055
it makes a difference and even like this

687
00:34:05,009 --> 00:34:12,065
is a Mac computer and I can rut got GCC

688
00:34:10,055 --> 00:34:16,055
installed and it generates its Intel

689
00:34:13,046 --> 00:34:19,015
processor in there but it's not directly

690
00:34:16,055 --> 00:34:20,914
compatible with Linux code so it's

691
00:34:19,429 --> 00:34:22,700
pretty important for this course we're

692
00:34:21,409 --> 00:34:29,690
saying just stick with the shark

693
00:34:22,007 --> 00:34:30,044
machines for everything you do so what

694
00:34:29,069 --> 00:34:32,075
are some characteristics that have

695
00:34:31,007 --> 00:34:35,105
assembly code especially how do they

696
00:34:33,029 --> 00:34:38,033
differ from C well first of all there's

697
00:34:36,005 --> 00:34:43,031
a number of different sort of integer

698
00:34:38,069 --> 00:34:45,125
data types of size 1 2 4 and 8 bytes an

699
00:34:43,031 --> 00:34:50,072
integer data type they don't distinguish

700
00:34:46,025 --> 00:34:53,081
sign versus unsigned in how it gets

701
00:34:50,072 --> 00:34:56,075
stored and even an address or a pointer

702
00:34:53,081 --> 00:34:58,169
is just stored as a number in a computer

703
00:34:57,002 --> 00:35:03,011
and doesn't have any special

704
00:34:59,069 --> 00:35:04,091
significance to it a floating-point is

705
00:35:03,011 --> 00:35:06,023
handled in a very different way on the

706
00:35:04,091 --> 00:35:08,153
other hand with a different set of

707
00:35:06,023 --> 00:35:10,109
registers that I think I'll talked about

708
00:35:09,053 --> 00:35:14,099
very briefly in one of the later

709
00:35:11,009 --> 00:35:16,088
lectures the program itself is in x86

710
00:35:14,099 --> 00:35:17,158
it's just a series of bytes and I'll

711
00:35:16,088 --> 00:35:20,170
show you some examples of those and

712
00:35:18,058 --> 00:35:23,156
things like a raise and structs and

713
00:35:21,007 --> 00:35:26,072
things that you think of as fundamental

714
00:35:24,056 --> 00:35:29,075
datatypes don't exist at the machine

715
00:35:27,035 --> 00:35:32,042
level they're sort of constructed

716
00:35:29,075 --> 00:35:33,146
artificially by the compiler and later

717
00:35:32,042 --> 00:35:36,095
in the course and these lectures will

718
00:35:34,046 --> 00:35:39,122
cross over into how that's actually done

719
00:35:36,095 --> 00:35:42,110
as well so some of the things you're you

720
00:35:40,022 --> 00:35:45,101
know about and see exists here and some

721
00:35:43,001 --> 00:35:48,053
of them are sort of have to be built up

722
00:35:46,001 --> 00:35:51,013
in layers on top of the assembly level

723
00:35:48,062 --> 00:35:50,113
program

724
00:35:51,619 --> 00:35:56,665
so the other thing about assembly level

725
00:35:54,619 --> 00:35:58,666
programming is each instruction is very

726
00:35:57,079 --> 00:36:03,102
very limited in what it can do it can

727
00:35:59,089 --> 00:36:07,108
move data from a register to memory from

728
00:36:03,309 --> 00:36:10,190
or it can do an addition or a

729
00:36:07,279 --> 00:36:11,353
multiplication or something like that

730
00:36:10,019 --> 00:36:17,338
but it can really basically only do one

731
00:36:12,019 --> 00:36:19,072
thing and and so you have to write a

732
00:36:17,509 --> 00:36:20,960
whole if you were writing it by hand

733
00:36:19,549 --> 00:36:23,630
you'd have to write a whole series of

734
00:36:20,096 --> 00:36:23,875
instructions to get anything done and

735
00:36:23,063 --> 00:36:25,118
that's part of the reason why it's

736
00:36:24,739 --> 00:36:30,140
really much better to what the compiler

737
00:36:26,018 --> 00:36:35,307
do that and that will also see the sort

738
00:36:30,014 --> 00:36:39,089
of how things like do loops while loops

739
00:36:35,469 --> 00:36:42,478
conditional switch statements those are

740
00:36:39,089 --> 00:36:46,768
all built up on top of some other lower

741
00:36:42,559 --> 00:36:50,608
level features in the instructions so

742
00:36:47,569 --> 00:36:53,930
for this function a some store actually

743
00:36:51,049 --> 00:36:57,130
it gets encoded by a total of fourteen

744
00:36:53,093 --> 00:36:59,262
bytes and so one thing about x86 is some

745
00:36:57,859 --> 00:37:02,901
instructions are as short as one byte

746
00:37:00,099 --> 00:37:07,146
but others can be as long as 15 bytes

747
00:37:03,279 --> 00:37:07,308
saw in the encoding and

748
00:37:12,041 --> 00:37:18,460
Oh like I said each each instruction

749
00:37:16,039 --> 00:37:21,200
really typically only does one thing so

750
00:37:18,829 --> 00:37:23,908
for example and see if you say star desc

751
00:37:21,002 --> 00:37:26,075
equals T what that will typically and

752
00:37:24,619 --> 00:37:28,690
not always but this sort of way to think

753
00:37:26,093 --> 00:37:30,532
about that at the machine level is it

754
00:37:28,069 --> 00:37:33,143
ten years some local value would be

755
00:37:31,369 --> 00:37:36,230
typically stored in a register and as

756
00:37:34,043 --> 00:37:37,094
you know and see if you put star in

757
00:37:36,023 --> 00:37:40,072
front of it you want it referenced as a

758
00:37:37,094 --> 00:37:43,139
pointer and if that reference is on the

759
00:37:40,279 --> 00:37:46,900
left you want to store a number of value

760
00:37:44,039 --> 00:37:50,042
at that place where you're pointing to

761
00:37:46,009 --> 00:37:52,058
so what would typically happen is

762
00:37:50,042 --> 00:37:55,471
guessed that the actual pointer value

763
00:37:53,039 --> 00:37:58,978
would also be stored in a register here

764
00:37:55,849 --> 00:38:01,970
it's in register RBX and i use a move

765
00:37:59,329 --> 00:38:04,354
instruction to say take the value from

766
00:38:01,097 --> 00:38:06,139
one register which is called our ax here

767
00:38:04,579 --> 00:38:10,600
and store it in the memory location

768
00:38:07,039 --> 00:38:13,408
that's specified by another register so

769
00:38:10,789 --> 00:38:15,793
you see the idea we'll go into more

770
00:38:13,759 --> 00:38:17,764
detail about all these register names

771
00:38:15,829 --> 00:38:19,700
and what the parentheses mean but you

772
00:38:18,259 --> 00:38:22,910
get the rough idea that a move

773
00:38:19,007 --> 00:38:26,316
instruction is saying can refer to

774
00:38:22,091 --> 00:38:28,124
either a register or a memory location

775
00:38:27,009 --> 00:38:31,400
and the actual object code

776
00:38:29,024 --> 00:38:38,024
representation of this is just three

777
00:38:31,004 --> 00:38:39,883
bytes where the first byte tells it that

778
00:38:38,024 --> 00:38:42,029
it and we would even talk much in this

779
00:38:40,279 --> 00:38:46,220
course about how the instructions are

780
00:38:42,074 --> 00:38:48,193
encoded won't generally let programs do

781
00:38:46,022 --> 00:38:50,048
that for us but in this case it only

782
00:38:48,859 --> 00:38:53,860
takes three bytes to write that

783
00:38:50,048 --> 00:38:55,627
particular instruction so how can we

784
00:38:53,869 --> 00:38:57,892
know that kind of stuff how can we

785
00:38:56,059 --> 00:38:59,750
figure out that level of detail well

786
00:38:58,099 --> 00:39:03,890
there's some really useful tools that

787
00:38:59,075 --> 00:39:05,099
let you examine machine code even if you

788
00:39:03,089 --> 00:39:08,120
don't have a copy of the original C file

789
00:39:05,099 --> 00:39:09,197
or even the assembly code file ahead of

790
00:39:09,002 --> 00:39:14,061
time and there's one called a

791
00:39:10,097 --> 00:39:17,446
disassembler so an assembler goes from

792
00:39:14,259 --> 00:39:20,900
this text version of instructions to a

793
00:39:18,319 --> 00:39:22,327
byte level representation and the

794
00:39:20,009 --> 00:39:24,062
disassembler just reverses that it says

795
00:39:23,119 --> 00:39:30,170
here is a series of bytes

796
00:39:25,043 --> 00:39:32,060
and I the disassembler know that this

797
00:39:30,017 --> 00:39:34,103
particular byte sequence refers is a

798
00:39:32,006 --> 00:39:37,073
move instruction and so it will now

799
00:39:35,003 --> 00:39:40,004
print out on the screen to say oh that

800
00:39:38,027 --> 00:39:42,095
was a move instruction and so it

801
00:39:40,013 --> 00:39:45,047
basically reverse engineers from the

802
00:39:42,095 --> 00:39:47,108
object code back to the assembly code or

803
00:39:45,047 --> 00:39:55,052
something sort of like the assembly code

804
00:39:48,008 --> 00:39:58,076
you'll see it lost of what it's very

805
00:39:55,052 --> 00:40:00,074
slightly different one thing also to

806
00:39:58,076 --> 00:40:03,122
notice I should mention about assembly

807
00:40:00,074 --> 00:40:05,168
code is all those you know all the names

808
00:40:04,022 --> 00:40:09,050
I used all the names of variables are

809
00:40:06,068 --> 00:40:11,126
completely lost at the assembly code

810
00:40:09,005 --> 00:40:13,064
level or the machine code level things

811
00:40:12,026 --> 00:40:16,055
are just there in registers they're

812
00:40:14,009 --> 00:40:18,041
somewhere in memory the program has no

813
00:40:16,055 --> 00:40:21,128
understanding of your original source

814
00:40:18,041 --> 00:40:23,123
code at that level and so the

815
00:40:22,028 --> 00:40:26,036
disassembled is just a way to go

816
00:40:24,023 --> 00:40:29,075
backwards and you can do that yourself

817
00:40:26,036 --> 00:40:35,101
and you'll find that useful in various

818
00:40:29,075 --> 00:40:35,101
contexts and to do that yourself

819
00:40:37,509 --> 00:40:46,593
things kind of monkeying around music so

820
00:40:43,219 --> 00:40:47,232
if I compile the sum program

821
00:41:01,059 --> 00:41:08,059
so if I do the more standard thing you

822
00:41:04,072 --> 00:41:11,074
do in using a compiler you say run the

823
00:41:08,059 --> 00:41:13,111
compiler give it some optimization tell

824
00:41:11,092 --> 00:41:15,099
it what the source files are until where

825
00:41:14,011 --> 00:41:19,015
to put the final executable code and I'm

826
00:41:16,062 --> 00:41:25,117
terribly clever I call the function sum

827
00:41:19,015 --> 00:41:28,050
and so sum is a binary file of eight

828
00:41:26,017 --> 00:41:31,021
thousand six hundred sixty-three bikes

829
00:41:28,005 --> 00:41:34,054
you'll see off on the left it's marked

830
00:41:31,021 --> 00:41:38,034
as executable and it actually works I

831
00:41:34,099 --> 00:41:40,156
can add numbers together with it so

832
00:41:38,034 --> 00:41:46,117
that's the year the standard executable

833
00:41:41,056 --> 00:41:50,137
program excuse me and if I run a program

834
00:41:47,017 --> 00:41:54,061
called object dump and ask it to

835
00:41:51,037 --> 00:41:58,045
disassemble it can do various things it

836
00:41:54,061 --> 00:41:59,125
will spit out a disassembled version of

837
00:41:58,045 --> 00:42:06,072
the program it will fly by on the screen

838
00:42:00,025 --> 00:42:06,072
but if I redirect that to some file

839
00:42:07,029 --> 00:42:12,075
which I already did I'll remove the old

840
00:42:10,045 --> 00:42:12,048
one

841
00:42:17,001 --> 00:42:25,009
and now I look at that you will see that

842
00:42:22,057 --> 00:42:26,143
it has what I described as is the

843
00:42:25,081 --> 00:42:29,086
disassembled representation of the

844
00:42:27,043 --> 00:42:31,048
program including some files that you

845
00:42:29,086 --> 00:42:33,112
didn't some functions that you didn't

846
00:42:31,093 --> 00:42:37,107
write as ones that are sort of the

847
00:42:34,012 --> 00:42:40,084
low-level functions that are used in the

848
00:42:38,007 --> 00:42:42,084
initial startup of a program called in

849
00:42:40,084 --> 00:42:45,084
it

850
00:42:42,084 --> 00:42:45,084
oops

851
00:42:47,078 --> 00:42:52,119
but here somewhere in the middle of it

852
00:42:50,052 --> 00:42:56,061
you'll see lo and behold is that program

853
00:42:53,019 --> 00:43:00,060
that function some story that got

854
00:42:56,061 --> 00:43:05,096
compiled and you can see that what it

855
00:43:00,006 --> 00:43:08,085
did was it took this 14 bytes from the

856
00:43:05,096 --> 00:43:11,127
original that the object code and it

857
00:43:09,039 --> 00:43:14,091
picked those apart and came back with

858
00:43:12,027 --> 00:43:16,101
what instructions those bytes in code so

859
00:43:14,091 --> 00:43:19,143
for example the push instruction only

860
00:43:17,001 --> 00:43:24,006
takes a single byte the move as you saw

861
00:43:20,043 --> 00:43:27,048
before takes three bytes this call

862
00:43:24,051 --> 00:43:29,118
because it has to give the location of

863
00:43:27,093 --> 00:43:34,155
where to call is a five byte instruction

864
00:43:30,018 --> 00:43:37,050
and so forth but again the disassembler

865
00:43:35,055 --> 00:43:38,121
didn't have access to the source code it

866
00:43:37,005 --> 00:43:40,101
didn't have access even to the assembly

867
00:43:39,021 --> 00:43:46,029
code it figured this out just by the

868
00:43:41,046 --> 00:43:48,053
bytes in the actual object code file so

869
00:43:46,029 --> 00:43:51,084
this is the way if you ever want to know

870
00:43:48,053 --> 00:43:53,135
actually the byte level encoding this is

871
00:43:51,084 --> 00:43:58,140
how you figure it out is to run a

872
00:43:54,035 --> 00:44:01,071
program run it through an assembler get

873
00:43:59,004 --> 00:44:06,035
object code and then come back out with

874
00:44:01,071 --> 00:44:06,071
it there's another way you can do it

875
00:44:06,083 --> 00:44:11,139
using the debugging program which you'll

876
00:44:10,023 --> 00:44:16,095
get to know very well in the next web

877
00:44:12,039 --> 00:44:23,067
you're going to do and it's called gdb

878
00:44:16,095 --> 00:44:26,097
and gdb is a very powerful debugging

879
00:44:23,067 --> 00:44:28,166
program that you can examine step

880
00:44:26,097 --> 00:44:33,144
through and operate on programs in and

881
00:44:29,066 --> 00:44:35,118
again you can if you if the source code

882
00:44:34,044 --> 00:44:38,121
for it's available it will make use of

883
00:44:36,018 --> 00:44:40,077
it but it also can be used on programs

884
00:44:39,021 --> 00:44:42,075
for which there's no source available

885
00:44:40,077 --> 00:44:44,121
but one of the features is the ability

886
00:44:42,075 --> 00:44:51,077
to disassemble functions in there so if

887
00:44:45,021 --> 00:44:53,027
I say disassemble some store

888
00:44:51,077 --> 00:44:54,152
it'll come back with something that

889
00:44:53,081 --> 00:44:58,115
looks a lot like what you saw from the

890
00:44:55,052 --> 00:45:01,103
from object dump a listing of the

891
00:44:59,015 --> 00:45:03,071
instructions and here it just shows in

892
00:45:02,003 --> 00:45:05,099
hex what the addresses of those

893
00:45:03,071 --> 00:45:10,073
different instructions are it doesn't

894
00:45:05,099 --> 00:45:12,155
show the byte level encoding so there's

895
00:45:10,091 --> 00:45:16,106
my point here is there's various tools

896
00:45:13,055 --> 00:45:18,113
that let you look at a program even if

897
00:45:17,006 --> 00:45:21,020
it's actual representation is a binary

898
00:45:19,013 --> 00:45:23,077
file that you don't want to examine

899
00:45:21,002 --> 00:45:23,059
directly

900
00:45:32,047 --> 00:45:37,083
I just plug this in

901
00:45:42,569 --> 00:45:47,950
so what this slide shows is what I just

902
00:45:45,097 --> 00:45:49,138
showed you on the screen which is what

903
00:45:47,095 --> 00:45:53,176
the object dump program produces for

904
00:45:50,038 --> 00:45:56,095
this function and this is a version

905
00:45:54,076 --> 00:45:59,080
showing what gdb would show you for it

906
00:45:56,095 --> 00:46:02,724
and with gdb if you want to actually get

907
00:46:00,016 --> 00:46:06,405
the bytes out you can do that you can

908
00:46:03,579 --> 00:46:09,130
basically for any address you can just

909
00:46:06,549 --> 00:46:11,580
give an address and tell it to display

910
00:46:09,013 --> 00:46:16,066
some number of bytes and so this rather

911
00:46:11,859 --> 00:46:19,932
cryptic command to gdb says examine 14

912
00:46:16,066 --> 00:46:25,123
bytes in hex format starting at the

913
00:46:20,589 --> 00:46:27,615
address of the function sum store and it

914
00:46:26,023 --> 00:46:30,602
produced something that looks like what

915
00:46:27,849 --> 00:46:29,945
you see on the left

916
00:46:32,022 --> 00:46:37,090
in fact disassembly is a tool that can

917
00:46:35,029 --> 00:46:39,115
be used as part of any of reverse

918
00:46:37,009 --> 00:46:41,101
engineering tools and I used to demo

919
00:46:40,015 --> 00:46:47,080
this by showing a disassembly of the

920
00:46:42,082 --> 00:46:51,181
windows of Microsoft Word I had a PC

921
00:46:47,008 --> 00:46:54,085
back then not a mess but some people and

922
00:46:52,081 --> 00:46:56,170
you know our slides are online and so we

923
00:46:55,057 --> 00:46:59,095
got some nasty grams from people saying

924
00:46:57,007 --> 00:47:01,039
you know you're violating the Microsoft

925
00:46:59,095 --> 00:47:04,099
end-user license agreement when you do

926
00:47:02,002 --> 00:47:06,064
that because you're supposed to you

927
00:47:04,099 --> 00:47:09,100
don't know this but remember all those

928
00:47:06,064 --> 00:47:13,153
click through I agree things that you

929
00:47:10,009 --> 00:47:16,090
never read one of them is that we not to

930
00:47:14,053 --> 00:47:20,101
try to reverse-engineer any microsoft

931
00:47:16,009 --> 00:47:23,011
product so so this is when technically

932
00:47:21,001 --> 00:47:26,014
so I'm sure just for modesty I blanked

933
00:47:23,092 --> 00:47:27,100
this out but you can actually do it if

934
00:47:26,014 --> 00:47:31,015
you can find where the file is it's sort

935
00:47:28,000 --> 00:47:34,069
of obscure where the actual executable

936
00:47:31,024 --> 00:47:39,085
files of an application now my point is

937
00:47:34,069 --> 00:47:41,140
that words like any other application

938
00:47:39,085 --> 00:47:43,144
you run is just an executable file and

939
00:47:42,004 --> 00:47:49,075
that executable file is just a bunch of

940
00:47:44,044 --> 00:47:51,097
bytes that encode instructions okay so

941
00:47:50,011 --> 00:47:54,048
let's go a little bit further into this

942
00:47:51,097 --> 00:47:57,129
to assembly level programming business

943
00:47:54,048 --> 00:48:01,117
so I keep talking about registers and

944
00:47:58,029 --> 00:48:04,078
x86 64 has this totally quirky set of

945
00:48:02,017 --> 00:48:07,024
registers and it's a reflection again of

946
00:48:04,078 --> 00:48:11,155
this sort of evolutionary history to it

947
00:48:07,024 --> 00:48:14,098
but you'll see that there's 16 registers

948
00:48:12,055 --> 00:48:18,073
that you can use to hold integers and

949
00:48:14,098 --> 00:48:20,098
pointers and some of them have these

950
00:48:18,073 --> 00:48:22,138
sort of alphabetic names and some of

951
00:48:20,098 --> 00:48:24,145
them have numeric names I'll show you

952
00:48:23,038 --> 00:48:27,043
why in a minute and also for each

953
00:48:25,045 --> 00:48:32,050
register if you use the sort of percent

954
00:48:27,088 --> 00:48:33,145
are name of it you'll get 64 bits but if

955
00:48:32,005 --> 00:48:36,076
you use the percent II version of it

956
00:48:34,045 --> 00:48:40,047
you'll get 32 bits and what you'll find

957
00:48:37,021 --> 00:48:43,102
in programs that manipulate long in

958
00:48:40,065 --> 00:48:44,109
you'll see the use of are and if they're

959
00:48:44,002 --> 00:48:47,025
just in there

960
00:48:45,009 --> 00:48:49,041
two-bit things you'll see code saying

961
00:48:47,025 --> 00:48:51,033
percent e so you'll see both of these

962
00:48:49,041 --> 00:48:54,117
show up but and it's fairly important to

963
00:48:52,005 --> 00:48:58,088
remember that the percent e version is

964
00:48:55,017 --> 00:49:03,099
just the low order 32 bits of a larger

965
00:48:58,088 --> 00:49:04,116
percent our entity and in fact it goes

966
00:49:03,099 --> 00:49:06,168
beyond that

967
00:49:05,016 --> 00:49:11,025
you can also reference the lower order

968
00:49:07,068 --> 00:49:13,161
16 bits and the low order two bit I'm

969
00:49:11,025 --> 00:49:16,122
sorry one byte 16 want 2 bytes and one

970
00:49:14,061 --> 00:49:20,145
byte within each of these registers as

971
00:49:17,022 --> 00:49:25,059
well but again think of these as like

972
00:49:21,045 --> 00:49:27,099
named locations where you can store

973
00:49:25,059 --> 00:49:32,088
values and you can retrieve values from

974
00:49:27,099 --> 00:49:34,113
them and you have to you the suit of

975
00:49:32,088 --> 00:49:39,105
personifying machine level programming

976
00:49:35,013 --> 00:49:42,042
here not you personally will actually

977
00:49:40,005 --> 00:49:45,018
have to explicitly name those registers

978
00:49:42,042 --> 00:49:46,086
for the most part to say where things

979
00:49:45,018 --> 00:49:49,092
should go where they should come out of

980
00:49:46,086 --> 00:49:51,165
it's not like a memory where you just

981
00:49:49,092 --> 00:49:53,115
give a number to tell where to look for

982
00:49:52,065 --> 00:49:55,128
you could compute a number there

983
00:49:54,015 --> 00:49:59,064
actually each one is identified

984
00:49:56,028 --> 00:50:06,066
separately so just as a little bit of

985
00:49:59,064 --> 00:50:10,083
history with ia32 so back we just talked

986
00:50:06,066 --> 00:50:13,068
about there being 8 registers all the %

987
00:50:10,083 --> 00:50:17,136
e versions and one of the changes that

988
00:50:13,086 --> 00:50:19,164
went from ia32 to x86 64 was to double

989
00:50:18,036 --> 00:50:22,053
the number of registers and by the way

990
00:50:20,064 --> 00:50:23,160
this is a really helpful thing because

991
00:50:22,053 --> 00:50:28,068
it was very frustrating how few

992
00:50:24,006 --> 00:50:37,023
registers there were in the old I 32

993
00:50:28,068 --> 00:50:39,114
machines and then the as I mentioned you

994
00:50:37,077 --> 00:50:43,089
could actually in the old machine refer

995
00:50:40,014 --> 00:50:46,107
to the lower door 16 bytes of these

996
00:50:43,089 --> 00:50:50,097
registers and that was a legacy from the

997
00:50:47,007 --> 00:50:54,066
8086 days and within the first floor you

998
00:50:51,069 --> 00:50:57,072
could even refer to the individual to

999
00:50:54,066 --> 00:51:00,093
lord or bytes in those

1000
00:50:57,072 --> 00:51:03,078
so nowadays you can actually get to the

1001
00:51:00,093 --> 00:51:06,126
low order byte of all of them and we

1002
00:51:03,078 --> 00:51:08,157
just sort of got that covered in the

1003
00:51:07,026 --> 00:51:10,125
book actually we don't talk about how

1004
00:51:09,057 --> 00:51:13,155
you can get to these bytes because

1005
00:51:11,025 --> 00:51:23,025
that's really a legacy from back before

1006
00:51:14,055 --> 00:51:31,110
the 8086 was one called the 8080 which

1007
00:51:23,025 --> 00:51:34,026
was a an 8 byte machine so anyways you

1008
00:51:32,001 --> 00:51:37,026
can see then how you got from this kind

1009
00:51:34,026 --> 00:51:39,108
of weird state of affairs to the even

1010
00:51:37,035 --> 00:51:42,093
weirder state that we are in today where

1011
00:51:40,008 --> 00:51:47,010
some of them have names and some of them

1012
00:51:42,093 --> 00:51:50,151
have numbers and those names by the way

1013
00:51:47,001 --> 00:51:53,100
had a reason back in ancient days they

1014
00:51:51,051 --> 00:51:55,134
had very specific purposes and so they

1015
00:51:54,009 --> 00:52:00,021
were given names that sort of reflected

1016
00:51:56,034 --> 00:52:02,097
those purposes but that that all went

1017
00:52:00,021 --> 00:52:05,076
away years and years ago and so now

1018
00:52:02,097 --> 00:52:07,140
these names are just legacy names have

1019
00:52:05,076 --> 00:52:09,111
nothing to do with their purpose now I

1020
00:52:08,004 --> 00:52:11,043
should mention there's only there are

1021
00:52:10,011 --> 00:52:16,095
some special there's one special

1022
00:52:11,079 --> 00:52:18,123
register nowadays as shown in pink here

1023
00:52:16,095 --> 00:52:21,117
and that's called the stack pointer and

1024
00:52:19,023 --> 00:52:23,106
that register you don't just use any old

1025
00:52:22,017 --> 00:52:26,052
way you please it has a very specific

1026
00:52:24,006 --> 00:52:28,071
purpose and all the other registers

1027
00:52:26,052 --> 00:52:29,130
there's some that are slightly different

1028
00:52:28,071 --> 00:52:32,076
than the other but for the most part

1029
00:52:30,003 --> 00:52:37,010
they're all usable for holding program

1030
00:52:33,021 --> 00:52:39,087
data back in the ia32 days there was a

1031
00:52:37,037 --> 00:52:42,102
register called the base pointer that

1032
00:52:39,087 --> 00:52:44,091
also got used for procedures but that no

1033
00:52:43,002 --> 00:52:49,035
longer gets used anymore either

1034
00:52:45,027 --> 00:52:50,100
at least not usually so anyways I didn't

1035
00:52:49,035 --> 00:52:53,040
want to I don't want to spend a lot of

1036
00:52:51,000 --> 00:52:56,073
time on historic legacy stuff and have

1037
00:52:53,085 --> 00:52:57,183
you memorized you know what feature was

1038
00:52:56,073 --> 00:52:59,169
added and what model of processor but

1039
00:52:58,083 --> 00:53:02,124
just in case you're wondering why

1040
00:53:00,069 --> 00:53:04,140
there's these weird names for these

1041
00:53:03,024 --> 00:53:08,563
things just so you appreciate the fact

1042
00:53:05,004 --> 00:53:12,102
that this is a legacy thing

1043
00:53:08,779 --> 00:53:15,806
okay so now we can think of it then that

1044
00:53:13,038 --> 00:53:17,627
there's eight registers with names and

1045
00:53:16,049 --> 00:53:21,071
there's eight registers that are

1046
00:53:17,969 --> 00:53:22,970
indicated by some number and let's look

1047
00:53:21,269 --> 00:53:28,650
at some of the instructions that operate

1048
00:53:22,979 --> 00:53:31,170
on those registers and there's sort of

1049
00:53:28,065 --> 00:53:33,734
three different so move the move

1050
00:53:31,017 --> 00:53:38,846
instruction in x86 is actually can do a

1051
00:53:34,319 --> 00:53:41,327
lot of things because it can take

1052
00:53:38,999 --> 00:53:44,072
different types of information or what

1053
00:53:42,119 --> 00:53:47,192
they call operands so the source and

1054
00:53:44,729 --> 00:53:50,783
some where you're you're copying from

1055
00:53:47,849 --> 00:53:52,913
the source to the destination the source

1056
00:53:51,269 --> 00:53:55,295
can be some what's called immediate it's

1057
00:53:53,489 --> 00:53:58,140
actually a number that's baked into the

1058
00:53:55,529 --> 00:54:01,550
program that you want to copy into some

1059
00:53:58,014 --> 00:54:05,413
other location a register we've talked

1060
00:54:01,739 --> 00:54:07,796
about is one a specially named memory of

1061
00:54:05,539 --> 00:54:10,680
locations and memory is the array of

1062
00:54:08,309 --> 00:54:13,140
bytes that you typically you have to

1063
00:54:10,068 --> 00:54:16,007
specify what's the address that you're

1064
00:54:13,014 --> 00:54:18,953
either reading from if if it's the

1065
00:54:16,619 --> 00:54:22,700
source are you writing to if it's the

1066
00:54:19,079 --> 00:54:26,101
destination and so the move instruction

1067
00:54:23,429 --> 00:54:31,170
gives you all these possibilities an

1068
00:54:26,299 --> 00:54:33,650
immediate value can be written to a

1069
00:54:31,017 --> 00:54:36,146
register or directly to memory a

1070
00:54:33,065 --> 00:54:38,163
register value can be copied to another

1071
00:54:36,299 --> 00:54:42,302
register or written to memory or you can

1072
00:54:39,063 --> 00:54:44,672
take a value from memory read it from

1073
00:54:42,329 --> 00:54:47,366
memory and copy it to a register so if

1074
00:54:45,239 --> 00:54:50,276
you think of a wait shouldn't there be

1075
00:54:47,699 --> 00:54:52,890
nine different combinations here well no

1076
00:54:50,609 --> 00:54:55,625
because it doesn't make sense to have an

1077
00:54:52,089 --> 00:54:58,958
immediate value as a destination it's a

1078
00:54:55,769 --> 00:55:00,848
constant and also just for sort of the

1079
00:54:59,759 --> 00:55:03,776
sake of convenience so the hardware

1080
00:55:01,559 --> 00:55:06,150
designers it doesn't let you directly

1081
00:55:03,929 --> 00:55:08,400
copy from one memory location to another

1082
00:55:06,015 --> 00:55:10,484
what you have to do is use two

1083
00:55:08,004 --> 00:55:11,031
instructions one to copy from memory to

1084
00:55:10,619 --> 00:55:15,692
read it from memory

1085
00:55:11,067 --> 00:55:17,216
copy it to a register and a second to

1086
00:55:16,349 --> 00:55:19,390
take that value in the register and

1087
00:55:17,819 --> 00:55:23,980
rewrite it to memory

1088
00:55:19,039 --> 00:55:27,040
so that's why there's this only five

1089
00:55:23,098 --> 00:55:29,155
possibilities and so each of these

1090
00:55:27,049 --> 00:55:33,052
actual five combinations you'll see in

1091
00:55:30,055 --> 00:55:35,098
some form or another so for example if I

1092
00:55:33,052 --> 00:55:38,098
take a constant value and copy it to a

1093
00:55:35,098 --> 00:55:39,157
register it's a little like you can

1094
00:55:38,098 --> 00:55:41,155
think of registries in sort of the

1095
00:55:40,057 --> 00:55:44,136
temporary data that you're operating on

1096
00:55:42,055 --> 00:55:46,147
right now so it's a way of sort of

1097
00:55:45,036 --> 00:55:51,099
assigning a constant value to a

1098
00:55:47,047 --> 00:55:53,131
temporary similarly if you're have a

1099
00:55:51,099 --> 00:55:56,140
memory as your destination it's like

1100
00:55:54,031 --> 00:56:01,036
storing a constant value in memory

1101
00:55:57,004 --> 00:56:02,080
somewhere if you're copying from one

1102
00:56:01,036 --> 00:56:04,111
register to another it's sort of like

1103
00:56:03,016 --> 00:56:08,109
copying one temporary value to another

1104
00:56:05,011 --> 00:56:13,033
one register to memory it's as if you

1105
00:56:09,009 --> 00:56:15,016
it's sort of like storing to an address

1106
00:56:13,033 --> 00:56:16,117
so a pointer dereference where the

1107
00:56:15,079 --> 00:56:20,086
pointers on the left side the

1108
00:56:17,017 --> 00:56:22,114
dereference and memory to register is

1109
00:56:21,049 --> 00:56:26,056
the opposite it's your you're reading

1110
00:56:23,014 --> 00:56:32,017
from some location into a temporary

1111
00:56:26,056 --> 00:56:36,091
position so these Yosi all five versions

1112
00:56:32,017 --> 00:56:38,094
get used in some form or another so now

1113
00:56:36,091 --> 00:56:42,127
let's talk about how we write these

1114
00:56:38,094 --> 00:56:45,112
pointers how we specify either a source

1115
00:56:43,027 --> 00:56:49,111
or a destination for a memory reference

1116
00:56:46,012 --> 00:56:52,015
and you already saw one version of this

1117
00:56:50,011 --> 00:56:54,090
in fact in some of the code when you put

1118
00:56:52,042 --> 00:56:57,064
the name of a register in parenthesis

1119
00:56:54,009 --> 00:56:59,011
that's just saying use this register

1120
00:56:57,064 --> 00:57:02,101
whatever is in that that's an address

1121
00:57:00,001 --> 00:57:06,010
and use that address to reference some

1122
00:57:03,001 --> 00:57:10,003
memory location and so you'll see

1123
00:57:07,000 --> 00:57:11,077
something like this is equivalent of

1124
00:57:10,003 --> 00:57:12,067
dereferencing a pointer and putting it

1125
00:57:11,077 --> 00:57:14,095
in there temporary

1126
00:57:12,067 --> 00:57:17,122
you're also allowed to do a little bit

1127
00:57:14,095 --> 00:57:19,191
of arithmetic to derive an address from

1128
00:57:18,022 --> 00:57:23,095
some collection of registers and other

1129
00:57:20,091 --> 00:57:26,164
constant values so if you see a number

1130
00:57:23,095 --> 00:57:30,124
called the displacement D in front of

1131
00:57:27,064 --> 00:57:32,099
this parenthesis it means to offset not

1132
00:57:31,024 --> 00:57:35,027
use the address that's in the

1133
00:57:32,099 --> 00:57:36,185
register but add or subtract some number

1134
00:57:35,054 --> 00:57:39,098
from it to get an address that's just

1135
00:57:37,085 --> 00:57:42,116
slightly off of it by some fixed amount

1136
00:57:39,098 --> 00:57:46,184
and that we'll see is fairly useful for

1137
00:57:43,016 --> 00:57:49,079
accessing different data structures so

1138
00:57:47,084 --> 00:57:51,136
here is an example of a very simple

1139
00:57:49,079 --> 00:57:55,163
function that we can understand

1140
00:57:52,036 --> 00:57:58,067
everything about it already because we

1141
00:57:56,063 --> 00:58:02,078
know what the move instruction does and

1142
00:57:58,067 --> 00:58:05,102
that the sort of classic swapping of two

1143
00:58:02,078 --> 00:58:07,172
values that are stored in memory so my

1144
00:58:06,002 --> 00:58:11,063
point my arguments are two pointers

1145
00:58:08,072 --> 00:58:12,146
called XP and YP and I'm going to

1146
00:58:11,063 --> 00:58:16,088
dereference those pointers I'm going to

1147
00:58:13,046 --> 00:58:20,080
read from memory into registers and then

1148
00:58:16,088 --> 00:58:24,100
I'm going to copy back to to memory but

1149
00:58:20,008 --> 00:58:27,083
reversing the the two destinations and

1150
00:58:25,000 --> 00:58:31,007
so as you can imagine it it lines up to

1151
00:58:28,055 --> 00:58:34,103
be for move instructions that correspond

1152
00:58:31,007 --> 00:58:37,064
to these four references and the final

1153
00:58:35,003 --> 00:58:40,004
one rekt just won't learn more about

1154
00:58:37,064 --> 00:58:42,068
functions and how they're called but

1155
00:58:40,004 --> 00:58:46,013
just think of the read is it gets you it

1156
00:58:43,004 --> 00:58:54,008
returns from wherever the calling

1157
00:58:46,013 --> 00:58:58,030
position was and so let's look at at

1158
00:58:54,044 --> 00:59:04,066
more detail at the actual code then and

1159
00:58:58,003 --> 00:59:07,064
so it turns out with 64 x86 64 the

1160
00:59:04,066 --> 00:59:10,094
arguments always come in some specific

1161
00:59:07,091 --> 00:59:12,146
registers and the ones to remember for

1162
00:59:10,094 --> 00:59:14,189
today is Rd I will be the first argument

1163
00:59:13,046 --> 00:59:17,123
register and RS I will be the second

1164
00:59:15,089 --> 00:59:19,091
argument register there can be up to six

1165
00:59:18,023 --> 00:59:23,152
of these and we'll go into more of that

1166
00:59:19,091 --> 00:59:25,150
later so those two registers represent

1167
00:59:23,359 --> 00:59:29,540
the values of XP and YP those are set

1168
00:59:26,005 --> 00:59:31,046
before when this before the function is

1169
00:59:29,054 --> 00:59:33,092
actually begins executing that's set by

1170
00:59:31,091 --> 00:59:36,095
the part of the code that calls this

1171
00:59:33,092 --> 00:59:38,153
function and those will be pointers so

1172
00:59:37,031 --> 00:59:42,090
what they are is they contain addresses

1173
00:59:39,053 --> 00:59:44,106
that specifying locations in memory

1174
00:59:42,009 --> 00:59:46,062
and then within the code the compiler

1175
00:59:45,006 --> 00:59:50,064
just came up with its own ideas of how

1176
00:59:47,043 --> 00:59:53,079
to use different registers for temporary

1177
00:59:50,064 --> 00:59:56,097
data by whatever what's known as the

1178
00:59:53,079 --> 00:59:58,167
register allocation algorithm it uses

1179
00:59:56,097 --> 01:00:00,183
and we don't really care we just want

1180
00:59:59,067 --> 01:00:04,125
what we'll want to do is figure out what

1181
01:00:01,083 --> 01:00:06,171
it's doing and we'll see that a register

1182
01:00:05,025 --> 01:00:12,113
is our ax is being used to hold the

1183
01:00:07,071 --> 01:00:12,113
value T 0 and our DX of the value T 1

1184
01:00:13,043 --> 01:00:20,055
now so let's get actually concrete here

1185
01:00:16,008 --> 01:00:23,010
and this is very detailed but I think

1186
01:00:20,055 --> 01:00:25,119
it's important that you understand sort

1187
01:00:24,000 --> 01:00:29,016
of you can almost simulate the execution

1188
01:00:26,019 --> 01:00:31,019
of some instructions by yourself you're

1189
01:00:29,016 --> 01:00:33,078
going to really have to know this stuff

1190
01:00:31,019 --> 01:00:35,094
so what each of these instructions is

1191
01:00:33,078 --> 01:00:38,112
doing and how it works and really have

1192
01:00:35,094 --> 01:00:40,131
that wired into you pretty well so let's

1193
01:00:39,012 --> 01:00:44,097
make up an example I'll let's imagine

1194
01:00:41,031 --> 01:00:47,115
that the two addresses that are used for

1195
01:00:44,097 --> 01:00:50,121
these two pointers are in hex 1 2 0 and

1196
01:00:48,015 --> 01:00:54,021
1 0 0 by the way those would not be

1197
01:00:51,021 --> 01:00:55,089
typical addresses they're way too small

1198
01:00:54,021 --> 01:00:59,034
a number but it's much easier to use

1199
01:00:55,089 --> 01:01:00,111
them as an illustration and let's

1200
01:00:59,034 --> 01:01:05,115
suppose that one of them held the value

1201
01:01:01,011 --> 01:01:10,013
1 2 3 and the other 4 5 6 so the first

1202
01:01:06,015 --> 01:01:13,017
instruction says use RDI as an address

1203
01:01:10,013 --> 01:01:17,052
copy from that memory location and store

1204
01:01:13,017 --> 01:01:20,034
the result and register R X so R di is 1

1205
01:01:17,052 --> 01:01:22,077
2 0 I'll read from that address I'll

1206
01:01:20,034 --> 01:01:25,077
read the value 1 2 3 and store it and

1207
01:01:22,077 --> 01:01:28,080
register R ax these are all by the way 8

1208
01:01:25,077 --> 01:01:31,175
byte values and I'm just sort of

1209
01:01:29,007 --> 01:01:35,088
glossing over that part of it but the Q

1210
01:01:32,075 --> 01:01:39,075
refers to what in Intel terminology is a

1211
01:01:35,088 --> 01:01:46,104
quad word a word because it goes back to

1212
01:01:39,075 --> 01:01:52,101
the 8086 is 16 bits 2 bytes a long word

1213
01:01:47,004 --> 01:01:53,058
is 32 bits and a quad word is 64 bits

1214
01:01:53,001 --> 01:01:56,055
that

1215
01:01:53,058 --> 01:02:00,087
just their terminology and we're stuck

1216
01:01:56,055 --> 01:02:02,142
with it okay so that one instruction had

1217
01:02:00,087 --> 01:02:05,118
that effect the second instruction does

1218
01:02:03,042 --> 01:02:09,063
the same thing but using RSI which holds

1219
01:02:06,018 --> 01:02:12,063
one zero zero as an address until it

1220
01:02:09,063 --> 01:02:16,148
copies four fifty four five six into RDX

1221
01:02:12,063 --> 01:02:19,146
and then the third instruction is

1222
01:02:17,048 --> 01:02:23,055
writing back to memory so it sources

1223
01:02:20,046 --> 01:02:26,100
register RDX the destination has the

1224
01:02:24,018 --> 01:02:29,027
address of r di which is one two zero

1225
01:02:27,000 --> 01:02:33,065
and its storing that back in memory and

1226
01:02:30,008 --> 01:02:36,081
finally the fourth instruction does the

1227
01:02:33,065 --> 01:02:38,070
the other part of the right so you see

1228
01:02:36,081 --> 01:02:40,125
these four instructions to read from

1229
01:02:38,007 --> 01:02:42,084
memory into registers two of them wrote

1230
01:02:41,025 --> 01:02:48,027
from registers back to memory and that's

1231
01:02:43,047 --> 01:02:50,136
the whole function and you can see it

1232
01:02:48,045 --> 01:02:56,067
this move instruction is is is doing all

1233
01:02:51,036 --> 01:02:58,077
the work here so we've shown that

1234
01:02:56,067 --> 01:03:01,098
example just showed this very simple

1235
01:02:58,077 --> 01:03:04,095
memory referencing that's designated by

1236
01:03:01,098 --> 01:03:05,124
the parentheses and as I mentioned you

1237
01:03:04,095 --> 01:03:08,169
can do a version where you put a

1238
01:03:06,024 --> 01:03:11,100
displacement there too and in fact

1239
01:03:09,069 --> 01:03:12,144
there's a much more elaborate form and

1240
01:03:12,000 --> 01:03:16,059
we'll see that this is useful for

1241
01:03:13,044 --> 01:03:17,115
implementing array references where

1242
01:03:16,059 --> 01:03:22,145
there can be actually two registers

1243
01:03:18,015 --> 01:03:26,094
involved and there can be a displacement

1244
01:03:23,045 --> 01:03:28,053
which is a constant offset and a scale

1245
01:03:26,094 --> 01:03:31,182
factor which will be one two four eight

1246
01:03:29,025 --> 01:03:36,108
and the general idea of it is to take

1247
01:03:32,082 --> 01:03:39,111
our register that I'm referring to as R

1248
01:03:37,008 --> 01:03:44,021
sub I that's known as an index register

1249
01:03:40,011 --> 01:03:49,020
you multiply it by the scale factor I'll

1250
01:03:44,021 --> 01:03:52,074
you add the value of RB register RB and

1251
01:03:50,001 --> 01:03:56,085
you also add the constant displacement

1252
01:03:52,074 --> 01:04:00,081
and these have a RB refers to base our

1253
01:03:56,085 --> 01:04:01,143
eye is index and s is scale and it turns

1254
01:04:00,081 --> 01:04:03,123
out this will be the sort of natural way

1255
01:04:02,043 --> 01:04:05,124
to implement array reference it will

1256
01:04:04,023 --> 01:04:06,106
make a lot more sense when we talk about

1257
01:04:06,024 --> 01:04:09,073
arrays

1258
01:04:07,006 --> 01:04:13,027
but basically you can think of is if

1259
01:04:09,073 --> 01:04:14,161
this is an array index I have to

1260
01:04:13,027 --> 01:04:18,121
typically scale it by however many bytes

1261
01:04:15,061 --> 01:04:21,073
my data type is so if it's an entire to

1262
01:04:19,021 --> 01:04:24,055
scale it by four it's no long I have to

1263
01:04:21,073 --> 01:04:30,076
scale it by eight so that's where these

1264
01:04:24,055 --> 01:04:33,097
scale factors will come in and basically

1265
01:04:31,003 --> 01:04:38,020
the the format in the assembly code lets

1266
01:04:33,097 --> 01:04:39,193
you eliminate some of these fields if

1267
01:04:38,002 --> 01:04:42,064
they're not being used so you'll and we

1268
01:04:40,093 --> 01:04:43,168
already saw that single parenthesis is

1269
01:04:42,082 --> 01:04:48,106
sort of a reduced version of this form

1270
01:04:44,068 --> 01:04:52,072
so let's just do some examples of these

1271
01:04:49,006 --> 01:04:56,032
address computations and let's imagine

1272
01:04:52,072 --> 01:04:59,079
that register RDX hold text F with three

1273
01:04:56,032 --> 01:05:06,034
zeros and RCX held a one with two zeros

1274
01:05:00,042 --> 01:05:08,116
so if I rather than doing one at a time

1275
01:05:06,034 --> 01:05:11,038
you can see each of these I'm taking RDX

1276
01:05:09,016 --> 01:05:15,040
which is f with three zeros adding eight

1277
01:05:11,074 --> 01:05:18,076
and so that's F zero zero eight here I'm

1278
01:05:15,004 --> 01:05:22,006
adding together registers RDX and RCX

1279
01:05:18,076 --> 01:05:24,100
and it gives me F 1 0 0 I'm doing the

1280
01:05:22,006 --> 01:05:30,043
same here except that I'm scaling RCX by

1281
01:05:25,000 --> 01:05:35,083
4 so 4 times 1 0 0 is is 4 0 0 and I'm

1282
01:05:30,097 --> 01:05:38,155
adding that to F and here I'm taking RDX

1283
01:05:35,083 --> 01:05:42,154
which is f 0 with 3 zeros if I double

1284
01:05:39,055 --> 01:05:46,069
that I get 1e with 3 zeros if you think

1285
01:05:43,054 --> 01:05:50,118
about shifting an F to the left 1 you

1286
01:05:46,069 --> 01:05:54,124
get a 1 and then it goes 1 1 1 0 and

1287
01:05:51,018 --> 01:05:58,036
that's an e ok and then I'm adding this

1288
01:05:55,024 --> 01:05:59,101
displacement of 8 0 to it so the point

1289
01:05:58,036 --> 01:06:01,108
of this is all of this is arithmetic

1290
01:06:00,001 --> 01:06:05,062
it's all using whatever is in the

1291
01:06:02,008 --> 01:06:07,057
register and there's some rules for how

1292
01:06:05,062 --> 01:06:09,088
you combine this and get an address and

1293
01:06:07,057 --> 01:06:12,150
then that's being used to either read or

1294
01:06:09,088 --> 01:06:12,150
write some memory locations

1295
01:06:14,052 --> 01:06:20,651
okay so now what is the final part of it

1296
01:06:17,043 --> 01:06:23,106
today I'll go through some arithmetic

1297
01:06:21,119 --> 01:06:26,130
and one of the things that we'll be sure

1298
01:06:24,006 --> 01:06:28,080
to confuse you and drive you crazy and

1299
01:06:26,013 --> 01:06:31,068
make you be sending email to the staff

1300
01:06:28,008 --> 01:06:34,050
for explanation is an instruction called

1301
01:06:31,068 --> 01:06:37,146
load effective address and the reason is

1302
01:06:35,022 --> 01:06:41,031
its purpose in life is to do basically

1303
01:06:38,046 --> 01:06:44,142
the ampersand operation of C to compute

1304
01:06:41,031 --> 01:06:48,075
an address based on some whatever you

1305
01:06:45,042 --> 01:06:50,067
want to compute an address from but it

1306
01:06:48,075 --> 01:06:52,110
also turns out to be a pretty handy way

1307
01:06:50,067 --> 01:06:57,071
to do arithmetic and the C compiler

1308
01:06:53,001 --> 01:07:01,098
likes to use it so in particular

1309
01:06:57,071 --> 01:07:03,075
it looks the the format of it looks like

1310
01:07:02,007 --> 01:07:07,011
a move instruction there's a source and

1311
01:07:04,011 --> 01:07:10,044
a destination but the destination has to

1312
01:07:07,047 --> 01:07:14,136
be a register and the source will be one

1313
01:07:10,044 --> 01:07:16,128
of these memory references so it looks

1314
01:07:15,036 --> 01:07:19,080
like a move instruction it looks like

1315
01:07:17,028 --> 01:07:21,042
you're doing some address computation

1316
01:07:19,008 --> 01:07:23,043
then you're reading from memory and

1317
01:07:21,042 --> 01:07:26,043
storing it to a register but what it

1318
01:07:24,015 --> 01:07:30,015
actually does is it does that address

1319
01:07:26,052 --> 01:07:32,130
computation and then it actually writes

1320
01:07:30,015 --> 01:07:35,096
that address not the memory value but

1321
01:07:33,003 --> 01:07:38,094
the the value of got that got computed

1322
01:07:35,096 --> 01:07:39,174
directly to the register which is what

1323
01:07:39,021 --> 01:07:42,114
you want to do here remember the

1324
01:07:40,074 --> 01:07:44,082
ampersand operation is give me the

1325
01:07:43,014 --> 01:07:50,106
address of some place give me a pointer

1326
01:07:45,054 --> 01:07:53,061
that designates some location so for

1327
01:07:51,006 --> 01:07:57,015
example this is fairly typical in C code

1328
01:07:54,024 --> 01:08:02,118
if you say multiply X by 12 it will turn

1329
01:07:57,096 --> 01:08:04,125
it into a le Lotus and address

1330
01:08:03,018 --> 01:08:09,072
computation and this is just a clever

1331
01:08:05,025 --> 01:08:13,394
way to compute three times our GI adds

1332
01:08:09,072 --> 01:08:17,111
are di plus two times r di so that three

1333
01:08:13,619 --> 01:08:25,240
times R di and stores it in our ax and

1334
01:08:17,759 --> 01:08:27,190
then Sal Q means shift left by two and

1335
01:08:25,024 --> 01:08:29,062
so you remember shifting up by two is

1336
01:08:27,019 --> 01:08:32,035
like multiplying by four so the first

1337
01:08:29,062 --> 01:08:34,156
value computed three times X I shift

1338
01:08:32,035 --> 01:08:40,060
that left four by two positions and I

1339
01:08:35,056 --> 01:08:42,058
have twelve times X so that's a very

1340
01:08:40,006 --> 01:08:44,053
special that le.a but you'll see it all

1341
01:08:42,076 --> 01:08:46,084
over the place so you need to be ready

1342
01:08:45,007 --> 01:08:49,008
for it these other ones look more like

1343
01:08:47,056 --> 01:08:50,134
what you'd expect for arithmetic

1344
01:08:49,008 --> 01:08:54,091
instructions they have names like add

1345
01:08:51,034 --> 01:08:56,077
and subtract and multiply and so forth

1346
01:08:54,091 --> 01:08:59,118
and they all have the same general

1347
01:08:56,077 --> 01:09:01,084
format that they have two arguments and

1348
01:09:00,018 --> 01:09:05,026
what's called the destination is

1349
01:09:02,047 --> 01:09:07,134
actually also a source it's a little

1350
01:09:05,026 --> 01:09:11,113
like in C if you say X plus equals Y

1351
01:09:08,034 --> 01:09:14,089
it's saying take the value of x add the

1352
01:09:12,013 --> 01:09:17,112
value of y and then store the result in

1353
01:09:14,089 --> 01:09:19,183
X and now the destination is like that

1354
01:09:18,012 --> 01:09:23,017
the other thing that's weird is that the

1355
01:09:20,083 --> 01:09:24,091
operands are in the inverse order from

1356
01:09:23,017 --> 01:09:27,046
where you'd expect them to be so the

1357
01:09:25,063 --> 01:09:28,069
source comes first in the destination

1358
01:09:27,046 --> 01:09:30,138
comes last and that's important to

1359
01:09:29,023 --> 01:09:31,038
remember

1360
01:09:32,038 --> 01:09:36,102
and other thing you'll see that there's

1361
01:09:34,009 --> 01:09:38,095
nothing special here whether it's a

1362
01:09:37,002 --> 01:09:42,055
except that this is a arithmetic shift

1363
01:09:39,076 --> 01:09:43,120
and this is a logical shift of whether

1364
01:09:42,055 --> 01:09:45,073
it's assigned your unsigned value

1365
01:09:44,002 --> 01:09:48,004
because you remember the bit level

1366
01:09:45,073 --> 01:09:52,117
behavior of these two instructions is

1367
01:09:48,004 --> 01:09:55,021
the same and then there's a series of

1368
01:09:53,017 --> 01:09:58,024
instructions that are used that are just

1369
01:09:55,057 --> 01:10:03,082
take one operand increment decrement a

1370
01:09:58,087 --> 01:10:04,173
negate and not not is not is like the

1371
01:10:03,082 --> 01:10:09,097
tilde operation and see not the

1372
01:10:05,073 --> 01:10:11,077
exclamation mark so those are the basic

1373
01:10:09,097 --> 01:10:12,154
instructions and again now we can

1374
01:10:12,013 --> 01:10:15,028
actually look at some programs and

1375
01:10:13,054 --> 01:10:18,061
understand them and here's one that just

1376
01:10:15,028 --> 01:10:21,034
does a bunch of junk of arithmetic

1377
01:10:18,061 --> 01:10:23,113
instructions and it converts into the

1378
01:10:21,034 --> 01:10:26,107
following assembly code and you see it's

1379
01:10:24,013 --> 01:10:31,051
using this LA instruction multiple times

1380
01:10:27,007 --> 01:10:34,021
to do addition in various forms and it

1381
01:10:31,051 --> 01:10:36,079
also has shifting and it has

1382
01:10:34,021 --> 01:10:38,035
multiplication you saw in the original

1383
01:10:36,079 --> 01:10:41,170
code I just have addition and

1384
01:10:38,035 --> 01:10:44,059
multiplication here I have various

1385
01:10:42,007 --> 01:10:46,042
instructions I only have one multiply

1386
01:10:44,059 --> 01:10:48,106
here whereas I had two there so the

1387
01:10:47,005 --> 01:10:51,040
compiler instead of scrambling things

1388
01:10:49,006 --> 01:10:54,049
around trying to find clever ways to

1389
01:10:51,004 --> 01:10:57,097
implement what you're asking for using

1390
01:10:54,049 --> 01:11:01,077
less complex expensive less

1391
01:10:58,033 --> 01:11:01,077
time-consuming instructions

1392
01:11:02,042 --> 01:11:10,067
and if you sort of go through this code

1393
01:11:05,054 --> 01:11:12,098
carefully what you'll find is that this

1394
01:11:10,067 --> 01:11:15,100
instruction here corresponds to this

1395
01:11:12,098 --> 01:11:17,737
computation of t1 is adding two values

1396
01:11:16,000 --> 01:11:22,076
and giving it a new name it's putting in

1397
01:11:18,619 --> 01:11:28,648
our ax similarly this one is adding V to

1398
01:11:22,076 --> 01:11:30,158
t1 and storing it back in in our a X the

1399
01:11:28,909 --> 01:11:34,130
x box for doesn't show up directly here

1400
01:11:31,058 --> 01:11:36,092
it turns out what it does is it jumps

1401
01:11:34,013 --> 01:11:41,051
right it head to here and multiply Y by

1402
01:11:36,092 --> 01:11:45,140
48 it does it by first computing 3y like

1403
01:11:41,051 --> 01:11:49,030
we saw before and computing shifting

1404
01:11:46,004 --> 01:11:52,843
that left by 4 because 3 times 16 is 48

1405
01:11:49,489 --> 01:11:55,585
and then the 4 here that sin x plus 4

1406
01:11:53,239 --> 01:11:58,570
actually shows up here it just uses the

1407
01:11:56,449 --> 01:12:04,400
displacement field of this computation

1408
01:11:58,057 --> 01:12:05,626
to add 4 to some other values and so

1409
01:12:04,004 --> 01:12:07,049
this is labeled then these comments show

1410
01:12:06,139 --> 01:12:11,143
how these correspond to the program and

1411
01:12:07,085 --> 01:12:11,183
these registers show it so the important

1412
01:12:11,179 --> 01:12:14,200
thing to get from here you will want to

1413
01:12:12,083 --> 01:12:17,150
actually go back through this and make

1414
01:12:14,389 --> 01:12:22,250
sure you believe that the comments are

1415
01:12:18,005 --> 01:12:23,066
correct but it's very important for you

1416
01:12:22,025 --> 01:12:25,031
to figure out this la instruction

1417
01:12:24,011 --> 01:12:26,063
otherwise you're just going to be

1418
01:12:25,031 --> 01:12:28,082
hopelessly confused

1419
01:12:26,063 --> 01:12:30,106
and it's also important to understand

1420
01:12:28,082 --> 01:12:32,171
that the the code that gets generated

1421
01:12:31,006 --> 01:12:36,008
will correctly implement your si

1422
01:12:33,071 --> 01:12:37,126
function but it might not exactly

1423
01:12:36,026 --> 01:12:40,945
replicate at a low level

1424
01:12:38,026 --> 01:12:45,175
the exact sequence of operations you

1425
01:12:41,179 --> 01:12:47,233
specified at a high level so that will

1426
01:12:45,409 --> 01:12:50,000
just to summarize then you've already

1427
01:12:47,719 --> 01:12:52,723
gotten a glimpse then of of what this

1428
01:12:50,000 --> 01:12:55,013
very odd world of machine programming is

1429
01:12:53,119 --> 01:12:59,360
and how different it is from C code

1430
01:12:55,013 --> 01:13:02,096
already it's also you've already seen

1431
01:12:59,036 --> 01:13:06,835
that x86 is weird like I said it's

1432
01:13:02,096 --> 01:13:09,167
English it's not a Latin it's not well

1433
01:13:07,159 --> 01:13:14,150
designed and but you just got to deal

1434
01:13:10,067 --> 01:13:16,836
with that so that's your beginning to

1435
01:13:14,015 --> 01:13:19,334
machine level programming thanks a lot

1436
01:13:17,439 --> 01:13:19,442
I

