1
00:00:01,002 --> 00:00:07,101
大家下午好，现在我们是

2
00:00:06,033 --> 00:00:09,075
要跳进 的一部分 

3
00:00:08,001 --> 00:00:13,040
当然， 我会打电话的真正核心 

4
00:00:09,075 --> 00:00:14,121
我们进入机器的过程 

5
00:00:13,049 --> 00:00:18,000
高级编程 和术语 

6
00:00:15,021 --> 00:00:20,106
机器语言我的意思是，当 

7
00:00:18,000 --> 00:00:23,022
你实际上考虑 的 

8
00:00:21,006 --> 00:00:25,011
个别指令得到执行

9
00:00:23,022 --> 00:00:27,090
通过响应 到 设备的 

10
00:00:25,056 --> 00:00:30,057
计划和有真正的两种形式 

11
00:00:27,009 --> 00:00:32,037
机器程序一个是实际 

12
00:00:30,057 --> 00:00:35,100
该计算机上运行的目标代码

13
00:00:33,018 --> 00:00:38,055
正如我们将看到一系列字节 

14
00:00:36,000 --> 00:00:41,085
该编码指令 的 

15
00:00:38,055 --> 00:00:44,112
处理器执行，但就是因为它 

16
00:00:41,085 --> 00:00:46,092
很难看 字节，并了解他们 

17
00:00:45,012 --> 00:00:50,025
有各种文字的形式，使之 

18
00:00:47,055 --> 00:00:53,094
更加清晰 的那些中的 一个 是组件 

19
00:00:50,025 --> 00:00:55,107
代码，它曾经是告诉 人们 

20
00:00:53,094 --> 00:00:57,162
程序的机器和现在它是什么 

21
00:00:56,007 --> 00:01:00,015
编译器的目标是 

22
00:00:58,062 --> 00:01:02,103
生成汇编代码，我将使用

23
00:01:00,087 --> 00:01:05,106
这些条款，当 我说的机器码我 

24
00:01:03,003 --> 00:01:08,085
那种互换平均目标代码

25
00:01:06,006 --> 00:01:11,495
二进制形式或汇编代码的 

26
00:01:08,085 --> 00:01:12,102
它的文本版本互换 

27
00:01:11,549 --> 00:01:16,710
因为真的有一个一对一 

28
00:01:13,002 --> 00:01:19,011
它们之间 但万一我排序 的映射 

29
00:01:16,071 --> 00:01:21,075
的使用像汇编代码的一个术语，当我 

30
00:01:19,092 --> 00:01:22,101
而不是一直说机器

31
00:01:22,011 --> 00:01:28,056
代码是因为他们是真的 

32
00:01:23,082 --> 00:01:33,084
所以这同样的总体思路 是那种之一 

33
00:01:28,056 --> 00:01:35,097
地方本课程213 513 需要 

34
00:01:34,002 --> 00:01:39,491
特殊角度说的很

35
00:01:35,097 --> 00:01:41,786
从曾经做过其他地方不同

36
00:01:39,509 --> 00:01:44,520
计算你的坏日子会 

37
00:01:42,659 --> 00:01:45,810
需要采取一个当然是 

38
00:01:44,052 --> 00:01:47,127
通常被称为装配水平 

39
00:01:45,081 --> 00:01:50,100
编程你实际上 学习 的方式 

40
00:01:48,027 --> 00:01:52,104
写在汇编程序和你的计划 

41
00:01:51,000 --> 00:01:58,095
分配将做的事情一样

42
00:01:53,004 --> 00:02:00,653
排序号码的阵列 或设置 

43
00:01:58,095 --> 00:02:02,139
某种链表 数据结构 的 

44
00:02:00,689 --> 00:02:05,040
只是有点低级编程即 

45
00:02:03,039 --> 00:02:08,128
现在你 就别想了 

46
00:02:05,004 --> 00:02:11,010
想要写的汇编代码等 

47
00:02:08,479 --> 00:02:12,270
人们并没有真正享受到这些课程 

48
00:02:11,064 --> 00:02:13,080
很好

49
00:02:12,027 --> 00:02:15,102
所以他们得到了某种 我们 

50
00:02:13,008 --> 00:02:18,009
我们削减了课程，但什么样的了

51
00:02:16,002 --> 00:02:21,081
我们的是版本是，这是相当 

52
00:02:18,009 --> 00:02:24,018
重要的东西要知道作为排序的 

53
00:02:21,081 --> 00:02:26,124
之间有什么你如何写网关

54
00:02:24,099 --> 00:02:28,185
你说的程序和C或任何 其他 

55
00:02:27,024 --> 00:02:33,048
语言，以及 这些程序实际上 

56
00:02:29,085 --> 00:02:34,134
执行了机器让机器代码，它在

57
00:02:33,048 --> 00:02:36,120
排序的中间形式的存在的

58
00:02:35,034 --> 00:02:38,112
中间语言，你需要 

59
00:02:37,002 --> 00:02:42,011
了解到， 为了更好地了解 

60
00:02:39,012 --> 00:02:46,110
你的程序正在试图做的， 

61
00:02:42,029 --> 00:02:48,081
什么机器试图 为这样做 

62
00:02:47,001 --> 00:02:51,003
那 我们的观点会 结果 

63
00:02:48,081 --> 00:02:52,155
我们 实际上 不会 写除非在非常 

64
00:02:51,003 --> 00:02:55,074
我们不会对极少量 

65
00:02:53,055 --> 00:02:57,144
实际上坐下来 编写汇编 

66
00:02:56,001 --> 00:03:00,036
在这个过程中的程序，但你会 

67
00:02:58,044 --> 00:03:02,136
做的是你会 看很多的 

68
00:03:00,036 --> 00:03:07,101
这是由C编译器生成的代码

69
00:03:03,036 --> 00:03:09,120
GCC 和尝试看看如何做什么 

70
00:03:08,001 --> 00:03:12,066
出来的时候编译涉及到什么 

71
00:03:10,002 --> 00:03:15,078
走进它如何做这种低级 

72
00:03:12,066 --> 00:03:19,145
代码实现更高 层次 

73
00:03:15,096 --> 00:03:22,137
构建体， 我试图 

74
00:03:19,739 --> 00:03:26,370
在表达我的计划是如何 我们的程序 

75
00:03:23,037 --> 00:03:28,041
在机器实现的功能

76
00:03:26,037 --> 00:03:30,078
语言是如何我们的数据结构，如

77
00:03:28,041 --> 00:03:33,114
数组和结构如何是那些 

78
00:03:30,078 --> 00:03:35,109
在机器代码实现的 ，所以我们是 

79
00:03:34,014 --> 00:03:38,088
要学习 所有这些东西 ，它 

80
00:03:36,009 --> 00:03:41,016
借此课程的显著块

81
00:03:38,088 --> 00:03:41,169
和 讲座的 相当 数量得到 

82
00:03:41,016 --> 00:03:46,092
通过所有的 材料，因为它是 

83
00:03:42,069 --> 00:03:48,078
真的挺了一点，但我觉得 它 像 

84
00:03:46,092 --> 00:03:53,181
我说，我认为 这是 合适的核心 

85
00:03:48,078 --> 00:03:55,164
其中，这当然是和你知道的 

86
00:03:54,081 --> 00:04:00,084
这个过程中，我们只看到一个 

87
00:03:56,064 --> 00:04:02,115
特别等级的机器，甚至 

88
00:04:00,084 --> 00:04:05,139
虽然有很多不同的多 

89
00:04:03,015 --> 00:04:09,018
机器语言的可能性 

90
00:04:06,039 --> 00:04:11,082
在那里，我们选择了Intel的 

91
00:04:09,045 --> 00:04:14,864
英特尔指令 的 64位版本 

92
00:04:11,082 --> 00:04:16,811
如此 设置， 我会去通过 一点点 

93
00:04:15,269 --> 00:04:20,880
仅次于英特尔的历史以及它是如何获得 

94
00:04:17,549 --> 00:04:23,250
就在哪里 ，我们将 着眼于通过 

95
00:04:20,088 --> 00:04:25,157
这个想法如何 做的C代码涉及到 

96
00:04:23,025 --> 00:04:27,874
汇编代码的机器代码 等等 

97
00:04:25,949 --> 00:04:30,011
我们将通过一定的低级别 

98
00:04:28,099 --> 00:04:33,146
你需要 了解的 基本知识 

99
00:04:30,569 --> 00:04:35,610
什么装配切割机的代码如下

100
00:04:33,569 --> 00:04:38,460
等，然后我们会真正采取和 

101
00:04:35,061 --> 00:04:43,090
看看 聚焦 一些实际的代码 

102
00:04:38,046 --> 00:04:45,935
特别是在算术运算等等 

103
00:04:43,639 --> 00:04:48,707
86是那种对口语任期 

104
00:04:46,349 --> 00:04:51,433
英特尔处理器和原因是

105
00:04:49,319 --> 00:04:55,385
第一个被称为 8086 和 

106
00:04:52,189 --> 00:05:01,190
然后他们那种跳过81，但 随后 

107
00:04:55,979 --> 00:05:04,979
他们去了80〜86等83 86 

108
00:05:01,289 --> 00:05:08,330
所以在普通的一件事是86等 

109
00:05:04,979 --> 00:05:10,013
人们叫它x86和一件事 

110
00:05:08,699 --> 00:05:12,743
这是重要的这一点，它会 

111
00:05:10,319 --> 00:05:16,385
有什么样的 程序看起来影响

112
00:05:13,139 --> 00:05:20,430
就像是x86的是像 英语 语言 

113
00:05:16,979 --> 00:05:23,063
它一直以权责发生制和进化 

114
00:05:20,043 --> 00:05:26,061
分层之上的不同特点 

115
00:05:23,819 --> 00:05:29,822
彼此并不总是 最 

116
00:05:26,061 --> 00:05:32,300
优雅的方式 ， 所以就像 英语 有 

117
00:05:29,849 --> 00:05:34,500
所有这些类的古怪东西，怎么 

118
00:05:32,849 --> 00:05:35,912
你写的是多么不同 

119
00:05:34,005 --> 00:05:38,594
你念它，并有所有这些 

120
00:05:36,479 --> 00:05:39,551
不规则的情况下，它不会使

121
00:05:39,089 --> 00:05:43,020
感觉它 不是排序的 

122
00:05:40,199 --> 00:05:45,930
专门设计的语言是相同的 

123
00:05:43,002 --> 00:05:48,036
使用x86它是刚刚得到一个语言 

124
00:05:45,093 --> 00:05:49,125
因为有一帮的决定 

125
00:05:48,036 --> 00:05:51,081
在本地很可能是正确的 

126
00:05:50,025 --> 00:05:53,034
要做 的事情，但在全球范围并不 

127
00:05:51,081 --> 00:05:55,130
还有其他指令集是 

128
00:05:54,015 --> 00:05:59,564
更清洁和更容易理解 

129
00:05:56,003 --> 00:06:01,029
但我们推测它只是 同样的原因 

130
00:05:59,699 --> 00:06:02,780
你学习英语，而不是 

131
00:06:01,056 --> 00:06:05,061
学习世界语 或类似的东西 

132
00:06:03,509 --> 00:06:10,574
这， 这是一个更为有用 

133
00:06:05,061 --> 00:06:13,083
语言是x86的东西有时是 

134
00:06:11,159 --> 00:06:18,810
称为西斯克有 一个很大的东西 

135
00:06:13,083 --> 00:06:20,072
一般所谓的风险在80年代初 80年代 

136
00:06:18,081 --> 00:06:22,460
与 西斯克·西斯克 

137
00:06:20,819 --> 00:06:24,900
良好的风险是一个新的相对较新的 

138
00:06:23,189 --> 00:06:27,900
知道他们称为降低 

139
00:06:24,009 --> 00:06:29,768
指令集计算机，它是所有

140
00:06:27,009 --> 00:06:32,738
愤怒和没人的名字 是什么 

141
00:06:30,659 --> 00:06:35,744
来之前，但风险的人命名 

142
00:06:33,629 --> 00:06:38,130
一个西斯克之前什么来为 复杂 

143
00:06:36,509 --> 00:06:39,240
指令集计算机与 

144
00:06:38,013 --> 00:06:43,013
明显

145
00:06:39,024 --> 00:06:45,063
贬义性质，该标题 等 

146
00:06:43,013 --> 00:06:47,046
智能的经典的 菲斯克 

147
00:06:45,063 --> 00:06:49,322
架构意味着它有一吨的 

148
00:06:47,046 --> 00:06:51,138
我们不打算功能， 在划痕 

149
00:06:49,889 --> 00:06:56,130
表面上，如果你 想它 的 

150
00:06:52,038 --> 00:06:58,074
手册它是两个大胖子的书籍， 

151
00:06:56,013 --> 00:07:00,452
现在你 的PDF文档 做的 ，但 

152
00:06:58,074 --> 00:07:04,253
它仍然是一个巨大的东西量 

153
00:07:00,569 --> 00:07:08,430
约500页以上的说明一切 

154
00:07:04,919 --> 00:07:10,016
从做数字算术，甚至 

155
00:07:08,043 --> 00:07:13,128
十进制浮点和各种 

156
00:07:10,889 --> 00:07:16,440
愚蠢的东西在里面，但事实证明 

157
00:07:14,028 --> 00:07:18,407
你可以种得到一个不错的 

158
00:07:16,044 --> 00:07:21,105
处理它通过 更注重公正 

159
00:07:18,659 --> 00:07:23,735
什么是代码看起来就像 是GCC 

160
00:07:22,005 --> 00:07:28,994
产生的那种程序，

161
00:07:24,419 --> 00:07:35,447
你 通常写，你也应该 

162
00:07:29,039 --> 00:07:39,270
认识到这许多的这个水平 

163
00:07:35,699 --> 00:07:41,711
不应该是成功的 

164
00:07:39,027 --> 00:07:44,052
设计，因为正如我 说刚 

165
00:07:41,819 --> 00:07:47,460
很多东西在那里 ，但英特尔 

166
00:07:44,052 --> 00:07:50,291
这样一个很棒的公司，有这么 

167
00:07:47,046 --> 00:07:52,074
很多市场，自此更好的技术

168
00:07:50,759 --> 00:07:54,840
至于半导体比其 

169
00:07:52,074 --> 00:07:58,107
竞争者一直能 种 

170
00:07:54,084 --> 00:08:03,413
保持这个东西活 了将近 40 

171
00:07:59,007 --> 00:08:06,033
多年来，这 是非常令人钦佩所以才 

172
00:08:04,169 --> 00:08:09,173
给你 的时间尺度 的西装 ，因为我 

173
00:08:06,033 --> 00:08:11,372
提到的8086是中的第一个

174
00:08:09,569 --> 00:08:15,440
第一单芯片的16位 

175
00:08:11,669 --> 00:08:17,762
微处理器是在78 和 出来 

176
00:08:15,044 --> 00:08:20,893
它 轻微变化 是一个 非常基础 

177
00:08:18,599 --> 00:08:26,550
对原IBM PC 我知道 

178
00:08:21,289 --> 00:08:28,370
早你们中的大多数你们的生活 ，但它 

179
00:08:26,055 --> 00:08:31,544
是一种的大突破 

180
00:08:29,099 --> 00:08:35,198
对桌面认沽电脑 

181
00:08:32,039 --> 00:08:37,082
很多人有一直很多很多 

182
00:08:36,089 --> 00:08:40,020
代我只是给你 

183
00:08:37,469 --> 00:08:43,140
从亮点是有关 

184
00:08:40,002 --> 00:08:46,029
这个特定的类386，其 

185
00:08:43,014 --> 00:08:47,112
早于1985年 是一个 

186
00:08:46,029 --> 00:08:49,116
真正从 这些 制造转型 

187
00:08:48,012 --> 00:08:52,019
是个人电脑，可以运行 

188
00:08:50,016 --> 00:08:54,089
不是很有趣的 

189
00:08:52,019 --> 00:08:57,047
地点-那些能实际 运行 

190
00:08:54,089 --> 00:08:59,165
像UNIX或Linux计算机 

191
00:08:57,047 --> 00:09:02,056
其原因是他们它扩展 到32 

192
00:09:00,065 --> 00:09:04,163
位 ，他们删除 了一些怪异的 

193
00:09:03,037 --> 00:09:07,079
解决的东西，曾经在 

194
00:09:05,063 --> 00:09:10,136
有使这些看起来像那种的 

195
00:09:07,079 --> 00:09:12,128
通用处理器和明显 

196
00:09:11,036 --> 00:09:17,060
早在85，这也正是有时 

197
00:09:13,028 --> 00:09:23,090
称为IA32英特尔架构32，其 

198
00:09:17,006 --> 00:09:25,067
是的代码 了 占主导地位的方式 告诉 

199
00:09:23,009 --> 00:09:28,088
即使只是在几年前，所以 甚至达到如 

200
00:09:26,021 --> 00:09:34,064
最近在过去的这个夏天本课程

201
00:09:29,069 --> 00:09:36,095
教我32， 然后有和 

202
00:09:34,064 --> 00:09:39,161
我会谈论 它 更晚一些 有 

203
00:09:36,095 --> 00:09:43,148
在后面的一个奇怪的故事的理由

204
00:09:40,061 --> 00:09:47,153
延伸部从32到64位 哪种 

205
00:09:44,048 --> 00:09:50,096
都是由英特尔和 奇数悄悄在

206
00:09:48,053 --> 00:09:55,109
模拟奔腾4 II，但你看到它

207
00:09:50,096 --> 00:09:57,104
只有大约10 年前 的一个 

208
00:09:56,009 --> 00:10:00,074
他们做智能事情 会是 

209
00:09:58,004 --> 00:10:04,082
该机器可以运行 

210
00:10:00,074 --> 00:10:06,098
64位代码还可以运行32位的代码，以便 

211
00:10:04,082 --> 00:10:08,123
他们能够有点 带出所有 

212
00:10:06,098 --> 00:10:10,133
这些机器而不必每个人都 

213
00:10:09,023 --> 00:10:14,068
改变了他们的软件，它的 

214
00:10:11,033 --> 00:10:17,042
采取有关的那个时间量 

215
00:10:14,068 --> 00:10:25,102
软件主要来自远离过渡 

216
00:10:17,042 --> 00:10:28,136
32位代码，以64位代码 ，然后 

217
00:10:26,002 --> 00:10:32,015
实际上是相当有趣的考虑，您 

218
00:10:29,036 --> 00:10:34,058
可以映射如何快速的单一处理器

219
00:10:32,015 --> 00:10:39,029
将运行并且将其在一个爬起来 

220
00:10:34,058 --> 00:10:41,075
相当稳健的步伐，直到2004年左右，并 

221
00:10:39,029 --> 00:10:43,052
那么英特尔有和所有公司得到

222
00:10:41,075 --> 00:10:44,174
与动力严重的麻烦 

223
00:10:43,052 --> 00:10:48,113
他们的筹码他们的消费 

224
00:10:45,074 --> 00:10:50,087
接近百瓦特所以想象一个100 

225
00:10:49,013 --> 00:10:53,021
瓦灯泡和多少热量 

226
00:10:50,087 --> 00:10:55,166
生成 您尝试 在盒子里面 

227
00:10:53,093 --> 00:10:58,121
吹上真的很难风扇，以保持它 

228
00:10:56,066 --> 00:11:00,080
变得太热 ，他们是 

229
00:10:59,021 --> 00:11:03,089
达到这种 地步他们 真的 

230
00:11:00,008 --> 00:11:04,015
不能去远远超出一个百瓦特 

231
00:11:03,089 --> 00:11:06,157
所以他们那种有 

232
00:11:05,005 --> 00:11:08,071
功率预算问题，并为 

233
00:11:07,057 --> 00:11:11,062
结果，他们一直没能规模 

234
00:11:09,016 --> 00:11:14,020
向上的频率有多快内 

235
00:11:11,062 --> 00:11:20,071
驱动这件事钟超出 

236
00:11:14,056 --> 00:11:22,135
只是 自2004年以来 几千兆赫兹 等什么 

237
00:11:20,071 --> 00:11:24,169
发生的情况是，他们说好我们不能

238
00:11:23,035 --> 00:11:26,134
做任何单一处理器速度更快，但我们 

239
00:11:25,069 --> 00:11:28,141
可以把一堆处理器上

240
00:11:27,034 --> 00:11:32,035
单芯片和那些被 称作 

241
00:11:29,041 --> 00:11:35,086
核或多核所以大部分的你 

242
00:11:32,044 --> 00:11:38,056
笔记本电脑可能会对 这 两个核心 

243
00:11:35,086 --> 00:11:41,161
和一台笔记本电脑处理器和服务器

244
00:11:38,056 --> 00:11:44,082
最多可以有16个内核， 所以这些都是 

245
00:11:42,061 --> 00:11:48,130
独立的处理器是所有 

246
00:11:44,082 --> 00:11:52,101
驻留在单个芯片上鲨 

247
00:11:49,003 --> 00:11:56,004
机器可以追溯到2008年，他们是 

248
00:11:53,001 --> 00:11:59,034
每个有他们四个核 

249
00:11:56,004 --> 00:12:00,013
鲨鱼机的一件事 

250
00:11:59,034 --> 00:12:01,105
电脑还没有真正得到的是 

251
00:12:01,003 --> 00:12:04,039
快多了

252
00:12:02,005 --> 00:12:08,005
在此期间所以还是有 

253
00:12:04,066 --> 00:12:09,139
球道和他们在他们的一天 

254
00:12:08,005 --> 00:12:15,013
非常高的性能机器 ，使他们 

255
00:12:10,039 --> 00:12:21,040
还是相当不错的 这显示图片 

256
00:12:15,085 --> 00:12:24,085
这构成了芯片的我觉得 

257
00:12:21,049 --> 00:12:26,125
尖锐的机器或大约 是 

258
00:12:24,085 --> 00:12:28,146
同一个时代，你会看到 ，随着 

259
00:12:27,025 --> 00:12:32,050
图为这 四个核心是 

260
00:12:29,046 --> 00:12:34,072
集成到一个芯片上 ，然后向下 

261
00:12:32,005 --> 00:12:36,019
底部就是他们所说的高速缓存 

262
00:12:34,072 --> 00:12:39,171
我们会学到很多关于高速缓存存储器 

263
00:12:36,064 --> 00:12:42,160
但它是它基本上是一个暂时的 

264
00:12:40,071 --> 00:12:44,167
内存用于保存最近 

265
00:12:43,006 --> 00:12:47,104
访问的数据，这样 就可以得到它 

266
00:12:45,067 --> 00:12:52,162
更快速 ，你会看到 那个 

267
00:12:48,058 --> 00:12:55,066
在四个核心共享，所以如果你 

268
00:12:53,062 --> 00:12:58,147
看看最新的，如果你是走下车 

269
00:12:55,066 --> 00:13:00,070
在目录中的最新逛街上 

270
00:12:59,047 --> 00:13:03,073
例如，我没有任何芯片 

271
00:13:01,006 --> 00:13:07,030
它的照片是他们所谓的模型

272
00:13:03,073 --> 00:13:09,078
Broadwell微架构模型，你会看到一个 

273
00:13:07,003 --> 00:13:12,010
单片机他们有多个内核 

274
00:13:10,023 --> 00:13:16,048
forfor 严重 的标准桌面模式 

275
00:13:13,000 --> 00:13:18,079
八项服务器级的机器 和 

276
00:13:16,048 --> 00:13:20,125
然后在周边建

277
00:13:18,079 --> 00:13:23,128
有对各种连接

278
00:13:21,025 --> 00:13:26,028
世界因此DDR的其余部分是你的方式 

279
00:13:24,028 --> 00:13:30,109
连接到主存储器什么叫做

280
00:13:26,028 --> 00:13:33,030
DRAM动态RAM PCI是连接 

281
00:13:31,009 --> 00:13:36,073
到外围设备 

282
00:13:33,048 --> 00:13:42,055
SATA是不同 类型 的连接 

283
00:13:36,073 --> 00:13:45,109
的光盘和USB那么你知道它是USB 

284
00:13:42,055 --> 00:13:51,058
然后将以太网是连接 

285
00:13:46,009 --> 00:13:53,086
也为网络连接 ，这样的 

286
00:13:51,085 --> 00:13:55,162
全部集成在单个芯片上 不 

287
00:13:53,086 --> 00:13:59,113
只是处理器本身 ，而是很多 

288
00:13:56,062 --> 00:14:02,149
该胶合该处理器成逻辑

289
00:14:00,013 --> 00:14:05,071
更大的系统 和一个有趣的 事情 

290
00:14:03,049 --> 00:14:06,051
你会注意到的是，桌面模式 

291
00:14:05,071 --> 00:14:09,160
是一个更高的功率

292
00:14:06,069 --> 00:14:11,167
65瓦特相对于服务器是45瓦特 

293
00:14:10,006 --> 00:14:14,062
当你投入了大量的计算机在 

294
00:14:12,067 --> 00:14:17,073
房间原来的功率是最大的 

295
00:14:15,016 --> 00:14:18,027
发出你必须 处理 

296
00:14:20,032 --> 00:14:25,117
所以智能唯一一家 在 此 

297
00:14:23,035 --> 00:14:29,062
游戏有几分历史的竞争对手 

298
00:14:26,017 --> 00:14:33,246
一个名为AMD和AMD公司是 

299
00:14:29,062 --> 00:14:36,085
总是有点二号仅次于英特尔 

300
00:14:33,399 --> 00:14:44,620
在我虽然给了我们 他的二号 

301
00:14:36,085 --> 00:14:46,087
在她身后，但他们有一点 

302
00:14:44,062 --> 00:14:49,461
在突发时间时，他们种了 出来 

303
00:14:46,087 --> 00:14:52,806
英特尔领先的因为英特尔已经 浪费 

304
00:14:50,019 --> 00:14:54,970
他们的时间对一些不好的想法，他们 

305
00:14:53,589 --> 00:14:57,606
实际上是 说 想出 了 一个 

306
00:14:54,097 --> 00:15:01,446
64位扩展到英特尔，我们 

307
00:14:57,759 --> 00:15:02,798
现在使用AMD虽然不只是 

308
00:15:02,319 --> 00:15:05,415
做得非常好 

309
00:15:03,149 --> 00:15:08,166
英特尔之类的实现，它 必须 

310
00:15:06,279 --> 00:15:13,540
共同的行动，并且它没有和它 

311
00:15:08,319 --> 00:15:14,980
或多或少粉碎AMD，但 我 

312
00:15:13,054 --> 00:15:17,793
应该指出，他们有这些 

313
00:15:14,098 --> 00:15:18,181
凶猛的专利诉讼在很多年前 

314
00:15:18,279 --> 00:15:22,630
并且 ， 其结果 是整个 

315
00:15:19,081 --> 00:15:26,040
许可协议，允许AMD公司

316
00:15:22,063 --> 00:15:28,069
生产x86处理器-现在是 

317
00:15:26,769 --> 00:15:32,110
在64英特尔背后有趣的故事 

318
00:15:29,023 --> 00:15:33,612
位，他们决定让这个激进 

319
00:15:32,011 --> 00:15:39,088
转移到一个架构， 它们 

320
00:15:33,819 --> 00:15:42,550
叫他们称为IA-64 

321
00:15:39,088 --> 00:15:44,179
在当时，它是基于一个整体

322
00:15:42,055 --> 00:15:47,116
新概念，看着真不错 

323
00:15:45,079 --> 00:15:48,094
纸和初步结果看 

324
00:15:48,016 --> 00:15:50,062
有希望

325
00:15:48,094 --> 00:15:52,126
他们投入了大量的资金在这 

326
00:15:50,062 --> 00:15:54,891
东西，他们组成了一个联合操作 与 

327
00:15:53,026 --> 00:15:56,122
惠普就这个问题和它打开 

328
00:15:55,449 --> 00:16:01,110
出不 上班 是太 

329
00:15:57,022 --> 00:16:02,113
激进它承担奇迹 

330
00:16:01,011 --> 00:16:05,610
通过优化功能

331
00:16:03,013 --> 00:16:08,014
编译器，因此它是一个从 

332
00:16:05,709 --> 00:16:09,714
技术上的想法是非常有趣 

333
00:16:08,023 --> 00:16:12,085
技术，但在 市场上它 

334
00:16:10,209 --> 00:16:16,215
没有工作，这是排序的 

335
00:16:12,085 --> 00:16:17,184
岔开， 英特尔追求和感觉 

336
00:16:16,269 --> 00:16:19,356
有义务保持下去，因为他们会 

337
00:16:17,949 --> 00:16:22,240
它并沿投入这么多来到 

338
00:16:20,139 --> 00:16:24,040
AMD和他们说好，我们 不必 

339
00:16:22,024 --> 00:16:27,100
这样做根本性的转变，我们只是有点

340
00:16:24,004 --> 00:16:30,303
做制作加入的明显的事情 

341
00:16:28,000 --> 00:16:33,031
寄存器更大的决策事情

342
00:16:30,339 --> 00:16:34,120
从32 到64位 和他们来了 

343
00:16:33,031 --> 00:16:37,042
与 

344
00:16:34,012 --> 00:16:40,080
并得到了与成功等 

345
00:16:37,042 --> 00:16:43,123
英特尔那种不得不只是怯怯地 

346
00:16:40,008 --> 00:16:46,030
跟在别人后面AMD在这一点，但他们能 

347
00:16:44,023 --> 00:16:48,094
因为他们的交叉授权协议，以便 

348
00:16:47,002 --> 00:16:52,045
现在正如我所提到 的硬件明智 

349
00:16:48,094 --> 00:16:54,151
几乎所有的处理器 处于 

350
00:16:52,045 --> 00:16:57,052
笔记本电脑在台式机甚至是你的 

351
00:16:55,051 --> 00:17:05,077
最近一代的手机都 

352
00:16:57,052 --> 00:17:07,117
64位处理器还等什么，我们将讨论 

353
00:17:05,077 --> 00:17:09,756
关于那我们用来教IA32但 

354
00:17:08,017 --> 00:17:13,060
该走了， 这 是第一项 ，其中 

355
00:17:10,449 --> 00:17:16,990
我们跳过它一起所以我们 

356
00:17:13,006 --> 00:17:18,010
使用的是什么，我们将调用86 - 64还有的 

357
00:17:16,099 --> 00:17:21,163
不同的方式，这是一个名为但这 

358
00:17:19,000 --> 00:17:24,072
排序的 ，如果它命名的 Linux的方法 

359
00:17:22,063 --> 00:17:26,128
你感兴趣的AI 32有一个 

360
00:17:24,072 --> 00:17:28,153
与 相关联的网络上的文件

361
00:17:27,028 --> 00:17:31,030
本书叫网页放在一边去 

362
00:17:29,053 --> 00:17:32,149
通过至少一些基础知识 

363
00:17:31,003 --> 00:17:35,086
它而是要真正 读懂你需要 

364
00:17:33,049 --> 00:17:39,058
学习64位，因为它假定 你 

365
00:17:36,013 --> 00:17:42,076
样已经知道，好让我们 

366
00:17:40,039 --> 00:17:44,134
进去， 我要指出-如果只是为了 

367
00:17:42,076 --> 00:17:46,171
普遍关心的其他主要类 

368
00:17:45,034 --> 00:17:50,119
目前普遍使用的处理器是 

369
00:17:47,071 --> 00:17:54,076
所谓的手臂所以实际上ARM是一个缩写 

370
00:17:51,019 --> 00:17:56,110
橡子RISC机器 ，我只是告诉 你 

371
00:17:55,021 --> 00:17:59,098
什么 风险意味着 它意味着风险 降低 

372
00:17:57,001 --> 00:18:01,096
指令集计算机橡实装置

373
00:17:59,098 --> 00:18:03,139
像你知道一棵橡树的种子 它 

374
00:18:02,005 --> 00:18:08,068
是一家英国公司 

375
00:18:04,039 --> 00:18:10,045
并决定做出 自己的个人 

376
00:18:08,068 --> 00:18:11,134
在它 的早期计算机和 

377
00:18:10,045 --> 00:18:13,060
他们说，我们不会买 那些 

378
00:18:12,034 --> 00:18:14,110
从英特尔的芯片，我们会作出 

379
00:18:13,006 --> 00:18:17,014
他们自己 ，使他们 的设计和 

380
00:18:15,001 --> 00:18:19,060
制造自己的芯片以及一个 

381
00:18:17,068 --> 00:18:22,069
公司计算机制造商，这是一个

382
00:18:19,069 --> 00:18:24,097
完整的半身像，但事实证明， 

383
00:18:22,069 --> 00:18:27,073
他们会拿出 一个相当不错的 

384
00:18:24,097 --> 00:18:29,193
指令集，这是足够 

385
00:18:28,009 --> 00:18:34,087
简单，它可以在芯片上放置和 

386
00:18:30,093 --> 00:18:36,109
更重要的是它 可以进行定制，以便手臂 

387
00:18:34,087 --> 00:18:38,115
现在是它自己的公司 

388
00:18:37,009 --> 00:18:41,035
总部设在英格兰剑桥和 

389
00:18:39,015 --> 00:18:43,078
原因的原因的一部分

390
00:18:41,035 --> 00:18:45,111
他们是成功的，因此是因为 

391
00:18:43,078 --> 00:18:48,085
它往往是低功率 

392
00:18:46,011 --> 00:18:50,110
比x86机器，因为要求

393
00:18:48,085 --> 00:18:52,152
这是简单的，但其他的是， 他们 

394
00:18:51,001 --> 00:18:56,065
实际上不卖，他们卖的处理器

395
00:18:53,052 --> 00:18:59,074
公司权利的许可 

396
00:18:56,074 --> 00:19:02,155
使用权，他们的设计等，如果 

397
00:18:59,074 --> 00:19:05,080
你看像手机处理器 

398
00:19:03,055 --> 00:19:07,141
实际ARM处理器是一个小 

399
00:19:05,008 --> 00:19:09,036
在芯片上，然后在它的小部分

400
00:19:08,041 --> 00:19:12,103
他们将有其他的东西 ， 使 

401
00:19:10,008 --> 00:19:16,015
图形走的更好，以提高您的手机 

402
00:19:13,003 --> 00:19:18,028
调用等等，所以 他们真的 很 

403
00:19:16,015 --> 00:19:22,030
卖知识产权是什么 

404
00:19:18,028 --> 00:19:23,035
反对的芯片，所以我们已经人 

405
00:19:22,003 --> 00:19:25,081
得到各种查询 你什么 时候 

406
00:19:23,098 --> 00:19:26,173
要开始 谈论 手臂 在你的 

407
00:19:26,008 --> 00:19:30,043
书或你的 课程或东西 ，我们 

408
00:19:27,073 --> 00:19:31,138
去那将是另一本书来写 

409
00:19:30,043 --> 00:19:36,049
公平对待 武装它会像一个 

410
00:19:32,038 --> 00:19:37,134
的东西全部重做，我们没有 

411
00:19:36,049 --> 00:19:40,105
倾向于做 ，现在 

412
00:19:38,034 --> 00:19:44,065
但只是让你 知道有 排序的 

413
00:19:41,005 --> 00:19:47,070
两个世界在那里的x86和ARM是 

414
00:19:44,065 --> 00:19:47,070
现在统治力的球员

415
00:19:48,049 --> 00:19:51,131
所以让我们来谈谈一些术语和

416
00:19:51,038 --> 00:19:54,041
你可能听说过其中的一些 

417
00:19:52,031 --> 00:19:56,117
条件之前，但我们要清楚这样 

418
00:19:54,041 --> 00:20:00,077
当我们谈论 的说明 

419
00:19:57,017 --> 00:20:03,065
指令集的的目标 

420
00:20:00,077 --> 00:20:04,139
编译器给你一个系列 

421
00:20:03,065 --> 00:20:09,089
告诉机器指令 

422
00:20:05,039 --> 00:20:11,054
究竟要做什么，但事实证明， 

423
00:20:09,089 --> 00:20:12,142
硬件的人会找出所有 

424
00:20:11,054 --> 00:20:16,097
种 实施 聪明的方法 

425
00:20:13,042 --> 00:20:19,076
一些指令都是真的 

426
00:20:16,097 --> 00:20:20,162
速度快，但需要大量 的硬件部分 是 

427
00:20:19,076 --> 00:20:23,090
相当缓慢但不要花太多的硬件 

428
00:20:21,062 --> 00:20:26,105
在所有的，所以他们成功地创造 

429
00:20:23,009 --> 00:20:28,016
这个这个抽象的名字叫 

430
00:20:27,005 --> 00:20:31,052
指令集架构，其是

431
00:20:28,097 --> 00:20:32,168
编译器的目标应该是什么 

432
00:20:31,052 --> 00:20:35,105
然后让硬件的人的身影 

433
00:20:33,068 --> 00:20:37,112
如何最好地实现 它，然后 

434
00:20:36,005 --> 00:20:42,008
低，使 这是一个 概念 

435
00:20:38,012 --> 00:20:46,028
实际上它在20世纪60年代走过来如此 

436
00:20:42,008 --> 00:20:49,082
据 这连 我的时间之前 为 

437
00:20:46,028 --> 00:20:52,034
电脑的人，但它是一个非常 

438
00:20:49,082 --> 00:20:53,090
在世界上 的重要概念

439
00:20:52,034 --> 00:20:56,057
电脑，然后他们叫什么 

440
00:20:54,062 --> 00:20:56,150
低层次的东西它是如何实际获取 

441
00:20:56,057 --> 00:20:58,061
实施被称为

442
00:20:57,005 --> 00:21:00,050
微架构 

443
00:20:58,061 --> 00:21:03,074
我们会聊的很是很了解 

444
00:21:00,095 --> 00:21:04,154
微架构在此过程中 和 

445
00:21:03,074 --> 00:21:07,130
我有点提到过的机器代码 

446
00:21:05,054 --> 00:21:10,109
通用术语， 既包括 

447
00:21:08,003 --> 00:21:13,010
实际的位进行操作的字节

448
00:21:11,009 --> 00:21:15,106
执行以及汇编 级 

449
00:21:13,037 --> 00:21:15,106
它的版本

450
00:21:17,043 --> 00:21:23,141
正如我提到的，你能 想到从 

451
00:21:20,007 --> 00:21:28,050
的视图的指令集点，以便IA32 

452
00:21:24,041 --> 00:21:31,053
86 64，什么叫安腾或本 

453
00:21:28,005 --> 00:21:34,061
不是很成功的英特尔 那些 事 

454
00:21:31,053 --> 00:21:34,106
都在不同的一些方法 

455
00:21:35,015 --> 00:21:40,041
指令集架构手臂

456
00:21:37,035 --> 00:21:41,133
实际上类似于英特尔已经 

457
00:21:40,041 --> 00:21:43,104
通过各种 不同的世代所以 

458
00:21:42,033 --> 00:21:48,033
有各种不同的代 

459
00:21:44,004 --> 00:21:50,046
其指令从设置等等 

460
00:21:48,033 --> 00:21:52,056
程序员机级的程序员

461
00:21:50,046 --> 00:21:55,134
角度来看事情是有点 不同 

462
00:21:52,056 --> 00:21:58,104
比你看到当你第一次写C代码 

463
00:21:56,034 --> 00:22:00,120
所有有一些非常显眼的部分 

464
00:21:59,004 --> 00:22:04,011
指令机器状态的

465
00:22:01,002 --> 00:22:07,014
你可以检查 和测试 

466
00:22:04,011 --> 00:22:09,033
操作上，你必须在事实，你

467
00:22:07,032 --> 00:22:11,121
永远不会明白那些是什么，如果

468
00:22:09,033 --> 00:22:14,100
你只是用 C 来 思考 这样的 

469
00:22:12,021 --> 00:22:17,088
特别是有某种类型 的 

470
00:22:15,000 --> 00:22:21,006
程序计数器来 告诉你什么什么 

471
00:22:17,088 --> 00:22:22,110
地址是你的指令 

472
00:22:21,006 --> 00:22:27,042
下一步准备执行何方 

473
00:22:23,001 --> 00:22:31,002
位于内存中，然后有一组 

474
00:22:27,042 --> 00:22:33,063
寄存器其是 的那 部分的 

475
00:22:31,011 --> 00:22:36,033
程序员实际上利用了你 

476
00:22:33,063 --> 00:22:37,155
可以把它们看成是一个非常小 

477
00:22:36,033 --> 00:22:41,037
的存储位置， 而是数量

478
00:22:38,055 --> 00:22:43,104
不是让一个从 0地址多达n 

479
00:22:41,073 --> 00:22:47,142
减去1或东西，你实际上给 

480
00:22:44,004 --> 00:22:50,082
他们的名字特别，然后

481
00:22:48,042 --> 00:22:52,083
还有另一种类型的状态这 

482
00:22:50,082 --> 00:22:56,103
短短数位等值状态的那 

483
00:22:52,083 --> 00:22:59,106
谈到什么是什么结果 

484
00:22:57,003 --> 00:23:02,010
最近的一些指令，他们 

485
00:23:00,006 --> 00:23:03,087
没有它产生一个值 的0做到了 

486
00:23:02,001 --> 00:23:05,049
产生负或正值 

487
00:23:03,087 --> 00:23:06,135
而那些被 用来实现 

488
00:23:05,058 --> 00:23:10,074
条件分支，我们来看看

489
00:23:07,035 --> 00:23:12,123
在 后来 ，因为我们去，然后其他 

490
00:23:10,074 --> 00:23:14,100
它的一部分，使得 排序处理器的 

491
00:23:13,023 --> 00:23:20,082
然后 它的 另一部分 是 

492
00:23:15,000 --> 00:23:22,077
存储器和如在我的所述一个提到 

493
00:23:20,082 --> 00:23:24,099
第一个演讲的内存，你可以

494
00:23:22,077 --> 00:23:27,143
认为逻辑上只是一个数组 

495
00:23:24,099 --> 00:23:30,164
字节，这是什么 

496
00:23:28,043 --> 00:23:32,135
机器级程序员C'S，它的 

497
00:23:31,064 --> 00:23:34,130
在实际类型的小说

498
00:23:33,035 --> 00:23:36,107
不同的方式正如我前面提到 

499
00:23:35,003 --> 00:23:38,047
这些人都 有点之间的合作 

500
00:23:37,007 --> 00:23:42,011
操作系统和硬件 

501
00:23:38,074 --> 00:23:43,115
他们称之为 虚拟内存 是什么 使它 

502
00:23:42,011 --> 00:23:48,053
看起来像一个正在运行的每个程序 

503
00:23:44,015 --> 00:23:51,053
处理器有它自己的独立的 阵列 

504
00:23:48,053 --> 00:23:54,110
的字节，它可以访问即使 

505
00:23:51,053 --> 00:23:56,080
他们实际上内 的 共享价值观 

506
00:23:55,001 --> 00:23:59,099
物理内存本身 

507
00:23:56,008 --> 00:24:01,055
此外，你听说过这个词缓存 

508
00:24:00,008 --> 00:24:05,012
缓存的想法是 不可见的，在这里 

509
00:24:02,027 --> 00:24:08,054
一切都是因为它仅仅是自动 

510
00:24:05,012 --> 00:24:10,063
装载有最新内容，唯一的 

511
00:24:08,054 --> 00:24:12,125
这看起来不同的一点是，如果你

512
00:24:10,063 --> 00:24:14,102
访问内存会走得更快

513
00:24:13,025 --> 00:24:17,108
比它，如果它 没有被缓存 

514
00:24:15,002 --> 00:24:20,036
但它是不可见 的条款有 

515
00:24:18,008 --> 00:24:23,081
无指示操纵缓存

516
00:24:20,036 --> 00:24:28,085
有没有办法可以直接访问

517
00:24:23,081 --> 00:24:30,125
缓存 ，以便你已经看到它 

518
00:24:28,085 --> 00:24:34,121
已经抽象它有一些更多的

519
00:24:31,025 --> 00:24:36,122
真正的硬件，但下面的细节

520
00:24:35,021 --> 00:24:39,025
它那种微架构的 水平 

521
00:24:37,022 --> 00:24:43,061
有一些功能内置到它那 

522
00:24:39,061 --> 00:24:47,075
你不是你操作不是 

523
00:24:43,061 --> 00:24:50,092
利用直接办法呀，当你 

524
00:24:47,075 --> 00:24:50,092
写机水平的课程 

525
00:24:52,013 --> 00:24:58,107
所以，如果你有一个程序，然后说和 

526
00:24:56,073 --> 00:25:00,114
看到它通常会在更大

527
00:24:59,007 --> 00:25:04,032
计划，其中将包括多个文件 

528
00:25:01,014 --> 00:25:07,059
它会利用一些库 

529
00:25:04,032 --> 00:25:10,083
码等编译的过程

530
00:25:07,059 --> 00:25:12,141
实际上是一系列的步骤，这将 

531
00:25:10,083 --> 00:25:15,129
采取什么样的你为代码编写的 转 

532
00:25:13,041 --> 00:25:19,098
成机器代码 与它相结合 

533
00:25:16,029 --> 00:25:22,073
编译的编译器生成的代码的 

534
00:25:19,098 --> 00:25:24,195
库终于产生的

535
00:25:22,073 --> 00:25:27,171
文件的实际执行 

536
00:25:25,095 --> 00:25:30,180
程序和SVET在这所显示

537
00:25:28,071 --> 00:25:33,090
图像， 所述第一步骤是将Ç 

538
00:25:31,008 --> 00:25:36,021
和实际产生从汇编代码 

539
00:25:33,009 --> 00:25:37,104
它再接下来是 运行 

540
00:25:36,093 --> 00:25:41,106
通过汇编它接受 

541
00:25:38,085 --> 00:25:42,093
指令 文本表示 和 

542
00:25:42,006 --> 00:25:45,078
把它变成实际的字节级 

543
00:25:43,065 --> 00:25:49,074
表示我们来看看 这 一切 

544
00:25:45,078 --> 00:25:51,165
不久，然后有一个程序

545
00:25:49,074 --> 00:25:55,089
称为 其 合并在一起 的接头 

546
00:25:52,065 --> 00:25:58,101
所有这两个不同的文件你 

547
00:25:55,089 --> 00:26:01,094
单个文件的编译自己 

548
00:25:59,001 --> 00:26:05,058
对于库代码版本和与 

549
00:26:01,094 --> 00:26:06,108
后来终于有一个甚至一度运行 

550
00:26:05,058 --> 00:26:09,153
一个程序实际上有一些 

551
00:26:07,008 --> 00:26:14,073
是那些获得动态导入的库

552
00:26:10,053 --> 00:26:16,101
程序首先开始时，所以它是一个 

553
00:26:14,073 --> 00:26:18,138
排序许多层次的一系列活动的 

554
00:26:17,001 --> 00:26:24,015
我会通过一些的这些 

555
00:26:19,038 --> 00:26:27,045
一个接一个 给 你 因此， 例如 这里的 

556
00:26:24,015 --> 00:26:29,061
在一个方面不是很有趣功能 

557
00:26:27,045 --> 00:26:31,076
中做什么有用的，但它的排序 

558
00:26:29,061 --> 00:26:34,113
展示的两个基本思路

559
00:26:31,076 --> 00:26:37,113
编译 如果 我通过运行这个 

560
00:26:35,013 --> 00:26:40,020
C编译器我得到的东西看起来 

561
00:26:38,013 --> 00:26:43,068
像什么显示在右边， 

562
00:26:40,083 --> 00:26:44,175
这就是 sembly代码，并只 给 

563
00:26:43,068 --> 00:26:46,152
你它是什么样子的想法 

564
00:26:45,075 --> 00:26:49,107
一种奇怪的语言第一 

565
00:26:47,052 --> 00:26:52,080
一次 看到它 ，但你会看到那些 

566
00:26:50,007 --> 00:26:55,008
％的那些东西是在 

567
00:26:52,008 --> 00:26:56,019
寄存器的实际名称记住我 

568
00:26:55,008 --> 00:27:00,060
告诉你有，你给寄存器 

569
00:26:56,091 --> 00:27:01,188
按名称，然后将这些指令 

570
00:27:00,006 --> 00:27:04,071
告诉它做一些事情推 线索 

571
00:27:02,088 --> 00:27:07,092
装置推东西到堆栈

572
00:27:05,025 --> 00:27:10,083
此举意味着移动从一个地方复制 

573
00:27:08,028 --> 00:27:14,100
其他 呼叫意味着调用一些 

574
00:27:10,083 --> 00:27:18,084
程序的流行是 推动对口 

575
00:27:15,000 --> 00:27:21,006
然后代表是退出 回报出于此 

576
00:27:18,093 --> 00:27:22,158
特定的功能 ，所以你看到 的 每一个 

577
00:27:21,006 --> 00:27:26,007
这些是一个指令，它是写 

578
00:27:23,058 --> 00:27:29,079
在文本，但每个那些 会变成 

579
00:27:26,007 --> 00:27:33,054
在对象的一个实际指令 

580
00:27:29,079 --> 00:27:35,088
码表示，所以我要告诉你 

581
00:27:33,054 --> 00:27:37,083
这其实是一个稍微清洗 

582
00:27:35,088 --> 00:27:38,169
起来到底发生了什么所以让版本

583
00:27:37,083 --> 00:27:46,179
我告诉你的 事实 ，因为你 

584
00:27:39,069 --> 00:27:49,161
会遇到 多一点 -他们 

585
00:27:47,079 --> 00:27:52,103
有这个大前请让我 

586
00:27:50,061 --> 00:27:52,103
大 

587
00:27:59,085 --> 00:28:01,139
和

588
00:28:04,009 --> 00:28:12,100
这个拉起来，这样 你 可以看到它设置 

589
00:28:10,049 --> 00:28:17,140
你可以看到它在他们后面

590
00:28:13,000 --> 00:28:18,004
越大越好

591
00:28:22,081 --> 00:28:26,107
让我得到了另外一个 

592
00:28:39,012 --> 00:28:42,012
在 

593
00:28:49,429 --> 00:28:59,010
他们已经登录到鱼 

594
00:28:54,929 --> 00:29:01,650
机器拿到这里，所以这是一个文件

595
00:28:59,001 --> 00:29:04,026
那么你看这就是所谓的一些 点 C和 

596
00:29:01,065 --> 00:29:07,134
我会提到所有的 这些程序 是 

597
00:29:04,026 --> 00:29:11,825
可你能看到整个 井 

598
00:29:08,034 --> 00:29:13,493
削减AFS是我个人和所有 

599
00:29:12,059 --> 00:29:16,740
首先东西是我自己的个人 

600
00:29:13,799 --> 00:29:22,080
联系，但一旦你到 了类网页 

601
00:29:16,074 --> 00:29:23,109
页面awwh代码斜线，然后这一切都 

602
00:29:22,008 --> 00:29:26,100
由它是特别给定演讲 

603
00:29:24,009 --> 00:29:29,728
我觉得这些都是在 首页 链接 

604
00:29:27,000 --> 00:29:32,004
太，你可以在那里看到各种文件 

605
00:29:29,809 --> 00:29:36,390
这被用于示范 

606
00:29:32,004 --> 00:29:39,060
C文件显然是程序， 

607
00:29:36,039 --> 00:29:41,133
我们键入，然后一个有是S

608
00:29:39,096 --> 00:29:44,100
这是汇编代码一个结束路 

609
00:29:42,033 --> 00:29:52,121
[R什么叫做拆卸所以不管怎么说 

610
00:29:45,036 --> 00:29:59,105
如果我说GCC - 博- -穆斯林先生- FO g ^ 

611
00:29:53,021 --> 00:30:02,028
减去资本 某些C点什么我 

612
00:29:59,429 --> 00:30:05,100
也只是 告诉编译器 接受 

613
00:30:02,028 --> 00:30:07,547
C代码并把它变成组件 

614
00:30:05,001 --> 00:30:10,014
代码，这样，当你调用GCC你 

615
00:30:07,799 --> 00:30:12,890
实际调用它不只是一个

616
00:30:10,023 --> 00:30:15,212
计划，但节目的整个序列 

617
00:30:12,089 --> 00:30:17,258
该做的各个阶段

618
00:30:15,419 --> 00:30:21,360
编译并给予它这个减 

619
00:30:18,059 --> 00:30:23,084
资本F开关我说停，我会 

620
00:30:21,036 --> 00:30:28,115
只是做第一部分C到装配 

621
00:30:23,309 --> 00:30:30,395
代码和- 哦，小G是 

622
00:30:29,015 --> 00:30:33,033
什么样的规格

623
00:30:31,169 --> 00:30:37,207
优化我希望编译器做 

624
00:30:33,033 --> 00:30:40,044
所以，如果 你不说 什么 -只是 

625
00:30:37,549 --> 00:30:42,840
点燃

626
00:30:40,044 --> 00:30:45,111
优化的代码，它其实很

627
00:30:42,084 --> 00:30:50,109
难以阅读 的代码是非常乏味的 

628
00:30:46,011 --> 00:30:54,045
如果你说的工作方式- 一个哦 

629
00:30:51,009 --> 00:30:56,010
这是你用来做什么的-打开 

630
00:30:54,045 --> 00:30:58,053
优化它 

631
00:30:56,001 --> 00:31:00,006
原来，由于海湾合作委员会，因为他们已经得到了 

632
00:30:58,053 --> 00:31:03,090
更先进的 是做了很多的 

633
00:31:00,006 --> 00:31:05,085
现在的优化为目的 

634
00:31:03,009 --> 00:31:08,103
这当然使代码很辛苦 

635
00:31:06,039 --> 00:31:11,948
了解所以 它 只是用的一个 

636
00:31:09,084 --> 00:31:15,141
最近的海湾合作委员会的代出来了 

637
00:31:12,299 --> 00:31:20,460
这个级别称为图G调试 

638
00:31:16,041 --> 00:31:21,138
这是一个不错的的这门课程的目的 

639
00:31:20,046 --> 00:31:24,054
这门课程一个不错的水平，它的排序 

640
00:31:22,038 --> 00:31:27,102
确实明显的一种优化 

641
00:31:25,026 --> 00:31:31,077
使代码可读而不 

642
00:31:28,002 --> 00:31:33,015
那种奢侈的在试图改写 

643
00:31:31,077 --> 00:31:35,088
的方式，将您的整个程序 

644
00:31:33,015 --> 00:31:37,664
让很多不同，希望 

645
00:31:35,088 --> 00:31:39,153
更高效所以这就是我们将使用 

646
00:31:37,799 --> 00:31:42,150
在这个过程中它只有在存在 

647
00:31:40,053 --> 00:31:43,442
最近它的 GCC版本

648
00:31:42,015 --> 00:31:50,057
在其他的编译器非标 

649
00:31:43,919 --> 00:31:56,960
问题没有它的O大写的 O 

650
00:31:50,057 --> 00:31:58,140
它代表了优化，从而是什么 

651
00:31:56,096 --> 00:32:03,173
命令只是没被产生的文件 

652
00:31:59,004 --> 00:32:04,037
叫一些 点C以便让我告诉 你 

653
00:32:06,044 --> 00:32:12,089
什么一些点S是让我来告诉你 

654
00:32:09,539 --> 00:32:12,890
该功能有些店

655
00:32:15,028 --> 00:32:20,086
你可以看到，那么好吗 

656
00:32:27,065 --> 00:32:34,071
所以这是它的代码说，一些商店

657
00:32:31,059 --> 00:32:35,133
然后你会看到你会 认识 

658
00:32:34,071 --> 00:32:38,157
我之前提到的这些指令

659
00:32:36,033 --> 00:32:42,039
推动移动调用必须移动 

660
00:32:39,057 --> 00:32:47,064
弹出其余的 ，但 你也看到 

661
00:32:42,039 --> 00:32:50,058
其他垃圾那里，我们编辑了 

662
00:32:48,027 --> 00:32:53,061
为演示文稿， 甚至在 

663
00:32:50,058 --> 00:32:54,153
书里得到了编辑出来，原因 是 

664
00:32:53,061 --> 00:32:56,154
这些是 不是 各种指令 

665
00:32:55,053 --> 00:33:00,081
代码本身 的真正直接一部分 

666
00:32:57,054 --> 00:33:01,119
他们有一个周期开始，这是一 

667
00:33:00,081 --> 00:33:03,120
迹象表明，这些都不是真正 

668
00:33:02,019 --> 00:33:07,103
说明还有别的东西

669
00:33:04,002 --> 00:33:11,016
他们都涉及到什么 

670
00:33:08,003 --> 00:33:14,016
需要被馈送到信息 

671
00:33:11,034 --> 00:33:17,058
调试器为它能够找到 

672
00:33:14,016 --> 00:33:19,074
程序 和一些 各部位 

673
00:33:17,058 --> 00:33:21,087
链接器的信息告诉它 

674
00:33:19,074 --> 00:33:23,112
这是 一个全局定义函数 

675
00:33:21,087 --> 00:33:26,121
而且，你不其他各种东西 

676
00:33:24,012 --> 00:33:30,105
真的需要重新思考最初约 

677
00:33:27,021 --> 00:33:32,043
所以我们有点把这些出来的 

678
00:33:31,005 --> 00:33:35,079
计划只是为了让他们 更具可读性 

679
00:33:32,043 --> 00:33:37,056
但如果你这样做 你自己，你会 

680
00:33:35,079 --> 00:33:38,160
找到这个CRUD在那里，我们没有 

681
00:33:37,056 --> 00:33:40,101
希望您能喜欢哦，我的天哪这 

682
00:33:39,006 --> 00:33:49,061
未在 本书中，我 不知道该怎么 

683
00:33:41,001 --> 00:33:50,015
用它做让我们回去 

684
00:33:57,083 --> 00:34:02,132
另一件事是人 在学习 

685
00:33:59,033 --> 00:34:05,090
上的数据网络是 尖锐 对比非 charkh 

686
00:34:03,032 --> 00:34:10,055
它的确与众不同，甚至这样的 

687
00:34:05,009 --> 00:34:12,065
是Mac电脑，我可以得到车辙GCC 

688
00:34:10,055 --> 00:34:16,055
安装和它产生了英特尔

689
00:34:13,046 --> 00:34:19,015
处理器在那里，但它直接不 

690
00:34:16,055 --> 00:34:20,914
与Linux的代码兼容，因此它的 

691
00:34:19,429 --> 00:34:22,700
这个过程中 ，我们是 非常重要的 

692
00:34:21,409 --> 00:34:29,690
他说只要坚持与鲨鱼

693
00:34:22,007 --> 00:34:30,044
一切机器，你这样做是什么

694
00:34:29,069 --> 00:34:32,075
有一些 特性 有 

695
00:34:31,007 --> 00:34:35,105
汇编代码尤其是他们如何

696
00:34:33,029 --> 00:34:38,033
由C不同那么首先 有 

697
00:34:36,005 --> 00:34:43,031
许多不同的 排序整数 的 

698
00:34:38,069 --> 00:34:45,125
数据类型大小1 2 4 和8个字节的一个 

699
00:34:43,031 --> 00:34:50,072
它们不区分整数数据类型 

700
00:34:46,025 --> 00:34:53,081
注册与未签名的它是如何获得 

701
00:34:50,072 --> 00:34:56,075
储存和甚至地址或指针 

702
00:34:53,081 --> 00:34:58,169
只是存储为一个号码在计算机 

703
00:34:57,002 --> 00:35:03,011
并 没有 任何特殊 

704
00:34:59,069 --> 00:35:04,091
意义给它 的浮点是 

705
00:35:03,011 --> 00:35:06,023
在上一个非常不同的方式处理

706
00:35:04,091 --> 00:35:08,153
另一方面与一组不同的 

707
00:35:06,023 --> 00:35:10,109
注册了我想我会讲到 

708
00:35:09,053 --> 00:35:14,099
在后来的一个很简单 

709
00:35:11,009 --> 00:35:16,088
演讲的程序本身是在86 

710
00:35:14,099 --> 00:35:17,158
它只是一个字节串，以及我会 

711
00:35:16,088 --> 00:35:20,170
告诉你这些的一些例子， 

712
00:35:18,058 --> 00:35:23,156
之类的东西 加薪和结构以及 

713
00:35:21,007 --> 00:35:26,072
的事情，你觉得作为根本的 

714
00:35:24,056 --> 00:35:29,075
数据类型 不会在机器上存在 

715
00:35:27,035 --> 00:35:32,042
水平有几分构建 

716
00:35:29,075 --> 00:35:33,146
人为由编译器和后 

717
00:35:32,042 --> 00:35:36,095
在使用过程中和这些宣讲会 

718
00:35:34,046 --> 00:35:39,122
跨 到怎么说实际上 已经完成了 

719
00:35:36,095 --> 00:35:42,110
还有这样一些事情， 你是你 

720
00:35:40,022 --> 00:35:45,101
了解并看到 这里存在一些 

721
00:35:43,001 --> 00:35:48,053
他们都是那种 必须建立 

722
00:35:46,001 --> 00:35:51,013
在 装配水平的 顶层 

723
00:35:48,062 --> 00:35:50,113
程序 

724
00:35:51,619 --> 00:35:56,665
所以有关 装配 水平的另一件事

725
00:35:54,619 --> 00:35:58,666
编程是每一个指令是很 

726
00:35:57,079 --> 00:36:03,102
在它能做什么非常有限它能 

727
00:35:59,089 --> 00:36:07,108
从寄存器 从将数据移动到 存储器 

728
00:36:03,309 --> 00:36:10,190
或者它可以做加法或 

729
00:36:07,279 --> 00:36:11,353
乘法或类似 的东西

730
00:36:10,019 --> 00:36:17,338
但是真正能够基本上只能 做一个 

731
00:36:12,019 --> 00:36:19,072
的事情，所以你 必须写 

732
00:36:17,509 --> 00:36:20,960
整如果你手工编写它 

733
00:36:19,549 --> 00:36:23,630
你必须写一个全系列 

734
00:36:20,096 --> 00:36:23,875
说明做成任何事情和 

735
00:36:23,063 --> 00:36:25,118
这是部分原因，为什么它的 

736
00:36:24,739 --> 00:36:30,140
真的好很多 的编译器是什么 

737
00:36:26,018 --> 00:36:35,307
做到这一点，也将看到 排序 

738
00:36:30,014 --> 00:36:39,089
之类的东西怎么办循环而循环

739
00:36:35,469 --> 00:36:42,478
有条件的switch语句是那些 

740
00:36:39,089 --> 00:36:46,768
所有建立在其他一些低顶

741
00:36:42,559 --> 00:36:50,608
在这样的指令级特性 

742
00:36:47,569 --> 00:36:53,930
此功能 的一些商店居然 

743
00:36:51,049 --> 00:36:57,130
它获得由总共 十四 编码 

744
00:36:53,093 --> 00:36:59,262
字节， 这么一件事 约86是一些 

745
00:36:57,859 --> 00:37:02,901
指令是短至一个字节

746
00:37:00,099 --> 00:37:07,146
但也有的可能长达 15个字节 

747
00:37:03,279 --> 00:37:07,308
在编码看到的和 

748
00:37:12,041 --> 00:37:18,460
哦，就像我说的每一个每一个 指令 

749
00:37:16,039 --> 00:37:21,200
真的一般仅做一件事情，所以 

750
00:37:18,829 --> 00:37:23,908
例如，看看如果你说 明星递减 

751
00:37:21,002 --> 00:37:26,075
等于 吨 什么是通常会和 

752
00:37:24,619 --> 00:37:28,690
不一定，但这种方式思考 

753
00:37:26,093 --> 00:37:30,532
有关机器 级是 

754
00:37:28,069 --> 00:37:33,143
10年一些地方的价值将是 

755
00:37:31,369 --> 00:37:36,230
通常存储在寄存器中 并作为 

756
00:37:34,043 --> 00:37:37,094
你知道，看你把明星 

757
00:37:36,023 --> 00:37:40,072
它的面前 ，你想把 它当作一个参考 

758
00:37:37,094 --> 00:37:43,139
指针，如果该参考是 对 

759
00:37:40,279 --> 00:37:46,900
离开你想存储多个值 

760
00:37:44,039 --> 00:37:50,042
在那里你指着那个地方

761
00:37:46,009 --> 00:37:52,058
那么什么会发生通常是 

762
00:37:50,042 --> 00:37:55,471
孰料实际 指针值 

763
00:37:53,039 --> 00:37:58,978
也将被保存在这里注册 

764
00:37:55,849 --> 00:38:01,970
它在寄存器RBX我用一招 

765
00:37:59,329 --> 00:38:04,354
指示 说：要与值 

766
00:38:01,097 --> 00:38:06,139
一个寄存器，它在这里 呼吁 我们的斧头 

767
00:38:04,579 --> 00:38:10,600
并将其存储在存储器中的位置 

768
00:38:07,039 --> 00:38:13,408
多数民众赞成 由另一寄存器指定使 

769
00:38:10,789 --> 00:38:15,793
你看到的 想法 ，我们将进入更 

770
00:38:13,759 --> 00:38:17,764
所有这些寄存器名细节

771
00:38:15,829 --> 00:38:19,700
什么括号的意思，但你 

772
00:38:18,259 --> 00:38:22,910
得到粗略的想法，一个举动 

773
00:38:19,007 --> 00:38:26,316
指令是说可以参考 

774
00:38:22,091 --> 00:38:28,124
任一寄存器 或存储器位置 

775
00:38:27,009 --> 00:38:31,400
和实际的对象代码

776
00:38:29,024 --> 00:38:38,024
这表示是短短三年 

777
00:38:31,004 --> 00:38:39,883
字节，其中第一个字节告诉它 

778
00:38:38,024 --> 00:38:42,029
它和我们甚至会在此说的多了

779
00:38:40,279 --> 00:38:46,220
当然有关 说明如何 

780
00:38:42,074 --> 00:38:48,193
编码一般不会让程序做 

781
00:38:46,022 --> 00:38:50,048
对于我们，但在这种情况下，只有

782
00:38:48,859 --> 00:38:53,860
需要三个字节写 

783
00:38:50,048 --> 00:38:55,627
特定指令所以我们如何能 

784
00:38:53,869 --> 00:38:57,892
知道这种东西怎么样才 

785
00:38:56,059 --> 00:38:59,750
弄清楚详细程度以及 

786
00:38:58,099 --> 00:39:03,890
有一些真正 有用的工具， 

787
00:38:59,075 --> 00:39:05,099
让您 检查机器代码 ， 即使 你 

788
00:39:03,089 --> 00:39:08,120
没有原来的C文件的副本

789
00:39:05,099 --> 00:39:09,197
甚至汇编代码文件提前 

790
00:39:09,002 --> 00:39:14,061
时间，有一个叫 

791
00:39:10,097 --> 00:39:17,446
拆装所以汇编从去 

792
00:39:14,259 --> 00:39:20,900
这一指令文本版本的 

793
00:39:18,319 --> 00:39:22,327
字节级表示和所述 

794
00:39:20,009 --> 00:39:24,062
反汇编只是颠倒，它说，

795
00:39:23,119 --> 00:39:30,170
这里是一系列 字节 

796
00:39:25,043 --> 00:39:32,060
我反汇编知道这 

797
00:39:30,017 --> 00:39:34,103
特定字节序列是指是一个 

798
00:39:32,006 --> 00:39:37,073
移动指令， 所以它现在将 

799
00:39:35,003 --> 00:39:40,004
打印出来的 屏幕 上说，哦那 

800
00:39:38,027 --> 00:39:42,095
是移动指令 ，所以它 

801
00:39:40,013 --> 00:39:45,047
基本扭转工程师从 

802
00:39:42,095 --> 00:39:47,108
对象代码返回到汇编 代码或 

803
00:39:45,047 --> 00:39:55,052
东西有点像 汇编代码 

804
00:39:48,008 --> 00:39:58,076
你会看到它失去 的是什么是非常 

805
00:39:55,052 --> 00:40:00,074
略有不同的一件事也 

806
00:39:58,076 --> 00:40:03,122
注意到我应该提到关于议会

807
00:40:00,074 --> 00:40:05,168
代码是你所知道所有 的名字 

808
00:40:04,022 --> 00:40:09,050
我用的所有变量的名称 是 

809
00:40:06,068 --> 00:40:11,126
在汇编代码完全失去

810
00:40:09,005 --> 00:40:13,064
一级或 机器代码 级别 的东西 

811
00:40:12,026 --> 00:40:16,055
只是没有在寄存器中他们 

812
00:40:14,009 --> 00:40:18,041
某处存储器中的程序有没有 

813
00:40:16,055 --> 00:40:21,128
原始源的理解

814
00:40:18,041 --> 00:40:23,123
在 这一水平 ，因此代码 

815
00:40:22,028 --> 00:40:26,036
拆解只是很长的路要走 

816
00:40:24,023 --> 00:40:29,075
向后，你可以做你自己 

817
00:40:26,036 --> 00:40:35,101
你会发现各种有用 

818
00:40:29,075 --> 00:40:35,101
背景和自己做 

819
00:40:37,509 --> 00:40:46,593
样的东西转转 乐这样瞎搞

820
00:40:43,219 --> 00:40:47,232
如果我编译 和程序 

821
00:41:01,059 --> 00:41:08,059
所以，如果我做你更标准的东西 

822
00:41:04,072 --> 00:41:11,074
在使用编译器做你说过的运行 

823
00:41:08,059 --> 00:41:13,111
编译器给它一些优化诉说 

824
00:41:11,092 --> 00:41:15,099
它的源文件是什么，直到其中 

825
00:41:14,011 --> 00:41:19,015
把最后的可执行代码和我 

826
00:41:16,062 --> 00:41:25,117
非常聪明的我调用该函数总和 

827
00:41:19,015 --> 00:41:28,050
所以总和为八的二进制文件 

828
00:41:26,017 --> 00:41:31,021
千663 自行车 

829
00:41:28,005 --> 00:41:34,054
你会看到关上 它标志着左 

830
00:41:31,021 --> 00:41:38,034
如可执行文件 和它 的 实际 工作 我 

831
00:41:34,099 --> 00:41:40,156
可以用它一起添加号码， 

832
00:41:38,034 --> 00:41:46,117
这是这一年 的标准执行 

833
00:41:41,056 --> 00:41:50,137
程序原谅我，如果我运行一个程序 

834
00:41:47,017 --> 00:41:54,061
所谓的对象转储，并问 

835
00:41:51,037 --> 00:41:58,045
拆开它可以做各种事情它 

836
00:41:54,061 --> 00:41:59,125
会吐出的反汇编版本

837
00:41:58,045 --> 00:42:06,072
该计划将在屏幕上飞过 

838
00:42:00,025 --> 00:42:06,072
但 如果我重定向 到一些文件 

839
00:42:07,029 --> 00:42:12,075
这我已经做我会删除旧的

840
00:42:10,045 --> 00:42:12,048
一 

841
00:42:17,001 --> 00:42:25,009
现在我看，你会看到， 

842
00:42:22,057 --> 00:42:26,143
有什么样的我可谓是 

843
00:42:25,081 --> 00:42:29,086
的拆卸表示

844
00:42:27,043 --> 00:42:31,048
程序包括一些文件， 您 

845
00:42:29,086 --> 00:42:33,112
这样做， 你没有不某些功能

846
00:42:31,093 --> 00:42:37,107
写成那些有几分的 

847
00:42:34,012 --> 00:42:40,084
了在所使用的低级别的功能 

848
00:42:38,007 --> 00:42:42,084
一个叫做程序的初始启动

849
00:42:40,084 --> 00:42:45,084
它 

850
00:42:42,084 --> 00:42:45,084
哎呀

851
00:42:47,078 --> 00:42:52,119
但这里的某个地方在它 的中间 

852
00:42:50,052 --> 00:42:56,061
你会看到你瞧是程序

853
00:42:53,019 --> 00:43:00,060
该 功能的一些故事， 得到了 

854
00:42:56,061 --> 00:43:05,096
编译，你可以看到什么 

855
00:43:00,006 --> 00:43:08,085
确实是花 了 这14个字节从 

856
00:43:05,096 --> 00:43:11,127
原，所述目标代码和它

857
00:43:09,039 --> 00:43:14,091
挑选那些开并 与之 回来 

858
00:43:12,027 --> 00:43:16,101
什么指令代码的字节，因此 

859
00:43:14,091 --> 00:43:19,143
例如仅推送指令 

860
00:43:17,001 --> 00:43:24,006
采用单个字节的举动，你看到的 

861
00:43:20,043 --> 00:43:27,048
之前有 三个字节 这个调用 

862
00:43:24,051 --> 00:43:29,118
因为它给 的位置 

863
00:43:27,093 --> 00:43:34,155
其中调用是5个字节指令 

864
00:43:30,018 --> 00:43:37,050
等等，但 再次拆装 

865
00:43:35,055 --> 00:43:38,121
没有访问源 代码，它 

866
00:43:37,005 --> 00:43:40,101
没有连 到组件 的访问 

867
00:43:39,021 --> 00:43:46,029
代码它由刚刚想通了这一点

868
00:43:41,046 --> 00:43:48,053
在实际 的 目标代码文件字节，因此 

869
00:43:46,029 --> 00:43:51,084
这是方式，如果你想知道 

870
00:43:48,053 --> 00:43:53,135
实际上在字节级编码，这是 

871
00:43:51,084 --> 00:43:58,140
如何你看着办吧是运行 

872
00:43:54,035 --> 00:44:01,071
程序通过一个汇编程序运行得 

873
00:43:59,004 --> 00:44:06,035
对象代码，然后回来了与 

874
00:44:01,071 --> 00:44:06,071
它还有另外一种方式 ，你可以做到这一点 

875
00:44:06,083 --> 00:44:11,139
使用调试程序，你会 

876
00:44:10,023 --> 00:44:16,095
了解得非常好，在未来网络 

877
00:44:12,039 --> 00:44:23,067
你会做，这就是所谓的GDB 

878
00:44:16,095 --> 00:44:26,097
和gdb是一个非常强大的调试

879
00:44:23,067 --> 00:44:28,166
程序可以检查的步骤 

880
00:44:26,097 --> 00:44:33,144
通过与在程序运行，

881
00:44:29,066 --> 00:44:35,118
再次，你可以的，如果你如果源代码 

882
00:44:34,044 --> 00:44:38,121
它的可用 它 会利用 

883
00:44:36,018 --> 00:44:40,077
它，但它也可以在程序 中 使用 

884
00:44:39,021 --> 00:44:42,075
对此有没有 可用的源 

885
00:44:40,077 --> 00:44:44,121
但的 特点 之一 是能力 

886
00:44:42,075 --> 00:44:51,077
拆卸功能，在那里，所以如果 

887
00:44:45,021 --> 00:44:53,027
我说拆机一些商店

888
00:44:51,077 --> 00:44:54,152
它会回来的东西 ， 

889
00:44:53,081 --> 00:44:58,115
看起来很像 你在看到了 什么 

890
00:44:55,052 --> 00:45:01,103
从对象转储的列表 

891
00:44:59,015 --> 00:45:03,071
说明这里它只是 显示 在 

892
00:45:02,003 --> 00:45:05,099
十六进制这些东西的地址

893
00:45:03,071 --> 00:45:10,073
不同的指令它不 

894
00:45:05,099 --> 00:45:12,155
显示字节级编码，以便有

895
00:45:10,091 --> 00:45:16,106
我的观点在这里 有各种工具 

896
00:45:13,055 --> 00:45:18,113
，让 你看即使程序 

897
00:45:17,006 --> 00:45:21,020
它的实际表现 是一个二进制 

898
00:45:19,013 --> 00:45:23,077
文件，您不想检查 

899
00:45:21,002 --> 00:45:23,059
直

900
00:45:32,047 --> 00:45:37,083
我只需将其插入这 

901
00:45:42,569 --> 00:45:47,950
还等什么这张幻灯片显示的是 什么，我只是 

902
00:45:45,097 --> 00:45:49,138
显示 在屏幕 上 是 什么 

903
00:45:47,095 --> 00:45:53,176
对象转储程序产生用于 

904
00:45:50,038 --> 00:45:56,095
这个功能，这是一个版本 

905
00:45:54,076 --> 00:45:59,080
展示什么GDB会告诉你吧 

906
00:45:56,095 --> 00:46:02,724
并用gdb，如果你想真正得到 

907
00:46:00,016 --> 00:46:06,405
字节出来，你可以做到这一点，你可以 

908
00:46:03,579 --> 00:46:09,130
基本上任何 地址你可以只 

909
00:46:06,549 --> 00:46:11,580
给一个地址 ， 并 告诉它显示 

910
00:46:09,013 --> 00:46:16,066
一些字节数等 ，而这 

911
00:46:11,859 --> 00:46:19,932
神秘的命令GDB说检查 14 

912
00:46:16,066 --> 00:46:25,123
字节十六进制 格式起始于 

913
00:46:20,589 --> 00:46:27,615
功能和商店的地址，并将其 

914
00:46:26,023 --> 00:46:30,602
生产的东西，看起来像什么 

915
00:46:27,849 --> 00:46:29,945
你看左边 

916
00:46:32,022 --> 00:46:37,090
其实拆卸是一个工具， 可以 

917
00:46:35,029 --> 00:46:39,115
被用作任何 反向的 一部分 

918
00:46:37,009 --> 00:46:41,101
工程工具 和我用来演示 

919
00:46:40,015 --> 00:46:47,080
这通过显示的 拆卸 

920
00:46:42,082 --> 00:46:51,181
Microsoft Word中的窗口我有一台PC 

921
00:46:47,008 --> 00:46:54,085
当时不是好惹的，但一些人， 

922
00:46:52,081 --> 00:46:56,170
你知道我们的幻灯片是在线，所以我们

923
00:46:55,057 --> 00:46:59,095
得到了一些人讨厌克 说 

924
00:46:57,007 --> 00:47:01,039
你知道 你 违反了微软 

925
00:46:59,095 --> 00:47:04,099
最终用户 许可协议，当你做 

926
00:47:02,002 --> 00:47:06,064
因为你应该给你 

927
00:47:04,099 --> 00:47:09,100
不知道这一点，但记得 那些 

928
00:47:06,064 --> 00:47:13,153
通过点击我同意的事情，你

929
00:47:10,009 --> 00:47:16,090
从来没有读过其中之一是， 我们不 

930
00:47:14,053 --> 00:47:20,101
尝试反向工程的任何微软 

931
00:47:16,009 --> 00:47:23,011
这样的产品，所以这是 技术上时 

932
00:47:21,001 --> 00:47:26,014
所以我敢肯定，只是谦虚我空白

933
00:47:23,092 --> 00:47:27,100
这一点，但实际上你可以做，如果 

934
00:47:26,014 --> 00:47:31,015
你可以找到该文件是它的排序

935
00:47:28,000 --> 00:47:34,069
晦涩的地方 实际 的 可执行 

936
00:47:31,024 --> 00:47:39,085
应用程序的文件现在 我的观点是 

937
00:47:34,069 --> 00:47:41,140
那话 像任何其他应用程序 

938
00:47:39,085 --> 00:47:43,144
您运行只是一个可执行文件和 

939
00:47:42,004 --> 00:47:49,075
该可执行文件是只是一堆 

940
00:47:44,044 --> 00:47:51,097
字节是编码的说明 好 了， 

941
00:47:50,011 --> 00:47:54,048
让我们去一个远一点这个 

942
00:47:51,097 --> 00:47:57,129
装配级编程业务 

943
00:47:54,048 --> 00:48:01,117
所以我一直在谈论寄存器和

944
00:47:58,029 --> 00:48:04,078
86 64这是完全古怪的一套 

945
00:48:02,017 --> 00:48:07,024
寄存器和它 再次的 反映 

946
00:48:04,078 --> 00:48:11,155
这种进化的历史给它的

947
00:48:07,024 --> 00:48:14,098
但你会看到， 有 16个寄存器 

948
00:48:12,055 --> 00:48:18,073
你可以用它来保持整数和 

949
00:48:14,098 --> 00:48:20,098
指针和他们中的一些有这些 

950
00:48:18,073 --> 00:48:22,138
排序字母的名字和一些 

951
00:48:20,098 --> 00:48:24,145
他们有数字的名字，我会告诉你 

952
00:48:23,038 --> 00:48:27,043
为什么在一分钟，也是每个 

953
00:48:25,045 --> 00:48:32,050
如果您使用的那种百分比注册

954
00:48:27,088 --> 00:48:33,145
它是名字 ，你会得到64位，但如果 

955
00:48:32,005 --> 00:48:36,076
您使用的百分比II版吧 

956
00:48:34,045 --> 00:48:40,047
你会得到32位，你会发现什么 

957
00:48:37,021 --> 00:48:43,102
在操纵在长节目

958
00:48:40,065 --> 00:48:44,109
你会看到使用的 是，如果他们 

959
00:48:44,002 --> 00:48:47,025
只是在那里 

960
00:48:45,009 --> 00:48:49,041
二位 的东西，你会看到代码说 

961
00:48:47,025 --> 00:48:51,033
Ë 百分之 所以你会看到这两个 

962
00:48:49,041 --> 00:48:54,117
出现， 但它是公平重要 

963
00:48:52,005 --> 00:48:58,088
记住％的 E文版是 

964
00:48:55,017 --> 00:49:03,099
只是较大 的 低阶32位 

965
00:48:58,088 --> 00:49:04,116
我们百分之实体，实际上它去 

966
00:49:03,099 --> 00:49:06,168
除此之外

967
00:49:05,016 --> 00:49:11,025
你也可以参考低阶 

968
00:49:07,068 --> 00:49:13,161
16位和低位两位我 

969
00:49:11,025 --> 00:49:16,122
对不起一个字节16要 2个字节 ，一个 

970
00:49:14,061 --> 00:49:20,145
内的每一个这些寄存器作为字节

971
00:49:17,022 --> 00:49:25,059
很好，但再想想这些像 

972
00:49:21,045 --> 00:49:27,099
命名地点，你可以存储 

973
00:49:25,059 --> 00:49:32,088
值你 可以检索值 

974
00:49:27,099 --> 00:49:34,113
他们和你有你的西装 

975
00:49:32,088 --> 00:49:39,105
拟人机器语言 

976
00:49:35,013 --> 00:49:42,042
这里不是你 个人 实际上会 

977
00:49:40,005 --> 00:49:45,018
必须明确 命名这些寄存器 

978
00:49:42,042 --> 00:49:46,086
大部分说那里的东西 

979
00:49:45,018 --> 00:49:49,092
应该去的地方，他们应该出来的 

980
00:49:46,086 --> 00:49:51,165
它不是你就像一个内存 

981
00:49:49,092 --> 00:49:53,115
给一个号码告诉 到哪里寻找 

982
00:49:52,065 --> 00:49:55,128
你可以计算一个数值 存在 

983
00:49:54,015 --> 00:49:59,064
其实每一个被标识 

984
00:49:56,028 --> 00:50:06,066
分别所以就像一点点 

985
00:49:59,064 --> 00:50:10,083
历史与 IA32所以回到刚才我们谈到 

986
00:50:06,066 --> 00:50:13,068
大约有为8个寄存器的所有％ 

987
00:50:10,083 --> 00:50:17,136
Ë版本和变化一个 

988
00:50:13,086 --> 00:50:19,164
从IA32来到x86的64是翻番 

989
00:50:18,036 --> 00:50:22,053
寄存器的数量和方式 

990
00:50:20,064 --> 00:50:23,160
这是一个非常有用的东西，因为 

991
00:50:22,053 --> 00:50:28,068
这是非常令人沮丧的多么少 

992
00:50:24,006 --> 00:50:37,023
登记有在旧 我 32 

993
00:50:28,068 --> 00:50:39,114
机器然后我提到你 

994
00:50:37,077 --> 00:50:43,089
实际上可以在旧机器指 

995
00:50:40,014 --> 00:50:46,107
到下 门16个字节的这些 

996
00:50:43,089 --> 00:50:50,097
寄存器和这是从遗留 

997
00:50:47,007 --> 00:50:54,066
8086天和一楼之内 你 

998
00:50:51,069 --> 00:50:57,072
甚至可以参照个人 

999
00:50:54,066 --> 00:51:00,093
主或 在这些 字节 

1000
00:50:57,072 --> 00:51:03,078
所以现在你可以真正得到的 

1001
00:51:00,093 --> 00:51:06,126
所有这些， 我们的低位字节

1002
00:51:03,078 --> 00:51:08,157
只是有些得到了覆盖在 

1003
00:51:07,026 --> 00:51:10,125
本书实际上我们不谈谈 如何 

1004
00:51:09,057 --> 00:51:13,155
你可以到这些字节，因为 

1005
00:51:11,025 --> 00:51:23,025
这是真正 从后之前遗留 

1006
00:51:14,055 --> 00:51:31,110
8086 一个叫 8080，其 

1007
00:51:23,025 --> 00:51:34,026
是 一个8字节的计算机，以便反正你 

1008
00:51:32,001 --> 00:51:37,026
可以看到，那么 你是如何 从这种 有 

1009
00:51:34,026 --> 00:51:39,108
事务的怪异状态， 偶数 

1010
00:51:37,035 --> 00:51:42,093
离奇的状态， 我们 在 今天的 

1011
00:51:40,008 --> 00:51:47,010
其中一些人的名字 ，其中一些 

1012
00:51:42,093 --> 00:51:50,151
顺便说一下有数字和那些名字 

1013
00:51:47,001 --> 00:51:53,100
有一个原因，早在远古时代 ，他们 

1014
00:51:51,051 --> 00:51:55,134
有非常 具体的目的 ，所以他们 

1015
00:51:54,009 --> 00:52:00,021
给予某种反映名称

1016
00:51:56,034 --> 00:52:02,097
这些目的但是，所有去 

1017
00:52:00,021 --> 00:52:05,076
离开多年以前 ，因此现在 

1018
00:52:02,097 --> 00:52:07,140
这些名字只是传统的名字有 

1019
00:52:05,076 --> 00:52:09,111
无关， 与他们的目的，现在我 

1020
00:52:08,004 --> 00:52:11,043
应该提到这里只有 有 

1021
00:52:10,011 --> 00:52:16,095
一些特殊的还有一个特殊的 

1022
00:52:11,079 --> 00:52:18,123
如图粉色 如今 这里 注册 

1023
00:52:16,095 --> 00:52:21,117
而这就是所谓的 堆栈指针和 

1024
00:52:19,023 --> 00:52:23,106
该寄存器你不只是使用任何旧 

1025
00:52:22,017 --> 00:52:26,052
这样你请它有一个非常具体的 

1026
00:52:24,006 --> 00:52:28,071
目的和所有其他寄存器 

1027
00:52:26,052 --> 00:52:29,130
还有一些略有不同 

1028
00:52:28,071 --> 00:52:32,076
比其他的，但 在大多数 情况 下 

1029
00:52:30,003 --> 00:52:37,010
他们都能够用于保持节目 

1030
00:52:33,021 --> 00:52:39,087
数据早在IA32天有一个 

1031
00:52:37,037 --> 00:52:42,102
寄存器称为基指针 

1032
00:52:39,087 --> 00:52:44,091
也 得到了使用程序，但没有 

1033
00:52:43,002 --> 00:52:49,035
再得到 了 使用， 也可以 

1034
00:52:45,027 --> 00:52:50,100
至少不是通常这样反正我没 

1035
00:52:49,035 --> 00:52:53,040
想我不想花很多 

1036
00:52:51,000 --> 00:52:56,073
时间对历史遗产的东西，有 

1037
00:52:53,085 --> 00:52:57,183
你记住，你知道什么是功能 

1038
00:52:56,073 --> 00:52:59,169
添加和处理器的什么型号，但 

1039
00:52:58,083 --> 00:53:02,124
以防万一你想知道为什么 

1040
00:53:00,069 --> 00:53:04,140
有这些这些奇怪的名字 

1041
00:53:03,024 --> 00:53:08,563
事情只要你喜欢这样的事实 

1042
00:53:05,004 --> 00:53:12,102
这是一个旧的东西 

1043
00:53:08,779 --> 00:53:15,806
好了，所以现在我们可以把 它 想象 那么 

1044
00:53:13,038 --> 00:53:17,627
有八个寄存器姓名和 

1045
00:53:16,049 --> 00:53:21,071
有八个寄存器是 

1046
00:53:17,969 --> 00:53:22,970
一些 数字 表明 ，让我们来看看 

1047
00:53:21,269 --> 00:53:28,650
在一些 该操作说明 

1048
00:53:22,979 --> 00:53:31,170
这些寄存器和有 几分 

1049
00:53:28,065 --> 00:53:33,734
三种不同的 移动使移动 

1050
00:53:31,017 --> 00:53:38,846
在x86指令其实是可以做 

1051
00:53:34,319 --> 00:53:41,327
很多的东西 ，因为它可以采取 

1052
00:53:38,999 --> 00:53:44,072
不同类型的信息还是什么 

1053
00:53:42,119 --> 00:53:47,192
他们称这样的操作数源和 

1054
00:53:44,729 --> 00:53:50,783
有些地方你是 你 抄袭 

1055
00:53:47,849 --> 00:53:52,913
源到目的地的源 

1056
00:53:51,269 --> 00:53:55,295
可以通过一些什么所谓 即时它 

1057
00:53:53,489 --> 00:53:58,140
实际上那烤 成一个数

1058
00:53:55,529 --> 00:54:01,550
要复制 到一些程序

1059
00:53:58,014 --> 00:54:05,413
其他位置 的注册，我们已经讨论过 

1060
00:54:01,739 --> 00:54:07,796
大约是一个特别命名的记忆 

1061
00:54:05,539 --> 00:54:10,680
位置和存储器是阵列 

1062
00:54:08,309 --> 00:54:13,140
字节，你通常你必须 

1063
00:54:10,068 --> 00:54:16,007
指定什么，你是 地址 

1064
00:54:13,014 --> 00:54:18,953
无论是从，如果是，如果阅读 

1065
00:54:16,619 --> 00:54:22,700
源， 你写，如果它是 

1066
00:54:19,079 --> 00:54:26,101
目的地等移动指令 

1067
00:54:23,429 --> 00:54:31,170
给你所有这些可能性的 

1068
00:54:26,299 --> 00:54:33,650
立即值可以 被写入 

1069
00:54:31,017 --> 00:54:36,146
寄存器，或直接对存储器的 

1070
00:54:33,065 --> 00:54:38,163
寄存器值可以被复制到 另一 

1071
00:54:36,299 --> 00:54:42,302
注册或写入到内存或即可 

1072
00:54:39,063 --> 00:54:44,672
取的值 从存储器 读出它 

1073
00:54:42,329 --> 00:54:47,366
内存并将其复制到寄存器，所以如果 

1074
00:54:45,239 --> 00:54:50,276
你觉得等待的不应该有 

1075
00:54:47,699 --> 00:54:52,890
这里九种不同的组合也没有

1076
00:54:50,609 --> 00:54:55,625
因为它没有意义 的有 

1077
00:54:52,089 --> 00:54:58,958
立即 值作为目标 这是一个 

1078
00:54:55,769 --> 00:55:00,848
常数，也只是排序的 

1079
00:54:59,759 --> 00:55:03,776
方便起见所以硬件 

1080
00:55:01,559 --> 00:55:06,150
设计师不会让你直接 

1081
00:55:03,929 --> 00:55:08,400
复制从一个内存位置移到另一个位置 

1082
00:55:06,015 --> 00:55:10,484
你所要做的是使用两种 

1083
00:55:08,004 --> 00:55:11,031
一个指令从内存中拷贝到

1084
00:55:10,619 --> 00:55:15,692
从内存中读取它 

1085
00:55:11,067 --> 00:55:17,216
将其复制到寄存器 和第二个 

1086
00:55:16,349 --> 00:55:19,390
取该值 在 寄存器和 

1087
00:55:17,819 --> 00:55:23,980
它 改写 内存 

1088
00:55:19,039 --> 00:55:27,040
所以这就是为什么有这个只有五 

1089
00:55:23,098 --> 00:55:29,155
可能性和因此每个的这些 

1090
00:55:27,049 --> 00:55:33,052
实际五个结合，你会看到 

1091
00:55:30,055 --> 00:55:35,098
某种形式或另一所以，例如，如果我 

1092
00:55:33,052 --> 00:55:38,098
取一个恒定值 ，并将其复制到 

1093
00:55:35,098 --> 00:55:39,157
注册它有点像，你可以

1094
00:55:38,098 --> 00:55:41,155
想登记 在排序 的 

1095
00:55:40,057 --> 00:55:44,136
临时数据，你的工作

1096
00:55:42,055 --> 00:55:46,147
现在所以它的排序的方式 

1097
00:55:45,036 --> 00:55:51,099
分配一个恒定值的 

1098
00:55:47,047 --> 00:55:53,131
临时同样，如果你有一个 

1099
00:55:51,099 --> 00:55:56,140
存储作为目标，它像 

1100
00:55:54,031 --> 00:56:01,036
在存储器中存储的恒定值

1101
00:55:57,004 --> 00:56:02,080
如果一个地方你从一个复制

1102
00:56:01,036 --> 00:56:04,111
注册到另一个它有点像 

1103
00:56:03,016 --> 00:56:08,109
复制一个临时值到另一个 

1104
00:56:05,011 --> 00:56:13,033
一个寄存器 内存就好像你 

1105
00:56:09,009 --> 00:56:15,016
它有点像存储到一个地址 

1106
00:56:13,033 --> 00:56:16,117
这样一个指针引用，其中

1107
00:56:15,079 --> 00:56:20,086
左侧指针 

1108
00:56:17,017 --> 00:56:22,114
解除引用和内存 寄存器是 

1109
00:56:21,049 --> 00:56:26,056
相反它是 你的，你正在阅读 

1110
00:56:23,014 --> 00:56:32,017
从某个位置到临时 

1111
00:56:26,056 --> 00:56:36,091
位置，以便这些 Yosi所有五个版本 

1112
00:56:32,017 --> 00:56:38,094
在某种形式的习惯或其他所以现在 

1113
00:56:36,091 --> 00:56:42,127
让我们来谈谈我们如何写这些 

1114
00:56:38,094 --> 00:56:45,112
指针我们如何指定一个源 

1115
00:56:43,027 --> 00:56:49,111
或用于存储器参考目的地

1116
00:56:46,012 --> 00:56:52,015
你已经看到了 这 一个版本 

1117
00:56:50,011 --> 00:56:54,090
其实在 一些 当你把 代码 

1118
00:56:52,042 --> 00:56:57,064
在括号中的寄存器的名字

1119
00:56:54,009 --> 00:56:59,011
这只是说使用这个寄存器 

1120
00:56:57,064 --> 00:57:02,101
无论是在那一个地址 

1121
00:57:00,001 --> 00:57:06,010
并使用该地址引用一些 

1122
00:57:03,001 --> 00:57:10,003
存储位置，所以你会 看到 

1123
00:57:07,000 --> 00:57:11,077
这样的事情是等效 

1124
00:57:10,003 --> 00:57:12,067
解引用指针，并把它

1125
00:57:11,077 --> 00:57:14,095
在那里 临时 

1126
00:57:12,067 --> 00:57:17,122
你也允许 做一点点 

1127
00:57:14,095 --> 00:57:19,191
算术的推导从地址 

1128
00:57:18,022 --> 00:57:23,095
寄存器 和其他的一些集合

1129
00:57:20,091 --> 00:57:26,164
常数值，所以如果你看到一个数字 

1130
00:57:23,095 --> 00:57:30,124
称为 在前面的 位移 ð 

1131
00:57:27,064 --> 00:57:32,099
这圆括号就意味着不能抵消 

1132
00:57:31,024 --> 00:57:35,027
使用这就是在地址 

1133
00:57:32,099 --> 00:57:36,185
注册，但加上或减去一些数 

1134
00:57:35,054 --> 00:57:39,098
从中得到，这只是一个地址

1135
00:57:37,085 --> 00:57:42,116
稍微偏离它由一些固定 量 

1136
00:57:39,098 --> 00:57:46,184
而且我们可以看到是相当 有用 

1137
00:57:43,016 --> 00:57:49,079
访问不同的数据结构，从而 

1138
00:57:47,084 --> 00:57:51,136
这里是一个非常 简单 的例子 

1139
00:57:49,079 --> 00:57:55,163
功能， 我们可以理解 

1140
00:57:52,036 --> 00:57:58,067
关于它的一切已经因为 我们 

1141
00:57:56,063 --> 00:58:02,078
知道移动指令做什么和 

1142
00:57:58,067 --> 00:58:05,102
此排序 的两款 经典 交换 的 

1143
00:58:02,078 --> 00:58:07,172
存储在 内存中 ，因此我的 价值观 

1144
00:58:06,002 --> 00:58:11,063
点我的论点是两个指针

1145
00:58:08,072 --> 00:58:12,146
所谓的XP和YP 和我要去 

1146
00:58:11,063 --> 00:58:16,088
解引用这些指针我要去

1147
00:58:13,046 --> 00:58:20,080
从存储器读入寄存器，然后 

1148
00:58:16,088 --> 00:58:24,100
我要去复制回内存，但 

1149
00:58:20,008 --> 00:58:27,083
扭转这两个目的地， 

1150
00:58:25,000 --> 00:58:31,007
所以你可以想像它，它排队 

1151
00:58:28,055 --> 00:58:34,103
对于对应的移动指令 

1152
00:58:31,007 --> 00:58:37,064
这四个参考，最终 

1153
00:58:35,003 --> 00:58:40,004
一个rekt 就不会了解 

1154
00:58:37,064 --> 00:58:42,068
功能以及他们是如何调用，但 

1155
00:58:40,004 --> 00:58:46,013
只是觉得读的是它可以让你它 

1156
00:58:43,004 --> 00:58:54,008
从哪里调用返回

1157
00:58:46,013 --> 00:58:58,030
位置是所以让我们来看看在

1158
00:58:54,044 --> 00:59:04,066
在实际的代码更详细然后和

1159
00:58:58,003 --> 00:59:07,064
因此，原来的64 86 64 

1160
00:59:04,066 --> 00:59:10,094
参数总是在一些特定的 

1161
00:59:07,091 --> 00:59:12,146
寄存器和那些要 记住 

1162
00:59:10,094 --> 00:59:14,189
今天是我 路 将是第一个 参数 

1163
00:59:13,046 --> 00:59:17,123
寄存器和RS我将是第二 

1164
00:59:15,089 --> 00:59:19,091
参数寄存器 可以有 多达六个 

1165
00:59:18,023 --> 00:59:23,152
这些和我们将进入更多的是 

1166
00:59:19,091 --> 00:59:25,150
后来所以这两个寄存器表示 

1167
00:59:23,359 --> 00:59:29,540
XP和YP的值的设定

1168
00:59:26,005 --> 00:59:31,046
当此之前，该功能前 

1169
00:59:29,054 --> 00:59:33,092
实际开始执行多数民众赞成通过设置

1170
00:59:31,091 --> 00:59:36,095
该部分代码调用此 

1171
00:59:33,092 --> 00:59:38,153
功能和那些会如此的指针 

1172
00:59:37,031 --> 00:59:42,090
它们是什么是它们包含地址 

1173
00:59:39,053 --> 00:59:44,106
当指定在存储器位置

1174
00:59:42,009 --> 00:59:46,062
然后将代码编译器内

1175
00:59:45,006 --> 00:59:50,064
只是想出了自己的想法如何 

1176
00:59:47,043 --> 00:59:53,079
用于临时不同的寄存器 

1177
00:59:50,064 --> 00:59:56,097
不论如何了所谓的数据 

1178
00:59:53,079 --> 00:59:58,167
寄存器分配算法， 它使用 

1179
00:59:56,097 --> 01:00:00,183
我们真的不关心我们只是想 

1180
00:59:59,067 --> 01:00:04,125
我们将要做的是弄清楚什么 

1181
01:00:01,083 --> 01:00:06,171
它在做什么，我们会看到一个寄存器 

1182
01:00:05,025 --> 01:00:12,113
是我们的斧头被用来 举行 

1183
01:00:07,071 --> 01:00:12,113
值T 0和我们的值T 1的DX 

1184
01:00:13,043 --> 01:00:20,055
现在让我们开始实际具体位置

1185
01:00:16,008 --> 01:00:23,010
这是非常详细的，但 我认为 

1186
01:00:20,055 --> 01:00:25,119
这一点很重要，你 明白那种 

1187
01:00:24,000 --> 01:00:29,016
你几乎可以模拟执行

1188
01:00:26,019 --> 01:00:31,019
通过自己的一些说明你

1189
01:00:29,016 --> 01:00:33,078
要真的要 知道这东西 

1190
01:00:31,019 --> 01:00:35,094
还等什么每一条指令是 

1191
01:00:33,078 --> 01:00:38,112
这样做，它是如何工作的，并真的 

1192
01:00:35,094 --> 01:00:40,131
该接线到你很好所以让我们 

1193
01:00:39,012 --> 01:00:44,097
弥补了一个例子， 我会告诉我们想象 

1194
01:00:41,031 --> 01:00:47,115
这是 用于两个地址

1195
01:00:44,097 --> 01:00:50,121
这两个指针在十六进制1 2 0和 

1196
01:00:48,015 --> 01:00:54,021
1 0 0顺便说那些不会 

1197
01:00:51,021 --> 01:00:55,089
他们来说太小了典型地址

1198
01:00:54,021 --> 01:00:59,034
一个数字，但它更容易 使用 

1199
01:00:55,089 --> 01:01:00,111
他们作为一个例证，让我们 

1200
01:00:59,034 --> 01:01:05,115
假设其中一人持有的价值 

1201
01:01:01,011 --> 01:01:10,013
1 2 3和其他4 5 6因此第一 

1202
01:01:06,015 --> 01:01:13,017
说明书上说使用RDI作为 地址 

1203
01:01:10,013 --> 01:01:17,052
从该内存位置 和存储复制

1204
01:01:13,017 --> 01:01:20,034
结果和寄存器 RX中以r di为 1 

1205
01:01:17,052 --> 01:01:22,077
2 0 我就从该地址读我会 

1206
01:01:20,034 --> 01:01:25,077
读出的值1 2 3，并将其存储和

1207
01:01:22,077 --> 01:01:28,080
寄存器R 斧 这些都是由 8 方式 

1208
01:01:25,077 --> 01:01:31,175
字节值，我有点刚

1209
01:01:29,007 --> 01:01:35,088
粉饰它的一部分 ，但将 q 

1210
01:01:32,075 --> 01:01:39,075
是指在英特尔术语是什么 

1211
01:01:35,088 --> 01:01:46,104
四字一个字，因为 它可以追溯到 

1212
01:01:39,075 --> 01:01:52,101
8086是16位的2个字节 长的字 

1213
01:01:47,004 --> 01:01:53,058
是32位，并且一个四字为64位 

1214
01:01:53,001 --> 01:01:56,055
那 

1215
01:01:53,058 --> 01:02:00,087
只是他们的术语和我们坚持 

1216
01:01:56,055 --> 01:02:02,142
与它没关系 ，这样一个指令有 

1217
01:02:00,087 --> 01:02:05,118
该效果的第二指令确实 

1218
01:02:03,042 --> 01:02:09,063
同样的事情，但使用RSI 持有 

1219
01:02:06,018 --> 01:02:12,063
一个零零 作为地址，直到它 

1220
01:02:09,063 --> 01:02:16,148
副本四张五十四五六成RDX 

1221
01:02:12,063 --> 01:02:19,146
然后将第三指令 是 

1222
01:02:17,048 --> 01:02:23,055
写回内存， 因此 源 

1223
01:02:20,046 --> 01:02:26,100
注册RDX 目的地有 

1224
01:02:24,018 --> 01:02:29,027
ř 二 的地址 是 一个两个零 

1225
01:02:27,000 --> 01:02:33,065
其存储，早在 记忆 和 

1226
01:02:30,008 --> 01:02:36,081
最后第四指令做的 

1227
01:02:33,065 --> 01:02:38,070
，所以你看到右边的另一部分

1228
01:02:36,081 --> 01:02:40,125
这四个指令读取 

1229
01:02:38,007 --> 01:02:42,084
内存到寄存器他们两个人写的 

1230
01:02:41,025 --> 01:02:48,027
从寄存器回内存，这就是 

1231
01:02:43,047 --> 01:02:50,136
整体功能，你 可以看到它 

1232
01:02:48,045 --> 01:02:56,067
这一举动指令时正在尽一切 

1233
01:02:51,036 --> 01:02:58,077
这里的工作，所以我们已经表明， 

1234
01:02:56,067 --> 01:03:01,098
例如只是表明这很简单 

1235
01:02:58,077 --> 01:03:04,095
多数民众赞成由指定的内存引用

1236
01:03:01,098 --> 01:03:05,124
括号和我提到了你 

1237
01:03:04,095 --> 01:03:08,169
可以做你把一个版本 

1238
01:03:06,024 --> 01:03:11,100
排量有 太多 而事实上 

1239
01:03:09,069 --> 01:03:12,144
还有一个更复杂的形式和 

1240
01:03:12,000 --> 01:03:16,059
我们将看到，这是有益的 

1241
01:03:13,044 --> 01:03:17,115
执行数组引用哪里

1242
01:03:16,059 --> 01:03:22,145
可以有实际上两个寄存器 

1243
01:03:18,015 --> 01:03:26,094
参与并且可以有位移 

1244
01:03:23,045 --> 01:03:28,053
这是 一个恒定的偏移和比例 

1245
01:03:26,094 --> 01:03:31,182
这将是因素一二四八

1246
01:03:29,025 --> 01:03:36,108
和它 的总体思路是走 

1247
01:03:32,082 --> 01:03:39,111
我们的寄存器，我指的是为R 

1248
01:03:37,008 --> 01:03:44,021
这是有名的索引寄存器子我

1249
01:03:40,011 --> 01:03:49,020
您可以通过比例因子 我将 它乘以 

1250
01:03:44,021 --> 01:03:52,074
您添加RB 寄存器 的值 RB和 

1251
01:03:50,001 --> 01:03:56,085
您还添加固定排水量

1252
01:03:52,074 --> 01:04:00,081
而这些有 RB指的是 我们的 基础 

1253
01:03:56,085 --> 01:04:01,143
映入眼帘的是指数，s是规模，事实证明 

1254
01:04:00,081 --> 01:04:03,123
走出这将是那种自然的 方式 

1255
01:04:02,043 --> 01:04:05,124
实施数组引用它 会 

1256
01:04:04,023 --> 01:04:06,106
使很多更有意义，当我们谈论 

1257
01:04:06,024 --> 01:04:09,073
阵列 

1258
01:04:07,006 --> 01:04:13,027
但基本上你能想到的是，如果 

1259
01:04:09,073 --> 01:04:14,161
这是一个数组索引 I必须 

1260
01:04:13,027 --> 01:04:18,121
通常由然而， 许多字节它的规模

1261
01:04:15,061 --> 01:04:21,073
我的数据类型是如此，如果它是一个完整的，以 

1262
01:04:19,021 --> 01:04:24,055
四缩放它 没有多久，我必须 

1263
01:04:21,073 --> 01:04:30,076
八缩放因此，这就是这些 

1264
01:04:24,055 --> 01:04:33,097
规模因素将进来，基本上 

1265
01:04:31,003 --> 01:04:38,020
在汇编代码的格式允许 

1266
01:04:33,097 --> 01:04:39,193
你消除一些 领域如果 

1267
01:04:38,002 --> 01:04:42,064
他们没有被使用 ，所以 你和我们 

1268
01:04:40,093 --> 01:04:43,168
已经看到单一括号 

1269
01:04:42,082 --> 01:04:48,106
排序的这种形式的简化版本 

1270
01:04:44,068 --> 01:04:52,072
所以 我们就做这一些例子 

1271
01:04:49,006 --> 01:04:56,032
地址计算，让我们想象 

1272
01:04:52,072 --> 01:04:59,079
该寄存器RDX保存文本˚F三 

1273
01:04:56,032 --> 01:05:06,034
零和RCX举行了两个零一 

1274
01:05:00,042 --> 01:05:08,116
所以，如果我不是做一次一个 

1275
01:05:06,034 --> 01:05:11,038
你可以看到每 一个这些我正在 RDX 

1276
01:05:09,016 --> 01:05:15,040
这为f与三个零加入8 

1277
01:05:11,074 --> 01:05:18,076
并且使公司的F 零点零八这里我 

1278
01:05:15,004 --> 01:05:22,006
相加寄存器RDX和RCX 

1279
01:05:18,076 --> 01:05:24,100
它给了我f 1的0 0我正在做的 

1280
01:05:22,006 --> 01:05:30,043
同样在这里除了我缩放 RCX由 

1281
01:05:25,000 --> 01:05:35,083
4，从而4次1 0 0是是4 0 0，我 

1282
01:05:30,097 --> 01:05:38,155
并补充说，以F和我在这里取RDX 

1283
01:05:35,083 --> 01:05:42,154
这为f 0 与 3个零，如果 我的两倍 

1284
01:05:39,055 --> 01:05:46,069
我得到1E与 3个零，如果你认为 

1285
01:05:43,054 --> 01:05:50,118
关于移一个F向左1你 

1286
01:05:46,069 --> 01:05:54,124
得到一个1，然后将它变为1 1 1 0

1287
01:05:51,018 --> 01:05:58,036
这是确定一个e和我 加入这个 

1288
01:05:55,024 --> 01:05:59,101
的8 0位移到它，因此点 

1289
01:05:58,036 --> 01:06:01,108
这是这一切的是算术

1290
01:06:00,001 --> 01:06:05,062
这一切都使用无论是在 

1291
01:06:02,008 --> 01:06:07,057
注册并有 如何 的一些规则 

1292
01:06:05,062 --> 01:06:09,088
你把这个 ，并得到一个地址 ， 

1293
01:06:07,057 --> 01:06:12,150
那么系统会将此用来读取或 

1294
01:06:09,088 --> 01:06:12,150
写一些内存位置 

1295
01:06:14,052 --> 01:06:20,651
好了，所以现在什么是 它的 最后一部分 

1296
01:06:17,043 --> 01:06:23,106
今天我会去通过一些 算法 

1297
01:06:21,119 --> 01:06:26,130
和的事情之一， 我们一定会 

1298
01:06:24,006 --> 01:06:28,080
来迷惑你 ，推动 你疯了， 

1299
01:06:26,013 --> 01:06:31,068
让你可以发送电子邮件 给员工 

1300
01:06:28,008 --> 01:06:34,050
为解释是所谓的指令 

1301
01:06:31,068 --> 01:06:37,146
加载有效地址和所述的原因是 

1302
01:06:35,022 --> 01:06:41,031
其生活的目的是从根本上做 

1303
01:06:38,046 --> 01:06:44,142
C 的符号操作 ，以计算 

1304
01:06:41,031 --> 01:06:48,075
基于一些地址随便你 

1305
01:06:45,042 --> 01:06:50,067
要从但计算一个地址

1306
01:06:48,075 --> 01:06:52,110
也被证明是一个非常方便的方法 

1307
01:06:50,067 --> 01:06:57,071
做算术和C编译器 

1308
01:06:53,001 --> 01:07:01,098
喜欢在特定的使用它， 

1309
01:06:57,071 --> 01:07:03,075
它的外观格式 ，它看起来像 

1310
01:07:02,007 --> 01:07:07,011
移动指令有 一个源 

1311
01:07:04,011 --> 01:07:10,044
一个目的地，但目标 必须 

1312
01:07:07,047 --> 01:07:14,136
是寄存器和源极将是一个 

1313
01:07:10,044 --> 01:07:16,128
这些内存引用，因此它看起来

1314
01:07:15,036 --> 01:07:19,080
就像一个移动指令，它看起来像 

1315
01:07:17,028 --> 01:07:21,042
你正在做一些地址计算 

1316
01:07:19,008 --> 01:07:23,043
那么你从 内存中 读取 和 

1317
01:07:21,042 --> 01:07:26,043
它存储到寄存器，但它是什么

1318
01:07:24,015 --> 01:07:30,015
实际上做的是它那个地址 

1319
01:07:26,052 --> 01:07:32,130
计算，然后它 实际上写 

1320
01:07:30,015 --> 01:07:35,096
该地址无法在存储值，但 

1321
01:07:33,003 --> 01:07:38,094
这得到了计算GOT的价值 

1322
01:07:35,096 --> 01:07:39,174
直接向这正是寄存器

1323
01:07:39,021 --> 01:07:42,114
你想在这里做记得

1324
01:07:40,074 --> 01:07:44,082
符号操作是给我 

1325
01:07:43,014 --> 01:07:50,106
一些地方的地址给我一个指针 

1326
01:07:45,054 --> 01:07:53,061
， 指定一些位置，所以对于 

1327
01:07:51,006 --> 01:07:57,015
例如， 这 是 在 C代码 相当典型 

1328
01:07:54,024 --> 01:08:02,118
如果通过12多次说这 X 会变成 

1329
01:07:57,096 --> 01:08:04,125
它为乐莲花和地址 

1330
01:08:03,018 --> 01:08:09,072
计算而这仅仅是一个聪明的 

1331
01:08:05,025 --> 01:08:13,394
一种计算 三倍我们的GI增加 

1332
01:08:09,072 --> 01:08:17,111
是二加二次数R迪这样三个 

1333
01:08:13,619 --> 01:08:25,240
次数R迪并将其存储在我们的斧头和 

1334
01:08:17,759 --> 01:08:27,190
然后萨尔Q表示由 两个和 左移 

1335
01:08:25,024 --> 01:08:29,062
所以你还记得由两个上移是 

1336
01:08:27,019 --> 01:08:32,035
像由 四个，第一 乘以 

1337
01:08:29,062 --> 01:08:34,156
值计算三次XI移 

1338
01:08:32,035 --> 01:08:40,060
由两个位置，我留了四个 

1339
01:08:35,056 --> 01:08:42,058
有十二倍X所以 这是一个非常 

1340
01:08:40,006 --> 01:08:44,053
特别 是le.a但你都看到它 

1341
01:08:42,076 --> 01:08:46,084
的地方 ，所以 你需要做好准备 

1342
01:08:45,007 --> 01:08:49,008
它 这些其他的看起来更像 

1343
01:08:47,056 --> 01:08:50,134
你所期待的算术 

1344
01:08:49,008 --> 01:08:54,091
说明 他们有 像添加 名称 

1345
01:08:51,034 --> 01:08:56,077
和减法和乘法 等等 

1346
01:08:54,091 --> 01:08:59,118
它们都具有 相同的一般 

1347
01:08:56,077 --> 01:09:01,084
他们有两个参数的格式和 

1348
01:09:00,018 --> 01:09:05,026
什么所谓的目的地是 

1349
01:09:02,047 --> 01:09:07,134
居然还源这是一个有点 

1350
01:09:05,026 --> 01:09:11,113
像在 C，如果你说X 加等于 ÿ 

1351
01:09:08,034 --> 01:09:14,089
它说需要 x 的值 加 

1352
01:09:12,013 --> 01:09:17,112
的Y值，然后将结果存储在 

1353
01:09:14,089 --> 01:09:19,183
X现在的目标就是这样 

1354
01:09:18,012 --> 01:09:23,017
这是奇怪的另一件事是， 

1355
01:09:20,083 --> 01:09:24,091
操作数是在从逆顺序

1356
01:09:23,017 --> 01:09:27,046
在你期望他们是这样 

1357
01:09:25,063 --> 01:09:28,069
源至上在目的地 

1358
01:09:27,046 --> 01:09:30,138
排在最后，这就是重要

1359
01:09:29,023 --> 01:09:31,038
记得 

1360
01:09:32,038 --> 01:09:36,102
和其他的事情，你会看到有

1361
01:09:34,009 --> 01:09:38,095
这里没有什么特别它是否是一个 

1362
01:09:37,002 --> 01:09:42,055
不同之处在于这是 一个算术移位 

1363
01:09:39,076 --> 01:09:43,120
这就是是否逻辑移位 

1364
01:09:42,055 --> 01:09:45,073
它赋予 你的无符号值 

1365
01:09:44,002 --> 01:09:48,004
因为你还记得位水平 

1366
01:09:45,073 --> 01:09:52,117
这 两个 指令 的行为 是 

1367
01:09:48,004 --> 01:09:55,021
同样的，然后有一系列 

1368
01:09:53,017 --> 01:09:58,024
即使用该指令是刚 

1369
01:09:55,057 --> 01:10:03,082
只有一个操作数递增递减一 

1370
01:09:58,087 --> 01:10:04,173
否定而不是不是不是就像 

1371
01:10:03,082 --> 01:10:09,097
波浪操作，而不是看到 

1372
01:10:05,073 --> 01:10:11,077
感叹号所以这些都是基本 

1373
01:10:09,097 --> 01:10:12,154
指令和再现在我们可以

1374
01:10:12,013 --> 01:10:15,028
其实看一些节目和 

1375
01:10:13,054 --> 01:10:18,061
了解他们， 这里有一个刚 

1376
01:10:15,028 --> 01:10:21,034
做了一堆算术垃圾

1377
01:10:18,061 --> 01:10:23,113
说明，并将其转换成 

1378
01:10:21,034 --> 01:10:26,107
下面的汇编代码，你会看到它的

1379
01:10:24,013 --> 01:10:31,051
使用此 指令LA 多次 

1380
01:10:27,007 --> 01:10:34,021
做加法各种形式和它

1381
01:10:31,051 --> 01:10:36,079
也有移并且它具有

1382
01:10:34,021 --> 01:10:38,035
乘法你在原来看到的

1383
01:10:36,079 --> 01:10:41,170
代码我只是添加 和 

1384
01:10:38,035 --> 01:10:44,059
乘我在这里有各种各样的 

1385
01:10:42,007 --> 01:10:46,042
说明我只有一个 乘法 

1386
01:10:44,059 --> 01:10:48,106
在这里，而我有两个有这样 

1387
01:10:47,005 --> 01:10:51,040
编译器，而不是扰乱的事情 

1388
01:10:49,006 --> 01:10:54,049
周围试图找到巧妙的方法来 

1389
01:10:51,004 --> 01:10:57,097
实现你问使用 

1390
01:10:54,049 --> 01:11:01,077
更简单更便宜 

1391
01:10:58,033 --> 01:11:01,077
耗时指示 

1392
01:11:02,042 --> 01:11:10,067
如果你就想通过这个 代码 

1393
01:11:05,054 --> 01:11:12,098
小心你会 发现， 这 

1394
01:11:10,067 --> 01:11:15,100
这里指令对应于此 

1395
01:11:12,098 --> 01:11:17,737
T1的计算是将两个值 

1396
01:11:16,000 --> 01:11:22,076
并给它它把新名称

1397
01:11:18,619 --> 01:11:28,648
我们的斧头同样这一项加V至 

1398
01:11:22,076 --> 01:11:30,158
t1和我们在一个存储回X的 

1399
01:11:28,909 --> 01:11:34,130
对于x框显示不出来 直接在这里 

1400
01:11:31,058 --> 01:11:36,092
事实证明，它的作用是它跳到 

1401
01:11:34,013 --> 01:11:41,051
正确的 IT 前往 这里繁衍Y上 

1402
01:11:36,092 --> 01:11:45,140
48它通过它第一计算3Y等 

1403
01:11:41,051 --> 01:11:49,030
我们以前看到和计算转移 

1404
01:11:46,004 --> 01:11:52,843
留下由4，因为3次 16 48是 

1405
01:11:49,489 --> 01:11:55,585
然后4这里罪x 加4 

1406
01:11:53,239 --> 01:11:58,570
这里实际显示了它只是使用了 

1407
01:11:56,449 --> 01:12:04,400
这种计算位移场

1408
01:11:58,057 --> 01:12:05,626
添加4到一些其他的值等 

1409
01:12:04,004 --> 01:12:07,049
这个标记，那么 这些言论表明 

1410
01:12:06,139 --> 01:12:11,143
如何将这些对应的程序和 

1411
01:12:07,085 --> 01:12:11,183
这些寄存器显示它如此重要 

1412
01:12:11,179 --> 01:12:14,200
事情得到 从这里 ， 你 会想 

1413
01:12:12,083 --> 01:12:17,150
其实回去通过此，使 

1414
01:12:14,389 --> 01:12:22,250
一定要相信，评论是 

1415
01:12:18,005 --> 01:12:23,066
正确的，但它是非常重要的，你 

1416
01:12:22,025 --> 01:12:25,031
要弄清楚这个 LA指令 

1417
01:12:24,011 --> 01:12:26,063
否则你只是要

1418
01:12:25,031 --> 01:12:28,082
绝望的困惑

1419
01:12:26,063 --> 01:12:30,106
而且同样重要的是理解

1420
01:12:28,082 --> 01:12:32,171
该获取 生成的代码

1421
01:12:31,006 --> 01:12:36,008
将正确地贯彻执行贵驷 

1422
01:12:33,071 --> 01:12:37,126
功能但它可能不完全 

1423
01:12:36,026 --> 01:12:40,945
复制处于较低水平

1424
01:12:38,026 --> 01:12:45,175
操作的确切顺序你 

1425
01:12:41,179 --> 01:12:47,233
在较高的水平， 这样 将会在指定的 

1426
01:12:45,409 --> 01:12:50,000
只是总结，那么你已经 

1427
01:12:47,719 --> 01:12:52,723
得到的一瞥，然后的这是什么 

1428
01:12:50,000 --> 01:12:55,013
机器编程的非常奇怪的世界 

1429
01:12:53,119 --> 01:12:59,360
以及如何不同它是从C代码 

1430
01:12:55,013 --> 01:13:02,096
是的，还是你也已经看到了

1431
01:12:59,036 --> 01:13:06,835
这是x86的怪异就像我 说的 

1432
01:13:02,096 --> 01:13:09,167
英语这不是一个拉丁这不是很好 

1433
01:13:07,159 --> 01:13:14,150
设计，但你刚处理 

1434
01:13:10,067 --> 01:13:16,836
与 让 你的开始 

1435
01:13:14,015 --> 01:13:19,334
机器语言非常感谢 

1436
01:13:17,439 --> 01:13:19,442
一世 

