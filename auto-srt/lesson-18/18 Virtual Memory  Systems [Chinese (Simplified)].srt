1
00:00:00,003 --> 00:00:07,011
所以今天我们要继续我们的 

2
00:00:02,085 --> 00:00:09,584
通过查看虚拟内存的研究

3
00:00:07,083 --> 00:00:13,149
如何如何的地址 详细 

4
00:00:10,349 --> 00:00:16,740
翻译工作，然后和再 

5
00:00:14,049 --> 00:00:18,428
我们将学习如何虚拟内存 

6
00:00:16,074 --> 00:00:21,623
适用于Linux 和x86的实际系统

7
00:00:18,869 --> 00:00:24,330
64个系统和回报因为 这是 

8
00:00:22,289 --> 00:00:26,310
那你就真的能现在 

9
00:00:24,033 --> 00:00:29,732
了解如何fork和exec真正发挥作用

10
00:00:26,031 --> 00:00:31,080
以及如何如何重要的虚拟内存 

11
00:00:30,029 --> 00:00:38,820
系统是由于这些种类的 

12
00:00:31,008 --> 00:00:40,089
该系统的整个工作让我们 

13
00:00:38,082 --> 00:00:43,751
看看 我们 如何的一些具体的例子 

14
00:00:41,061 --> 00:00:49,089
做地址转换和这里的那 

15
00:00:44,489 --> 00:00:52,620
参考幻灯片让我们假设我们有

16
00:00:49,089 --> 00:00:54,668
这个 简单的存储系统 十四个 

17
00:00:52,062 --> 00:00:58,118
位虚拟地址为12位 

18
00:00:55,469 --> 00:01:04,890
的64个字节的物理地址页的大小

19
00:00:59,018 --> 00:01:08,027
所以在我们的我们，所以我们需要 六个DPL 

20
00:01:04,089 --> 00:01:10,113
位偏移的比特，然后将余下 

21
00:01:08,189 --> 00:01:14,130
位的虚拟页 序号和 

22
00:01:11,013 --> 00:01:17,100
同样，对于我们的物理地址，我们 

23
00:01:14,013 --> 00:01:19,077
需要我们需要六偏移位 ， 

24
00:01:18,000 --> 00:01:24,018
其余位形成有形的网页 

25
00:01:19,077 --> 00:01:28,131
数还好现在的TLB在这 

26
00:01:24,018 --> 00:01:32,527
在这个系统中有16个 入口，它的 

27
00:01:29,031 --> 00:01:36,063
4路集联，以便记住

28
00:01:32,689 --> 00:01:37,950
在TLB缓存 好吗 页表项 

29
00:01:36,063 --> 00:01:39,096
而那些页表项

30
00:01:37,095 --> 00:01:43,874
通过 虚拟页唯一标识 

31
00:01:39,096 --> 00:01:49,115
号码，以便我们只需要使用 VPN 来 

32
00:01:44,729 --> 00:01:53,790
访问条目中的TLB 我们 

33
00:01:49,979 --> 00:01:58,140
有16项4路集联等等 

34
00:01:53,079 --> 00:02:01,164
共有四套 ， 所以我们的

35
00:01:58,014 --> 00:02:05,085
使用低阶两个低位比特 

36
00:02:02,064 --> 00:02:07,122
和VPN作为指标，然后将 

37
00:02:05,085 --> 00:02:09,117
其余位就像任何其他的缓存 

38
00:02:08,022 --> 00:02:12,040
或标记位 

39
00:02:10,017 --> 00:02:14,676
好吧，然后这我们已经初始化 

40
00:02:12,004 --> 00:02:18,713
这与一些一些不同的值现在

41
00:02:14,829 --> 00:02:24,400
注意到的实际内容 

42
00:02:19,109 --> 00:02:26,175
在TLB在这棵树在这个区域 

43
00:02:24,004 --> 00:02:28,683
这里的权利， 因此这一套 ，这只是 

44
00:02:26,769 --> 00:02:31,836
帮忙鉴定一下设置有有 

45
00:02:29,079 --> 00:02:35,200
没有条目 称为设定值为零 

46
00:02:32,439 --> 00:02:38,486
正确的，我们 只是刚刚 我们只是 

47
00:02:35,002 --> 00:02:41,571
鉴定为 作为耶 

48
00:02:38,909 --> 00:02:43,956
只是- we're 只是明确列出 

49
00:02:41,769 --> 00:02:48,700
指数在如此我们每一个条目 

50
00:02:44,379 --> 00:02:51,970
TLB由这个标签的，如果当 

51
00:02:48,007 --> 00:02:58,018
TLB项是有效的物理页

52
00:02:51,097 --> 00:03:03,118
还好现在数量我们还需要一个页面 

53
00:02:58,081 --> 00:03:05,170
表，所以我们需要我们假定我们 

54
00:03:04,018 --> 00:03:09,076
在此页面表 ，我们只是 

55
00:03:06,007 --> 00:03:11,065
示出第一16 项和 

56
00:03:09,076 --> 00:03:15,112
每个页表项包括的

57
00:03:12,028 --> 00:03:18,987
物理页面数和有效的 做到了 

58
00:03:16,012 --> 00:03:23,211
有效位上 ，然后再指示 

59
00:03:19,239 --> 00:03:25,322
该页面是 在 内存 中 ，与 

60
00:03:23,319 --> 00:03:28,386
PPM字段给出物理页号 

61
00:03:26,069 --> 00:03:31,101
没关系， 再有没有实际 

62
00:03:28,989 --> 00:03:37,038
这VTN列 实际上 并不 存在 

63
00:03:31,389 --> 00:03:40,464
在页表没关系，现在我们有一个 

64
00:03:37,479 --> 00:03:43,527
简单简单直接的机甲直接映射 

65
00:03:41,139 --> 00:03:49,230
缓存它与物理寻址 

66
00:03:43,959 --> 00:03:53,590
地址等，它包含16套

67
00:03:50,049 --> 00:04:00,430
每一个热线，我们将承担 

68
00:03:53,059 --> 00:04:01,488
四字节的块大小，所以我们有那么我们 

69
00:04:00,043 --> 00:04:07,632
有四个 字节的块大小，所以我们需要 

70
00:04:02,019 --> 00:04:11,500
以抵消比特 缓存16套我们 

71
00:04:08,019 --> 00:04:15,150
意味着我们需要缓存索引位和 

72
00:04:11,005 --> 00:04:14,070
然后将剩余的比特是 

73
00:04:15,016 --> 00:04:20,065
对于标签现在只是它只是一个 

74
00:04:18,031 --> 00:04:24,070
那我 定义这个 途中发生意外 

75
00:04:20,065 --> 00:04:25,162
该系统的缓存标签 

76
00:04:24,007 --> 00:04:28,042
完全一样的物理页面 

77
00:04:26,062 --> 00:04:31,090
号码，以便这这这仅仅是 

78
00:04:29,005 --> 00:04:37,006
巧合，并没有不 

79
00:04:31,009 --> 00:04:40,038
现在没事了与一定是这样 

80
00:04:37,015 --> 00:04:44,019
AV视听系统 的魔法切换 

81
00:04:41,019 --> 00:04:44,019
好

82
00:04:45,009 --> 00:04:50,065
好了，让我们要去的看

83
00:04:47,023 --> 00:04:53,116
这个使用这个这几个例子 

84
00:04:50,065 --> 00:04:56,119
好一点的系统现在让我们假设 

85
00:04:54,016 --> 00:04:59,050
CPU执行指令 

86
00:04:57,019 --> 00:05:04,027
产生这是一个有效地址 

87
00:04:59,005 --> 00:05:05,103
的0的虚拟地址X 0 3天4，然后 

88
00:05:04,027 --> 00:05:10,036
它 传递的是对MMU 

89
00:05:06,048 --> 00:05:12,073
这是需要 弄清楚的 

90
00:05:10,036 --> 00:05:15,094
对应的物理地址，然后 

91
00:05:12,073 --> 00:05:19,156
它需要 从缓存中 读取数据， 或者 

92
00:05:15,094 --> 00:05:24,121
内存好了，什么是 第一件事情 ，我们 

93
00:05:20,056 --> 00:05:28,060
做的是我们刚写出来的位 

94
00:05:25,021 --> 00:05:31,063
这个虚拟地址好，然后我们 

95
00:05:28,096 --> 00:05:34,189
识别不同领域的好，所以我们 

96
00:05:31,063 --> 00:05:37,108
有偏移虚拟页偏移位

97
00:05:35,089 --> 00:05:40,143
然后的剩余位 

98
00:05:38,008 --> 00:05:51,015
虚拟页码 好吗 

99
00:05:41,043 --> 00:05:57,115
在这种情况下 ，偏移量是2 4 0 X 2为 

100
00:05:51,015 --> 00:06:03,069
该VPN是F，然后我们的 

101
00:05:58,015 --> 00:06:07,033
2 TLB余位，而这1 1 SO 3和 

102
00:06:03,069 --> 00:06:10,126
那么我们有标记位，而这 也 

103
00:06:07,033 --> 00:06:13,129
等于3这样的第一件事是 ， 

104
00:06:11,026 --> 00:06:17,074
MMU不给这个 地址是 检查 

105
00:06:14,029 --> 00:06:19,096
在TLB上希望页表 

106
00:06:17,074 --> 00:06:24,082
它需要进入的中缓存 

107
00:06:19,096 --> 00:06:28,164
在TLB如此这般提取指数

108
00:06:24,082 --> 00:06:28,164
位3和 给我们 

109
00:06:30,058 --> 00:06:36,154
所以现在是说，如果这个页面 

110
00:06:35,008 --> 00:06:40,057
表项是它要的TLB 

111
00:06:37,054 --> 00:06:45,115
在一套三好吧，所以我们去设定 

112
00:06:41,029 --> 00:06:51,030
三，现在我们正在寻找一个条目 

113
00:06:46,015 --> 00:06:54,067
在设定了三个有带 三个 标签 

114
00:06:51,039 --> 00:06:57,061
好了，我们去跨越这一个有 

115
00:06:54,067 --> 00:06:59,074
在这所四个项目的一个条目 

116
00:06:57,061 --> 00:07:00,106
与这不是编的七个标签和 

117
00:06:59,074 --> 00:07:03,100
加上有效位为零 

118
00:07:01,006 --> 00:07:06,088
哦，这里有一个在这里的 一个标签 的 项 

119
00:07:04,000 --> 00:07:08,041
三， 一如此的有效日期 

120
00:07:06,088 --> 00:07:12,106
我们的运气，我们运气好页表

121
00:07:08,041 --> 00:07:16,060
在TLB等等的TLB项

122
00:07:13,006 --> 00:07:20,011
返回值 的物理页面 

123
00:07:16,006 --> 00:07:21,100
这是零 ð回 MMU数

124
00:07:20,011 --> 00:07:25,057
现在可以构造物理

125
00:07:22,054 --> 00:07:28,150
地址，以便构建 物理 

126
00:07:25,057 --> 00:07:33,091
通过复制直接复制地址PA

127
00:07:29,005 --> 00:07:35,050
在VPO位的PPO位 好 权 

128
00:07:33,091 --> 00:07:36,180
正如我们 所讨论的是最后一次了 

129
00:07:35,095 --> 00:07:40,120
虚拟页偏移总是相同的

130
00:07:37,008 --> 00:07:41,017
物理页面 ， 因为 偏移 

131
00:07:41,002 --> 00:07:44,008
块大小 是在 虚拟地址 

132
00:07:42,007 --> 00:07:47,068
在物理地址空间 空间 

133
00:07:44,026 --> 00:07:51,043
同样大小没关系所以在这里，所以我们得到了 

134
00:07:48,031 --> 00:07:53,113
低阶 PPL位 ，然后在 物理 

135
00:07:51,043 --> 00:07:56,047
里面传来页码其中来自

136
00:07:54,013 --> 00:08:01,084
该公司 在TLB缓存 PT e 是 

137
00:07:56,083 --> 00:08:02,158
零XD并且使得形成PP n位 

138
00:08:01,084 --> 00:08:05,125
物理地址，因此他们削减 

139
00:08:03,058 --> 00:08:09,067
这些现在这些构成了我们我们

140
00:08:06,025 --> 00:08:11,053
物理地址所以现在的下一步 

141
00:08:09,067 --> 00:08:13,129
一旦我们的物理地址是 

142
00:08:11,053 --> 00:08:16,066
看发送到缓存，并 要求 

143
00:08:14,029 --> 00:08:19,075
缓存在返回值 

144
00:08:16,066 --> 00:08:22,087
解决在这种情况下，我们 只是 

145
00:08:19,075 --> 00:08:23,157
做一个字节访问好了，所以我们 

146
00:08:22,087 --> 00:08:27,132
要求高速缓存返回字节 

147
00:08:24,057 --> 00:08:32,146
这是在这个在这个物理地址

148
00:08:28,032 --> 00:08:37,108
好了，当然它缓存第一 

149
00:08:33,046 --> 00:08:39,100
检查看到的是，如果 字节 这是 

150
00:08:38,008 --> 00:08:43,037
请求中包含的一些块 

151
00:08:40,000 --> 00:08:46,004
缓存好了，所以我们 

152
00:08:43,037 --> 00:08:51,094
所以需要在它提取现金 

153
00:08:46,004 --> 00:08:55,016
索引比特是0 0 1 0 1 5，以便和 

154
00:08:51,094 --> 00:08:55,175
因此，如果这如果这个字节是真实存在 

155
00:08:55,016 --> 00:09:01,067
要求是它要缓存 

156
00:08:56,075 --> 00:09:06,113
在5集，所以我们去设定5，然后 

157
00:09:01,067 --> 00:09:09,119
我们正在寻找0 XD和LO的标签

158
00:09:07,013 --> 00:09:13,025
谁知这里的，我们有一个匹配的标签 

159
00:09:10,019 --> 00:09:15,020
而关于匹配有效位那么好

160
00:09:13,025 --> 00:09:19,043
行，我们是，我们要求是 

161
00:09:15,002 --> 00:09:24,005
在缓存和单词，单词 

162
00:09:19,043 --> 00:09:30,101
我们要求在偏移 2好吗 

163
00:09:24,005 --> 00:09:36,040
所以我们去所以这个偏移 1这是 

164
00:09:31,001 --> 00:09:36,085
偏移两个OH没有对不起 

165
00:09:49,035 --> 00:09:58,129
看看哦，对不起，这是它我 

166
00:09:57,082 --> 00:10:00,124
感到困惑的进入这些都是 

167
00:09:59,029 --> 00:10:06,064
索引比特，从而偏移量实际上是

168
00:10:01,024 --> 00:10:11,029
这里Zero的的 业务B，这 是我们的 

169
00:10:06,064 --> 00:10:13,069
物理地址好吗和B以及 

170
00:10:11,029 --> 00:10:16,072
抵消该 值 是零 ，因此我们 

171
00:10:13,069 --> 00:10:18,118
要求在第五盘我们 

172
00:10:16,072 --> 00:10:23,074
要求该字节偏移量为零

173
00:10:19,018 --> 00:10:25,101
这就是0 X 3 6 6所以我们必须一击 

174
00:10:23,074 --> 00:10:29,146
现金返回此字节 回 

175
00:10:26,001 --> 00:10:33,082
MMU这其中传递回了

176
00:10:30,046 --> 00:10:38,080
处理器将其存储在寄存器

177
00:10:33,082 --> 00:10:45,091
最有可能 确定，所以让我们来看看 另一个 

178
00:10:38,008 --> 00:10:46,036
例如 ，我在这里记录了这些用于 

179
00:10:45,091 --> 00:10:48,166
你如果想回去看看 

180
00:10:47,008 --> 00:10:52,102
他们让我们来 看看另一个例子 

181
00:10:49,066 --> 00:10:57,067
这将所以这个时候CPU发送 

182
00:10:53,002 --> 00:11:02,041
的0 X 0 0 0虚拟地址到 

183
00:10:57,067 --> 00:11:08,152
MMU 可以的，所以如果我们，如果我们 写出来的 

184
00:11:02,041 --> 00:11:11,050
对于虚拟 地址，我们 的位 

185
00:11:09,052 --> 00:11:13,150
让我们得到我们得到这样的结果，然后 

186
00:11:12,031 --> 00:11:17,128
我们已经标出关闭虚拟 页偏移 

187
00:11:14,005 --> 00:11:20,071
虚拟页码和TLB 

188
00:11:18,028 --> 00:11:23,046
虚拟页的索引低位比特

189
00:11:21,016 --> 00:11:28,048
数量和，然后为标签 

190
00:11:23,046 --> 00:11:30,049
TLBŤ从而步骤1相同，检查之前 

191
00:11:28,048 --> 00:11:35,076
与TLB让我们看看该网页

192
00:11:30,076 --> 00:11:35,076
在在在TLBŤ表条目 

193
00:11:35,085 --> 00:11:42,144
与TLB所以我们要求在这种情况下， 

194
00:11:44,509 --> 00:11:51,170
如果此集合这一点，如果此页表

195
00:11:47,043 --> 00:11:56,132
项中的TLB 它会在 

196
00:11:51,017 --> 00:12:02,486
这将是在零度以下 ， 这 将有 

197
00:11:56,519 --> 00:12:05,790
零的标签，所以我们看我们期待和 

198
00:12:02,639 --> 00:12:08,696
设置为零 的零 标签 现在这 

199
00:12:05,079 --> 00:12:10,085
不符 哦3年哦9 

200
00:12:09,209 --> 00:12:14,100
不匹配

201
00:12:10,085 --> 00:12:15,134
零轮零散的比赛，但有效位 0 

202
00:12:14,001 --> 00:12:19,910
所以这不仅是一个有效的条目 

203
00:12:15,899 --> 00:12:22,740
巧合的是， 这是啤酒桶是 0，所以 

204
00:12:20,009 --> 00:12:26,042
这是一个TLB错过 好了，这是一个 

205
00:12:22,074 --> 00:12:28,160
无赖，因为现在我们必须去关闭 

206
00:12:26,339 --> 00:12:32,393
芯片并进行昂贵的内存访问

207
00:12:29,006 --> 00:12:37,295
刚读从页表项 

208
00:12:32,879 --> 00:12:41,890
在页表所以现在我们必须 这样 

209
00:12:37,889 --> 00:12:44,950
现在我们要检查与页表 

210
00:12:41,089 --> 00:12:44,095
[音乐]

211
00:12:48,089 --> 00:12:54,097
我们正在寻找一个虚拟页 

212
00:12:55,054 --> 00:13:06,103
虚拟页零，所以我们选中的条目 

213
00:13:03,059 --> 00:13:10,103
在零虚拟页面， 看看是否页 

214
00:13:07,003 --> 00:13:14,060
除了页面是内存如果是这样，如果它 

215
00:13:11,003 --> 00:13:18,005
具有有效的是 它在内存中 ，因为 

216
00:13:14,006 --> 00:13:20,042
有效的那一个所以这个，所以我们有 

217
00:13:18,023 --> 00:13:23,048
有效的物理页号，以便在

218
00:13:20,096 --> 00:13:28,171
内存返回页表项或

219
00:13:23,048 --> 00:13:34,133
在PPN回的回 MNU 

220
00:13:29,071 --> 00:13:37,109
其是它是一个0 X 0 X 2 8 和现在 

221
00:13:35,033 --> 00:13:39,122
您可以使用 物理的毫米 

222
00:13:38,009 --> 00:13:43,010
页码构建物理

223
00:13:40,022 --> 00:13:46,034
址，才复制虚拟 

224
00:13:43,001 --> 00:13:50,009
页面直接偏移到物理 

225
00:13:46,034 --> 00:13:55,090
页面偏移量，然后我们 PT n是是 8 

226
00:13:50,018 --> 00:13:58,112
所以，我们有1 0 其1 0 0 0 8 

227
00:13:55,009 --> 00:14:01,103
所以现在这些串接形成

228
00:13:59,012 --> 00:14:04,043
物理 地址 和现在的MMU有 

229
00:14:02,084 --> 00:14:08,105
物理地址，它可以移交给 

230
00:14:04,043 --> 00:14:11,102
高速缓存和请求缓存 

231
00:14:09,005 --> 00:14:17,036
在在那个返回值

232
00:14:12,002 --> 00:14:21,095
物理地址所以现在缓存得到 

233
00:14:17,036 --> 00:14:24,065
物理地址，并提取 

234
00:14:21,095 --> 00:14:31,118
缓存索引位，在这种情况下 

235
00:14:24,065 --> 00:14:32,150
是是 8 K 0 X 8，所以如果此块如果 

236
00:14:32,018 --> 00:14:35,084
我们正在寻找的字 

237
00:14:33,005 --> 00:14:36,077
包含在高速缓存对不起，如果 

238
00:14:35,084 --> 00:14:40,145
我们正在寻找字节包含 

239
00:14:37,022 --> 00:14:45,110
在缓存中它会在8集 ， 所以 我们去 

240
00:14:41,045 --> 00:14:49,069
所以缓存去设置 8，它看起来 

241
00:14:46,001 --> 00:14:52,067
一个匹配的标签，其在这种情况下是 

242
00:14:49,069 --> 00:14:55,178
事实证明，这28只喜欢 

243
00:14:52,076 --> 00:14:59,565
PPN只是巧合 

244
00:14:55,799 --> 00:15:02,814
所以在八根，我们有，如果我们一个标签 

245
00:15:00,249 --> 00:15:06,040
有块有24标记的条目

246
00:15:02,949 --> 00:15:07,035
所以有一些是好的，所以这是一个 

247
00:15:06,004 --> 00:15:10,113
高速缓存未命中现在缓存有 

248
00:15:07,809 --> 00:15:19,905
请求传递物理地址 

249
00:15:10,149 --> 00:15:21,234
该内存是获取该咬伤 怎么办 

250
00:15:20,769 --> 00:15:22,842
你看到的问题是如何是你如何 

251
00:15:21,999 --> 00:15:25,480
知道你是怎么确定的大小 

252
00:15:23,499 --> 00:15:33,500
虚拟页偏移和是的，它是 

253
00:15:25,048 --> 00:15:33,077
根据页面大小 是64个 字节 

254
00:15:34,019 --> 00:15:41,910
所以64个字节，因此这就是为什么我们有660 TL

255
00:15:39,016 --> 00:15:41,091
和PPO位 

256
00:15:43,061 --> 00:15:47,123
好了，所以是清楚的 向大家 

257
00:15:46,012 --> 00:15:52,030
这就是那种东西，有时 

258
00:15:48,023 --> 00:15:52,030
轮番上涨的考试 ，你只知道 

259
00:15:55,074 --> 00:15:59,142
是的存在之间的关系 

260
00:15:58,062 --> 00:16:04,080
的物理页号和长度 

261
00:16:00,042 --> 00:16:06,042
返现这样 好这样的 问题 

262
00:16:04,008 --> 00:16:07,044
是在那里的任何关系 

263
00:16:06,042 --> 00:16:10,047
物理页号的长度和 

264
00:16:08,016 --> 00:16:11,064
现金标签 ，这只是一个完整的 

265
00:16:10,092 --> 00:16:13,185
巧合

266
00:16:11,064 --> 00:16:16,113
还好只是 它刚好是 

267
00:16:14,085 --> 00:16:17,169
只是一个巧合，他们通常它们 

268
00:16:17,013 --> 00:16:32,079
不必 排队像 

269
00:16:18,069 --> 00:16:33,117
任何其他问题，是的是的 所以 

270
00:16:32,079 --> 00:16:35,145
例如，如果我想在有更多的套我的 

271
00:16:34,017 --> 00:16:39,024
缓存然后我需要更多的位，他们 

272
00:16:36,045 --> 00:16:43,053
溢出的权利，如果这是迈克是 

273
00:16:39,087 --> 00:16:47,093
只是一个巧合，因为我有六个PPL 

274
00:16:43,053 --> 00:16:50,109
位和正好四的块大小 和 

275
00:16:47,093 --> 00:16:52,152
四套 所以如果我，如果我的 缓存有更多的 

276
00:16:51,009 --> 00:16:55,047
设置一个缓存索引，将会波及 

277
00:16:53,052 --> 00:17:00,074
然后缓存标签不匹配 

278
00:16:55,047 --> 00:17:02,138
与物理页号好了，所以它 

279
00:17:00,074 --> 00:17:05,112
必须 像在这种场合 下 

280
00:17:03,038 --> 00:17:08,040
这是这是正确的它是类似 

281
00:17:06,012 --> 00:17:09,731
之前，它只是碰巧问题

282
00:17:08,058 --> 00:17:12,153
是巧合 ，也许 我应该有 

283
00:17:09,839 --> 00:17:15,901
选择了不同的 例子，但他们 

284
00:17:13,053 --> 00:17:15,982
完全 独立 

285
00:17:18,025 --> 00:17:24,052
其他人好没关系 

286
00:17:27,038 --> 00:17:33,074
好了，所以现在我想我想跟 

287
00:17:31,429 --> 00:17:35,510
你如何如何这些东西全部作品 

288
00:17:33,074 --> 00:17:38,135
在这种情况下 ，真正的系统它是一个 

289
00:17:35,051 --> 00:17:41,138
从英特尔核i7 系统到下一个 86 64 

290
00:17:39,035 --> 00:17:46,060
它的高端台式机的家庭

291
00:17:42,038 --> 00:17:51,062
系统x86的64 有类似于 

292
00:17:46,006 --> 00:17:53,047
您用来做鲨鱼机

293
00:17:51,062 --> 00:17:53,101
您的实验室 

294
00:17:55,003 --> 00:18:02,050
所以这里的，这里的 方式存储 

295
00:17:59,011 --> 00:18:05,026
系统会在酷睿i7 的 

296
00:18:02,077 --> 00:18:08,155
处理器封装是芯片 好了，所以 

297
00:18:05,026 --> 00:18:13,051
这就像一个单一的，然后 再 

298
00:18:09,055 --> 00:18:16,153
有四个内核中的每个这个包 

299
00:18:13,051 --> 00:18:20,097
核心是一个单独的作为一个单独的CPU和 

300
00:18:17,053 --> 00:18:23,074
金丝雀单独执行指令

301
00:18:20,097 --> 00:18:26,176
好了，所以每个每个核心各自 的这些 

302
00:18:23,074 --> 00:18:29,139
核心具有寄存器文件， 然后 

303
00:18:27,076 --> 00:18:34,099
一些硬件状态的指示

304
00:18:30,039 --> 00:18:38,074
它有两个L1高速缓存有一个数据 

305
00:18:34,099 --> 00:18:42,138
缓存称为其用于对D高速缓存 

306
00:18:38,074 --> 00:18:44,158
来获取数据和保持数据 

307
00:18:43,038 --> 00:18:47,094
从内存中取出，然后有一个

308
00:18:45,058 --> 00:18:50,062
指令缓存称为AI缓存 

309
00:18:47,094 --> 00:18:55,108
其中认为从的说明

310
00:18:50,062 --> 00:18:59,076
码的代码区域 ，从而数据 该 D 

311
00:18:56,008 --> 00:19:03,042
缓存有数据只有AI缓存有 

312
00:18:59,076 --> 00:19:05,089
说明仅存在每个32千个字节 

313
00:19:03,042 --> 00:19:07,141
8路组相联，使他们感到 非常 

314
00:19:05,089 --> 00:19:13,111
小，但 它们有相当高的 

315
00:19:08,041 --> 00:19:16,063
关联再下 一级 

316
00:19:14,011 --> 00:19:18,040
层次是所谓的L2 

317
00:19:16,063 --> 00:19:23,110
统一高速缓存，因为它可以同时按住 

318
00:19:18,004 --> 00:19:26,071
指令和数据好 这是一个有点 

319
00:19:24,001 --> 00:19:29,008
大一点的256千个字节，也 

320
00:19:27,007 --> 00:19:32,026
八路关联 等两个 

321
00:19:29,017 --> 00:19:36,094
这些缓存是在对核心 

322
00:19:32,026 --> 00:19:39,060
本身确定，然后外并进入 

323
00:19:36,094 --> 00:19:41,173
这是由所有 内核 共享的L3高速缓存

324
00:19:39,006 --> 00:19:45,013
其是8兆字节和16 白色 

325
00:19:42,073 --> 00:19:47,155
联想确定这样的访问是因为 

326
00:19:46,003 --> 00:19:51,016
L1高速缓存是最靠近处理器 

327
00:19:48,055 --> 00:19:57,121
这是，这是快这样四 

328
00:19:51,043 --> 00:20:00,109
周期来访问L1 L2是更大和一个 

329
00:19:58,021 --> 00:20:04,108
稍远一点，使其与它有关 

330
00:20:01,009 --> 00:20:07,018
10 10 个周期访问此 和13是 

331
00:20:05,008 --> 00:20:08,011
关闭核心权利，因此必须走了过来 

332
00:20:07,018 --> 00:20:12,100
一个 

333
00:20:08,011 --> 00:20:16,012
连接 部分连接关关 

334
00:20:13,000 --> 00:20:20,061
芯片 进入到这个这个 缓存 和 

335
00:20:16,021 --> 00:20:28,039
因此，访问时间为这个 L3缓存 

336
00:20:20,061 --> 00:20:32,062
它现在的像50 30〜50次

337
00:20:28,039 --> 00:20:34,102
MMU 有它也有 顶级域名 的层次结构 

338
00:20:32,062 --> 00:20:37,111
而我与学生交谈后， 

339
00:20:35,002 --> 00:20:42,010
类中的 最后演讲就像 我误 

340
00:20:38,011 --> 00:20:46,065
说，该系统没有一个 

341
00:20:42,001 --> 00:20:51,037
TLB中的层次结构，但它确实有一个 

342
00:20:46,065 --> 00:20:56,119
小的L1数据TLB 和一个和一个单独的 

343
00:20:51,046 --> 00:20:58,123
指令TLB所以这具有16 64 

344
00:20:57,019 --> 00:21:02,038
总条目和它的4路集 

345
00:20:59,023 --> 00:21:07,078
联想这么多少套在 那里 

346
00:21:02,038 --> 00:21:10,104
然后在L1这多少套 

347
00:21:07,078 --> 00:21:10,104
数据TLB 

348
00:21:13,047 --> 00:21:20,073
16 右好， 然后将 

349
00:21:18,054 --> 00:21:23,115
指令TLB有多个条目

350
00:21:20,073 --> 00:21:25,116
有趣所以它是一个 

351
00:21:24,015 --> 00:21:28,056
有趣的决定我 猜我猜 

352
00:21:26,016 --> 00:21:30,030
思维我不我真的不 知道 

353
00:21:28,056 --> 00:21:33,120
我只是试图揣测的是， 

354
00:21:30,003 --> 00:21:36,102
他们之所以会做出指示

355
00:21:34,002 --> 00:21:39,066
TLB更大的犯罪嫌疑人的处罚 

356
00:21:37,029 --> 00:21:49,080
缺少说明会更

357
00:21:39,084 --> 00:21:50,109
较大，但亲爱的，我不知道 它是一个 

358
00:21:49,008 --> 00:21:53,106
有趣的决定，然后有一个 

359
00:21:51,009 --> 00:22:00,054
有一个统一的TLB低于其

360
00:21:54,078 --> 00:22:01,083
是一个较大的仍较大，因此，我认为 

361
00:22:00,054 --> 00:22:02,145
如果你想知道我的意思是 

362
00:22:02,028 --> 00:22:06,060
有趣的这样想为什么他们 

363
00:22:03,045 --> 00:22:09,057
有这些类似的二级高速缓存

364
00:22:06,006 --> 00:22:13,050
为什么他们不只是让这些 L1 L2 

365
00:22:09,057 --> 00:22:17,085
缓存 更大的权利和的情况下， 

366
00:22:14,004 --> 00:22:22,017
将在D缓存和 我的情况下， 

367
00:22:17,085 --> 00:22:22,137
缓存在这里我会告诉你在 短短的 

368
00:22:22,017 --> 00:22:25,026
如果 你挂在有一 点点 

369
00:22:23,037 --> 00:22:28,044
真正有趣的原因，他们不能 

370
00:22:26,007 --> 00:22:33,096
让这些事情变大或更大 

371
00:22:28,044 --> 00:22:37,071
在那里有一个这么有有

372
00:22:33,096 --> 00:22:39,099
还有的属性有几分 

373
00:22:37,071 --> 00:22:41,139
的 约束在中的大小 

374
00:22:39,099 --> 00:22:43,191
偏移和 在这些这些 索引位 

375
00:22:42,039 --> 00:22:47,124
如果缓存也同样吸引 我会告诉你 

376
00:22:44,091 --> 00:22:50,112
在通过TLB膝盖的第二对 

377
00:22:48,024 --> 00:22:54,027
我的意思是 我想到的一个 原因 

378
00:22:51,012 --> 00:22:57,030
为什么他们没有，为什么他们有第二 

379
00:22:54,027 --> 00:23:01,029
水平，如果他们决定只是为了 

380
00:22:57,003 --> 00:23:03,066
使L1数据 D TLB和 ITL B的 

381
00:23:01,047 --> 00:23:05,112
长大了，你知道拿拿 

382
00:23:03,093 --> 00:23:08,139
他们用于 此L2晶体管

383
00:23:06,012 --> 00:23:14,064
并且，只是给他们一个水平

384
00:23:09,039 --> 00:23:19,053
TLB 由分区的IT 你有种 

385
00:23:14,064 --> 00:23:21,123
那些通过分割那些那些 

386
00:23:19,053 --> 00:23:24,072
存储的时间提前你是那种 

387
00:23:22,023 --> 00:23:26,114
走自己所以 

388
00:23:24,072 --> 00:23:30,135
如果你没有这个二级TLB 

389
00:23:27,014 --> 00:23:34,056
而你只是增加 说 你给 

390
00:23:31,035 --> 00:23:38,100
一半，所以它由L 1和L中的数据 

391
00:23:34,056 --> 00:23:40,056
TLB 指令TLB 两倍大，然后 

392
00:23:39,000 --> 00:23:44,022
你是那种把自己锁在右 

393
00:23:40,056 --> 00:23:45,152
- 如果你运行你可能会遇到你了 

394
00:23:44,022 --> 00:23:50,045
仍可能会耗尽指示和 

395
00:23:46,052 --> 00:23:53,088
在这种能力缺失在L1

396
00:23:50,045 --> 00:23:56,124
缓存我在说同样的数据

397
00:23:53,088 --> 00:23:58,104
右所以你 不知道，你可以在 

398
00:23:57,024 --> 00:24:01,062
特定的程序有可能有烤

399
00:23:59,004 --> 00:24:03,039
可能很多更多的数据页表 

400
00:24:01,062 --> 00:24:07,098
项指令页表 

401
00:24:03,039 --> 00:24:11,061
为了 副条目反之亦然所以通过 

402
00:24:07,098 --> 00:24:12,120
创建缓存的第二个层次

403
00:24:11,061 --> 00:24:17,145
你有种对冲你的赌注 权 

404
00:24:13,002 --> 00:24:22,047
所以，你可能小姐 罚你的时候 

405
00:24:18,045 --> 00:24:24,123
有这样的L2高速缓存的缺失损失 在 

406
00:24:22,065 --> 00:24:29,093
L1是不是几乎一样大，这将是，如果 

407
00:24:25,023 --> 00:24:33,089
因为如果你这样做不好吧，这样 

408
00:24:29,093 --> 00:24:34,179
这就是那种那张思维

409
00:24:33,089 --> 00:24:38,145
现在有一个有记忆 

410
00:24:35,079 --> 00:24:41,085
控制器，其计数，其取

411
00:24:39,045 --> 00:24:46,106
从 内存中 的数据 ， 然后有联系 

412
00:24:42,039 --> 00:24:46,106
给其他核 到I / O 桥 

413
00:24:49,002 --> 00:24:54,024
现在和2N所以这真的很有趣所以 

414
00:24:52,002 --> 00:24:56,911
这是有趣的， 看看 这 一切 是如何 

415
00:24:54,024 --> 00:24:59,067
组合在一起并结束 

416
00:24:56,929 --> 00:25:04,200
所以让我们来看看让我们来 看看它，因此 

417
00:24:59,067 --> 00:25:06,123
CPU生成在英特尔的虚拟地址 

418
00:25:04,002 --> 00:25:11,085
系统 虚拟地址是48 

419
00:25:07,023 --> 00:25:19,122
与4K 大小的块的比特，以便偏移12 

420
00:25:12,003 --> 00:25:22,038
位，然后36 位的VPN因此首先我们 

421
00:25:20,022 --> 00:25:25,059
看在高速缓存中的我的意思是在 

422
00:25:22,038 --> 00:25:28,083
TLB 和我们之前所说有 

423
00:25:25,059 --> 00:25:32,103
有16 TLB设置，这是 我的L1 

424
00:25:28,083 --> 00:25:36,135
显示L1数据TLB，所以我们打破它 

425
00:25:33,003 --> 00:25:40,077
成 4个TLB I指数比特 和32标签 

426
00:25:37,035 --> 00:25:43,116
位，所以我们做了查找的在TLB 

427
00:25:40,077 --> 00:25:45,141
看看我们是否能够发现 私人那 

428
00:25:44,016 --> 00:25:48,044
包含对应的物理 

429
00:25:46,041 --> 00:25:51,072
这个 虚拟地址 ，如果页号

430
00:25:48,044 --> 00:25:54,099
我们有一个命中，则 MMU可以只 

431
00:25:51,072 --> 00:25:58,089
直接构造的物理地址

432
00:25:54,099 --> 00:26:00,132
通过复制，因为我们复制以前看到 

433
00:25:58,089 --> 00:26:02,258
GPO的PPO，然后使用TPN 

434
00:26:01,032 --> 00:26:07,040
这是从TLB返回

435
00:26:03,059 --> 00:26:07,400
是不是这样，现在书柜

436
00:26:09,035 --> 00:26:18,048
如果有一个TLB失败，则系统 

437
00:26:13,002 --> 00:26:21,033
具有获取相应的 PT PP N 

438
00:26:18,048 --> 00:26:23,055
从使用 多路 页表 

439
00:26:21,051 --> 00:26:25,089
查找我们看多层次查找我们 

440
00:26:24,018 --> 00:26:27,086
看着面前 了，我会 告诉 你 

441
00:26:25,089 --> 00:26:31,158
这是如何工作的更详细一点 

442
00:26:27,086 --> 00:26:37,092
来了，但最终的结果是， 

443
00:26:32,058 --> 00:26:42,063
页表项位于和 PP N 

444
00:26:37,092 --> 00:26:43,146
从该提取和串接 

445
00:26:42,063 --> 00:26:46,742
与PPÒ以形成 物理 

446
00:26:44,046 --> 00:26:51,099
解决则MMU通过 该 

447
00:26:47,309 --> 00:26:56,150
物理地址缓存L1 

448
00:26:51,099 --> 00:26:59,103
数据缓存有64套，所以我们需要 六 

449
00:26:56,015 --> 00:27:03,020
现在 缓存索引位 这里就是我 

450
00:27:00,039 --> 00:27:06,054
通知之前暗指的是， 

451
00:27:03,002 --> 00:27:11,016
缓存索引 和高速缓存 的数量偏移 

452
00:27:06,054 --> 00:27:14,130
位是完全相同的VPO在 

453
00:27:11,034 --> 00:27:17,127
虚拟地址好吗所以在 

454
00:27:15,003 --> 00:27:22,004
在高速缓存偏移和索引位

455
00:27:18,027 --> 00:27:25,098
物理地址是相同的 

456
00:27:22,004 --> 00:27:27,051
所述VPO偏移位和虚拟 

457
00:27:25,098 --> 00:27:28,182
解决好了，这是不是一个 

458
00:27:27,087 --> 00:27:30,138
巧合 不像其他 还好 

459
00:27:29,082 --> 00:27:33,087
例如我发现你这是不是 一个 

460
00:27:31,038 --> 00:27:38,043
巧合，这是 这是在 

461
00:27:34,032 --> 00:27:42,036
根这是为什么L1的根 

462
00:27:38,088 --> 00:27:44,767
缓存是如此之小，设置三路 

463
00:27:42,072 --> 00:27:46,158
直到实现自己的高速缓存查找

464
00:27:45,559 --> 00:27:50,550
我们将在第二个看

465
00:27:47,058 --> 00:27:51,099
依赖于缓存索引和缓存 

466
00:27:50,055 --> 00:27:53,154
偏移位与物理地址

467
00:27:51,099 --> 00:27:55,132
是 相同于偏移的位和 

468
00:27:54,054 --> 00:27:58,111
虚拟地址 

469
00:27:56,032 --> 00:28:01,033
反正所以后来我们做我们的现金我们做我们的 

470
00:27:59,011 --> 00:28:04,018
高速缓存查找使用现金 不 

471
00:28:01,042 --> 00:28:07,051
查找使用使用这个物理

472
00:28:04,081 --> 00:28:09,175
调整取索引位来标识 

473
00:28:07,051 --> 00:28:12,135
资产 使用的标签，看看是否有一个 

474
00:28:10,075 --> 00:28:17,110
匹配，如果有那么我们有一击 

475
00:28:13,035 --> 00:28:20,113
其返回 结果背单词 

476
00:28:18,001 --> 00:28:23,079
在CPU 否则有一个 小姐这样的话 

477
00:28:21,013 --> 00:28:28,027
高速缓存必须 从请求数据 

478
00:28:23,088 --> 00:28:30,091
，L2，L3和主存储器最终最差 

479
00:28:28,027 --> 00:28:33,115
该数据来自主要情况

480
00:28:31,018 --> 00:28:39,033
记忆，所以我想最坏的情况下它涉及 

481
00:28:34,015 --> 00:28:41,029
从盘右页错失页 这么低 

482
00:28:39,033 --> 00:28:42,115
虽然最终的数据数据 

483
00:28:41,029 --> 00:28:49,036
回来并返回到 

484
00:28:43,015 --> 00:28:52,036
CPU是现在的页表项上 

485
00:28:49,036 --> 00:28:56,077
在Intel 系统具有以下 

486
00:28:52,036 --> 00:29:04,060
结构，你可以看到水平 

487
00:28:56,077 --> 00:29:07,138
1 级 页面，其级别水平 

488
00:29:04,006 --> 00:29:10,051
1〜3页记得那 

489
00:29:08,038 --> 00:29:14,065
页表项指向 的 地址 

490
00:29:11,005 --> 00:29:19,027
下一级页表的确定，所以它 

491
00:29:14,065 --> 00:29:21,157
包含1级1级PTË 

492
00:29:19,027 --> 00:29:27,099
包含基地址的 物理 

493
00:29:22,057 --> 00:29:30,121
2级表 的地址等 

494
00:29:27,099 --> 00:29:32,182
有一个有一点 是 这样 的 

495
00:29:31,021 --> 00:29:36,058
他们把它叫做P VP为有效位 

496
00:29:33,082 --> 00:29:37,171
本所以这种识别是否该

497
00:29:36,058 --> 00:29:41,149
该页面是在内存中还是没有 ，如果它不是 

498
00:29:38,071 --> 00:29:47,103
然后它再有它的 位置 

499
00:29:42,049 --> 00:29:47,103
在 磁盘 页表 

500
00:29:48,379 --> 00:29:56,600
有位来控制是否是 

501
00:29:53,009 --> 00:30:00,032
页表可以读取只能读 

502
00:29:56,006 --> 00:30:01,795
或可 其实 这 这么 写 的 

503
00:30:00,032 --> 00:30:05,731
对应于所有可到达的网页，以便 

504
00:30:02,389 --> 00:30:07,486
你知道你可以 显示所有可到达 

505
00:30:06,019 --> 00:30:10,820
网页，以便所有 的部分 

506
00:30:08,359 --> 00:30:15,080
多数民众赞成这个涵盖的地址空间 

507
00:30:10,082 --> 00:30:18,031
特别是页表项有也 

508
00:30:15,008 --> 00:30:20,407
一个位，表明用户能否

509
00:30:18,769 --> 00:30:23,770
可以访问或者如果他们需要

510
00:30:20,479 --> 00:30:25,486
在内核模式下运行，所以这是这个 

511
00:30:23,869 --> 00:30:28,948
内核是如何保护其代码和 

512
00:30:26,179 --> 00:30:31,234
从用户程序的数据有一个

513
00:30:29,659 --> 00:30:33,697
有一点这里指示是否 

514
00:30:31,729 --> 00:30:37,970
我们应该使用 回 写 或 写 

515
00:30:34,039 --> 00:30:40,048
通过此这些页表

516
00:30:37,097 --> 00:30:41,256
和所有的系统我知道的使用使用权 

517
00:30:40,129 --> 00:30:49,070
回来只是因为小姐处罚 

518
00:30:42,129 --> 00:30:51,133
巨大的命中损失 忘记CD 

519
00:30:49,007 --> 00:30:54,466
确实有一个有一个参考位 

520
00:30:51,529 --> 00:31:01,588
其中当MMU读取或设置 

521
00:30:54,529 --> 00:31:04,820
写入读取或写入该坑的 

522
00:31:02,119 --> 00:31:06,142
在此页表指向和有 

523
00:31:04,082 --> 00:31:07,621
再有一个有一点是 

524
00:31:06,349 --> 00:31:10,416
表示页面大小 是否 

525
00:31:08,359 --> 00:31:14,090
任一4 千个字节或四兆字节 

526
00:31:11,019 --> 00:31:20,440
好吧，然后有这个还有这个 

527
00:31:14,009 --> 00:31:23,428
新的禁用它的XD位哪家 

528
00:31:20,044 --> 00:31:25,843
禁用允许您禁用或启用 

529
00:31:23,509 --> 00:31:28,558
从所有到达的页面执行

530
00:31:26,239 --> 00:31:30,331
从页表项，所以这是 

531
00:31:28,999 --> 00:31:35,034
堆栈现代系统如何保护 

532
00:31:31,159 --> 00:31:37,246
从代码注入攻击堆栈

533
00:31:35,349 --> 00:31:40,432
还好最后一级页表项 

534
00:31:38,029 --> 00:31:43,460
指向它指向的不是一个叉 

535
00:31:41,179 --> 00:31:47,840
另一页表，但实际上一个页面

536
00:31:43,046 --> 00:31:49,465
在内存中，所以同样的，我们 有 

537
00:31:47,084 --> 00:31:52,085
这里 同位 相同的40个比特 

538
00:31:49,879 --> 00:31:58,590
该给的物理地址

539
00:31:52,094 --> 00:31:59,172
在内存页，然后我们有 

540
00:31:58,059 --> 00:32:02,133
的该页面是否是指示 

541
00:32:00,072 --> 00:32:05,160
存在于存储器中或不和重写 

542
00:32:03,033 --> 00:32:10,132
并和权限执行权限

543
00:32:06,006 --> 00:32:12,057
正确的通过 我们的右后卫 位 

544
00:32:10,429 --> 00:32:14,940
有一个 参考有这 

545
00:32:13,011 --> 00:32:18,108
参考位，然后有一个肮脏的

546
00:32:14,094 --> 00:32:21,099
位该MMU设置时将其写入

547
00:32:19,008 --> 00:32:24,060
该页面好 了，这是怎么了，这 是 

548
00:32:21,099 --> 00:32:25,538
在 OLS 如何 知道它需要 时 

549
00:32:24,006 --> 00:32:29,082
它选择这个，如果它选择此页 

550
00:32:26,429 --> 00:32:31,950
受害人它看起来在脏位 

551
00:32:30,036 --> 00:32:35,099
看它是否 需要 编写一个页面 

552
00:32:31,095 --> 00:32:35,099
回你有一个问题 

553
00:32:42,029 --> 00:32:48,960
执行意味着你不能执行任何 

554
00:32:46,429 --> 00:32:55,760
你无法加载任何指示

555
00:32:48,096 --> 00:33:00,185
从该页面没关系的说明

556
00:32:55,076 --> 00:33:02,109
该用户或管理员模式中

557
00:33:01,049 --> 00:33:05,087
决定您是否可以访问 

558
00:33:03,009 --> 00:33:08,228
所以，如果它被设置为管理员模式下页

559
00:33:05,429 --> 00:33:10,514
只有 内核可以可以访问该页面 

560
00:33:08,309 --> 00:33:14,100
该网页上的任何东西，如果它被设置为您 

561
00:33:11,279 --> 00:33:20,390
那么任何人用户代码和内核代码

562
00:33:14,001 --> 00:33:20,030
可以访问该网页的唯一 问题 

563
00:33:22,022 --> 00:33:28,098
好了，那么它的方式确实解决 

564
00:33:25,679 --> 00:33:30,720
然后翻译是物理的

565
00:33:28,098 --> 00:33:33,114
这个过程使内核为 每 

566
00:33:30,072 --> 00:33:35,145
进程维护你知道设定的

567
00:33:34,014 --> 00:33:39,075
当然，页表，然后在它 

568
00:33:36,045 --> 00:33:43,119
保持第一L 1 的地址 

569
00:33:39,075 --> 00:33:47,109
表在称为CR 3行寄存器和 

570
00:33:44,019 --> 00:33:52,083
这是 一个 物理地址板到 

571
00:33:48,009 --> 00:33:57,728
1 级 页表 的基的的 

572
00:33:52,083 --> 00:34:04,095
VPN被分成36除以4 

573
00:33:57,809 --> 00:34:08,690
等于9位，让的偏移 到 

574
00:34:04,095 --> 00:34:07,169
每个页表项

575
00:34:10,088 --> 00:34:16,127
好了，所以有两到第九

576
00:34:14,053 --> 00:34:19,058
在每一个潜在的页表项 

577
00:34:17,027 --> 00:34:23,063
在这些不同的页面的每个交

578
00:34:19,058 --> 00:34:26,063
表所以该VPN一个被使用的 

579
00:34:23,063 --> 00:34:31,112
高阶九个位被 用来计算 

580
00:34:26,063 --> 00:34:34,154
中的偏移量成表和 

581
00:34:32,012 --> 00:34:38,036
每个你可以看到每个级别一个PT II 

582
00:34:35,054 --> 00:34:41,147
占地内存大片这512

583
00:34:38,036 --> 00:34:45,041
GB的大小，所以你可以看到 

584
00:34:42,047 --> 00:34:48,086
今天存在最大多数程序

585
00:34:45,041 --> 00:34:50,069
你只需要一个 一级页表 

586
00:34:48,086 --> 00:34:53,132
进入这个被初始化，将

587
00:34:50,069 --> 00:34:59,075
覆盖你知道绝大多数的 你 

588
00:34:54,032 --> 00:35:03,068
节目也 没关系下九位 

589
00:35:00,029 --> 00:35:07,124
因此在级别1中的页表项

590
00:35:03,068 --> 00:35:11,150
页表指向它给 

591
00:35:08,024 --> 00:35:16,111
2级页面的物理地址 

592
00:35:12,005 --> 00:35:19,049
表，然后在该VPN位

593
00:35:17,011 --> 00:35:22,082
虚拟地址时，用于计算

594
00:35:19,094 --> 00:35:25,169
偏移成表等它只是 

595
00:35:22,082 --> 00:35:27,161
级联，最后的最后一个 

596
00:35:26,069 --> 00:35:31,076
九个比特位的低位 

597
00:35:28,061 --> 00:35:37,124
该VPN 被用于形成一个偏移 

598
00:35:31,076 --> 00:35:41,077
四级页表，在 其中 

599
00:35:38,024 --> 00:35:45,110
每个每个PTè指向实际页面 

600
00:35:41,086 --> 00:35:46,175
它给出了一个物理页号码，然后 

601
00:35:46,001 --> 00:35:53,063
这则物理页号

602
00:35:47,075 --> 00:35:55,076
萃取，并用所述VPO级联

603
00:35:53,072 --> 00:35:57,085
我们复制下来，形成一个物理 

604
00:35:55,076 --> 00:35:57,085
地址

605
00:36:01,049 --> 00:36:08,094
还好今天大家现在好了好了 

606
00:36:07,499 --> 00:36:11,880
还有的这个有这个很酷的技巧

607
00:36:08,094 --> 00:36:15,443
我为这暗指 早些时候 

608
00:36:11,088 --> 00:36:18,123
现在限制L1缓存的大小， 这个 

609
00:36:16,289 --> 00:36:20,990
一点上，我们一直在我们一直使用

610
00:36:19,023 --> 00:36:25,047
模型，其中的MMU

611
00:36:20,099 --> 00:36:27,928
采用边缘做地址转换

612
00:36:25,047 --> 00:36:30,096
并创建一个完整的虚拟地址 

613
00:36:28,819 --> 00:36:32,897
物理地址， 然后发送该 

614
00:36:30,096 --> 00:36:36,099
物理地址缓存不错，但 

615
00:36:33,599 --> 00:36:40,697
在现实英特尔不对这个可爱的把戏 

616
00:36:36,099 --> 00:36:42,968
加快L1缓存访问等 什么的 

617
00:36:41,579 --> 00:36:47,654
所以我们既定 现实会发生什么 

618
00:36:43,859 --> 00:36:52,230
虚拟 地址 很好，而且在这个虚拟 

619
00:36:48,329 --> 00:36:55,410
解决索引和关闭物理 

620
00:36:52,023 --> 00:36:59,118
索引和 偏移这是在 

621
00:36:55,041 --> 00:37:01,113
物理地址是相同的准确 

622
00:37:00,018 --> 00:37:03,947
对应于PP o在物理 

623
00:37:02,013 --> 00:37:07,892
地址是完全相同 

624
00:37:04,109 --> 00:37:11,940
该DPO 虚拟地址，以便 

625
00:37:08,009 --> 00:37:15,082
手段是，当给出的MMU 

626
00:37:11,094 --> 00:37:18,123
虚拟地址 就可以发送VPO 

627
00:37:15,739 --> 00:37:22,410
截止到即使它是 一个 L1缓存

628
00:37:19,023 --> 00:37:25,412
即使L1是是，这是物理

629
00:37:22,041 --> 00:37:26,930
寻址我们可以发送 的VPO在 

630
00:37:25,619 --> 00:37:29,657
虚拟地址 到 L1 缓存 

631
00:37:27,299 --> 00:37:33,299
因为这一点，因为 这 

632
00:37:29,999 --> 00:37:36,053
现象， 即 该 TPO是相同 

633
00:37:33,299 --> 00:37:39,326
在VPO所以即使之前的MMU是 

634
00:37:36,539 --> 00:37:42,545
做任何地址转换可以 

635
00:37:39,569 --> 00:37:45,643
发送此这些这些VPO位的 

636
00:37:42,599 --> 00:37:48,660
缓存，然后缓存可以去忙 

637
00:37:46,309 --> 00:37:52,334
提取索引缓存索引 

638
00:37:48,066 --> 00:37:56,395
比特仰视你知道所有仰视

639
00:37:52,559 --> 00:37:59,630
在该组中的所述线与 

640
00:37:56,989 --> 00:38:03,044
然后把一切都准备了 标签 

641
00:38:00,269 --> 00:38:05,400
检查哪些可以后才会出现 

642
00:38:03,539 --> 00:38:08,910
地址转换应该发生，因此 

643
00:38:05,004 --> 00:38:11,723
曾经有一个物理才会发生 

644
00:38:08,091 --> 00:38:12,093
以从中我们可以提取解决 

645
00:38:12,119 --> 00:38:16,170
该 

646
00:38:12,093 --> 00:38:16,170
现金标签所以这所以有一点点 

647
00:38:16,017 --> 00:38:21,030
L1缓存 现在并行 

648
00:38:17,007 --> 00:38:23,079
存取 所以我们可以 ，你可以是 MMM 

649
00:38:21,003 --> 00:38:29,302
做地址转换，而在 

650
00:38:24,042 --> 00:38:29,221
L1缓存大干快上它， 它的 查找 

651
00:38:31,013 --> 00:38:38,702
好吧所以现在让我们来看看 Linux 如何 

652
00:38:34,052 --> 00:38:41,100
实现虚拟虚拟内存和在 

653
00:38:38,819 --> 00:38:43,820
这样做现在 得到 更加清晰 

654
00:38:42,000 --> 00:38:46,008
了解如何fork和exec和 

655
00:38:43,829 --> 00:38:48,630
装载真的好吗工作，所以我们看到的 

656
00:38:46,008 --> 00:38:50,297
此图片的画面像这样的 

657
00:38:48,063 --> 00:38:52,067
前 几次 ，这是虚拟 

658
00:38:51,089 --> 00:38:55,800
在Linux进程 的地址空间 

659
00:38:52,067 --> 00:38:56,145
因为我们 的 ， 因为 路 

660
00:38:55,008 --> 00:38:59,042
虚拟内存系统每天都要工作

661
00:38:57,045 --> 00:39:05,079
过程中有一个非常相似的外观 

662
00:39:00,014 --> 00:39:12,071
地址空间程序文本 代码 

663
00:39:05,079 --> 00:39:14,168
总是被加载在 相同的0 X 400000 

664
00:39:12,071 --> 00:39:17,180
解决而 这之后 

665
00:39:15,068 --> 00:39:19,167
这来自 初始化 数据 

666
00:39:17,819 --> 00:39:22,980
的的点数据部

667
00:39:20,067 --> 00:39:26,246
可执行的二进制，然后还有的 

668
00:39:22,098 --> 00:39:28,667
BSS段包含未初始化 

669
00:39:26,849 --> 00:39:34,770
这是这是在所定义的数据

670
00:39:29,549 --> 00:39:38,420
二进制， 然后将热则热 

671
00:39:34,077 --> 00:39:40,149
从初始化数据向上增长

672
00:39:38,042 --> 00:39:43,116
有它的指向全球 

673
00:39:41,049 --> 00:39:46,065
变量称为 全局变量 

674
00:39:44,016 --> 00:39:49,023
这个所谓的休息，以便进程上下文

675
00:39:46,065 --> 00:39:50,148
内核跟踪顶部的地方

676
00:39:49,023 --> 00:39:53,070
堆是此这个过程 

677
00:39:51,048 --> 00:39:56,064
有一个内存映射区域 

678
00:39:53,007 --> 00:40:00,036
共享库，然后在顶部

679
00:39:56,064 --> 00:40:02,753
用户的用户级别的用户 

680
00:40:00,099 --> 00:40:04,178
用户可访问的内存有该用户 

681
00:40:03,329 --> 00:40:09,420
栈增长下降，这是尖

682
00:40:05,069 --> 00:40:12,095
通过第一个，然后内核 

683
00:40:09,042 --> 00:40:13,125
代码和数据不辜负在上

684
00:40:12,329 --> 00:40:18,660
地址空间的一部分

685
00:40:14,025 --> 00:40:20,031
现在这幅画不完全 

686
00:40:18,066 --> 00:40:22,092
准确居然还有像一个很大的差距

687
00:40:20,031 --> 00:40:25,340
堆的 顶部 和之间

688
00:40:22,092 --> 00:40:28,113
开始的内核代码和 

689
00:40:25,619 --> 00:40:31,710
数据我之所以说是， 

690
00:40:29,013 --> 00:40:35,046
英特尔架构说，有这么 

691
00:40:31,071 --> 00:40:37,149
有48 虚拟地址位，所以如果 

692
00:40:35,046 --> 00:40:42,063
这就是它 的了 高位 

693
00:40:38,049 --> 00:40:44,918
48位的地址为0，则所有的所有 

694
00:40:42,063 --> 00:40:47,100
剩余的位必须 是0的所有 的 

695
00:40:45,359 --> 00:40:49,433
所有高度的其余忍受 

696
00:40:48,000 --> 00:40:52,029
64 高阶 位需要是0 

697
00:40:50,099 --> 00:40:56,099
所以它有点像符号扩展 

698
00:40:52,029 --> 00:40:59,108
权利，如果说如果 高位 

699
00:40:56,099 --> 00:41:02,099
在48位地址为1，那么你 

700
00:40:59,369 --> 00:41:04,590
延长1点一路 攀升 到 

701
00:41:02,099 --> 00:41:06,990
剩余的高序位好了，所以那些 

702
00:41:04,059 --> 00:41:08,154
是唯一可行 又那么是什么 

703
00:41:06,099 --> 00:41:11,118
所做的就是创建 一个以两个内核 

704
00:41:09,054 --> 00:41:13,095
居住生活在一个内核

705
00:41:12,018 --> 00:41:18,069
虚拟 地址空间 的一部分

706
00:41:13,095 --> 00:41:22,754
其中，该12的 12位高位比特 

707
00:41:18,069 --> 00:41:24,728
都还好所有的人，以便创造，所以你 

708
00:41:23,609 --> 00:41:29,970
可以认为它是这样的内核生活 

709
00:41:25,349 --> 00:41:33,040
在64的64位地址的最顶端

710
00:41:29,097 --> 00:41:34,126
空间好吗 

711
00:41:33,004 --> 00:41:37,006
另一种方式把它的 上校 

712
00:41:35,026 --> 00:41:38,119
地址总是以一个最开始 

713
00:41:37,006 --> 00:41:40,057
显著位 为1个用户地址 

714
00:41:39,019 --> 00:41:43,075
总是有最显著位

715
00:41:40,057 --> 00:41:45,130
零那只是 没有详细 

716
00:41:43,075 --> 00:41:49,153
并没有真正影响的事情，但 惠顿 

717
00:41:46,003 --> 00:41:53,029
最重要的是，这，这是

718
00:41:50,053 --> 00:41:56,098
的过程中的虚拟地址空间 

719
00:41:53,056 --> 00:41:57,130
程序的权利 等的内核中存在 

720
00:41:56,098 --> 00:42:01,147
在每个虚拟地址空间 

721
00:41:58,003 --> 00:42:06,282
在这过程中所以有有内核 

722
00:42:02,047 --> 00:42:07,141
代码和数据，然后它也 映射 它 

723
00:42:06,579 --> 00:42:12,550
有其虚拟地址的区

724
00:42:08,041 --> 00:42:16,096
该地图的 这的 每个 元素空间

725
00:42:12,055 --> 00:42:19,117
此区域在物理地址 

726
00:42:16,096 --> 00:42:21,193
内存好了，所以，这 本该映射 

727
00:42:20,017 --> 00:42:25,063
区域对应于量 

728
00:42:22,093 --> 00:42:26,122
DRAM芯片上 ，所以它是一个 机制 

729
00:42:25,063 --> 00:42:29,131
该内核使用以访问 

730
00:42:27,022 --> 00:42:32,391
物理地址确定，这是 

731
00:42:30,031 --> 00:42:35,032
重要的，因为记得内核 

732
00:42:32,589 --> 00:42:36,687
在那里，你永远不能，你不能关闭 

733
00:42:35,032 --> 00:42:41,098
地址转换的权利，它总是 

734
00:42:37,569 --> 00:42:44,260
发生OK甚至即使 内核 

735
00:42:41,098 --> 00:42:44,164
运行地址 转换 

736
00:42:44,026 --> 00:42:49,120
发生内核生成

737
00:42:45,064 --> 00:42:54,163
虚拟地址所以这这这这 

738
00:42:50,002 --> 00:42:58,045
区域，这是地图 的 一个区域 

739
00:42:55,063 --> 00:43:01,099
物理内存 ，因此如果你的核心 

740
00:42:58,063 --> 00:43:06,012
访问是 这一这个块的 字节0 

741
00:43:01,099 --> 00:43:08,143
将它 实际上 将 成为主题 

742
00:43:06,579 --> 00:43:11,170
加快地址的 

743
00:43:09,043 --> 00:43:14,050
对应的物理地址为0 

744
00:43:11,017 --> 00:43:17,466
如果它在访问一个字节偏移 

745
00:43:14,005 --> 00:43:19,021
在该区域 1 的物理地址 

746
00:43:17,619 --> 00:43:21,430
从相应的物理地址 

747
00:43:19,066 --> 00:43:23,074
地址转换的过程会 

748
00:43:21,043 --> 00:43:26,047
1 确定 ，所以基本上通过阅读和写作 

749
00:43:24,046 --> 00:43:29,065
进入这个区域 的核心是阅读 

750
00:43:26,047 --> 00:43:31,131
并写入到物理内存和

751
00:43:29,065 --> 00:43:34,254
这所以有内核的部分 

752
00:43:32,031 --> 00:43:38,056
是对每一个工艺相同 

753
00:43:34,839 --> 00:43:40,810
右边的代码一样它不是，但 

754
00:43:38,056 --> 00:43:43,150
再有就是有特定的过程

755
00:43:40,081 --> 00:43:45,139
数据结构，内核

756
00:43:44,005 --> 00:43:48,094
维护每个过程， 对于 

757
00:43:46,039 --> 00:43:51,091
在该进程的背景下，所以我们 

758
00:43:49,039 --> 00:43:53,098
提及这些 ，并指所有这些 

759
00:43:51,091 --> 00:43:57,540
所有这些数据结构为 

760
00:43:53,098 --> 00:43:58,887
背景和这些当然必须是 

761
00:43:58,359 --> 00:44:05,490
这些将是为每个不同 

762
00:43:59,769 --> 00:44:09,760
流程现在的Linux组织举办本 

763
00:44:05,049 --> 00:44:12,100
作为一个集合的虚拟地址区域 

764
00:44:09,076 --> 00:44:14,095
其称之为领域 就像一个 领域 

765
00:44:13,000 --> 00:44:19,093
段想起来它只是一个块 

766
00:44:14,095 --> 00:44:25,764
相关存储器的邻接块

767
00:44:19,093 --> 00:44:31,093
项目因此有一个有一个区域

768
00:44:26,619 --> 00:44:34,626
用于代码 有用于共享数据的区域 

769
00:44:31,093 --> 00:44:42,169
图书馆有区有一个区域

770
00:44:35,319 --> 00:44:45,730
堆栈，它包含 一个有一个 

771
00:44:43,069 --> 00:44:48,678
结构对于每个过程称为 

772
00:44:45,073 --> 00:44:53,089
任务的任务结构 ，这包含了 

773
00:44:49,299 --> 00:44:56,307
指针MM结构，其具有 

774
00:44:53,089 --> 00:44:59,508
一堆东西在里面 ，但它包含 

775
00:44:57,099 --> 00:45:02,950
在一级页面 ，这些地址

776
00:45:00,309 --> 00:45:06,312
表好了， 这就是 环境 的一部分 

777
00:45:02,095 --> 00:45:07,734
在此过程中运行 时，这个过程 

778
00:45:06,609 --> 00:45:09,220
定内核将借此 

779
00:45:08,589 --> 00:45:10,632
条目

780
00:45:09,022 --> 00:45:13,116
这PGD项，他将其复制到 

781
00:45:11,019 --> 00:45:17,500
CR3好了，这是它 只是 切换 

782
00:45:14,016 --> 00:45:21,016
通过改变 CR3寄存器内核 

783
00:45:17,005 --> 00:45:25,030
改变了地址空间，所以这是 怎么 

784
00:45:21,016 --> 00:45:28,665
一旦一旦一旦CR3值

785
00:45:25,075 --> 00:45:30,134
随后改变的过程不再 

786
00:45:28,809 --> 00:45:34,887
访问前步骤 

787
00:45:30,809 --> 00:45:37,750
页表右边左右，然后有一个 

788
00:45:35,589 --> 00:45:41,380
然后有一个指针列表 

789
00:45:37,075 --> 00:45:43,614
这些这些 所谓的 区域结构的 

790
00:45:41,038 --> 00:45:46,767
区域结构确定了在开始

791
00:45:44,289 --> 00:45:48,318
开始，该地区的任何结束 

792
00:45:47,109 --> 00:45:52,660
保护像 这是只读 

793
00:45:48,579 --> 00:45:54,606
区域例如，使代码的代码 

794
00:45:52,066 --> 00:45:56,475
部分将被设置为只读， 或者是 

795
00:45:54,849 --> 00:45:59,530
它的读/写，然后有一些 

796
00:45:57,069 --> 00:46:05,280
其它一些其他的标志，其 

797
00:45:59,053 --> 00:46:04,128
看到我们将在后面看到 

798
00:46:07,069 --> 00:46:12,918
特别是当我们的时候，我们 看一下 

799
00:46:09,091 --> 00:46:15,750
共享和映射我们的目的

800
00:46:13,539 --> 00:46:18,546
这些这些标志位告诉我们，无论是 

801
00:46:16,569 --> 00:46:20,577
该网页与其他进程共享 

802
00:46:18,609 --> 00:46:25,210
或者 它 是否 为 私有 此 

803
00:46:21,369 --> 00:46:28,030
过程因此通常默认的 是， 

804
00:46:25,021 --> 00:46:29,116
页面都是 私人 ，但你有 

805
00:46:28,003 --> 00:46:32,068
选择，如果你做，如果你做了相当多 

806
00:46:30,016 --> 00:46:36,019
工作的，你可以得到 预言分享 

807
00:46:32,068 --> 00:46:39,096
共享内存 好了，让我们来 看看 

808
00:46:36,046 --> 00:46:39,051
当我们有一个页面错误 ，会发生什么

809
00:46:40,589 --> 00:46:47,589
让我们这样说有，你知道的

810
00:46:43,299 --> 00:46:48,381
处理器发出的指令， 

811
00:46:47,589 --> 00:46:52,596
调节翻译过程确定

812
00:46:49,119 --> 00:46:55,240
该记者页面不 

813
00:46:53,289 --> 00:46:57,372
包含在内存中，因此它会触发 一个 

814
00:46:55,024 --> 00:47:00,393
缺页等故障处理程序 

815
00:46:58,119 --> 00:47:03,730
有几个有几件事情 

816
00:47:00,609 --> 00:47:06,654
可能已经发生了 ，也许我们 一个 

817
00:47:03,073 --> 00:47:08,128
正在读内存故障是由于

818
00:47:07,059 --> 00:47:10,030
该内存该区域甚至不 

819
00:47:09,028 --> 00:47:12,070
存在

820
00:47:10,003 --> 00:47:16,096
我们甚至还没有创建的内核 

821
00:47:12,007 --> 00:47:19,116
甚至还没有创建分配的那

822
00:47:16,096 --> 00:47:19,695
在虚拟内存页面还好吧， 

823
00:47:19,809 --> 00:47:24,390
这是一个错误

824
00:47:20,559 --> 00:47:26,559
所以这访问 不存在的页面 

825
00:47:24,039 --> 00:47:28,188
，诱发赛格故障所以内核 

826
00:47:26,559 --> 00:47:31,635
说出来，因为它运行下来的数字

827
00:47:28,539 --> 00:47:34,566
区域结构的这个名单， 它是 

828
00:47:32,319 --> 00:47:38,380
任何地方都不会找到这个地址， 

829
00:47:34,809 --> 00:47:40,930
这些区域的范围内，从而 

830
00:47:38,038 --> 00:47:44,038
就是这样的引起的赛格故障行为 

831
00:47:40,093 --> 00:47:46,096
访问 不存在的页面另一 

832
00:47:44,038 --> 00:47:49,117
可能是该指令 

833
00:47:47,023 --> 00:47:54,102
试图写入到一个只读的 

834
00:47:50,017 --> 00:47:58,896
将虚拟地址的部分分段

835
00:47:54,309 --> 00:48:00,640
空间以及他们这一点，有 

836
00:47:59,049 --> 00:48:03,490
没有在页表的MMU 

837
00:48:00,064 --> 00:48:05,071
通常会检查权限 

838
00:48:03,049 --> 00:48:07,117
在位页表项和 

839
00:48:05,071 --> 00:48:10,710
抛出一个异常，如果正确的是 

840
00:48:08,017 --> 00:48:13,045
试图写入只读页 

841
00:48:11,349 --> 00:48:15,447
但在这种情况下，有没有页面 

842
00:48:13,045 --> 00:48:17,046
表项直接进入招，这就是为什么 

843
00:48:16,329 --> 00:48:19,407
我触发页面错误 

844
00:48:17,046 --> 00:48:20,142
所以MMU不知道这是一个

845
00:48:20,109 --> 00:48:26,610
非法权 

846
00:48:21,042 --> 00:48:29,115
上校 可以检查保护 

847
00:48:26,061 --> 00:48:31,062
这方面，如果它在该套件 

848
00:48:30,015 --> 00:48:33,114
文本的情况下，将 设置为read 

849
00:48:31,071 --> 00:48:37,095
只有这样触发保护 

850
00:48:34,014 --> 00:48:44,049
除了这实际上Linux的报告 

851
00:48:37,095 --> 00:48:45,168
作为一个段错误 ，然后再另 

852
00:48:44,049 --> 00:48:49,050
选择是，也许我们正在 努力 

853
00:48:46,068 --> 00:48:52,122
从有效区域读取的有效数据

854
00:48:49,005 --> 00:48:57,006
所以那么内核假的 

855
00:48:53,022 --> 00:49:01,071
请求的页面中，并返回到 

856
00:48:57,051 --> 00:49:06,120
请求的数据返回到回 

857
00:49:01,071 --> 00:49:19,079
CPU 好吧，我想 看看 过去的事情 

858
00:49:07,002 --> 00:49:20,033
今天是是是 好问对不起 

859
00:49:25,004 --> 00:49:31,005
是啊，这样所有的段都 

860
00:49:27,081 --> 00:49:33,156
包含在可执行文件好吗 

861
00:49:31,005 --> 00:49:36,066
有一个在在的开始 

862
00:49:34,056 --> 00:49:40,056
小精灵二进制还有所有的所有的列表 

863
00:49:37,011 --> 00:49:43,053
不同的细分好了，所以当它

864
00:49:40,056 --> 00:49:46,137
当它 当鸡蛋充当载荷 二进制 

865
00:49:43,053 --> 00:49:52,064
创建它的每一个领域创造

866
00:49:47,037 --> 00:49:52,064
那些每个那些段的 

867
00:49:53,039 --> 00:49:57,718
哦，好的是那么有多少是构建 

868
00:49:56,869 --> 00:50:00,961
喜欢你

869
00:49:58,069 --> 00:50:04,640
路易斯的李尚属首创 最近打 

870
00:50:01,789 --> 00:50:11,797
的确免疫力的兴趣如一日 

871
00:50:04,064 --> 00:50:14,072
这是页面故障后是在MMU 

872
00:50:12,589 --> 00:50:16,880
不知道这些好所以是 

873
00:50:15,044 --> 00:50:19,123
问题是究竟如何是这些 

874
00:50:16,088 --> 00:50:22,097
用咏叹调卡车，他们正在使用 

875
00:50:20,023 --> 00:50:24,292
他们 在这个使用这个内容 

876
00:50:22,097 --> 00:50:28,097
这个例子 反正 他们在习惯 

877
00:50:24,499 --> 00:50:34,160
该页面错误很好，而且也只是 

878
00:50:28,097 --> 00:50:34,996
作为题外话I所示这些实际上是

879
00:50:34,016 --> 00:50:38,415
如 列表 ，但在现实中实现

880
00:50:35,869 --> 00:50:37,938
他们系统

