1
00:00:00,003 --> 00:00:06,102
大家下午好，所以我很抱歉我 

2
00:00:05,019 --> 00:00:08,103
要我去主要是通过坐 

3
00:00:07,002 --> 00:00:11,291
这个讲座我设法 做一些事情 

4
00:00:09,003 --> 00:00:14,091
我的膝盖昨天，我有 

5
00:00:11,309 --> 00:00:17,323
麻烦 走动 非常 多 ，但 

6
00:00:14,091 --> 00:00:20,156
今天我们要谈 的是 

7
00:00:17,449 --> 00:00:24,515
输入/输出是什么样子从 

8
00:00:21,056 --> 00:00:27,093
程序员的角度，这是一个 

9
00:00:25,109 --> 00:00:31,166
你已经学到了很多东西，而不是 

10
00:00:27,093 --> 00:00:34,176
标准的UNIX库一样的 

11
00:00:31,679 --> 00:00:37,694
printf和scanf函数和那些套路和

12
00:00:35,076 --> 00:00:38,157
我们将谈论他们一点 ，但什么 

13
00:00:37,829 --> 00:00:42,210
先说说实际上是低 

14
00:00:39,057 --> 00:00:44,093
级I / O 的东西，是直接 

15
00:00:42,021 --> 00:00:46,850
接口到操作系统 和 

16
00:00:44,093 --> 00:00:49,101
这就是 你接下来 要做的 事情 需要 

17
00:00:47,039 --> 00:00:52,410
了解部分的一些这种材料

18
00:00:50,001 --> 00:00:54,800
你将需要在未来网络 

19
00:00:52,041 --> 00:00:59,064
那今晚午夜 了出来

20
00:00:54,809 --> 00:01:01,680
外壳实验室，你需要同时你会 

21
00:00:59,064 --> 00:01:03,623
要重新审视 这几个其它实验室 

22
00:01:01,068 --> 00:01:09,077
沿当然包括最终网 

23
00:01:04,199 --> 00:01:13,500
在Web代理网络进行，因此这是有点 

24
00:01:09,077 --> 00:01:15,150
在那里我们我们真的挖下去 

25
00:01:13,005 --> 00:01:18,030
深入到这种类型 的节目，你 

26
00:01:16,005 --> 00:01:21,048
做，如果你正在编写系统软件

27
00:01:18,075 --> 00:01:24,090
事情是非常勉强上方 

28
00:01:21,093 --> 00:01:28,142
在操作系统 层面，我知道 

29
00:01:24,009 --> 00:01:31,268
为自己 学习这些材料我的 

30
00:01:28,979 --> 00:01:35,070
其实从 213了解到这种材料 

31
00:01:32,159 --> 00:01:36,270
我的合着者戴维·哈洛伦 是一个 

32
00:01:35,007 --> 00:01:38,013
谁知道这个东西了 

33
00:01:36,027 --> 00:01:40,050
他写这本书我学到的那部分 

34
00:01:38,067 --> 00:01:42,111
它通过阅读 这本书就像 你 

35
00:01:40,005 --> 00:01:44,554
但 我发现 它 其实非常有用 

36
00:01:43,011 --> 00:01:46,107
知道和各种不同的其他的 

37
00:01:45,049 --> 00:01:50,120
情况下，我一直在此期间 

38
00:01:47,007 --> 00:01:53,034
这是一个相当几年前，所以我 

39
00:01:50,759 --> 00:01:54,930
认为这是值得的理解，我会 

40
00:01:53,034 --> 00:01:58,086
还别说这种物质 

41
00:01:54,093 --> 00:02:01,532
通常是教你实在不明白 

42
00:01:58,086 --> 00:02:03,102
它在大多数书涵盖除了 那些 

43
00:02:02,369 --> 00:02:06,422
被计入系统真正面向 

44
00:02:04,002 --> 00:02:09,075
程序员和相当神秘，或者你 

45
00:02:06,899 --> 00:02:11,933
试图通过阅读手册页了解它

46
00:02:09,075 --> 00:02:12,090
那就是去尝试一个相当隐蔽的方式 

47
00:02:12,239 --> 00:02:16,260
和理解 

48
00:02:12,009 --> 00:02:17,103
和排序一组抽象的

49
00:02:16,026 --> 00:02:23,315
通过 API 提供的 ，所以我希望你会 发现 

50
00:02:18,084 --> 00:02:24,623
这很有用，这样我们将 谈论 

51
00:02:23,549 --> 00:02:28,650
那么是什么我提到这个 

52
00:02:25,379 --> 00:02:31,418
低级别的I / O，我通过UNIX支持 

53
00:02:28,065 --> 00:02:34,244
和其他相关的操作系统和 

54
00:02:31,769 --> 00:02:38,774
然后被叫力 包 其代表 

55
00:02:34,829 --> 00:02:41,890
强劲 IO 哦，你居然会 

56
00:02:38,819 --> 00:02:46,170
不能采用这种封装形式，直到 最后 

57
00:02:42,439 --> 00:02:48,750
实验室的课程在 代理 实验室 

58
00:02:46,017 --> 00:02:51,069
这时候你会经常使用它，但它 

59
00:02:48,075 --> 00:02:52,140
值得看的，另一部分是在 

60
00:02:51,069 --> 00:02:55,538
本书是在 书中有据可查

61
00:02:53,004 --> 00:02:58,403
如果你 真的想了解如何 

62
00:02:56,159 --> 00:03:01,170
软件工程或系统的工作 

63
00:02:58,799 --> 00:03:02,840
你能做的最好的事情是，如果 你已经，如果它 

64
00:03:01,017 --> 00:03:05,031
有好品质的源代码查看 

65
00:03:03,209 --> 00:03:08,280
在学习你可以学到很多东西 

66
00:03:05,031 --> 00:03:10,160
这样做，我真的推荐 

67
00:03:08,028 --> 00:03:12,707
在你去的书 章 

68
00:03:10,439 --> 00:03:14,522
进取，学习所有的代码是 

69
00:03:12,959 --> 00:03:18,962
弥补了力拓这不是一个巨大的数额和 

70
00:03:15,269 --> 00:03:21,150
刚开的微妙之处 

71
00:03:18,989 --> 00:03:23,250
涉及如何处理错误如何 

72
00:03:21,015 --> 00:03:27,254
你处理特殊情况和

73
00:03:23,025 --> 00:03:30,104
这样的事情，然后我们会跟 

74
00:03:27,389 --> 00:03:32,250
他们对文件是如何表示的 

75
00:03:30,329 --> 00:03:36,000
排序各种数据结构的背后

76
00:03:32,025 --> 00:03:39,084
文件如何支持标准I / O和 

77
00:03:36,000 --> 00:03:43,979
I / O重定向和 UNIX， 还 谈 

78
00:03:39,084 --> 00:03:44,181
关于所谓的 缓冲I / O的I / O 

79
00:03:43,979 --> 00:03:50,033
你是比较熟悉的，看 

80
00:03:45,081 --> 00:03:52,250
当你用printf和scanf等等UNIX 

81
00:03:50,519 --> 00:03:54,575
其实有一个更简单，更

82
00:03:52,979 --> 00:03:57,090
我的统一视图/ O比任何其他 

83
00:03:55,079 --> 00:04:00,131
操作系统它是很好的一个

84
00:03:57,009 --> 00:04:02,738
它的设计特点是，很多的 

85
00:04:00,599 --> 00:04:05,621
抽象内置于概念 

86
00:04:02,819 --> 00:04:07,901
文件 和文件实际上只是一个 

87
00:04:05,819 --> 00:04:10,530
字节和UNIX顺序不 

88
00:04:08,639 --> 00:04:13,721
不同类别的区分 

89
00:04:10,053 --> 00:04:16,382
不像说的Windows或更早版本的文件 

90
00:04:14,459 --> 00:04:18,524
Macintosh操作系统的版本

91
00:04:16,859 --> 00:04:20,912
它只是感谢他们为打架和 

92
00:04:19,109 --> 00:04:24,240
操作系统级别都有本质

93
00:04:21,389 --> 00:04:26,910
没有更详细的了解

94
00:04:24,024 --> 00:04:30,040
文件的内部结构

95
00:04:26,091 --> 00:04:32,091
和它做的事情之一就是文件 

96
00:04:30,004 --> 00:04:35,101
通常最初的想法 是的 

97
00:04:32,091 --> 00:04:38,113
存储上的东西说盘 

98
00:04:36,037 --> 00:04:42,112
驱动器或 一些其他外部存储 

99
00:04:39,013 --> 00:04:45,097
设备和你打开 你读它或 

100
00:04:43,012 --> 00:04:48,097
写 你关闭它的排序 

101
00:04:45,097 --> 00:04:51,124
标准操作，而且还UNIX使用 

102
00:04:48,097 --> 00:04:54,109
文件的概念来表示多 

103
00:04:52,024 --> 00:05:00,025
其他不同的东西，包括 对 

104
00:04:55,009 --> 00:05:01,018
例子是将I / O设备 

105
00:05:00,025 --> 00:05:04,072
连接到一个设备

106
00:05:01,099 --> 00:05:07,150
特殊的机器TTY代表 

107
00:05:04,072 --> 00:05:11,113
电传其是古董术语 

108
00:05:08,005 --> 00:05:14,074
对于人们如何使用实际 

109
00:05:12,013 --> 00:05:17,104
接口打字机电脑

110
00:05:15,019 --> 00:05:20,098
我们 像 看其它东西

111
00:05:18,004 --> 00:05:23,100
文件的网络连接是什么

112
00:05:20,098 --> 00:05:25,180
被称为插座，当你做 

113
00:05:24,000 --> 00:05:30,004
在你做互联网通信 

114
00:05:26,008 --> 00:05:33,012
它通过您通过写入发送消息 

115
00:05:30,004 --> 00:05:36,052
插座，你接受传入 

116
00:05:34,002 --> 00:05:41,065
通过从套接字中读取通信 

117
00:05:36,052 --> 00:05:43,093
等 API 的相同的低级别 是 

118
00:05:41,083 --> 00:05:46,099
同样无论你是在读或写 

119
00:05:43,093 --> 00:05:49,116
磁盘驱动器或发送的文件

120
00:05:46,099 --> 00:05:49,116
在互联网上的数据包

121
00:05:54,025 --> 00:05:58,123
所以核心业务相关的再 

122
00:05:57,028 --> 00:06:00,037
当然是有文件被打开和 

123
00:05:59,023 --> 00:06:04,102
关闭它们，阅读 和写作 

124
00:06:01,018 --> 00:06:07,039
他们的其他种类的属性的 这 

125
00:06:05,002 --> 00:06:10,069
与大多数但不是所有的文件关联 

126
00:06:07,039 --> 00:06:12,121
是什么所谓 的文件位置， 

127
00:06:10,069 --> 00:06:14,077
再次，如果当你读你想象 

128
00:06:13,021 --> 00:06:16,075
从文件中你不想总是 

129
00:06:14,077 --> 00:06:18,154
每次你做一次从头开始 

130
00:06:16,075 --> 00:06:20,083
读你，你读一些数据，然后 

131
00:06:19,054 --> 00:06:23,152
你读更多的数据，因此这是一个 

132
00:06:21,055 --> 00:06:27,121
通过这只是一个文件位置跟踪 

133
00:06:24,052 --> 00:06:30,094
一个柜台，上面写着多少字节具有 

134
00:06:28,021 --> 00:06:33,097
已被写入 从该文件中 读 这么 

135
00:06:30,094 --> 00:06:36,103
到目前为止，我知道 去 什么地方 ， 你 

136
00:06:33,097 --> 00:06:38,194
实际上 ，即使改变与价值 

137
00:06:37,003 --> 00:06:42,049
称为各类操作

138
00:06:39,094 --> 00:06:44,109
求这只是一个改变的方式 

139
00:06:42,049 --> 00:06:46,138
文件指针 的位置的指针 

140
00:06:45,009 --> 00:06:49,102
现在如果不工作也很好的 

141
00:06:47,038 --> 00:06:54,039
输入是 ，你不能移动 终端 

142
00:06:50,002 --> 00:06:57,043
你不能排序 的备份和有 

143
00:06:54,039 --> 00:06:59,041
恢复被提交给 它 的数据 

144
00:06:57,043 --> 00:07:01,048
早期或跳跃前进，并开始 

145
00:06:59,059 --> 00:07:03,133
尚未接受输入数据

146
00:07:01,048 --> 00:07:06,085
但如此有一些类型的文件有 

147
00:07:04,033 --> 00:07:08,107
文件位置和寻求和其他

148
00:07:06,085 --> 00:07:11,179
没有类似网络套接字你 

149
00:07:09,007 --> 00:07:15,040
不能跳起来插座它在你的时间 

150
00:07:12,079 --> 00:07:19,093
只能读取或写入特定的

151
00:07:15,004 --> 00:07:22,018
包，因为他们进来，但一般 

152
00:07:19,093 --> 00:07:24,169
想起来了，然后是文件位置

153
00:07:22,054 --> 00:07:28,063
在与相关联的 数据的一部分

154
00:07:25,069 --> 00:07:34,069
打开文件， 告诉我有多远沿 

155
00:07:28,063 --> 00:07:36,088
这个文件有我读出或写入 和 

156
00:07:34,069 --> 00:07:37,102
然后再在那里，因为文件

157
00:07:36,088 --> 00:07:40,093
有所有这些不同的 东西 

158
00:07:38,002 --> 00:07:42,711
他们 那种统一在这个文件 

159
00:07:40,093 --> 00:07:44,170
抽象但显然有 

160
00:07:42,729 --> 00:07:48,820
差异和不同的属性来 

161
00:07:45,007 --> 00:07:49,075
他们，所以有几分许多 

162
00:07:48,082 --> 00:07:51,159
不同类别和子类别 

163
00:07:50,038 --> 00:07:54,106
但那些我们会考虑一下我们的一个 

164
00:07:52,059 --> 00:07:57,067
常规文件想到的东西，

165
00:07:55,006 --> 00:08:02,865
都 在一个磁盘驱动器的目录 是 

166
00:07:58,039 --> 00:08:04,126
目录被认为是一个类型的文件 

167
00:08:02,919 --> 00:08:06,984
意思是这样的数据， 有刚 

168
00:08:05,026 --> 00:08:09,735
足够的文件，但当然 

169
00:08:07,569 --> 00:08:10,662
它是一种特殊的文件， 它 的 

170
00:08:09,969 --> 00:08:14,061
实际上确实有 一个解释 

171
00:08:11,499 --> 00:08:16,503
在该文件中的条目 描述 

172
00:08:14,889 --> 00:08:19,950
位置和其他文件属性

173
00:08:16,899 --> 00:08:24,900
然后正如我 所提到的术语插座 

174
00:08:20,499 --> 00:08:26,860
是网络的连接，它的 

175
00:08:24,999 --> 00:08:29,064
既用于发送和用于接收 

176
00:08:26,086 --> 00:08:30,138
在网络上的消息 有其他 

177
00:08:29,649 --> 00:08:34,716
我们不会真正谈论的文件

178
00:08:31,038 --> 00:08:40,087
例如，当你管，当你从 

179
00:08:35,319 --> 00:08:43,000
一个应用程序到另一个， 无论是 

180
00:08:40,087 --> 00:08:44,161
第一程序 和所述的输出

181
00:08:43,000 --> 00:08:50,399
所述第二输入是特殊类型的 

182
00:08:45,061 --> 00:08:53,122
文件称为管道，他们正在处理 

183
00:08:50,399 --> 00:08:56,620
通过写作是把东西放到了 

184
00:08:54,022 --> 00:08:59,041
管道和阅读是把一些东西 

185
00:08:56,062 --> 00:09:00,711
指出，管的 类似的东西 

186
00:08:59,041 --> 00:09:03,106
所谓的符号链接这 仅仅是一个 

187
00:09:01,269 --> 00:09:06,130
这样， 你可以有 多个名称 

188
00:09:04,006 --> 00:09:13,515
文件和指向的文件

189
00:09:06,013 --> 00:09:15,088
是不是真的，而无需进行 

190
00:09:13,569 --> 00:09:18,910
一个文件，然后其他的单独副本

191
00:09:15,088 --> 00:09:21,897
特殊类型的设备，所以我们不会 

192
00:09:18,091 --> 00:09:24,097
真的 ，我们将 只考虑第一 

193
00:09:22,689 --> 00:09:34,120
三种类型的文件，并在事实上为

194
00:09:24,097 --> 00:09:35,122
今天 主要是前两个这样的想法 

195
00:09:34,012 --> 00:09:38,023
一个文件，然后它只是包含 

196
00:09:36,022 --> 00:09:40,941
任意数据和操作系统 

197
00:09:38,023 --> 00:09:43,062
真正为常规文件不会 尝试 

198
00:09:41,139 --> 00:09:46,720
进入细节里面有什么

199
00:09:43,269 --> 00:09:48,294
该文件，并有一些类 

200
00:09:46,072 --> 00:09:51,611
这将区分应用

201
00:09:48,519 --> 00:09:54,543
文本文件和二进制文件之间

202
00:09:52,259 --> 00:09:57,790
没有真正在操作系统 级别 

203
00:09:54,759 --> 00:10:00,790
但更多更高水平和主 

204
00:09:57,079 --> 00:10:02,928
与不同的是，一个文本文件 

205
00:10:00,079 --> 00:10:06,172
应该只有标准字

206
00:10:03,639 --> 00:10:10,480
ASCII或另一类将是 

207
00:10:07,072 --> 00:10:14,073
各种编码，让你做 

208
00:10:10,048 --> 00:10:17,097
非英文 字母 的涂料 和 

209
00:10:14,073 --> 00:10:20,092
二进制文件将是东西像 

210
00:10:17,529 --> 00:10:26,553
图像或实际 

211
00:10:20,092 --> 00:10:28,180
代码或视频或音频 文件或 

212
00:10:26,769 --> 00:10:32,050
东西，它是你中 

213
00:10:29,008 --> 00:10:33,046
该代码有一个字节序列 

214
00:10:32,005 --> 00:10:41,904
以某种形式编码的数字 

215
00:10:34,018 --> 00:10:44,047
直接再约的主要事情 

216
00:10:41,949 --> 00:10:47,982
文本文件 是 有 一定的 

217
00:10:44,047 --> 00:10:50,074
区分换行符功能

218
00:10:48,279 --> 00:10:54,010
字符意义的它线的末端 

219
00:10:50,074 --> 00:10:57,106
文本和你已经了解了 

220
00:10:54,001 --> 00:11:00,630
字符它有一个 零 的代码 

221
00:10:58,006 --> 00:11:03,345
作为一个字节码， 并且 成为了一个 

222
00:11:00,639 --> 00:11:05,664
你的攻击，因为禁用码

223
00:11:03,399 --> 00:11:10,690
它会被解释 为一个 换行符 

224
00:11:05,889 --> 00:11:13,000
该功能获取 的屁股 刚刚提 

225
00:11:10,069 --> 00:11:14,328
这一点，这是一个 地方，当你 

226
00:11:13,000 --> 00:11:18,699
说一个Windows之间传输文件 

227
00:11:14,949 --> 00:11:21,070
机器和Linux或Mac上的一个 

228
00:11:18,699 --> 00:11:24,100
的事情，如果它是有一个 文本文件 

229
00:11:21,007 --> 00:11:25,836
被改变为两个类的系统 

230
00:11:24,001 --> 00:11:28,009
有 解释的不同方式 

231
00:11:25,899 --> 00:11:33,190
编码时是一条线的端部和 

232
00:11:28,018 --> 00:11:37,066
在Linux或Mac文件，它只是 这个 

233
00:11:33,019 --> 00:11:41,092
它代表行字符代码的

234
00:11:37,066 --> 00:11:44,080
喂哪来的Windows文件 完成 

235
00:11:41,092 --> 00:11:46,096
与线的齿字符端 

236
00:11:44,008 --> 00:11:48,091
在行回车喂，我展示 

237
00:11:47,032 --> 00:11:52,060
你的 对象 ，这张照片 是 

238
00:11:49,063 --> 00:11:53,832
你可能只看到在 博物馆 ，但 

239
00:11:52,006 --> 00:11:55,605
这是一 台打字机 ，只是告诉你 

240
00:11:54,399 --> 00:11:57,486
到底是什么回车 和 

241
00:11:56,199 --> 00:11:59,860
什么是换行符我想你可能 

242
00:11:58,269 --> 00:12:02,880
喜欢 的情况下，你从来 没有真正 

243
00:11:59,086 --> 00:12:05,685
用老式打字机

244
00:12:02,088 --> 00:12:08,116
基本处于我们 左边的 结束 

245
00:12:06,459 --> 00:12:14,230
打字机的 右手 侧是这条 

246
00:12:09,016 --> 00:12:18,097
当你沿着我会在开始打字

247
00:12:14,023 --> 00:12:22,932
页面的 这个滚轮与您的网页 

248
00:12:18,097 --> 00:12:23,179
它一起下沉，并走向终结 

249
00:12:23,139 --> 00:12:26,196
然后你 想回 

250
00:12:24,079 --> 00:12:29,083
下一行的开始，所以你要 

251
00:12:26,709 --> 00:12:33,970
既做回车这是 

252
00:12:30,019 --> 00:12:34,728
这个东西 它 推 到右边，你 

253
00:12:33,097 --> 00:12:37,102
想要做一个线 

254
00:12:34,899 --> 00:12:41,910
喂，你想上的滚筒去 

255
00:12:38,047 --> 00:12:43,536
到下一个行，以便有一个旋钮 

256
00:12:42,009 --> 00:12:45,072
在这里，你可以 用手但在扭曲 

257
00:12:43,959 --> 00:12:48,027
一般来说，你要做的就是沿着输入 

258
00:12:45,639 --> 00:12:51,702
然后你去扣篮 这样的，这 

259
00:12:48,639 --> 00:12:57,550
杠杆都推回事情，它 

260
00:12:52,269 --> 00:13:00,270
转动由一个线滚子 

261
00:12:57,055 --> 00:13:03,204
值得等回车换行符 

262
00:13:00,279 --> 00:13:10,302
在这里，实际上来自于 

263
00:13:03,699 --> 00:13:12,910
万一你不知道，然后一个目录

264
00:13:10,509 --> 00:13:15,100
我提到这是它作为 文件 存储 

265
00:13:12,091 --> 00:13:16,860
但它是一个文件操作 

266
00:13:15,001 --> 00:13:19,039
系统吃 的 文件系统的一部分 

267
00:13:17,679 --> 00:13:21,738
实际上 ，操作系统在解释 

268
00:13:19,048 --> 00:13:24,097
非常具体的方式和你也知道 

269
00:13:22,269 --> 00:13:27,730
每个目录内有两家 

270
00:13:24,097 --> 00:13:29,826
特殊文件DOT和点点参考

271
00:13:27,073 --> 00:13:36,160
本地文件和其 母公司在 

272
00:13:30,699 --> 00:13:38,787
树结构等在大多数系统 

273
00:13:37,006 --> 00:13:40,093
据我所知，有一个排序的系统

274
00:13:39,579 --> 00:13:43,655
分层组织的文件 

275
00:13:41,047 --> 00:13:48,336
我们不会谈论 太多的文件 

276
00:13:44,339 --> 00:13:52,540
系统，但有一个分层 

277
00:13:48,759 --> 00:13:55,990
组织和维持这个 

278
00:13:52,054 --> 00:13:57,603
一系列的文件 都应当是目录 

279
00:13:55,099 --> 00:13:59,558
与目录，然后 它是一个指针 

280
00:13:58,089 --> 00:14:03,186
其子目录这又是 文件 

281
00:14:00,449 --> 00:14:06,220
还等什么 在Unix 的简称 

282
00:14:04,059 --> 00:14:08,124
术语和大多数其他操作系统 

283
00:14:06,022 --> 00:14:14,001
作为路径名称是什么已知的系统

284
00:14:08,709 --> 00:14:17,714
办法通过这个层次 导航 

285
00:14:14,199 --> 00:14:23,790
文件， 并确定一个特定的一个 

286
00:14:17,759 --> 00:14:24,783
并且使所有来说，

287
00:14:23,079 --> 00:14:26,298
低级别 

288
00:14:24,999 --> 00:14:29,920
使用实现UNIX操作

289
00:14:27,009 --> 00:14:31,720
这是打开 文件读取它， 

290
00:14:29,092 --> 00:14:32,301
写和关闭它 和那些 

291
00:14:31,072 --> 00:14:35,691
从字面上那些的名字 

292
00:14:33,129 --> 00:14:39,147
功能如此开放的功能，那么你 

293
00:14:36,339 --> 00:14:41,367
提供一个路径名和路径名记 

294
00:14:39,309 --> 00:14:45,372
可以是绝对的意义，他们开始 

295
00:14:41,619 --> 00:14:47,712
以斜线和他们一路走 

296
00:14:45,939 --> 00:14:49,000
沿层次 ，他们可以是相对的 

297
00:14:48,549 --> 00:14:50,770
至 

298
00:14:49,000 --> 00:14:56,041
特别是无论你目前的

299
00:14:50,077 --> 00:14:58,108
目录是，他们也可以 

300
00:14:56,041 --> 00:15:04,123
相对于用户如果使用波浪号 

301
00:14:59,008 --> 00:15:07,069
斜线或波浪大号那么那样的 

302
00:15:05,023 --> 00:15:10,060
此路径名快捷方式去 

303
00:15:07,069 --> 00:15:11,146
特别是用户，这样的路径名即可 

304
00:15:10,006 --> 00:15:14,071
任何这些形式的，当你打开它，它 

305
00:15:12,046 --> 00:15:17,089
只是必须有某种方式，就像 

306
00:15:15,025 --> 00:15:19,111
你在其他地方指定您 

307
00:15:17,089 --> 00:15:23,125
分不清哪里这个特殊的文件 

308
00:15:20,011 --> 00:15:27,012
你试图 打开，因此它给 

309
00:15:24,025 --> 00:15:30,028
路径名，然后给了一个

310
00:15:27,012 --> 00:15:32,041
整数码，说你想要什么 

311
00:15:30,028 --> 00:15:33,121
当你打开 这个文件做

312
00:15:32,041 --> 00:15:37,108
以何种形式你想打开它 ， 

313
00:15:34,021 --> 00:15:41,026
该指定的模具系列常数 

314
00:15:38,008 --> 00:15:46,015
那些已经 预定义，当你 

315
00:15:41,026 --> 00:15:48,115
包括固有你可以和

316
00:15:46,078 --> 00:15:52,111
那些真正得到各按位的那些 

317
00:15:49,015 --> 00:15:56,106
是二 的幂一个一位标志， 

318
00:15:53,011 --> 00:16:00,046
位置或它的位置在一个位 

319
00:15:57,006 --> 00:16:02,014
场的地方，所以你可以顺理成章地 

320
00:16:00,046 --> 00:16:05,085
或者那些在一起，如果你想多 

321
00:16:02,014 --> 00:16:10,027
这样的组合，例如，我可以说 

322
00:16:05,085 --> 00:16:12,151
只读我可以说，读，写，我可以 

323
00:16:10,027 --> 00:16:15,100
说追加意义不，如果我打开 

324
00:16:13,051 --> 00:16:16,147
它写 不开始它的不 

325
00:16:16,000 --> 00:16:19,000
创业之初开始写

326
00:16:17,047 --> 00:16:21,073
写它无论在 文件 的结尾 

327
00:16:19,000 --> 00:16:25,021
现在这么所有这些可以 下到这 

328
00:16:21,073 --> 00:16:28,105
通过使用在书中描述

329
00:16:25,021 --> 00:16:31,027
正确的常量集的名称和 

330
00:16:29,005 --> 00:16:33,037
oaring在一起，这将 

331
00:16:31,081 --> 00:16:35,110
返回的东西，就是所谓的文件 

332
00:16:33,037 --> 00:16:37,135
描述，这是一个 非常重要的 

333
00:16:36,001 --> 00:16:39,007
想法 和的原因之一 

334
00:16:38,035 --> 00:16:40,123
我们今天在谈论这个 ，这是 

335
00:16:39,007 --> 00:16:42,073
要在您的实验室很重要 

336
00:16:41,023 --> 00:16:48,132
这是 一个文件描述符的概念 

337
00:16:43,036 --> 00:16:50,095
这只是一个小的整数列出 

338
00:16:48,339 --> 00:16:53,140
其中特别是 打开的文件之一

339
00:16:50,095 --> 00:16:56,104
多数民众赞成正在使用这种特殊的 

340
00:16:53,014 --> 00:17:00,070
计划你 指的，所以它是 

341
00:16:57,085 --> 00:17:01,156
少数，因为这些都是时间 

342
00:17:00,007 --> 00:17:05,011
顺序，当你 

343
00:17:02,056 --> 00:17:08,127
在你的程序跑得比你和你 

344
00:17:06,001 --> 00:17:12,046
实际上限制在大多数机器上的一些 

345
00:17:09,027 --> 00:17:14,466
的 你 打开文件的 一些有限数量的 

346
00:17:12,055 --> 00:17:20,137
允许有在如果事实上 任何时间 

347
00:17:14,709 --> 00:17:26,790
你去看看。如果你在 

348
00:17:21,037 --> 00:17:26,079
机器和 你在限制限制类型 

349
00:17:29,033 --> 00:17:35,055
你会看到 那里，进入所谓的 

350
00:17:31,074 --> 00:17:37,083
描述10:24说，你不能 

351
00:17:35,055 --> 00:17:40,071
有 一千多 24个文件 打开 

352
00:17:38,064 --> 00:17:42,138
在任何给定时间，其实如果你已经 

353
00:17:40,071 --> 00:17:43,080
有一千个24个文件打开它是一个 

354
00:17:43,038 --> 00:17:46,125
机会，你真的做的事情 

355
00:17:44,061 --> 00:17:48,066
严重的问题在于你有没有 

356
00:17:47,025 --> 00:17:50,111
被关闭的文件，你应该 

357
00:17:48,066 --> 00:17:50,111
关闭 

358
00:17:58,059 --> 00:18:05,082
和所有的系统调用 ，包括 

359
00:18:02,429 --> 00:18:08,450
这些始终有一个返回代码和 

360
00:18:05,082 --> 00:18:10,571
返回代码有时会发生变化 的负 

361
00:18:08,639 --> 00:18:14,190
数是一个错误 有时 是零 

362
00:18:11,309 --> 00:18:16,406
一个错误，他们都是不同的 ，所有 

363
00:18:14,019 --> 00:18:18,087
混乱和所有不可思议的 ，所以你 

364
00:18:17,279 --> 00:18:22,740
不得不看的文档 

365
00:18:18,087 --> 00:18:23,756
这些功能的 每 一个和一个 

366
00:18:22,074 --> 00:18:27,593
的，我们要的规则之一

367
00:18:24,539 --> 00:18:29,850
锤离开在这个课程是每个 

368
00:18:28,259 --> 00:18:32,324
时间你做一个系统调用，你应该 

369
00:18:29,085 --> 00:18:33,159
检查返回代码 ，看看是否有 

370
00:18:32,909 --> 00:18:35,984
一个错误，然后做一些适当的

371
00:18:34,059 --> 00:18:38,082
处理这只是一个错误 的方式 

372
00:18:36,659 --> 00:18:39,746
实践它在屁股痛它 

373
00:18:38,082 --> 00:18:42,087
使你的代码看起来像一个老鼠窝 

374
00:18:40,529 --> 00:18:44,588
条件句是你真的会 

375
00:18:43,032 --> 00:18:46,841
而不是因为经常有一个 

376
00:18:45,119 --> 00:18:48,182
错误你决定你要什么 

377
00:18:47,129 --> 00:18:50,216
做的时候有一个误差大于更难 

378
00:18:48,749 --> 00:18:53,970
然后盘算只是忽略了这 一切 

379
00:18:50,999 --> 00:18:55,055
在一起，所以有大量 的代码 

380
00:18:53,097 --> 00:18:56,121
在那里，人们刚刚越过他们的 

381
00:18:55,559 --> 00:18:59,850
手指和希望从未有误差 

382
00:18:57,021 --> 00:19:02,025
他们的系统调用，但我们要 

383
00:18:59,085 --> 00:19:03,494
真正推动你很难说每

384
00:19:02,061 --> 00:19:05,148
时间你做一个系统调用检查 

385
00:19:04,259 --> 00:19:11,285
返回代码，并做一些事情，如果不是 

386
00:19:06,048 --> 00:19:14,073
右等开放将返回 

387
00:19:11,519 --> 00:19:16,320
号码， 以便 它是一个 int，它 

388
00:19:14,073 --> 00:19:19,352
回报，但如果它是一个负数 

389
00:19:16,032 --> 00:19:22,061
这 意味着它无法打开该文件 

390
00:19:20,009 --> 00:19:25,070
例如文件不 存在或 

391
00:19:22,061 --> 00:19:30,134
你想 在一个模式下打开它 那 

392
00:19:25,619 --> 00:19:33,450
你无权这样 再次打开 

393
00:19:31,034 --> 00:19:35,046
有三个 特定文件 

394
00:19:33,045 --> 00:19:38,384
与每一个相关的描述符

395
00:19:35,046 --> 00:19:40,083
运行一个 过程 是标准的输入 

396
00:19:38,789 --> 00:19:42,848
其他标准输出和 所述第三 

397
00:19:40,083 --> 00:19:44,159
是标准的错误，他们总是有一 

398
00:19:43,379 --> 00:19:53,471
文件描述符数零一和 二 

399
00:19:45,059 --> 00:19:55,068
所以，你不应该确指 

400
00:19:54,299 --> 00:19:58,394
他们通过自己的文件描述符号 

401
00:19:56,049 --> 00:20:03,218
即使你实际上可以可靠地 

402
00:19:59,249 --> 00:20:05,324
依靠这些值 只是，如果 你 

403
00:20:03,659 --> 00:20:09,240
要关闭也打开你的文件 

404
00:20:05,999 --> 00:20:12,390
看你给的路径名和一个有点 

405
00:20:09,024 --> 00:20:13,119
一个整数字段，让这些标志 

406
00:20:12,039 --> 00:20:17,055
说说模式中 

407
00:20:14,019 --> 00:20:19,113
要 打开关闭文件你 

408
00:20:17,055 --> 00:20:21,084
只是说 接近，你给的文件 

409
00:20:20,013 --> 00:20:26,019
文件描述符 的 不是 名称 

410
00:20:21,084 --> 00:20:28,095
文件并返回一个返回代码， 也因此 

411
00:20:26,073 --> 00:20:32,085
现在你可能会说， 为什么在世界 上 能 

412
00:20:28,095 --> 00:20:34,170
你曾经得到一个错误关闭，如果一个文件 

413
00:20:32,085 --> 00:20:39,120
它的开放和答案实际上是

414
00:20:35,007 --> 00:20:41,058
尤其可以发生，我们会看到，当 

415
00:20:40,002 --> 00:20:44,064
我们拥有多线程程序，其中 

416
00:20:42,021 --> 00:20:46,059
它可能有 两个基本 

417
00:20:44,082 --> 00:20:49,169
在同一时间运行的程序

418
00:20:46,059 --> 00:20:52,062
分享他们的数据结构和 

419
00:20:50,069 --> 00:20:55,101
相互共享互动

420
00:20:52,062 --> 00:20:57,063
他们的记忆是非常重要的一种 

421
00:20:56,001 --> 00:21:00,033
编程和一个你 可真 

422
00:20:57,063 --> 00:21:01,122
做坏可怕的失误和一个 

423
00:21:00,033 --> 00:21:03,069
坏可怕的错误是，如果你尝试 

424
00:21:02,022 --> 00:21:04,026
关闭这已经 得到 了文件 

425
00:21:03,069 --> 00:21:06,081
关闭

426
00:21:04,026 --> 00:21:08,064
这将是一个错误， 可 如果 发生 

427
00:21:06,081 --> 00:21:10,134
有两个不同的部分你 

428
00:21:08,064 --> 00:21:16,155
程序运行和他们每个人的尝试 

429
00:21:11,034 --> 00:21:20,061
关闭文件，以便在书和 

430
00:21:17,055 --> 00:21:22,086
在这段代码中，你会看到我们 

431
00:21:20,061 --> 00:21:24,069
介绍了一些错误处理例程

432
00:21:22,086 --> 00:21:28,098
其中一个被称为P错误和所有 

433
00:21:25,041 --> 00:21:31,080
它是打印一些没有任何 

434
00:21:28,098 --> 00:21:37,101
消息要打印，然后 

435
00:21:31,008 --> 00:21:39,087
退出程序或没有我想这 

436
00:21:38,001 --> 00:21:43,100
不将我会提到这一点 

437
00:21:40,059 --> 00:21:46,113
虽然它只是打印错误消息 

438
00:21:44,000 --> 00:21:48,009
但问题是，即使连一些如 

439
00:21:47,013 --> 00:21:53,037
平凡如关闭文件，你应该 

440
00:21:48,009 --> 00:21:56,022
检查返回码好了，所以这是 

441
00:21:53,037 --> 00:21:59,109
， 在这个低的 读取功能

442
00:21:57,003 --> 00:22:01,059
级别称为读取它给了 一个 

443
00:22:00,009 --> 00:22:04,068
文件描述符

444
00:22:01,059 --> 00:22:06,102
你提供一个指向缓冲区 

445
00:22:04,068 --> 00:22:10,146
你你已经分配 或者 

446
00:22:07,002 --> 00:22:13,011
美学 或通过malloc和也 

447
00:22:11,046 --> 00:22:17,046
指定缓冲区有多长，这样 

448
00:22:13,092 --> 00:22:20,124
它不能溢出该缓冲区，读

449
00:22:17,046 --> 00:22:22,054
只是意味着 读取的字节数，你 

450
00:22:21,024 --> 00:22:24,070
感觉

451
00:22:22,054 --> 00:22:27,076
但不超过数多，我告诉你 

452
00:22:24,007 --> 00:22:31,009
到这 听起来像一个奇怪的声明 

453
00:22:27,076 --> 00:22:33,082
你什么意思，你觉得什么样的好 

454
00:22:31,009 --> 00:22:38,038
它具有读取至少一个 字节，所以如果 

455
00:22:34,036 --> 00:22:41,134
例如，它是一个标准输入它

456
00:22:39,019 --> 00:22:43,117
将挂在那里， 等到实际 

457
00:22:42,034 --> 00:22:47,068
标准输入会等到 

458
00:22:44,017 --> 00:22:52,021
你输入一个字符串，然后打 

459
00:22:47,068 --> 00:22:54,093
返回，然后它会读取至少 

460
00:22:52,021 --> 00:22:59,029
的 某些 部分 进入程序 

461
00:22:54,093 --> 00:23:02,142
如果是 再次 的网络连接 

462
00:23:00,001 --> 00:23:06,004
读不会只是等待它会挂起，直到

463
00:23:03,042 --> 00:23:08,140
到达的东西 在那个特定的 

464
00:23:06,004 --> 00:23:12,061
网络连接，然后在一些阅读

465
00:23:09,004 --> 00:23:14,047
已发送的 字节数

466
00:23:12,061 --> 00:23:17,062
它和 我说一些含糊其辞 

467
00:23:14,083 --> 00:23:19,087
数字，因为事实是它有

468
00:23:17,062 --> 00:23:21,070
不能保证 它会读取任何固定 

469
00:23:19,087 --> 00:23:25,090
字节数将至少读 

470
00:23:22,042 --> 00:23:28,045
之一，它不会读取比 这更 

471
00:23:25,009 --> 00:23:30,040
缓冲器是但之间的数 

472
00:23:28,045 --> 00:23:34,057
可能是可变的，所以当它读取 

473
00:23:31,021 --> 00:23:35,113
小于该最大数目

474
00:23:34,057 --> 00:23:38,125
字节数您指定 的 

475
00:23:36,013 --> 00:23:40,084
称为短 读取，并且可以和 

476
00:23:39,025 --> 00:23:43,030
确实发生了，你 必须 写 

477
00:23:40,084 --> 00:23:45,150
代码期待它和我们谈谈 

478
00:23:43,075 --> 00:23:45,150
这一点 

479
00:23:48,053 --> 00:23:57,100
哦，等再次和 里德返回 

480
00:23:53,074 --> 00:24:03,098
分配数实际上数据 F 型的 

481
00:23:58,000 --> 00:24:09,026
像 SS 码 T IZE下划线吨这 是 

482
00:24:03,098 --> 00:24:10,196
通常为长整型这样一个潜在的 

483
00:24:09,026 --> 00:24:16,073
在它负数认为这个数字 

484
00:24:11,096 --> 00:24:18,167
是如果它是 一个零这意味着它的 命中 

485
00:24:16,073 --> 00:24:20,159
它检测并在文件中 

486
00:24:19,067 --> 00:24:22,142
你已经运行到存储的文件的末尾

487
00:24:21,059 --> 00:24:25,142
该网络连接已经 

488
00:24:23,042 --> 00:24:28,115
关闭或事情发生 ，如果它是 

489
00:24:26,042 --> 00:24:30,140
正则 该 字节数 

490
00:24:29,015 --> 00:24:33,106
已读，如果它是负它的 

491
00:24:31,004 --> 00:24:33,070
错误代码

492
00:24:38,057 --> 00:24:41,141
所以正如我所说，如果它是否读取它 

493
00:24:40,076 --> 00:24:43,115
不是字节 的数量少你 

494
00:24:42,041 --> 00:24:45,119
指明一个被称为短 

495
00:24:44,015 --> 00:24:51,017
算，我会谈谈为什么这样做 

496
00:24:46,019 --> 00:24:53,021
发生写作是那种同样的 想法 的 

497
00:24:51,017 --> 00:24:56,021
您提供的文件描述符 你 

498
00:24:53,021 --> 00:24:58,100
提供一个缓冲器，其中 所述数据 

499
00:24:56,021 --> 00:25:00,029
要写出 存储和你 

500
00:24:59,000 --> 00:25:06,092
放弃了多少个字节长做 你想做 

501
00:25:01,001 --> 00:25:09,017
你的权利，并会写一些

502
00:25:06,092 --> 00:25:11,141
的字节数到 输出至少 

503
00:25:09,017 --> 00:25:14,030
一个也没有超过n字节以上，但它可能 

504
00:25:12,041 --> 00:25:15,128
不是所有的人这是 一种 

505
00:25:14,003 --> 00:25:18,011
奇怪，因为你说我想写 

506
00:25:16,028 --> 00:25:21,041
这个我想将它发送到一个文件我想 

507
00:25:18,038 --> 00:25:25,043
送它 在 互联网 上 ，但它可以 

508
00:25:21,041 --> 00:25:27,122
可能不会向他们所有的，我们将 

509
00:25:25,088 --> 00:25:32,092
我们将谈论的是 那么 一点点 

510
00:25:28,022 --> 00:25:35,048
再这就是所谓的 短右 

511
00:25:32,092 --> 00:25:38,147
同样它将返回的 数量 

512
00:25:35,048 --> 00:25:43,142
过去写到所以如果它的字节

513
00:25:39,047 --> 00:25:46,103
小于 零这是 一个错误代码，以便 

514
00:25:44,042 --> 00:25:50,060
只给 你一个非常简单的 例子 

515
00:25:47,003 --> 00:25:52,061
这此代码的运行做了什么 

516
00:25:50,006 --> 00:25:53,060
你叫呼应您键入的意义 

517
00:25:52,061 --> 00:25:56,072
在东西，它会打印出来 

518
00:25:54,014 --> 00:26:00,071
并且它在它最 平凡的方式 

519
00:25:56,072 --> 00:26:03,083
可以通过读取指定单个

520
00:26:00,071 --> 00:26:05,123
字节读取单个字节正确，因此您

521
00:26:03,083 --> 00:26:07,112
记得我告诉过你阅读将在阅读 

522
00:26:06,023 --> 00:26:10,049
至少一个字节，但没有比多

523
00:26:08,012 --> 00:26:12,020
数你告诉它，当你给 

524
00:26:10,049 --> 00:26:14,087
这一个就意味着它会读取只有一个 

525
00:26:12,092 --> 00:26:17,138
字节和类似与你说的对

526
00:26:14,087 --> 00:26:19,108
右一个字节是有保证 到 

527
00:26:18,038 --> 00:26:23,105
发生 

528
00:26:20,008 --> 00:26:27,017
所以这是真的很糟糕的代码 

529
00:26:24,005 --> 00:26:29,060
调用 读或写的感

530
00:26:27,017 --> 00:26:32,093
系统级调用它是一个相对 

531
00:26:29,006 --> 00:26:34,082
昂贵的调用就意味着你踢 

532
00:26:32,093 --> 00:26:36,191
整个操作到操作 

533
00:26:35,036 --> 00:26:40,043
系统 做什么所谓的上下文 

534
00:26:37,091 --> 00:26:44,099
切换意味着它将进入 

535
00:26:41,006 --> 00:26:48,089
该系统的核心则启动运行 

536
00:26:45,071 --> 00:26:49,096
系统功能做任何读者 

537
00:26:48,089 --> 00:26:52,368
它的权利告诉给 

538
00:26:49,096 --> 00:26:55,134
回来了切换回你的工作 

539
00:26:53,169 --> 00:27:00,880
而且通常会采取可能 

540
00:26:56,034 --> 00:27:03,123
20,000至40,000个时钟周期，你 

541
00:27:00,088 --> 00:27:05,139
知道一个时钟周期时下小于 

542
00:27:03,429 --> 00:27:10,330
纳秒 所以你说的没错这就是一个 

543
00:27:06,039 --> 00:27:12,088
你说的10 微秒 

544
00:27:10,033 --> 00:27:14,122
有什么大不了的存在，但该会

545
00:27:12,088 --> 00:27:18,163
积少成多，如果你开始发送长文件 

546
00:27:15,022 --> 00:27:21,109
出过，你知道数百万字节，如果 

547
00:27:19,063 --> 00:27:25,065
你开始在向他们发送一个字节 

548
00:27:22,009 --> 00:27:28,208
时间你会花大部分时间 

549
00:27:25,083 --> 00:27:31,126
坐在操作系统会 

550
00:27:28,289 --> 00:27:34,301
快要疯了，所以这是不是 一个好主意 

551
00:27:32,026 --> 00:27:36,945
但它的工作， 这就是 一个实际 

552
00:27:34,409 --> 00:27:39,498
容易犯的错误，你可以让 程序员 

553
00:27:37,179 --> 00:27:42,970
是不使用 它 就是 用这个 

554
00:27:40,299 --> 00:27:45,010
低级别的 写入和读取和 

555
00:27:42,097 --> 00:27:47,406
计划将发挥罚款，它只是它 

556
00:27:45,001 --> 00:27:55,003
将 是非常 非常慢 ，但只是为了 

557
00:27:48,279 --> 00:27:57,940
给你这个想法呼叫的演示 

558
00:27:55,021 --> 00:28:00,110
操作系统有一个非常 

559
00:27:57,094 --> 00:27:59,453
凉

560
00:28:03,029 --> 00:28:08,460
所以这个程序，这 是 在网络 上 

561
00:28:06,179 --> 00:28:10,277
连结过的网页的代码本 

562
00:28:08,046 --> 00:28:14,064
讲座所以这个叫 

563
00:28:11,159 --> 00:28:18,197
在意义副本标准CPE标准

564
00:28:14,064 --> 00:28:19,161
输入刚才的代码我发现你和 

565
00:28:18,539 --> 00:28:25,601
所以，如果你输入 的东西它只是 

566
00:28:20,061 --> 00:28:33,074
回声回去，这样它的 读取，因此 

567
00:28:26,159 --> 00:28:33,740
看起来你和我 就像是一个 

568
00:28:35,012 --> 00:28:43,051
阅读的文本行，然后呼应 

569
00:28:39,009 --> 00:28:45,057
它回来，但它实际上做的 是 

570
00:28:43,159 --> 00:28:47,171
再次接口向所述终端是 

571
00:28:45,057 --> 00:28:48,120
一个，它实际上并没有醒过来 

572
00:28:47,279 --> 00:28:50,366
这个代码，直到它得到的完整产品线 

573
00:28:49,002 --> 00:28:53,055
但它实际上 只是 这些 打印 

574
00:28:51,149 --> 00:28:58,620
字符回到一个一个字符 

575
00:28:53,073 --> 00:29:02,252
时间，我可以演示，通过有一个

576
00:28:58,062 --> 00:29:06,159
所谓非常有趣的设施 

577
00:29:02,909 --> 00:29:09,120
跟踪中的痕迹，然后有何 追涨意愿 

578
00:29:07,059 --> 00:29:14,498
做，如果你给它 一个程序的名字 

579
00:29:09,012 --> 00:29:17,058
是它会检测每家每户系统 

580
00:29:15,029 --> 00:29:20,100
叫你尽一切基本上 

581
00:29:17,058 --> 00:29:22,877
所谓的操作系统功能 

582
00:29:20,001 --> 00:29:25,053
您所做的，当你运行一个程序，并 

583
00:29:23,399 --> 00:29:27,450
它通常会 查看了 这个巨大 

584
00:29:25,062 --> 00:29:29,124
高深莫测的东西，量你

585
00:29:27,045 --> 00:29:32,494
真的不希望看到我就展示 

586
00:29:30,024 --> 00:29:32,683
你这个 哦 

587
00:29:32,099 --> 00:29:37,258
它告诉你记录每一个 

588
00:29:36,009 --> 00:29:42,818
打电话，它通常是太多东西 

589
00:29:38,149 --> 00:29:45,000
所以 要做到这一点 比较有用 的方法 是 

590
00:29:42,899 --> 00:29:47,850
给它， 只有我 说的论据 

591
00:29:45,000 --> 00:29:51,059
想观看一些类的有限 

592
00:29:47,085 --> 00:29:52,089
当这个功能运行等 

593
00:29:51,059 --> 00:29:58,082
我只是希望我们的呼吁向右 

594
00:29:53,025 --> 00:30:00,060
低电平输出 右拐，你就会 

595
00:29:58,289 --> 00:30:05,291
看到发生了什么，然后是这个 

596
00:30:00,006 --> 00:30:09,045
字符串我在我输入变成了一系列 

597
00:30:05,309 --> 00:30:12,340
1个字节的权利要求为低电平 

598
00:30:09,099 --> 00:30:14,105
右功能

599
00:30:12,034 --> 00:30:20,131
当然还有一些方法，我可以告诉你 

600
00:30:15,059 --> 00:30:20,131
芦苇 和 右侧尝试 

601
00:30:23,008 --> 00:30:28,076
和它的所有困惑，因为我是我 

602
00:30:27,035 --> 00:30:30,122
这搞乱出来的标准错误

603
00:30:29,048 --> 00:30:32,087
但在终端上， 它像是 

604
00:30:31,022 --> 00:30:35,045
交织标准错误和 标准 

605
00:30:32,087 --> 00:30:36,184
出这么它是一种 乱 看，但 

606
00:30:35,045 --> 00:30:40,049
再次，你可以 看到它正在我 

607
00:30:37,084 --> 00:30:48,176
字符，它的阅读和1 

608
00:30:40,085 --> 00:30:51,167
在这个循环中写1 让我们 看看 

609
00:30:49,076 --> 00:30:54,088
控制用 DA 摆脱它回 

610
00:30:52,067 --> 00:30:54,088
码

611
00:31:01,069 --> 00:31:05,143
有啥这短短数企业为什么 

612
00:31:04,027 --> 00:31:08,053
会出现很好的一对夫妇

613
00:31:06,043 --> 00:31:10,062
那些正如我所说，如果你对付的

614
00:31:08,053 --> 00:31:12,109
档案结尾你不会阅读 

615
00:31:10,062 --> 00:31:16,126
你给出了然而，许多字节 

616
00:31:13,009 --> 00:31:21,021
缓冲区如果你正在阅读的文本行 

617
00:31:17,026 --> 00:31:24,040
从终端的终端

618
00:31:21,021 --> 00:31:26,095
处理程序将只发送一个葡萄酒 两个字 

619
00:31:24,004 --> 00:31:28,087
在与换行符时间

620
00:31:26,095 --> 00:31:32,110
终止它，如果你正在阅读或 

621
00:31:29,023 --> 00:31:36,034
写一个网络数据包的网络方式 

622
00:31:33,001 --> 00:31:38,029
包的工作是， 或消息，如果你 

623
00:31:36,034 --> 00:31:43,045
有一个大的长消息它分成 

624
00:31:38,038 --> 00:31:52,129
较小的块通常为约 一 

625
00:31:43,045 --> 00:31:55,072
千个字节左右，如果你是质疑 

626
00:31:53,029 --> 00:32:02,038
试图从最终的文件在哪里阅读

627
00:31:55,072 --> 00:32:03,133
我们把0是很短的计数 这是一个 

628
00:32:02,038 --> 00:32:08,080
真的很短算 肯定的，但它不是一个 

629
00:32:04,033 --> 00:32:11,119
负是这样它说，在这里，如果你 

630
00:32:08,008 --> 00:32:13,012
在你的文件 ，它会真正 遇到 

631
00:32:12,019 --> 00:32:16,042
这事实上是两件事情 它是一个 

632
00:32:13,084 --> 00:32:17,176
如果你喜欢近非常好的 问题 

633
00:32:16,042 --> 00:32:22,048
文件的 最后 ，你有 100个字节 

634
00:32:18,076 --> 00:32:24,157
左，你说读200的第一 

635
00:32:22,048 --> 00:32:27,052
调用read会回来拿到100 

636
00:32:25,057 --> 00:32:29,119
性格会说100，它会 

637
00:32:27,052 --> 00:32:32,083
拿到号码，然后你 再 打电话 

638
00:32:30,019 --> 00:32:34,084
第二次，它会返回 0， 

639
00:32:32,083 --> 00:32:37,135
所以这就是你如何实际检测 

640
00:32:34,084 --> 00:32:38,167
文件 的真正结束 ，而不是你 知道 

641
00:32:38,035 --> 00:32:41,080
你 可能已经找到了一些其他原因 

642
00:32:39,067 --> 00:32:43,102
短短数是，如果你确实

643
00:32:41,008 --> 00:32:45,085
获得读取 0的唯一情况下，你会得到 

644
00:32:44,002 --> 00:32:52,015
在4文件的末尾所以这是一个很好的 

645
00:32:46,057 --> 00:32:54,112
问题 感谢这么一次，如果在 

646
00:32:52,015 --> 00:32:57,022
互联网通常包是一个圆 

647
00:32:55,012 --> 00:33:00,016
它实际上取决于几千字节

648
00:32:57,022 --> 00:33:02,061
什么地方它是通过什么层了

649
00:33:00,052 --> 00:33:05,053
在协议它通过了，但 

650
00:33:02,061 --> 00:33:08,092
1500个字节实际上是什么标准 

651
00:33:05,062 --> 00:33:09,139
他们称之为最小传输单元，从而 

652
00:33:08,092 --> 00:33:12,109
如果你有一个很长的文件会 

653
00:33:10,039 --> 00:33:14,077
背部和这样的，如果块

654
00:33:13,009 --> 00:33:15,052
你想读入一个更大的 

655
00:33:14,077 --> 00:33:17,169
缓冲

656
00:33:15,052 --> 00:33:27,087
它通常会回来的大块

657
00:33:18,069 --> 00:33:29,104
没有换句话说 问题 你 和 

658
00:33:27,087 --> 00:33:31,159
如果再你写的代码你 

659
00:33:30,004 --> 00:33:33,103
不应指望任何数量特别 

660
00:33:32,059 --> 00:33:44,098
这将是依赖于

661
00:33:34,003 --> 00:33:46,099
没有实施 ，因为我只我很 

662
00:33:44,098 --> 00:33:50,155
只有在阅读或书写在一个字符 

663
00:33:46,099 --> 00:33:54,118
一时间 正确的 ，所以我想你 问 

664
00:33:51,055 --> 00:33:56,101
如果我喜欢花了弱类型的 

665
00:33:55,018 --> 00:33:59,053
在一个很长的字符串中的字符和 

666
00:33:57,001 --> 00:34:04,075
打回 我不知道，如果你试试吧 

667
00:33:59,053 --> 00:34:05,152
让我知道了答案，但它会 引起 

668
00:34:04,075 --> 00:34:07,096
一个错误，但该部分相信我 

669
00:34:06,052 --> 00:34:10,111
他们真的已经通过代码不见了

670
00:34:07,096 --> 00:34:11,161
很多次，并摆脱了 所有 的 

671
00:34:11,011 --> 00:34:15,016
这些潜伏的缓冲区溢出 

672
00:34:12,061 --> 00:34:16,134
在代码，但会让漏洞

673
00:34:15,061 --> 00:34:19,087
你做，我真的不知道 ，但 

674
00:34:17,034 --> 00:34:21,085
内，你应该写代码 

675
00:34:19,087 --> 00:34:23,104
又怀孕了短算作一个

676
00:34:21,085 --> 00:34:24,181
通过这一种方式的可能性和 

677
00:34:24,004 --> 00:34:28,021
使用此的头痛

678
00:34:25,081 --> 00:34:29,146
低级别的I / O是被处理的短 

679
00:34:28,021 --> 00:34:33,037
重要的不是它往往是一个老的 

680
00:34:30,046 --> 00:34:36,052
一个应用程序 级 的滋扰，所以你 

681
00:34:33,037 --> 00:34:39,836
通常不包这件事这种 

682
00:34:36,052 --> 00:34:42,711
的低级别的文件IO到其它 

683
00:34:40,169 --> 00:34:45,490
图书馆，我们在调用它的唯一 

684
00:34:43,179 --> 00:34:53,140
真正证明这又是何许 

685
00:34:45,049 --> 00:34:55,060
最低水平步骤和写作 

686
00:34:53,014 --> 00:34:57,016
也可以给你一个短数 

687
00:34:55,006 --> 00:34:59,008
例如，如果你在发送数据包

688
00:34:57,034 --> 00:35:02,098
网络是它只会发送尽可能多的 

689
00:34:59,062 --> 00:35:04,063
该数据包可以装，然后返回 

690
00:35:02,098 --> 00:35:06,117
回给你，你必须保持抽 

691
00:35:04,063 --> 00:35:09,115
他们去送不同的数据包 

692
00:35:07,017 --> 00:35:12,040
所以 通常当你写的代码， 

693
00:35:10,015 --> 00:35:17,034
使用的同时，你有这个目标 

694
00:35:12,004 --> 00:35:19,062
预计这些短计数等等

695
00:35:17,034 --> 00:35:25,081
教授奥哈洛伦写了一包

696
00:35:19,098 --> 00:35:26,179
叫里奥，你会现在我们就 

697
00:35:25,081 --> 00:35:28,138
谈论这个 包是这个 

698
00:35:27,079 --> 00:35:29,083
一个包， 你真的要 

699
00:35:29,038 --> 00:35:32,061
想你 

700
00:35:29,083 --> 00:35:34,141
使用的最终网络的课程 

701
00:35:32,061 --> 00:35:36,130
因此对于现在 它更多的是 

702
00:35:35,041 --> 00:35:38,092
这里高层次的 代码示例 

703
00:35:37,003 --> 00:35:41,044
使用低级别的IO 

704
00:35:38,092 --> 00:35:43,117
在某种程度上， 它使 一个封装起来

705
00:35:41,071 --> 00:35:45,084
多一点可口所以里奥 

706
00:35:44,017 --> 00:35:52,084
实际上提供了许多不同的 

707
00:35:45,084 --> 00:35:57,121
两种不同 以及实际三两 

708
00:35:52,084 --> 00:36:01,099
不同层次的界面给 

709
00:35:58,021 --> 00:36:04,048
文件该文件IO最低的是 

710
00:36:01,099 --> 00:36:09,181
基本上只是一个相当小的包装 

711
00:36:04,048 --> 00:36:12,139
围绕现有的IO中的读

712
00:36:10,081 --> 00:36:15,109
并写入您看到了将处理 

713
00:36:13,039 --> 00:36:18,106
短期计数问题，所以当你说 

714
00:36:16,009 --> 00:36:21,010
里奥。如果您对读取调用

715
00:36:19,006 --> 00:36:25,042
最终功能和你说一些数字 

716
00:36:21,001 --> 00:36:27,019
咬 那么该 功能将不会返回 

717
00:36:25,042 --> 00:36:30,058
直到它读取的 字节， 

718
00:36:27,028 --> 00:36:32,071
更要小心的是，许多 

719
00:36:30,058 --> 00:36:36,097
字节是有，如果它是一个网络套接字 

720
00:36:32,071 --> 00:36:38,080
或文件很好，因为它会标志的 

721
00:36:36,097 --> 00:36:42,097
如果它 实际上 将 挂起错误信息 

722
00:36:39,061 --> 00:36:45,133
，如果它是一个网络连接的等待 

723
00:36:42,097 --> 00:36:47,128
读取的字节或返回如果有错误 

724
00:36:46,033 --> 00:36:51,034
它击中一个没有 到文件就是它的不 

725
00:36:48,028 --> 00:36:52,111
预期 和类似的右 ñ它是 

726
00:36:51,043 --> 00:36:56,074
排序周围 写一个包装的

727
00:36:53,011 --> 00:36:59,016
功能，将处理只是循环 

728
00:36:56,074 --> 00:37:03,079
直到短计数照顾

729
00:36:59,061 --> 00:37:06,115
然后有 一个其它类的I / O 

730
00:37:04,024 --> 00:37:08,071
这就是所谓的缓冲I / O，这是 

731
00:37:07,015 --> 00:37:11,083
你真的要在实践中使用 

732
00:37:08,071 --> 00:37:15,142
和你大多与使用 

733
00:37:11,083 --> 00:37:18,106
标准的UNIX iOS的功能是你 

734
00:37:16,042 --> 00:37:22,093
想用户代码中建立一个 

735
00:37:19,006 --> 00:37:25,054
字节的小缓冲区， 要么 

736
00:37:22,093 --> 00:37:27,172
被读取但还未消耗

737
00:37:25,054 --> 00:37:30,055
应用程序或你累积 

738
00:37:28,072 --> 00:37:32,113
在程序中的一些字节数

739
00:37:30,064 --> 00:37:39,067
之前它实际上猛伸到 

740
00:37:33,013 --> 00:37:41,110
文件或到网络上，并有 

741
00:37:39,094 --> 00:37:42,723
一个 两个版本是一个文本 

742
00:37:42,001 --> 00:37:46,170
面向酒面向眼 

743
00:37:43,569 --> 00:37:52,592
另一种是只面向字节 

744
00:37:46,269 --> 00:37:54,880
I / O所以，让我们通过什么 

745
00:37:52,799 --> 00:37:56,820
功能实际上并没有看 

746
00:37:54,088 --> 00:37:58,144
他们的代码，以便为我提到的那些 

747
00:37:57,009 --> 00:38:01,011
所谓阅读下载和以创作只是很

748
00:37:59,044 --> 00:38:04,143
薄它们具有相同的 一般 

749
00:38:01,209 --> 00:38:05,288
语义的读取和写入 ，但他们 

750
00:38:04,539 --> 00:38:09,608
应对短期计数问题 

751
00:38:05,999 --> 00:38:13,083
所以让我们其实看看 读EM 

752
00:38:10,229 --> 00:38:21,317
如此反复看书给出一个文件

753
00:38:13,839 --> 00:38:24,915
描述符中的目标缓冲器和 

754
00:38:22,109 --> 00:38:27,880
多少个字符 如何 指示 

755
00:38:25,599 --> 00:38:37,611
许多字节它应该阅读和 

756
00:38:27,088 --> 00:38:39,257
它应该它应该我们 

757
00:38:37,719 --> 00:38:43,150
返回的 我想这将返回 

758
00:38:40,049 --> 00:38:50,380
负数，如果有一个错误 的零 

759
00:38:43,015 --> 00:38:53,694
如果它是在文件 或数 的结束 

760
00:38:50,038 --> 00:38:55,069
中读取的字节，所以我想我是一个小

761
00:38:53,829 --> 00:38:57,670
有点 我本来应该若再细心 

762
00:38:55,069 --> 00:39:00,118
它击中中途文件的结束 

763
00:38:57,067 --> 00:39:02,406
它会返回一个简短计数但是这

764
00:39:01,018 --> 00:39:05,044
唯一的情况下，它不会返回短 

765
00:39:03,009 --> 00:39:09,130
如果真有 可能有 伯爵夫人 

766
00:39:05,044 --> 00:39:11,583
阅读更多字节，因此这里的主循环 

767
00:39:09,013 --> 00:39:15,162
你看到的是它不断给你打电话读了

768
00:39:11,979 --> 00:39:17,001
一遍又一遍，直到它的幸福啊一个 

769
00:39:15,279 --> 00:39:19,920
这样， 可以欣喜的是，如果它读作 

770
00:39:17,199 --> 00:39:23,283
许多字节 它应该 写 

771
00:39:19,092 --> 00:39:28,011
读 摆在首位，另一个是 

772
00:39:24,039 --> 00:39:31,440
如果它击中了错误代码，你会

773
00:39:28,839 --> 00:39:31,440
注意 

774
00:39:33,329 --> 00:39:43,332
哦，并且有一些细微之处 

775
00:39:40,589 --> 00:39:44,688
跟踪的错误的类型是但 

776
00:39:43,359 --> 00:39:47,380
一般常见的情况下，将 

777
00:39:45,579 --> 00:39:54,390
返回指示一个负数 

778
00:39:47,038 --> 00:39:58,096
如果错误如果阅读次数为零 ， 这 

779
00:39:54,039 --> 00:40:01,105
那么这表示进入文件 等 

780
00:39:58,096 --> 00:40:05,145
它会返回是作为多字节 

781
00:40:02,005 --> 00:40:10,021
它看了这么返回短期计数 和 

782
00:40:06,045 --> 00:40:12,414
在这里，它只是说，好吧，我读过

783
00:40:10,021 --> 00:40:14,098
这个字节数和增量和 

784
00:40:12,819 --> 00:40:16,848
递减正确的价值观，因此点 

785
00:40:14,098 --> 00:40:18,103
是 ，我们会继续循环继续做 

786
00:40:17,109 --> 00:40:21,760
读取，直到它得到的数 

787
00:40:19,003 --> 00:40:26,014
字节 它应该它击中了错误，或 

788
00:40:21,076 --> 00:40:27,139
遇到档案结尾 ，你会看到 

789
00:40:26,014 --> 00:40:29,101
它拥有所有这些 检查 

790
00:40:28,039 --> 00:40:33,103
每一个不同的错误条件 

791
00:40:30,001 --> 00:40:36,022
叫它做所以这段代码的方式是 

792
00:40:34,003 --> 00:40:38,020
那种典型的，它看起来有点 

793
00:40:36,022 --> 00:40:40,024
凌乱当你第一次看到它 ， 但 如果 

794
00:40:38,002 --> 00:40:44,098
您排序的研究它，它都有道理 

795
00:40:40,042 --> 00:40:47,089
哦，所以现在让我们来谈谈缓冲I / O 

796
00:40:45,016 --> 00:40:49,051
什么缓冲I / O是， 这是一个 

797
00:40:47,089 --> 00:40:50,092
很重要的概念，所以 它 的 一部分 

798
00:40:49,051 --> 00:41:00,090
我们想告诉你的代码的原因 

799
00:40:50,092 --> 00:41:04,147
它所以缓冲I / O是想法 

800
00:41:00,549 --> 00:41:08,950
那，有一个缓冲的意思只是 

801
00:41:05,047 --> 00:41:11,098
字符 阵列的字节阵列

802
00:41:08,095 --> 00:41:16,147
他们就分配和 关联 

803
00:41:11,098 --> 00:41:18,447
这个特殊的文件和程序，如果 

804
00:41:17,047 --> 00:41:21,426
它是在读什么需要做的是它 

805
00:41:19,329 --> 00:41:25,240
将填补这个缓冲区，它会给一个 

806
00:41:21,849 --> 00:41:28,540
用一个 更大的数字阅读

807
00:41:25,024 --> 00:41:30,091
大量基本 的大小 

808
00:41:28,054 --> 00:41:33,061
实际你多少数量分配 

809
00:41:30,091 --> 00:41:36,172
这个缓冲区，系统将填补

810
00:41:34,024 --> 00:41:39,903
那以达到该数字 的 

811
00:41:37,072 --> 00:41:42,154
字符，然后该用户时

812
00:41:40,119 --> 00:41:46,130
程序要现在就来看看这个 

813
00:41:43,054 --> 00:41:47,803
得到一些字节它会 

814
00:41:46,013 --> 00:41:50,392
检查我已经 有一些在 

815
00:41:48,289 --> 00:41:53,338
那些没有读入 ，如果缓冲区

816
00:41:50,509 --> 00:41:56,542
所以我就归还这些，如果不 

817
00:41:53,779 --> 00:41:59,690
然后我会重新填充缓冲这样的想法 

818
00:41:56,839 --> 00:42:00,937
它是不是每次都去 

819
00:41:59,069 --> 00:42:03,468
操作系统 和要求一个 

820
00:42:01,819 --> 00:42:06,823
人物小数目的字符 

821
00:42:04,089 --> 00:42:09,133
那个叫操作系统 说 

822
00:42:06,859 --> 00:42:11,953
给我几乎尽可能多的字符 

823
00:42:09,529 --> 00:42:14,578
因为 你已经得到了一些限制，然后 

824
00:42:12,799 --> 00:42:17,900
我就走开， 什么 

825
00:42:15,019 --> 00:42:21,410
应用程序我有点 拉 

826
00:42:17,009 --> 00:42:22,037
这一次输出一对夫妇字节，但 我 

827
00:42:21,041 --> 00:42:26,980
不会错误操作系统做 

828
00:42:23,018 --> 00:42:29,026
我是真正的功能 和方式， 

829
00:42:27,349 --> 00:42:34,970
确实它是 只是保持 的指针 

830
00:42:29,098 --> 00:42:39,124
该指示字节的 哪一部分 

831
00:42:34,097 --> 00:42:42,976
我已经 从引进 

832
00:42:40,024 --> 00:42:45,343
操作系统 调用 ，但没有 

833
00:42:43,849 --> 00:42:47,851
尚未提供给应用程序

834
00:42:45,559 --> 00:42:49,588
程序并因此在这种大 

835
00:42:47,869 --> 00:42:54,500
事情的图片，如果你 想象 你 

836
00:42:49,849 --> 00:42:56,450
你走你通过在任何一个文件

837
00:42:54,005 --> 00:42:59,027
在给定的时间点这个缓冲区 

838
00:42:56,045 --> 00:43:01,444
代表在该文件中的一些范围 

839
00:42:59,072 --> 00:43:03,140
其中绿色的是这东西 

840
00:43:01,849 --> 00:43:06,898
已经阅读应用 

841
00:43:04,004 --> 00:43:09,062
编程粉红色是这东西 

842
00:43:07,339 --> 00:43:12,406
被读取但是从操作系统 

843
00:43:09,098 --> 00:43:16,103
出文件，但还没有被阅读 

844
00:43:13,009 --> 00:43:20,180
应用程序，这是方式 

845
00:43:17,048 --> 00:43:23,116
实施一旦你想想 看 这是 

846
00:43:20,018 --> 00:43:28,627
不是太难做的是将其与关联 

847
00:43:24,016 --> 00:43:33,625
然后每个文件连接文件 

848
00:43:28,789 --> 00:43:37,220
告诉你如何描述帐户 

849
00:43:33,769 --> 00:43:44,980
许多字节有没有 被 

850
00:43:37,022 --> 00:43:48,038
但读指针AA 到 这个这个 

851
00:43:44,098 --> 00:43:51,197
转换是，然后将实际 

852
00:43:48,038 --> 00:43:54,697
的缓冲器的存储本身 

853
00:43:52,097 --> 00:43:57,097
字符分配的字节分配

854
00:43:55,039 --> 00:43:57,970
在缓冲区本身 

855
00:43:58,609 --> 00:44:07,703
所以这里有一个例子吧的 

856
00:44:03,092 --> 00:44:10,511
使用力拓先做到这一点回音，你 

857
00:44:08,549 --> 00:44:16,920
读出的线和读取线意味着它

858
00:44:11,339 --> 00:44:20,990
将查找和换行符停止 

859
00:44:16,092 --> 00:44:24,271
性格和写回出来 ， 

860
00:44:20,099 --> 00:44:24,208
如果再这样做了演示 

861
00:44:30,589 --> 00:44:33,615
这个代码

862
00:44:37,072 --> 00:44:39,078
嘿 

863
00:44:48,038 --> 00:44:53,069
这是一个小你又得到让我 

864
00:44:51,041 --> 00:44:57,690
跟踪正确的，因为这是一个有点 硬 

865
00:44:53,069 --> 00:44:57,438
看阅读很难找出 与 

866
00:45:03,086 --> 00:45:10,185
所以你会看到，它读取 整个 

867
00:45:09,057 --> 00:45:14,064
行， 现在，它的完成添加 

868
00:45:11,085 --> 00:45:18,159
它 只是 写 操作系统级 

869
00:45:14,064 --> 00:45:24,135
一个块值得一个调用的

870
00:45:19,059 --> 00:45:28,115
操作系统编写 函数，而不是 

871
00:45:25,035 --> 00:45:28,043
按字节一个字节 

872
00:45:38,349 --> 00:45:42,384
好了，所以再次我不打算去 

873
00:45:41,229 --> 00:45:46,150
通过所有的代码 ，但它实际上是 

874
00:45:42,699 --> 00:45:47,778
值得你这样做，由 

875
00:45:46,015 --> 00:45:50,038
办法其实我已经做了一些应用程序 

876
00:45:48,489 --> 00:45:52,563
在那里我 接过 里约热内卢码我要 添加 

877
00:45:50,038 --> 00:45:54,043
一些功能， 但它是一个非常 

878
00:45:53,229 --> 00:45:59,262
有用的出发点是能够 

879
00:45:54,088 --> 00:46:00,927
建立你 自己的定制程序 好吗 

880
00:45:59,559 --> 00:46:06,880
所以让我们来谈谈其他一些地方 

881
00:46:01,719 --> 00:46:10,420
文件之一 就是 与文件 相关联 

882
00:46:06,088 --> 00:46:11,457
是他们所谓的元数据，这样数据 

883
00:46:10,042 --> 00:46:14,047
是文件的 实际 内容 

884
00:46:12,249 --> 00:46:16,272
该文件中的实际字节，但 

885
00:46:14,092 --> 00:46:18,141
还有其他的 东西一大堆

886
00:46:16,479 --> 00:46:21,670
一个与该文件相关联

887
00:46:19,041 --> 00:46:25,190
什么类型的文件的 信息， 它 

888
00:46:21,067 --> 00:46:30,756
是什么保护的读/写/执行 

889
00:46:25,559 --> 00:46:34,150
保护它有一些信息 

890
00:46:31,359 --> 00:46:34,410
有关文件的 所有权 什么 

891
00:46:34,015 --> 00:46:39,144
键入它是

892
00:46:34,869 --> 00:46:40,875
而 与之相关联 也是 时代 

893
00:46:39,279 --> 00:46:43,284
是当它创造了它最后的时候 

894
00:46:41,469 --> 00:46:46,690
访问和是什么时候最后修改 

895
00:46:43,779 --> 00:46:49,779
所以这被称为元数据和每 

896
00:46:46,069 --> 00:46:52,218
文件具有那种信息

897
00:46:49,779 --> 00:46:54,880
与之相关的 ，你其实可以 

898
00:46:52,839 --> 00:47:02,140
它是在一个数据结构称为 

899
00:46:54,088 --> 00:47:03,927
统计数据结构，你可以，如果你 

900
00:47:02,014 --> 00:47:10,069
要编写然后排序的代码 

901
00:47:04,719 --> 00:47:13,725
探针的的目录结构 

902
00:47:10,069 --> 00:47:16,908
文件系统， 您可以 对通话 

903
00:47:13,779 --> 00:47:18,873
统计功能， 它给了的 

904
00:47:17,529 --> 00:47:24,640
要统计 的文件的路径名 

905
00:47:19,719 --> 00:47:27,744
然后 指向 它 的 指针 这些中的 一个 

906
00:47:24,064 --> 00:47:29,223
统计数据结构，然后，我们的 

907
00:47:27,969 --> 00:47:32,440
数据结构将由得到填补 

908
00:47:29,799 --> 00:47:35,440
这个特定的文件信息和 

909
00:47:32,044 --> 00:47:39,723
那么你可以测试各种属性 

910
00:47:35,044 --> 00:47:43,051
有关文件看看基本上得到

911
00:47:40,119 --> 00:47:46,203
那这是这里存储的信息

912
00:47:44,014 --> 00:47:49,323
并有所有这些讨厌的编译时间 

913
00:47:46,959 --> 00:47:51,998
您 使用常量或宏 

914
00:47:49,449 --> 00:47:51,458
使用 

915
00:47:53,014 --> 00:47:58,092
看待和审视这些签证 元 

916
00:48:03,008 --> 00:48:08,087
所以这里有一个 例子， 我会 做，但 

917
00:48:07,019 --> 00:48:11,111
这是一个被称为STAT检查它的功能

918
00:48:09,059 --> 00:48:14,093
在同一目录中，因此，如果您 

919
00:48:12,011 --> 00:48:17,090
查了一些文件，或通常说的不错

920
00:48:14,093 --> 00:48:21,095
这是一个常规文件，并且是你 

921
00:48:17,009 --> 00:48:25,013
允许，如果我现在打电话给看，而是 

922
00:48:21,095 --> 00:48:28,127
chmod 来消除设置所有 

923
00:48:26,003 --> 00:48:34,028
保护到零，你 知道说没有你 

924
00:48:29,027 --> 00:48:39,071
现在不能等看了一遍那

925
00:48:34,055 --> 00:48:42,080
只是把这个鳄鱼的这里，所以 

926
00:48:39,071 --> 00:48:45,110
现在这是 得到了很多 的部分 

927
00:48:42,008 --> 00:48:47,012
更棘手的是如何我们的 文件是如何 

928
00:48:46,001 --> 00:48:49,043
有关文件的所有信息 是 

929
00:48:47,084 --> 00:48:56,167
实际上是由 计划 代表 

930
00:48:49,052 --> 00:48:57,067
问题是统计要点 

931
00:49:06,098 --> 00:49:14,156
我会告诉你，你可以找到出路之一

932
00:49:09,033 --> 00:49:19,035
如果没有你说哪一步的人 2统计 

933
00:49:15,056 --> 00:49:21,114
你会得到更多的比你想 知道 这么 

934
00:49:19,035 --> 00:49:30,099
一般来说，你知道，如果你说男人 

935
00:49:22,014 --> 00:49:34,026
债务都将发出命令的UNIX是 

936
00:49:30,099 --> 00:49:39,108
您 可以 使用步骤文件，所以我 可以说 

937
00:49:34,026 --> 00:49:45,114
统计 点，它会打印 出一些 

938
00:49:40,089 --> 00:49:51,096
关于这种情况下的文件信息 

939
00:49:46,014 --> 00:49:56,090
我的本地目录，让我们看看 我能 STAT 

940
00:49:52,059 --> 00:50:01,128
这里的任何文件，它 会打印出一些 

941
00:49:56,009 --> 00:50:05,082
这件事，但是如果一些神秘的信息

942
00:50:02,028 --> 00:50:08,034
你说男人2统计 UNIX手册页 

943
00:50:06,063 --> 00:50:13,122
被分成 不同的类别 

944
00:50:08,034 --> 00:50:16,088
和事情， 我们的系统调用UNIX 

945
00:50:14,022 --> 00:50:20,109
系统库调用通常在 

946
00:50:16,088 --> 00:50:23,109
手册页和使第2 

947
00:50:21,009 --> 00:50:27,009
将返回 关于它 ，但 信息 

948
00:50:24,009 --> 00:50:29,022
它的点主要是统计是那么 

949
00:50:27,009 --> 00:50:31,038
你 打电话，你给它 的功能 

950
00:50:29,022 --> 00:50:34,026
的路径名和指向缓冲区的指针 

951
00:50:31,038 --> 00:50:39,041
你想它，然后它会 填满 

952
00:50:34,062 --> 00:50:40,158
在缓冲器与内容 

953
00:50:39,041 --> 00:50:44,112
关于 特定文件 的信息 

954
00:50:41,058 --> 00:50:48,063
而且它填补它的 形式 是一个 

955
00:50:45,012 --> 00:50:52,017
称为一个结构这些数据结构的

956
00:50:48,063 --> 00:50:54,114
退一步，这是相当 典型的很多 

957
00:50:52,017 --> 00:50:58,020
这些功能是 他们有 

958
00:50:55,014 --> 00:51:00,090
一些预定义的结构，如果你想 

959
00:50:58,047 --> 00:51:02,109
得到它，如果你想 获得信息 

960
00:51:00,009 --> 00:51:04,074
你通过你分配其中的一个 

961
00:51:03,009 --> 00:51:06,018
支柱你一个指针传递给 它，然后 

962
00:51:05,055 --> 00:51:11,063
库函数将填补

963
00:51:06,099 --> 00:51:10,163
细节 做 是否有意义 

964
00:51:22,054 --> 00:51:28,133
好吧所以现在让我们来看看一些 

965
00:51:26,869 --> 00:51:32,090
内部数据结构 ，所述 

966
00:51:29,033 --> 00:51:34,130
操作系统维护有关 

967
00:51:32,009 --> 00:51:38,033
用 程序和这个 相关的文件

968
00:51:35,003 --> 00:51:40,072
真是讨厌考试的来源 

969
00:51:38,033 --> 00:51:42,116
问题我只是提醒 你，你是 

970
00:51:40,369 --> 00:51:45,290
会想读的这部分 

971
00:51:43,016 --> 00:51:47,725
仔细研究书的做法 

972
00:51:45,029 --> 00:51:49,108
问题看旧的考试，因为我 

973
00:51:47,869 --> 00:51:51,290
可以向你保证，你会 得到 

974
00:51:49,369 --> 00:51:54,590
其中的一些在最后，这是 一个 

975
00:51:51,029 --> 00:51:58,031
承诺他们可以无限 

976
00:51:54,059 --> 00:52:00,104
晦涩所以我们可以我们可以火炬你 

977
00:51:58,049 --> 00:52:05,090
这些所谓的主要观点是， 

978
00:52:01,004 --> 00:52:07,833
与任何执行的进程 相关联的 

979
00:52:05,009 --> 00:52:15,011
你能想到的方法是 

980
00:52:07,869 --> 00:52:18,230
正在运行的程序是一个叫什么

981
00:52:15,092 --> 00:52:21,149
在描述符表和什么 

982
00:52:18,023 --> 00:52:26,099
包含对每一个打开的文件，你

983
00:52:22,049 --> 00:52:30,053
有它有一个指向 数据 

984
00:52:26,099 --> 00:52:31,163
结构称为一个表中的条目 

985
00:52:30,089 --> 00:52:37,094
那年代由操作维护 

986
00:52:32,063 --> 00:52:45,095
系统全局描述 每个 

987
00:52:38,039 --> 00:52:50,083
打开的文件实际上每个每 

988
00:52:45,095 --> 00:52:56,096
一次文件被打开时会分配 

989
00:52:50,083 --> 00:52:59,108
记录在该打开的文件表，从而

990
00:52:56,096 --> 00:53:03,104
我提到文件描述符0 1＆2具有 

991
00:53:00,008 --> 00:53:06,041
具体含义和其他文件或 

992
00:53:04,004 --> 00:53:08,045
你已经在开辟了其他的

993
00:53:06,041 --> 00:53:13,046
你的程序执行的过程中和 

994
00:53:08,045 --> 00:53:17,108
尚未关闭，以便使各 

995
00:53:13,046 --> 00:53:20,425
这些然后是所涉及的参考 

996
00:53:18,008 --> 00:53:24,077
特别是打开的文件，并让 

997
00:53:20,839 --> 00:53:26,839
有关文件，而同样的信息

998
00:53:24,077 --> 00:53:28,079
给文件中的立场 

999
00:53:26,839 --> 00:53:30,916
目前 ，我每次告诉你 

1000
00:53:28,097 --> 00:53:32,716
你打开一个文件有一个 用于常规 

1001
00:53:31,609 --> 00:53:34,705
文件中至少有一个关联

1002
00:53:33,589 --> 00:53:38,590
在文件中的位置在那里

1003
00:53:35,569 --> 00:53:39,660
这是你最后一次正确的读者或者 

1004
00:53:38,599 --> 00:53:44,660
你会成为你的下 自由 书写和 

1005
00:53:40,479 --> 00:53:46,516
所以这是该文件暂停，并有 

1006
00:53:44,066 --> 00:53:49,515
也其中使用由基准计数 

1007
00:53:46,849 --> 00:53:51,895
操作系统跟踪 

1008
00:53:50,109 --> 00:53:58,640
因为我们会看到它的可能 有 

1009
00:53:52,309 --> 00:54:01,309
多个多个进程共享一个 

1010
00:53:58,064 --> 00:54:02,069
在此 打开文件表项，它 

1011
00:54:01,309 --> 00:54:05,350
使用 此引用计数是 

1012
00:54:03,014 --> 00:54:09,613
跟踪的内存的标准方式

1013
00:54:05,719 --> 00:54:11,725
分配知道它何时不再 

1014
00:54:09,739 --> 00:54:16,792
如果 需要 时一直是入门 

1015
00:54:12,319 --> 00:54:19,400
够当文件不再

1016
00:54:17,269 --> 00:54:23,338
提供服务， 因此此内容 

1017
00:54:19,004 --> 00:54:25,058
所以无需为你打开每一个 

1018
00:54:23,959 --> 00:54:28,910
将在这一个项文件

1019
00:54:25,094 --> 00:54:31,203
表和该表作为我说的是共享 

1020
00:54:28,091 --> 00:54:35,770
在 整个操作系统和 

1021
00:54:32,049 --> 00:54:38,143
然后与相关的每一个文件是 

1022
00:54:36,589 --> 00:54:42,380
称为其代表在V节点 

1023
00:54:38,989 --> 00:54:45,046
假想节点而这正是该 

1024
00:54:42,038 --> 00:54:47,647
包含排序的相关信息

1025
00:54:45,559 --> 00:54:51,170
该文件特别是它在哪里 

1026
00:54:47,989 --> 00:54:54,994
存储这些信息 ， 你可以 

1027
00:54:51,017 --> 00:55:00,076
从统计之类的东西怎么弄

1028
00:54:55,489 --> 00:55:04,400
大是和之类的东西 ，以便 

1029
00:55:00,229 --> 00:55:06,268
这是在每家每户的文件 

1030
00:55:04,004 --> 00:55:09,613
系统实际上呈V节点条目 

1031
00:55:06,619 --> 00:55:13,630
无论是打开或关闭现在这样可以 

1032
00:55:10,009 --> 00:55:16,054
获得复杂，所以 ，例如，如果内 

1033
00:55:13,729 --> 00:55:18,808
你叫开 上两次 单节目 

1034
00:55:16,459 --> 00:55:22,420
你实际上会得到同样的功能 

1035
00:55:19,519 --> 00:55:24,615
两种不同的文件描述符和 

1036
00:55:22,042 --> 00:55:28,231
你就可以访问同一文件 

1037
00:55:25,479 --> 00:55:32,536
并在 这 两个 不同的位置 

1038
00:55:28,609 --> 00:55:37,651
它是有道理的 ，如果你 想象你 

1039
00:55:33,049 --> 00:55:40,090
从文件中读取，你可能想 

1040
00:55:38,029 --> 00:55:42,055
从两个不同的位置读

1041
00:55:40,459 --> 00:55:43,464
同一 程序 内的文件 和 

1042
00:55:42,289 --> 00:55:47,380
你 可以做， 这是完全合法 

1043
00:55:43,959 --> 00:55:49,270
你只需要调用开放两次，这将 

1044
00:55:48,199 --> 00:55:52,930
跟踪两 

1045
00:55:49,027 --> 00:55:54,076
位置，以便点是这些文件 

1046
00:55:52,093 --> 00:55:56,095
描述可能是指 

1047
00:55:54,076 --> 00:55:58,099
同样的文件，但他们在实际上是 

1048
00:55:56,095 --> 00:56:01,108
该文件内的不同位置和 

1049
00:55:58,099 --> 00:56:03,163
如果你是，如果你已经能也发生 

1050
00:56:02,008 --> 00:56:06,091
打开一个文件供读取和 

1051
00:56:04,063 --> 00:56:09,109
写，你 写进取， 

1052
00:56:06,091 --> 00:56:11,164
有那么读取字符 字节 

1053
00:56:10,009 --> 00:56:15,067
已经写 是有道理的 

1054
00:56:12,064 --> 00:56:19,078
它不是这样的 有两个 是个好 主意 

1055
00:56:15,067 --> 00:56:21,151
不同的写入文件打开是 

1056
00:56:19,078 --> 00:56:24,079
同时写入可以胡来 

1057
00:56:22,051 --> 00:56:25,060
文件相当严重这种方式，但 

1058
00:56:24,088 --> 00:56:28,144
没有什么操作系统 

1059
00:56:26,041 --> 00:56:32,104
阻止你这样做，所以它 

1060
00:56:29,044 --> 00:56:36,067
会不会这不是一个好 主意，但它是一个 

1061
00:56:33,004 --> 00:56:39,049
合法经营所以这点是 

1062
00:56:36,067 --> 00:56:42,148
你有什么水平的区分 

1063
00:56:39,049 --> 00:56:50,092
分享拍摄的地方，你看到，如果 

1064
00:56:43,048 --> 00:56:53,146
你有两个不同的表项 

1065
00:56:50,092 --> 00:56:55,108
共享一个文件，那么这是什么 

1066
00:56:54,046 --> 00:56:59,064
不同的存在 ，你可以 是 

1067
00:56:56,008 --> 00:56:59,064
在不同的文件位置工作 

1068
00:57:00,048 --> 00:57:06,142
同样当然更常见 

1069
00:57:03,052 --> 00:57:09,054
事情是你有两个不同的开放 

1070
00:57:07,042 --> 00:57:12,064
在那里的文件指的是不同的文件 

1071
00:57:09,072 --> 00:57:15,106
但现在，这就是生活变得 

1072
00:57:12,064 --> 00:57:19,078
令人兴奋的，如果你调用 fork 你还记得 

1073
00:57:16,006 --> 00:57:22,042
关于叉，它产生一个孩子，但 

1074
00:57:19,078 --> 00:57:23,164
那个孩子继承了大量的信息 

1075
00:57:22,042 --> 00:57:27,046
从其父和 的事情之一 

1076
00:57:24,064 --> 00:57:29,092
继承是它的描述符表它 

1077
00:57:27,082 --> 00:57:33,096
获取描述符表的副本

1078
00:57:29,092 --> 00:57:36,126
所以现在的家长和孩子都

1079
00:57:33,096 --> 00:57:38,194
在相同 的条目 

1080
00:57:37,026 --> 00:57:42,097
描述符表，所以他们正在共享 

1081
00:57:39,094 --> 00:57:45,133
文件，但不是在文件级别，但在 

1082
00:57:42,097 --> 00:57:49,111
打开文件表，这是什么意思 

1083
00:57:46,033 --> 00:57:52,090
是，如果家长不读它会碰到 

1084
00:57:50,011 --> 00:57:56,055
沿着文件位置，如果孩子 

1085
00:57:52,009 --> 00:57:59,014
知道 不读这本书是将它会看到 

1086
00:57:56,055 --> 00:58:01,069
这个从这个新的位置，这样就 可以 

1087
00:57:59,095 --> 00:58:01,102
为什么考试问题得到真正

1088
00:58:01,069 --> 00:58:05,140
有趣

1089
00:58:02,065 --> 00:58:07,141
因为这将跟踪 所有的 

1090
00:58:06,004 --> 00:58:13,012
这些不同的可能性 和 

1091
00:58:08,041 --> 00:58:15,750
他们会做不同的事情，所以 和 

1092
00:58:14,002 --> 00:58:17,098
那当然父母或 孩子 

1093
00:58:16,119 --> 00:58:19,960
可以开始打开和关闭自己 

1094
00:58:18,016 --> 00:58:22,665
文件以及，这将变得非常

1095
00:58:19,096 --> 00:58:25,995
混乱和这里就是你看到的原因 

1096
00:58:22,809 --> 00:58:30,700
这里有引用 计数，如果 

1097
00:58:26,859 --> 00:58:34,180
你有很多的分叉，然后去的 

1098
00:58:30,007 --> 00:58:39,103
您可以创建多个指向这个 

1099
00:58:34,018 --> 00:58:42,097
一个表条目，并以真 

1100
00:58:40,066 --> 00:58:46,093
真正关闭文件每一个都有 

1101
00:58:42,097 --> 00:58:48,486
调用关闭之前，该文件是真的 

1102
00:58:46,093 --> 00:58:56,532
从操作系统真正关闭

1103
00:58:49,359 --> 00:58:59,910
透视所以有 其他有趣的事情 

1104
00:58:57,369 --> 00:59:02,388
使生活变得有趣和太 

1105
00:58:59,091 --> 00:59:04,020
有助于考试题 

1106
00:59:02,559 --> 00:59:10,607
可能性是 什么 呢打电话叫 

1107
00:59:04,839 --> 00:59:10,841
重复数据删除 -和宗旨 的欺骗-是- 

1108
00:59:12,042 --> 00:59:21,097
原谅我重复在一个条目

1109
00:59:18,819 --> 00:59:24,827
描述符表和最常见的使用 

1110
00:59:21,097 --> 00:59:27,168
的这是一个IO重定向，要么 

1111
00:59:25,619 --> 00:59:31,420
大于或小于符号要么 

1112
00:59:28,068 --> 00:59:33,142
重定向宣读了代替 

1113
00:59:31,042 --> 00:59:36,115
从或而不是一个文件标准输入

1114
00:59:34,042 --> 00:59:39,651
写到标准输出写入到 

1115
00:59:37,015 --> 00:59:41,113
文件和路操作系统 

1116
00:59:40,029 --> 00:59:44,890
真正实现 即不久 

1117
00:59:42,013 --> 00:59:54,021
启动程序后， 它会调用 

1118
00:59:44,089 --> 00:59:56,508
叫杜克- 使它 从而使 

1119
00:59:54,021 --> 01:00:01,048
文件描述符1是不是标准 

1120
00:59:57,309 --> 01:00:04,390
输出这一过程，但它是 

1121
01:00:01,048 --> 01:00:07,069
其实原来的标准输出 

1122
01:00:04,039 --> 01:00:09,198
但它实际上是对一个描述符 

1123
01:00:07,069 --> 01:00:10,698
文件它应该 写入和 

1124
01:00:09,549 --> 01:00:12,550
同样，如果用它做输入

1125
01:00:11,319 --> 01:00:16,010
重定向

1126
01:00:12,055 --> 01:00:18,071
并且您也可以致电 公爵给自己 

1127
01:00:16,001 --> 01:00:22,009
做这类事情 和这些 

1128
01:00:18,071 --> 01:00:21,109
其实很好的理由这样做 

1129
01:00:25,084 --> 01:00:31,178
所以特别想像我打开文件 

1130
01:00:29,003 --> 01:00:39,020
和标准输出指向排序 

1131
01:00:32,078 --> 01:00:42,104
正常的事情，我打开一个 新的文件，我 

1132
01:00:39,002 --> 01:00:43,019
叫它B，然后我叫杜克原谅 

1133
01:00:43,004 --> 01:00:46,007
我

1134
01:00:43,037 --> 01:00:48,089
现在什么都文件描述符1 和 

1135
01:00:46,034 --> 01:00:50,129
对于共享 此文件描述符

1136
01:00:48,089 --> 01:00:53,174
在文件表项，您将看到 

1137
01:00:51,029 --> 01:00:57,032
的2个参考计数， 因此为了 

1138
01:00:54,074 --> 01:00:59,092
真正关闭它，然后 会是什么 

1139
01:00:57,032 --> 01:01:02,066
通常发生在这一点上是 

1140
01:00:59,092 --> 01:01:03,188
这是发生在开始之前你 

1141
01:01:02,066 --> 01:01:11,081
计划你想关闭文件

1142
01:01:04,088 --> 01:01:13,094
描述4，实际上还有很多 

1143
01:01:11,081 --> 01:01:16,127
错误的你可以不关闭使 

1144
01:01:13,094 --> 01:01:18,125
文件很容易犯错误的时候 

1145
01:01:17,027 --> 01:01:27,086
你必须 在 这些 多个 条目 

1146
01:01:19,025 --> 01:01:30,041
表YEP没有C，如果我把 这个关闭一个 

1147
01:01:27,086 --> 01:01:33,175
它只是坐在递减引用计数 

1148
01:01:30,041 --> 01:01:34,075
但是这 仍然是一个有效的项 在这里 

1149
01:01:35,044 --> 01:01:51,103
而肯定的，但由于意志减量 

1150
01:01:43,000 --> 01:01:53,092
原来 欺骗 的引用计数 

1151
01:01:52,003 --> 01:02:02,832
到会倒流，从那里 你想 

1152
01:01:53,092 --> 01:02:04,120
它应该这么做二是我想要的 

1153
01:02:02,859 --> 01:02:10,420
我提到的示例文件 

1154
01:02:05,002 --> 01:02:13,030
描述我想文件描述符到

1155
01:02:10,042 --> 01:02:15,951
变成什么样，我可以使用，并指 

1156
01:02:13,048 --> 01:02:18,417
与文件描述符1 这会 

1157
01:02:16,329 --> 01:02:24,000
实际上递减引用计数 

1158
01:02:18,849 --> 01:02:30,760
这是做之前做副本 

1159
01:02:24,000 --> 01:02:34,026
否则会造成类似的 

1160
01:02:30,076 --> 01:02:33,081
孤儿在此表中右 

1161
01:02:36,053 --> 01:02:45,068
哦，所以反正 欺骗2 还是一个功能强大 

1162
01:02:41,009 --> 01:02:47,096
但危险的机制， 那么现在终于 

1163
01:02:45,068 --> 01:02:50,132
让我 提更常见 

1164
01:02:48,077 --> 01:02:53,078
的I / O的应用程序是使用 

1165
01:02:51,032 --> 01:02:55,103
什么作为标准I / O和 

1166
01:02:53,078 --> 01:02:58,151
这就是在KNR记录，它的 

1167
01:02:56,003 --> 01:03:03,041
实际上C标准的一部分， 所有 

1168
01:02:59,051 --> 01:03:04,145
这些不同的功能， 因此在 

1169
01:03:03,041 --> 01:03:07,043
它增加了主要特点是有点像

1170
01:03:05,045 --> 01:03:09,128
你与选举事务处包看到它 

1171
01:03:07,043 --> 01:03:12,065
增加了缓冲，因此它没有做

1172
01:03:10,028 --> 01:03:21,071
这种低层次的 东西，它避免了所有 

1173
01:03:12,065 --> 01:03:23,087
比一些污秽和方式 

1174
01:03:21,071 --> 01:03:29,072
它的工作原理是什么，我们已经看到它

1175
01:03:23,087 --> 01:03:31,093
使用缓冲做VIO所以只是作为 

1176
01:03:29,081 --> 01:03:31,093
例

1177
01:03:44,068 --> 01:03:50,377
这里是一些调用printf 一个代码

1178
01:03:49,039 --> 01:03:58,930
角色在同一时间 以打印 字 

1179
01:03:50,989 --> 01:03:58,930
你好，但如果 我运行 ， 并 跟踪它 

1180
01:04:05,009 --> 01:04:10,044
你看到有只有一个系统 

1181
01:04:07,749 --> 01:04:13,180
呼叫两个 权利，它的工作原理 相同 

1182
01:04:10,359 --> 01:04:15,426
这样你用 它构建 了 里约热内卢 见到 代码 

1183
01:04:13,018 --> 01:04:20,116
一个缓冲区，它不是直到这个电话 

1184
01:04:16,029 --> 01:04:24,084
到F齐平，迫使输出 

1185
01:04:21,016 --> 01:04:26,017
实际上是一个打印输出通常 

1186
01:04:24,579 --> 01:04:31,596
该 自动发生，如果实际 

1187
01:04:26,017 --> 01:04:35,038
您打印一个换行符就会刷新 

1188
01:04:31,749 --> 01:04:45,807
它使我认为，称F是洗 

1189
01:04:35,038 --> 01:04:50,777
这里大概冗余谁谁那 

1190
01:04:46,329 --> 01:04:50,408
益处所以缓冲的I / O是更

1191
01:04:51,869 --> 01:05:04,908
高效的，因为它是因为 

1192
01:04:54,091 --> 01:05:06,540
缓冲这样的结果我们已经看到 

1193
01:05:05,259 --> 01:05:10,450
三种不同类型的I / O还有的 

1194
01:05:07,359 --> 01:05:13,390
低级别的 I / O叫你被称为 

1195
01:05:10,045 --> 01:05:14,050
UNIX I / O您看到这个包 是 

1196
01:05:13,039 --> 01:05:16,096
专门为这本书撰写和 

1197
01:05:14,095 --> 01:05:19,224
名为里约热内卢 ，然后 过程 

1198
01:05:16,096 --> 01:05:23,235
还有一个更大的，实际上 更丰富 

1199
01:05:20,079 --> 01:05:26,950
通过所提供的一组I / O的功能

1200
01:05:24,099 --> 01:05:29,230
UNIX标准库，所以你可能会问一个 

1201
01:05:26,095 --> 01:05:29,188
夫妇的问题一个很好的理由 

1202
01:05:29,023 --> 01:05:33,097
赫克你写这个，当你 

1203
01:05:30,088 --> 01:05:35,092
已经有了 ，如果如果 UNIX提供 

1204
01:05:33,097 --> 01:05:37,926
缓冲I / O 你为什么要自己做 

1205
01:05:35,092 --> 01:05:42,097
其原因是这 东西对不对 

1206
01:05:38,799 --> 01:05:45,801
作品真的很好的I / O你做 

1207
01:05:42,097 --> 01:05:47,406
终端或玷污，但它不会做 

1208
01:05:45,819 --> 01:05:50,820
非常好，网络连接 它 

1209
01:05:48,279 --> 01:05:53,470
是不是真的专为 等 

1210
01:05:50,829 --> 01:05:53,928
它就会真的搞砸等主 

1211
01:05:53,047 --> 01:05:56,406
原因你会发现自己 

1212
01:05:54,819 --> 01:05:59,470
使用这是当你开始 

1213
01:05:56,829 --> 01:06:02,829
使用网络连接哦 其他 

1214
01:05:59,047 --> 01:06:04,926
就是这些不 共存的很好 

1215
01:06:02,829 --> 01:06:06,852
缓冲I / O与reow的i / o 

1216
01:06:05,349 --> 01:06:08,400
因为它们各自保持自己的 

1217
01:06:07,059 --> 01:06:11,130
缓冲区， 他们不知道每个 

1218
01:06:08,859 --> 01:06:13,390
其他的，他们得到严重的混乱等等 

1219
01:06:11,769 --> 01:06:13,930
你种必须选择一个 或 

1220
01:06:13,039 --> 01:06:14,135
其他

1221
01:06:13,093 --> 01:06:16,166
对于任何 

1222
01:06:15,035 --> 01:06:25,037
满足特殊的I / O连接，不要试图 

1223
01:06:17,066 --> 01:06:27,092
混合所以就像我说的 UNIX与它们匹配

1224
01:06:25,055 --> 01:06:29,108
I / O，则 低级别从东西 

1225
01:06:27,092 --> 01:06:31,097
应用角度看，它就像 真的 

1226
01:06:30,008 --> 01:06:34,100
痛苦与短期特别 使用 

1227
01:06:31,097 --> 01:06:39,140
计数和错误代码，并和所有的 

1228
01:06:35,000 --> 01:06:42,002
的东西， 所以一般要 

1229
01:06:40,004 --> 01:06:44,051
无论是写自己的 包或使用 

1230
01:06:42,002 --> 01:06:46,076
其他一些包装它周围，使我 

1231
01:06:44,087 --> 01:06:48,143
该标准的I / O它给你的printf 

1232
01:06:46,094 --> 01:06:51,163
和scanf 而所有这些不错的功能 

1233
01:06:49,043 --> 01:07:00,137
这是它存在于所有系统的统一 

1234
01:06:52,063 --> 01:07:04,076
它是合理的标准化，从而在 

1235
01:07:01,037 --> 01:07:07,130
一般然后使用标准的I / O 

1236
01:07:04,076 --> 01:07:12,131
对于一天到一天的用途最年

1237
01:07:08,003 --> 01:07:16,052
文件我将使用原始IO 低 级别 

1238
01:07:13,031 --> 01:07:20,045
东西时，你必须 和 像 部分 

1239
01:07:16,079 --> 01:07:21,104
事实证明，信号不是你 

1240
01:07:20,045 --> 01:07:24,074
当你不应该使用标准I / O 

1241
01:07:22,004 --> 01:07:26,051
编写信号处理程序，然后REO 

1242
01:07:24,074 --> 01:07:29,156
你会找到有用 

1243
01:07:26,051 --> 01:07:34,108
特别是做 一个 网络 

1244
01:07:30,056 --> 01:07:36,155
其他的事情，你应该一个错误， 

1245
01:07:35,008 --> 01:07:41,021
学生在此做了一遍又一遍 

1246
01:07:37,055 --> 01:07:44,117
当然是他们试图 做定向的线 

1247
01:07:41,021 --> 01:07:47,045
我的事情是不是线 / O 等等之类 

1248
01:07:45,017 --> 01:07:48,113
JPEG 图像或 类似的东西和 

1249
01:07:47,045 --> 01:07:52,058
这是很重要的原因是 ， 

1250
01:07:49,013 --> 01:07:55,040
这些功能 是治疗结束 

1251
01:07:52,058 --> 01:07:56,120
行字符零是一个非常特殊的 

1252
01:07:55,004 --> 01:07:58,013
性格，他们会停下来读取或 

1253
01:07:57,002 --> 01:08:02,015
类似的东西，或者如果它是怎么回事 

1254
01:07:59,003 --> 01:08:04,058
Windows 和UNIX之间它会 

1255
01:08:02,033 --> 01:08:06,080
真正 改变一个从车厢 

1256
01:08:04,085 --> 01:08:08,090
从换行返回到托架

1257
01:08:06,008 --> 01:08:10,097
换行罪路功能，如

1258
01:08:09,035 --> 01:08:13,112
引导 土地和引导副本时停止 

1259
01:08:11,069 --> 01:08:14,078
他们打空字节，这不是什么

1260
01:08:14,012 --> 01:08:19,040
你想，当这些做网络

1261
01:08:15,059 --> 01:08:21,098
你想包发送出去，所以要 

1262
01:08:19,004 --> 01:08:24,213
小心一些，您对功能 

1263
01:08:21,098 --> 01:08:26,105
使用了很多， 你很熟悉 

1264
01:08:24,609 --> 01:08:30,340
可能是完全不合适的 

1265
01:08:27,068 --> 01:08:32,159
事情，你正在做的二进制 

1266
01:08:30,034 --> 01:08:35,075
数据或者 您进行通信 

1267
01:08:33,059 --> 01:08:37,136
网络之类 的东西，所以一定 

1268
01:08:35,075 --> 01:08:39,134
你知道 你在做 什么 时 

1269
01:08:38,036 --> 01:08:44,120
你开始使用这些种功能 

1270
01:08:40,034 --> 01:08:47,063
哦， 所以那些你 真的想知道 

1271
01:08:45,002 --> 01:08:48,098
这 东西 有有一个老乡 

1272
01:08:47,063 --> 01:08:54,128
名叫理查德·史蒂文斯不幸的是谁 

1273
01:08:49,016 --> 01:08:57,092
死了一段时间 前一段时间，但他的 

1274
01:08:55,028 --> 01:08:59,105
书籍住在这里面的各种各样的人

1275
01:08:57,092 --> 01:09:04,121
已经签约成为合作作者用 

1276
01:09:00,005 --> 01:09:08,056
他在他的缺席，并创造 新的 

1277
01:09:05,021 --> 01:09:11,030
这些书是用来版本

1278
01:09:08,056 --> 01:09:13,094
追溯到方式到目前为止，如果你真的 

1279
01:09:12,011 --> 01:09:16,043
想知道 这个东西是如何工作的 你 

1280
01:09:13,094 --> 01:09:17,156
想 成为 程序员第八 这些 

1281
01:09:16,043 --> 01:09:21,071
书籍是最好的，你可以得到 ，但我会 

1282
01:09:18,056 --> 01:09:25,060
也提醒你你的书架将成为 

1283
01:09:21,071 --> 01:09:27,137
很重担，因为有有

1284
01:09:25,006 --> 01:09:30,023
体积的一种二和三， 然后 

1285
01:09:28,037 --> 01:09:33,044
有网络书籍和史蒂文斯 

1286
01:09:30,077 --> 01:09:34,115
像百科全书参考，但

1287
01:09:33,044 --> 01:09:36,044
他们是优秀的书籍，如果你真的 

1288
01:09:35,015 --> 01:09:40,022
想了解的东西 

1289
01:09:36,044 --> 01:09:43,088
阅读史蒂文斯噢，还有 另一本书 

1290
01:09:40,022 --> 01:09:45,119
这 仅仅是具体到Linux这 

1291
01:09:43,088 --> 01:09:48,101
相当不错的， 有点它是非常 

1292
01:09:46,019 --> 01:09:50,081
详细，但因为 它只是试图 

1293
01:09:49,001 --> 01:09:54,008
对付Linux的是有点少 

1294
01:09:50,081 --> 01:09:56,114
不是试图去阅读史蒂文斯 的 怪异 

1295
01:09:54,071 --> 01:09:58,073
因为史蒂文斯将在这个版本说

1296
01:09:57,014 --> 01:10:00,050
UNIX的是这样工作 在这 

1297
01:09:58,091 --> 01:10:01,154
版本，它的工作原理是这样等等等等 

1298
01:10:00,005 --> 01:10:04,100
等等这一切都不同 ，它会 

1299
01:10:02,054 --> 01:10:10,078
你发疯 ，但史蒂文斯仍然是 

1300
01:10:05,045 --> 01:10:12,053
这是一个优秀的一套书确定，所以 

1301
01:10:10,078 --> 01:10:13,172
这是一个例子，我不打算 

1302
01:10:13,025 --> 01:10:16,097
通过它，但这些都是 那种 

1303
01:10:14,072 --> 01:10:19,121
的事情，我们 用它来 折磨学生 

1304
01:10:16,097 --> 01:10:22,160
您打开某些文件的描述符和 

1305
01:10:20,021 --> 01:10:26,057
你做一些受骗者和你做一些福克斯 

1306
01:10:23,006 --> 01:10:29,039
所以你结束了一个真正的意大利面条 

1307
01:10:26,057 --> 01:10:31,112
所有指针和分享的内容 

1308
01:10:29,093 --> 01:10:34,121
而什么是不共享的，然后你问 

1309
01:10:32,012 --> 01:10:36,098
是什么内容的打印，当然你 

1310
01:10:35,021 --> 01:10:40,093
要通过很详细追查

1311
01:10:36,098 --> 01:10:41,185
到底发生了什么的所以这些都是 

1312
01:10:40,093 --> 01:10:44,125
在这本书，我建议你在工作 

1313
01:10:42,085 --> 01:10:46,170
其中一些好吗 那将做它 

1314
01:10:45,025 --> 01:10:47,070
那么今天

