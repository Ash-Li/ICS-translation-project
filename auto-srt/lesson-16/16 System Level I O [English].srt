1
00:00:00,003 --> 00:00:06,102
good afternoon everyone so I apologize I

2
00:00:05,019 --> 00:00:08,103
have to I'm going to sit mostly through

3
00:00:07,002 --> 00:00:11,291
this lecture I managed to do something

4
00:00:09,003 --> 00:00:14,091
to my knee yesterday and I'm having

5
00:00:11,309 --> 00:00:17,323
trouble moving around very much but

6
00:00:14,091 --> 00:00:20,156
today what we're going to talk about is

7
00:00:17,449 --> 00:00:24,515
input/output what it looks like from the

8
00:00:21,056 --> 00:00:27,093
programmers perspective and this is a

9
00:00:25,109 --> 00:00:31,166
you've already learned instead of a lot

10
00:00:27,093 --> 00:00:34,176
of the standard UNIX libraries for like

11
00:00:31,679 --> 00:00:37,694
printf and scanf and those routines and

12
00:00:35,076 --> 00:00:38,157
we'll talk about them a little but what

13
00:00:37,829 --> 00:00:42,210
will first talk about is actually lower

14
00:00:39,057 --> 00:00:44,093
level i/o stuff that is directly

15
00:00:42,021 --> 00:00:46,850
interfacing to the operating system and

16
00:00:44,093 --> 00:00:49,101
this is what you're going to need to

17
00:00:47,039 --> 00:00:52,410
learn about partly some of this material

18
00:00:50,001 --> 00:00:54,800
you're going to need for the next web

19
00:00:52,041 --> 00:00:59,064
that comes out at midnight tonight the

20
00:00:54,809 --> 00:01:01,680
shell lab and you'll need to also you'll

21
00:00:59,064 --> 00:01:03,623
be revisiting this several other labs

22
00:01:01,068 --> 00:01:09,077
along the course including the final web

23
00:01:04,199 --> 00:01:13,500
the the web proxy web so this is sort of

24
00:01:09,077 --> 00:01:15,150
where we're we're really digging down

25
00:01:13,005 --> 00:01:18,030
deeply into this type of programming you

26
00:01:16,005 --> 00:01:21,048
do if you're writing system software

27
00:01:18,075 --> 00:01:24,090
things that are very just barely above

28
00:01:21,093 --> 00:01:28,142
the operating system level and I know

29
00:01:24,009 --> 00:01:31,268
for myself of learning this material I

30
00:01:28,979 --> 00:01:35,070
actually learned this material from 213

31
00:01:32,159 --> 00:01:36,270
my co-author David Halloran is the one

32
00:01:35,007 --> 00:01:38,013
who knew this stuff already

33
00:01:36,027 --> 00:01:40,050
he wrote that part of the book I learned

34
00:01:38,067 --> 00:01:42,111
it by reading the book just like you are

35
00:01:40,005 --> 00:01:44,554
but I found it actually very useful to

36
00:01:43,011 --> 00:01:46,107
know and a variety of different other

37
00:01:45,049 --> 00:01:50,120
situations I've been in in the meantime

38
00:01:47,007 --> 00:01:53,034
this is quite a few years ago and so I

39
00:01:50,759 --> 00:01:54,930
think it's worth understanding and I'll

40
00:01:53,034 --> 00:01:58,086
also mention this kind of material

41
00:01:54,093 --> 00:02:01,532
usually is taught you don't really see

42
00:01:58,086 --> 00:02:03,102
it covered in most books except for ones

43
00:02:02,369 --> 00:02:06,422
that are really oriented toward system

44
00:02:04,002 --> 00:02:09,075
programmers and are fairly arcane or you

45
00:02:06,899 --> 00:02:11,933
try and learn it by reading man pages

46
00:02:09,075 --> 00:02:12,090
and that's a fairly cryptic way to try

47
00:02:12,239 --> 00:02:16,260
and understand

48
00:02:12,009 --> 00:02:17,103
and a sort of a set of abstractions

49
00:02:16,026 --> 00:02:23,315
provided by an API so I hope you'll find

50
00:02:18,084 --> 00:02:24,623
this useful so what we'll talk about

51
00:02:23,549 --> 00:02:28,650
then is that what I mentioned this

52
00:02:25,379 --> 00:02:31,418
low-level i/o that I supported by UNIX

53
00:02:28,065 --> 00:02:34,244
and other related operating systems and

54
00:02:31,769 --> 00:02:38,774
then a package called Rio which stands

55
00:02:34,829 --> 00:02:41,890
to robust IO oh and you will actually

56
00:02:38,819 --> 00:02:46,170
not be using this package until the last

57
00:02:42,439 --> 00:02:48,750
lab for the course the proxy lab at

58
00:02:46,017 --> 00:02:51,069
which time you'll use it a lot but it's

59
00:02:48,075 --> 00:02:52,140
worth looking at and partly it's in the

60
00:02:51,069 --> 00:02:55,538
book it's well documented in the book

61
00:02:53,004 --> 00:02:58,403
and if you really want to understand how

62
00:02:56,159 --> 00:03:01,170
software works or a system works the

63
00:02:58,799 --> 00:03:02,840
best thing you can do is if you've if it

64
00:03:01,017 --> 00:03:05,031
there's good quality source code to look

65
00:03:03,209 --> 00:03:08,280
at and study you can learn a lot from

66
00:03:05,031 --> 00:03:10,160
doing that and I really recommend for

67
00:03:08,028 --> 00:03:12,707
that chapter in the book that you go

68
00:03:10,439 --> 00:03:14,522
ahead and study all of the code that

69
00:03:12,959 --> 00:03:18,962
makes up Rio it's not a huge amount and

70
00:03:15,269 --> 00:03:21,150
just getting for the subtlety is

71
00:03:18,989 --> 00:03:23,250
involved in how you deal with errors how

72
00:03:21,015 --> 00:03:27,254
you deal with exceptional conditions and

73
00:03:23,025 --> 00:03:30,104
things like that and then we'll talk to

74
00:03:27,389 --> 00:03:32,250
them about how files are represented the

75
00:03:30,329 --> 00:03:36,000
sort of various data structures behind

76
00:03:32,025 --> 00:03:39,084
files how they support standard i/o and

77
00:03:36,000 --> 00:03:43,979
i/o redirection and unix and also talk

78
00:03:39,084 --> 00:03:44,181
about the so-called buffered i/o the i/o

79
00:03:43,979 --> 00:03:50,033
that you're more familiar with and see

80
00:03:45,081 --> 00:03:52,250
when you use printf and scanf so UNIX

81
00:03:50,519 --> 00:03:54,575
actually has a much simpler and more

82
00:03:52,979 --> 00:03:57,090
unified view of i/o than any other

83
00:03:55,079 --> 00:04:00,131
operating system it's one of the nice

84
00:03:57,009 --> 00:04:02,738
design features of it is that a lot of

85
00:04:00,599 --> 00:04:05,621
abstractions are built into the notion

86
00:04:02,819 --> 00:04:07,901
of a file and a file is really just a

87
00:04:05,819 --> 00:04:10,530
sequence of bytes and in UNIX does not

88
00:04:08,639 --> 00:04:13,721
distinguish between different classes of

89
00:04:10,053 --> 00:04:16,382
files unlike say Windows or earlier

90
00:04:14,459 --> 00:04:18,524
versions of Macintosh operating system

91
00:04:16,859 --> 00:04:20,912
it just thanks to them as fights and the

92
00:04:19,109 --> 00:04:24,240
operating system level has essentially

93
00:04:21,389 --> 00:04:26,910
no understanding of a more detailed

94
00:04:24,024 --> 00:04:30,040
structure inside of a file

95
00:04:26,091 --> 00:04:32,091
and one of the things it does is a file

96
00:04:30,004 --> 00:04:35,101
is normally originally thought of is

97
00:04:32,091 --> 00:04:38,113
something that stored on say a disk

98
00:04:36,037 --> 00:04:42,112
drive or some other external storage

99
00:04:39,013 --> 00:04:45,097
device and that you open you read it or

100
00:04:43,012 --> 00:04:48,097
write it you close it those sort of

101
00:04:45,097 --> 00:04:51,124
standard operations but UNIX also use

102
00:04:48,097 --> 00:04:54,109
the notion of a file to represent many

103
00:04:52,024 --> 00:05:00,025
other different things including for

104
00:04:55,009 --> 00:05:01,018
example the devices that are the i/o

105
00:05:00,025 --> 00:05:04,072
devices that are connected to a

106
00:05:01,099 --> 00:05:07,150
particular machine the tty stands for

107
00:05:04,072 --> 00:05:11,113
teletype which is a antique terminology

108
00:05:08,005 --> 00:05:14,074
for how people used to actually

109
00:05:12,013 --> 00:05:17,104
interface typewriters to computers the

110
00:05:15,019 --> 00:05:20,098
other thing that our viewed as like

111
00:05:18,004 --> 00:05:23,100
files are the network connections what

112
00:05:20,098 --> 00:05:25,180
are known as sockets and when you do

113
00:05:24,000 --> 00:05:30,004
communication over the Internet you do

114
00:05:26,008 --> 00:05:33,012
it by you send a message by writing to a

115
00:05:30,004 --> 00:05:36,052
socket and you accept incoming

116
00:05:34,002 --> 00:05:41,065
communication by reading from a socket

117
00:05:36,052 --> 00:05:43,093
and so the same low-level of API is the

118
00:05:41,083 --> 00:05:46,099
same whether you're reading or writing

119
00:05:43,093 --> 00:05:49,116
files on your disk drive or sending

120
00:05:46,099 --> 00:05:49,116
packets over the Internet

121
00:05:54,025 --> 00:05:58,123
so the core operations then associated

122
00:05:57,028 --> 00:06:00,037
with files of course are opening and

123
00:05:59,023 --> 00:06:04,102
closing them and reading and writing

124
00:06:01,018 --> 00:06:07,039
them the other sort of attribute that's

125
00:06:05,002 --> 00:06:10,069
associated with most but not all files

126
00:06:07,039 --> 00:06:12,121
is what's called the file position so

127
00:06:10,069 --> 00:06:14,077
again if you imagine when you're reading

128
00:06:13,021 --> 00:06:16,075
from a file you don't want to always

129
00:06:14,077 --> 00:06:18,154
start at the beginning every time you do

130
00:06:16,075 --> 00:06:20,083
a read you you read some data and then

131
00:06:19,054 --> 00:06:23,152
you read some more data and so that's a

132
00:06:21,055 --> 00:06:27,121
tracked by a file position which is just

133
00:06:24,052 --> 00:06:30,094
a counter that says how many bytes has

134
00:06:28,021 --> 00:06:33,097
have been written read from this file so

135
00:06:30,094 --> 00:06:36,103
far so that I know where to go and you

136
00:06:33,097 --> 00:06:38,194
can actually even alter that value with

137
00:06:37,003 --> 00:06:42,049
a various classes operation called

138
00:06:39,094 --> 00:06:44,109
seeking which is just a way of changing

139
00:06:42,049 --> 00:06:46,138
the file pointer the position pointer

140
00:06:45,009 --> 00:06:49,102
now that doesn't work too well if your

141
00:06:47,038 --> 00:06:54,039
input is a terminal where you can't move

142
00:06:50,002 --> 00:06:57,043
you can't sort of back up and have a

143
00:06:54,039 --> 00:06:59,041
recover data that was presented to it

144
00:06:57,043 --> 00:07:01,048
earlier or jump ahead and start

145
00:06:59,059 --> 00:07:03,133
accepting data that hasn't been typed

146
00:07:01,048 --> 00:07:06,085
yet so there's some kinds of files have

147
00:07:04,033 --> 00:07:08,107
a file position and seeking and others

148
00:07:06,085 --> 00:07:11,179
don't similarly to a network socket you

149
00:07:09,007 --> 00:07:15,040
can't jump up socket for it in time you

150
00:07:12,079 --> 00:07:19,093
can only read or write the particular

151
00:07:15,004 --> 00:07:22,018
packet as they come in but in general

152
00:07:19,093 --> 00:07:24,169
think of it then is the file position as

153
00:07:22,054 --> 00:07:28,063
part of the the data associated with an

154
00:07:25,069 --> 00:07:34,069
open file that tells me how far along in

155
00:07:28,063 --> 00:07:36,088
this file have I read or written and

156
00:07:34,069 --> 00:07:37,102
then again the files there because

157
00:07:36,088 --> 00:07:40,093
there's all these different things

158
00:07:38,002 --> 00:07:42,711
they're sort of unified in this file

159
00:07:40,093 --> 00:07:44,170
abstraction but obviously there's

160
00:07:42,729 --> 00:07:48,820
differences and different attributes to

161
00:07:45,007 --> 00:07:49,075
them and so there's sort of many

162
00:07:48,082 --> 00:07:51,159
different categories and subcategories

163
00:07:50,038 --> 00:07:54,106
but the ones we'll think about our a

164
00:07:52,059 --> 00:07:57,067
regular files to think of things that

165
00:07:55,006 --> 00:08:02,865
are on a disk drive directories which is

166
00:07:58,039 --> 00:08:04,126
a directory is considered a type of file

167
00:08:02,919 --> 00:08:06,984
meaning the data that's in there is just

168
00:08:05,026 --> 00:08:09,735
enough as a file but of course

169
00:08:07,569 --> 00:08:10,662
it's a special kind of file and that it

170
00:08:09,969 --> 00:08:14,061
actually does have an interpretation

171
00:08:11,499 --> 00:08:16,503
that entries in that file describe the

172
00:08:14,889 --> 00:08:19,950
locations and attributes of other files

173
00:08:16,899 --> 00:08:24,900
and then as I mentioned the term socket

174
00:08:20,499 --> 00:08:26,860
is a connection to a network and it's

175
00:08:24,999 --> 00:08:29,064
both for sending and for receiving

176
00:08:26,086 --> 00:08:30,138
messages over the network there's other

177
00:08:29,649 --> 00:08:34,716
files that we won't really talk about

178
00:08:31,038 --> 00:08:40,087
for example when you pipe when you from

179
00:08:35,319 --> 00:08:43,000
one application to another that both the

180
00:08:40,087 --> 00:08:44,161
output of the first program and the

181
00:08:43,000 --> 00:08:50,399
input of the second are special types of

182
00:08:45,061 --> 00:08:53,122
files called pipes and they're handled

183
00:08:50,399 --> 00:08:56,620
by writing is putting something into the

184
00:08:54,022 --> 00:08:59,041
pipe and reading is to take something

185
00:08:56,062 --> 00:09:00,711
out of that pipe a similar something

186
00:08:59,041 --> 00:09:03,106
called a symbolic link which is just a

187
00:09:01,269 --> 00:09:06,130
way that you can have multiple names for

188
00:09:04,006 --> 00:09:13,515
a file and pointers to a file that

189
00:09:06,013 --> 00:09:15,088
aren't really without having to make

190
00:09:13,569 --> 00:09:18,910
separate copies of a file and then other

191
00:09:15,088 --> 00:09:21,897
special types of devices so we won't

192
00:09:18,091 --> 00:09:24,097
really we'll only consider the first

193
00:09:22,689 --> 00:09:34,120
three types of files and in fact for

194
00:09:24,097 --> 00:09:35,122
today mostly the first two so the idea

195
00:09:34,012 --> 00:09:38,023
of a file then is it just contains

196
00:09:36,022 --> 00:09:40,941
arbitrary data and the operating system

197
00:09:38,023 --> 00:09:43,062
really for regular file doesn't try to

198
00:09:41,139 --> 00:09:46,720
get into the details of what's inside

199
00:09:43,269 --> 00:09:48,294
that file and there's some class of

200
00:09:46,072 --> 00:09:51,611
applications that will distinguish

201
00:09:48,519 --> 00:09:54,543
between a text file and a binary file

202
00:09:52,259 --> 00:09:57,790
not really at the operating system level

203
00:09:54,759 --> 00:10:00,790
but more higher levels and the main

204
00:09:57,079 --> 00:10:02,928
difference with that is that a text file

205
00:10:00,079 --> 00:10:06,172
should only have the standard characters

206
00:10:03,639 --> 00:10:10,480
of ASCII or another class would be

207
00:10:07,072 --> 00:10:14,073
various encoding that allow you to do in

208
00:10:10,048 --> 00:10:17,097
coatings of non-english alphabets and

209
00:10:14,073 --> 00:10:20,092
binary files would be things like an

210
00:10:17,529 --> 00:10:26,553
image or a actual

211
00:10:20,092 --> 00:10:28,180
a code or a video or audio file or

212
00:10:26,769 --> 00:10:32,050
something that it's the you're within

213
00:10:29,008 --> 00:10:33,046
that code there's a sequence of bytes

214
00:10:32,005 --> 00:10:41,904
that are encoding numbers in some form

215
00:10:34,018 --> 00:10:44,047
directly and then the main thing about a

216
00:10:41,949 --> 00:10:47,982
text file is that there are certain

217
00:10:44,047 --> 00:10:50,074
functions that distinguish a newline

218
00:10:48,279 --> 00:10:54,010
character meaning the end of it line of

219
00:10:50,074 --> 00:10:57,106
text and you already learned about that

220
00:10:54,001 --> 00:11:00,630
character it's got the code of a zero a

221
00:10:58,006 --> 00:11:03,345
as a bytecode and that became one of the

222
00:11:00,639 --> 00:11:05,664
forbidden codes of your attacks because

223
00:11:03,399 --> 00:11:10,690
it would be interpreted as a newline by

224
00:11:05,889 --> 00:11:13,000
the function get ass just to mention

225
00:11:10,069 --> 00:11:14,328
that and this is one place when you're

226
00:11:13,000 --> 00:11:18,699
transferring files between say a Windows

227
00:11:14,949 --> 00:11:21,070
machine and a Linux or a Mac one of the

228
00:11:18,699 --> 00:11:24,100
things if it's a text file that has to

229
00:11:21,007 --> 00:11:25,836
be changed is the two classes of systems

230
00:11:24,001 --> 00:11:28,009
have different ways of interpreting of

231
00:11:25,899 --> 00:11:33,190
encoding when is the end of a line and

232
00:11:28,018 --> 00:11:37,066
in a Linux or Mac file it's just this

233
00:11:33,019 --> 00:11:41,092
character code a which stands for line

234
00:11:37,066 --> 00:11:44,080
feed where's the windows files finish

235
00:11:41,092 --> 00:11:46,096
with a tooth character end of line

236
00:11:44,008 --> 00:11:48,091
carriage return in line feed and I show

237
00:11:47,032 --> 00:11:52,060
you this picture of an object that

238
00:11:49,063 --> 00:11:53,832
you've probably only seen in museum but

239
00:11:52,006 --> 00:11:55,605
it's a typewriter and just to tell you

240
00:11:54,399 --> 00:11:57,486
what the heck is the carriage return and

241
00:11:56,199 --> 00:11:59,860
what's the line feed I thought you might

242
00:11:58,269 --> 00:12:02,880
like to in case you've never actually

243
00:11:59,086 --> 00:12:05,685
used an old-fashioned typewriter

244
00:12:02,088 --> 00:12:08,116
basically at the end of us on the left

245
00:12:06,459 --> 00:12:14,230
hand side of a typewriter is this bar

246
00:12:09,016 --> 00:12:18,097
and when you start typing along I'll the

247
00:12:14,023 --> 00:12:22,932
page the this roller with your page on

248
00:12:18,097 --> 00:12:23,179
it sinks along and it comes to the end

249
00:12:23,139 --> 00:12:26,196
and then you want to get back to the

250
00:12:24,079 --> 00:12:29,083
beginning of the next line so you want

251
00:12:26,709 --> 00:12:33,970
to both do the carriage return which is

252
00:12:30,019 --> 00:12:34,728
this thing shove it to the right and you

253
00:12:33,097 --> 00:12:37,102
want to do a line

254
00:12:34,899 --> 00:12:41,910
feed you want the roller on it to go

255
00:12:38,047 --> 00:12:43,536
down to the next line so there's a knob

256
00:12:42,009 --> 00:12:45,072
here that you can twist by hand but in

257
00:12:43,959 --> 00:12:48,027
general what you do is you type along

258
00:12:45,639 --> 00:12:51,702
and then you go slam like that and this

259
00:12:48,639 --> 00:12:57,550
lever both pushes the thing back and it

260
00:12:52,269 --> 00:13:00,270
rotates the the roller by one lines

261
00:12:57,055 --> 00:13:03,204
worth and so carriage return line feed

262
00:13:00,279 --> 00:13:10,302
is where that actually comes from in

263
00:13:03,699 --> 00:13:12,910
case you wonder and then a directory as

264
00:13:10,509 --> 00:13:15,100
I mentioned it's it's stored as a file

265
00:13:12,091 --> 00:13:16,860
but it's a file that the operating

266
00:13:15,001 --> 00:13:19,039
system eats the filesystem part of the

267
00:13:17,679 --> 00:13:21,738
operating system actually interprets in

268
00:13:19,048 --> 00:13:24,097
very specific ways and as you know

269
00:13:22,269 --> 00:13:27,730
within every directory there's two

270
00:13:24,097 --> 00:13:29,826
special files dot and dot dot referring

271
00:13:27,073 --> 00:13:36,160
to the local file and its parent in the

272
00:13:30,699 --> 00:13:38,787
tree structure and so in in most systems

273
00:13:37,006 --> 00:13:40,093
systems that I know of there's a sort of

274
00:13:39,579 --> 00:13:43,655
hierarchical organization to the files

275
00:13:41,047 --> 00:13:48,336
we're not going to talk much about file

276
00:13:44,339 --> 00:13:52,540
systems but there's a hierarchical

277
00:13:48,759 --> 00:13:55,990
organization and that maintained this a

278
00:13:52,054 --> 00:13:57,603
series of files each being the directory

279
00:13:55,099 --> 00:13:59,558
and the directory then it's a pointer to

280
00:13:58,089 --> 00:14:03,186
its sub directory which again are files

281
00:14:00,449 --> 00:14:06,220
and so what's referred to in UNIX

282
00:14:04,059 --> 00:14:08,124
terminology and most other operating

283
00:14:06,022 --> 00:14:14,001
systems what's known as a path name is a

284
00:14:08,709 --> 00:14:17,714
way to navigate through this hierarchy

285
00:14:14,199 --> 00:14:23,790
of files and identify one particular one

286
00:14:17,759 --> 00:14:24,783
and so that all comes to say that the

287
00:14:23,079 --> 00:14:26,298
low-level

288
00:14:24,999 --> 00:14:29,920
UNIX operations that use to implement

289
00:14:27,009 --> 00:14:31,720
this are to open a file to read it and

290
00:14:29,092 --> 00:14:32,301
write it and to close it and those

291
00:14:31,072 --> 00:14:35,691
literally those are the names of the

292
00:14:33,129 --> 00:14:39,147
functions so the open function then you

293
00:14:36,339 --> 00:14:41,367
give a path name and remember pathnames

294
00:14:39,309 --> 00:14:45,372
can be absolute meaning that they start

295
00:14:41,619 --> 00:14:47,712
with a slash and they go all the way

296
00:14:45,939 --> 00:14:49,000
down the hierarchy they can be relative

297
00:14:48,549 --> 00:14:50,770
to

298
00:14:49,000 --> 00:14:56,041
particular whatever your current

299
00:14:50,077 --> 00:14:58,108
directory is where and they can also be

300
00:14:56,041 --> 00:15:04,123
relative to a user if you use the tilde

301
00:14:59,008 --> 00:15:07,069
slash or tilde L then that sort of a

302
00:15:05,023 --> 00:15:10,060
shortcut in this path name to get to

303
00:15:07,069 --> 00:15:11,146
particular users so a path name can be

304
00:15:10,006 --> 00:15:14,071
any of those forms when you open it it

305
00:15:12,046 --> 00:15:17,089
just has to be some way that just like

306
00:15:15,025 --> 00:15:19,111
you specify in other places that you

307
00:15:17,089 --> 00:15:23,125
tell where this particular file is

308
00:15:20,011 --> 00:15:27,012
you're trying to open and so it's given

309
00:15:24,025 --> 00:15:30,028
a path name and then it's given a

310
00:15:27,012 --> 00:15:32,041
integer code that says what do you want

311
00:15:30,028 --> 00:15:33,121
to do when you open this file

312
00:15:32,041 --> 00:15:37,108
in what form do you want to open it and

313
00:15:34,021 --> 00:15:41,026
that specified die series of constants

314
00:15:38,008 --> 00:15:46,015
that are already predefined when you

315
00:15:41,026 --> 00:15:48,115
include the propria and you can and

316
00:15:46,078 --> 00:15:52,111
those actually get bitwise each of those

317
00:15:49,015 --> 00:15:56,106
is a one bit flag in a power of two

318
00:15:53,011 --> 00:16:00,046
position or it's a position one bit in a

319
00:15:57,006 --> 00:16:02,014
field somewhere and so you can logically

320
00:16:00,046 --> 00:16:05,085
or those together if you want multiple

321
00:16:02,014 --> 00:16:10,027
combinations so for example I can say

322
00:16:05,085 --> 00:16:12,151
read-only I can say read and write I can

323
00:16:10,027 --> 00:16:15,100
say append meaning don't if I'm opening

324
00:16:13,051 --> 00:16:16,147
it to write don't begin it the don't

325
00:16:16,000 --> 00:16:19,000
start writing at the beginning start

326
00:16:17,047 --> 00:16:21,073
writing it wherever the end of the file

327
00:16:19,000 --> 00:16:25,021
is now so all those can be down to this

328
00:16:21,073 --> 00:16:28,105
is described in the book by using the

329
00:16:25,021 --> 00:16:31,027
right set of names of constants and

330
00:16:29,005 --> 00:16:33,037
oaring them together and that will

331
00:16:31,081 --> 00:16:35,110
return something that's called a file

332
00:16:33,037 --> 00:16:37,135
descriptor and that's a very important

333
00:16:36,001 --> 00:16:39,007
idea that and one of the reasons why

334
00:16:38,035 --> 00:16:40,123
we're talking about this today this is

335
00:16:39,007 --> 00:16:42,073
going to be very important in your lab

336
00:16:41,023 --> 00:16:48,132
it's the notion of a file descriptor

337
00:16:43,036 --> 00:16:50,095
which is just a small integer that lists

338
00:16:48,339 --> 00:16:53,140
which particular one of the open files

339
00:16:50,095 --> 00:16:56,104
that's being used by this particular

340
00:16:53,014 --> 00:17:00,070
program are you referring to and so it's

341
00:16:57,085 --> 00:17:01,156
a small number because these are a time

342
00:17:00,007 --> 00:17:05,011
sequentially when you

343
00:17:02,056 --> 00:17:08,127
in your program than you run and you're

344
00:17:06,001 --> 00:17:12,046
in fact limited on most machines to some

345
00:17:09,027 --> 00:17:14,466
some bounded number of open files you're

346
00:17:12,055 --> 00:17:20,137
allowed to have at any time in fact if

347
00:17:14,709 --> 00:17:26,790
you go to see on if you're on the

348
00:17:21,037 --> 00:17:26,079
machine and you type in limits limit

349
00:17:29,033 --> 00:17:35,055
you'll see there that entry called

350
00:17:31,074 --> 00:17:37,083
descriptors 10:24 says that you can't

351
00:17:35,055 --> 00:17:40,071
have more than a thousand 24 files open

352
00:17:38,064 --> 00:17:42,138
at any given time and in fact if you've

353
00:17:40,071 --> 00:17:43,080
got a thousand 24 files open it's a

354
00:17:43,038 --> 00:17:46,125
chance you're doing something really

355
00:17:44,061 --> 00:17:48,066
seriously wrong being that you haven't

356
00:17:47,025 --> 00:17:50,111
been closing the files you should be

357
00:17:48,066 --> 00:17:50,111
closing

358
00:17:58,059 --> 00:18:05,082
and all of the system calls including

359
00:18:02,429 --> 00:18:08,450
these always have a return code and the

360
00:18:05,082 --> 00:18:10,571
return codes vary sometimes a negative

361
00:18:08,639 --> 00:18:14,190
number is an error sometimes a zero is

362
00:18:11,309 --> 00:18:16,406
an error they're all different and all

363
00:18:14,019 --> 00:18:18,087
confusing and all inscrutable so you

364
00:18:17,279 --> 00:18:22,740
have to look at the documentation for

365
00:18:18,087 --> 00:18:23,756
every single one of those functions and

366
00:18:22,074 --> 00:18:27,593
one of the the rules we're going to

367
00:18:24,539 --> 00:18:29,850
hammer away at in this course is every

368
00:18:28,259 --> 00:18:32,324
time you make a system call you should

369
00:18:29,085 --> 00:18:33,159
check the return code to see if there's

370
00:18:32,909 --> 00:18:35,984
an error and then do some appropriate

371
00:18:34,059 --> 00:18:38,082
way of handling the error that's just a

372
00:18:36,659 --> 00:18:39,746
practice it's a pain in the butt it

373
00:18:38,082 --> 00:18:42,087
makes your code look like a rat's nest

374
00:18:40,529 --> 00:18:44,588
of conditionals is you really would

375
00:18:43,032 --> 00:18:46,841
rather not because often there's an

376
00:18:45,119 --> 00:18:48,182
error you deciding what you're going to

377
00:18:47,129 --> 00:18:50,216
do when there's an error is harder than

378
00:18:48,749 --> 00:18:53,970
then figuring just ignoring it all

379
00:18:50,999 --> 00:18:55,055
together and so there's a lot of code

380
00:18:53,097 --> 00:18:56,121
out there where people just cross their

381
00:18:55,559 --> 00:18:59,850
fingers and hope there's never errors in

382
00:18:57,021 --> 00:19:02,025
their system calls but we're going to

383
00:18:59,085 --> 00:19:03,494
really push on you hard to say every

384
00:19:02,061 --> 00:19:05,148
time you make a system call check the

385
00:19:04,259 --> 00:19:11,285
return code and do something if it's not

386
00:19:06,048 --> 00:19:14,073
right and so the open will return a

387
00:19:11,519 --> 00:19:16,320
number so that it's an int that it

388
00:19:14,073 --> 00:19:19,352
returns but if it's a negative number

389
00:19:16,032 --> 00:19:22,061
that means it couldn't open the the file

390
00:19:20,009 --> 00:19:25,070
for example the file doesn't exist or

391
00:19:22,061 --> 00:19:30,134
you're trying to open it in a mode that

392
00:19:25,619 --> 00:19:33,450
you're not authorized to open again so

393
00:19:31,034 --> 00:19:35,046
there are three particular file

394
00:19:33,045 --> 00:19:38,384
descriptors associated with every single

395
00:19:35,046 --> 00:19:40,083
process that runs one is standard input

396
00:19:38,789 --> 00:19:42,848
the other standard output and the third

397
00:19:40,083 --> 00:19:44,159
is standard error and they always have a

398
00:19:43,379 --> 00:19:53,471
file descriptor number zero one and two

399
00:19:45,059 --> 00:19:55,068
and so that you shouldn't really refer

400
00:19:54,299 --> 00:19:58,394
to them by their file descriptor numbers

401
00:19:56,049 --> 00:20:03,218
even though you actually can reliably

402
00:19:59,249 --> 00:20:05,324
depend on those values simply if you

403
00:20:03,659 --> 00:20:09,240
want to close the file you also open you

404
00:20:05,999 --> 00:20:12,390
see you give a path name and a one bit a

405
00:20:09,024 --> 00:20:13,119
one integer field that gives these flags

406
00:20:12,039 --> 00:20:17,055
say something about the modes in which

407
00:20:14,019 --> 00:20:19,113
you want to open it to close a file you

408
00:20:17,055 --> 00:20:21,084
just say close and you give the file

409
00:20:20,013 --> 00:20:26,019
descriptor number not the name of the

410
00:20:21,084 --> 00:20:28,095
file and it returns a return code too so

411
00:20:26,073 --> 00:20:32,085
you might say now why in the world could

412
00:20:28,095 --> 00:20:34,170
you ever get an error closing a file if

413
00:20:32,085 --> 00:20:39,120
it's open and the answers that actually

414
00:20:35,007 --> 00:20:41,058
can happen in particular we'll see when

415
00:20:40,002 --> 00:20:44,064
we have multi-threaded programs where

416
00:20:42,021 --> 00:20:46,059
it's possible to have to essentially two

417
00:20:44,082 --> 00:20:49,169
programs running at the same time

418
00:20:46,059 --> 00:20:52,062
sharing their data structures and

419
00:20:50,069 --> 00:20:55,101
interacting with each other sharing

420
00:20:52,062 --> 00:20:57,063
their memory it's very important kind of

421
00:20:56,001 --> 00:21:00,033
programming and one that you can really

422
00:20:57,063 --> 00:21:01,122
make bad horrible mistakes in and one of

423
00:21:00,033 --> 00:21:03,069
the bad horrible mistakes is if you try

424
00:21:02,022 --> 00:21:04,026
to close the file that's already been

425
00:21:03,069 --> 00:21:06,081
closed

426
00:21:04,026 --> 00:21:08,064
it'll be an error and that can happen if

427
00:21:06,081 --> 00:21:10,134
there's two different parts of your

428
00:21:08,064 --> 00:21:16,155
program running and each of them tries

429
00:21:11,034 --> 00:21:20,061
to close the file so in the book and in

430
00:21:17,055 --> 00:21:22,086
the in this code you'll see we

431
00:21:20,061 --> 00:21:24,069
introduced some error handling routines

432
00:21:22,086 --> 00:21:28,098
one of which is called P error and all

433
00:21:25,041 --> 00:21:31,080
it does is print some not whatever

434
00:21:28,098 --> 00:21:37,101
message you want to print and then it

435
00:21:31,008 --> 00:21:39,087
exits the program or no I guess it

436
00:21:38,001 --> 00:21:43,100
doesn't the I'll mention it a little

437
00:21:40,059 --> 00:21:46,113
while it just prints an error message

438
00:21:44,000 --> 00:21:48,009
but the point is even even something as

439
00:21:47,013 --> 00:21:53,037
mundane as closing a file you should be

440
00:21:48,009 --> 00:21:56,022
checking the return code okay so this is

441
00:21:53,037 --> 00:21:59,109
the function that reads of at this low

442
00:21:57,003 --> 00:22:01,059
level is called read and it's given a

443
00:22:00,009 --> 00:22:04,068
file descriptor

444
00:22:01,059 --> 00:22:06,102
you provided a pointer to a buffer that

445
00:22:04,068 --> 00:22:10,146
you you've had to allocate either

446
00:22:07,002 --> 00:22:13,011
aesthetically or via malloc and you also

447
00:22:11,046 --> 00:22:17,046
specify how long that buffer is so that

448
00:22:13,092 --> 00:22:20,124
it can't overflow that buffer and read

449
00:22:17,046 --> 00:22:22,054
just means read as many bytes as you

450
00:22:21,024 --> 00:22:24,070
feel like

451
00:22:22,054 --> 00:22:27,076
but no more than the number I tell you

452
00:22:24,007 --> 00:22:31,009
to which sounds like a weird statement

453
00:22:27,076 --> 00:22:33,082
what do you mean what you feel like well

454
00:22:31,009 --> 00:22:38,038
it has to read at least one byte so if

455
00:22:34,036 --> 00:22:41,134
for example it's a standard input it

456
00:22:39,019 --> 00:22:43,117
will hang there and wait until actually

457
00:22:42,034 --> 00:22:47,068
with standard input it will wait until

458
00:22:44,017 --> 00:22:52,021
you've typed in a string and hit the

459
00:22:47,068 --> 00:22:54,093
return and it will then read at least

460
00:22:52,021 --> 00:22:59,029
some fraction of that into the program

461
00:22:54,093 --> 00:23:02,142
if it's a network connection again the

462
00:23:00,001 --> 00:23:06,004
read won't just wait it will hang until

463
00:23:03,042 --> 00:23:08,140
something arrives on that particular

464
00:23:06,004 --> 00:23:12,061
network connection and then read in some

465
00:23:09,004 --> 00:23:14,047
number of bytes that have been sent to

466
00:23:12,061 --> 00:23:17,062
it and I'm being vague by saying some

467
00:23:14,083 --> 00:23:19,087
number because the truth is it there's

468
00:23:17,062 --> 00:23:21,070
no guarantee it will read any fixed

469
00:23:19,087 --> 00:23:25,090
number of bytes it will read at least

470
00:23:22,042 --> 00:23:28,045
one and it won't read any more than that

471
00:23:25,009 --> 00:23:30,040
buffer is but the number between that

472
00:23:28,045 --> 00:23:34,057
might be variable and so when it reads

473
00:23:31,021 --> 00:23:35,113
less than that the number of maximum

474
00:23:34,057 --> 00:23:38,125
number of bytes you specify that's

475
00:23:36,013 --> 00:23:40,084
called a short read and that can and

476
00:23:39,025 --> 00:23:43,030
does happen and you have to write your

477
00:23:40,084 --> 00:23:45,150
code expecting it and we'll talk about

478
00:23:43,075 --> 00:23:45,150
that a little bit

479
00:23:48,053 --> 00:23:57,100
oh and so again and by Reed returns an

480
00:23:53,074 --> 00:24:03,098
assigned number actually of data type F

481
00:23:58,000 --> 00:24:09,026
size T like SS ize underscore t which is

482
00:24:03,098 --> 00:24:10,196
typically a long int so a potentially

483
00:24:09,026 --> 00:24:16,073
negative number in it that that number

484
00:24:11,096 --> 00:24:18,167
is if it's a zero it means that it's hit

485
00:24:16,073 --> 00:24:20,159
it's detected and in the file that

486
00:24:19,067 --> 00:24:22,142
you've run to the end of the stored file

487
00:24:21,059 --> 00:24:25,142
that the network connection has been

488
00:24:23,042 --> 00:24:28,115
closed or something has happened if it's

489
00:24:26,042 --> 00:24:30,140
positive then that the number of bytes

490
00:24:29,015 --> 00:24:33,106
that were read and if it's negative it's

491
00:24:31,004 --> 00:24:33,070
an error code

492
00:24:38,057 --> 00:24:41,141
so as I mentioned if it if it reads

493
00:24:40,076 --> 00:24:43,115
fewer than the number of bytes you

494
00:24:42,041 --> 00:24:45,119
specify that's referred to as a short

495
00:24:44,015 --> 00:24:51,017
count and I'll talk about why that would

496
00:24:46,019 --> 00:24:53,021
occur writing is sort of the same idea

497
00:24:51,017 --> 00:24:56,021
that you provide a file descriptor you

498
00:24:53,021 --> 00:24:58,100
provide a buffer where the the data that

499
00:24:56,021 --> 00:25:00,029
you want to write out is stored and you

500
00:24:59,000 --> 00:25:06,092
give up how many bytes long do you want

501
00:25:01,001 --> 00:25:09,017
your right to be and it will write some

502
00:25:06,092 --> 00:25:11,141
number of bytes to the output at least

503
00:25:09,017 --> 00:25:14,030
one and no more than n byte but it might

504
00:25:12,041 --> 00:25:15,128
not be all of them which is kind of

505
00:25:14,003 --> 00:25:18,011
weird because you said I want to write

506
00:25:16,028 --> 00:25:21,041
this I want to send it to a file I want

507
00:25:18,038 --> 00:25:25,043
to send it over the Internet but it can

508
00:25:21,041 --> 00:25:27,122
potentially not send them all and we'll

509
00:25:25,088 --> 00:25:32,092
we'll talk about that a little bit so

510
00:25:28,022 --> 00:25:35,048
again that's called a short right and

511
00:25:32,092 --> 00:25:38,147
similarly it will return the number of

512
00:25:35,048 --> 00:25:43,142
bytes that were written and so if it's

513
00:25:39,047 --> 00:25:46,103
less than zero that's an error code so

514
00:25:44,042 --> 00:25:50,060
just to give you a really simple example

515
00:25:47,003 --> 00:25:52,061
of this in action this code does what

516
00:25:50,006 --> 00:25:53,060
you call echoing meaning that you type

517
00:25:52,061 --> 00:25:56,072
in something and it will print it out

518
00:25:54,014 --> 00:26:00,071
and it does it in the most mundane way

519
00:25:56,072 --> 00:26:03,083
possible by reading specifying a single

520
00:26:00,071 --> 00:26:05,123
byte read and single byte right so you

521
00:26:03,083 --> 00:26:07,112
remember I told you read will read at

522
00:26:06,023 --> 00:26:10,049
least one byte but no more than the

523
00:26:08,012 --> 00:26:12,020
number you've told it so when you give

524
00:26:10,049 --> 00:26:14,087
it one it means it will read exactly one

525
00:26:12,092 --> 00:26:17,138
byte and similarly with right if you say

526
00:26:14,087 --> 00:26:19,108
right one byte that that's guaranteed to

527
00:26:18,038 --> 00:26:23,105
happen

528
00:26:20,008 --> 00:26:27,017
and so this is really really bad code in

529
00:26:24,005 --> 00:26:29,060
the sense that call to read or to write

530
00:26:27,017 --> 00:26:32,093
the system level call it's a relatively

531
00:26:29,006 --> 00:26:34,082
expensive call it means kicking your

532
00:26:32,093 --> 00:26:36,191
whole operation up to the operating

533
00:26:35,036 --> 00:26:40,043
system doing what's called a context

534
00:26:37,091 --> 00:26:44,099
switch meaning it will go into the

535
00:26:41,006 --> 00:26:48,089
kernel of the system invoke operating

536
00:26:45,071 --> 00:26:49,096
system functions do whatever the reader

537
00:26:48,089 --> 00:26:52,368
right tells it to

538
00:26:49,096 --> 00:26:55,134
to come back out switch back to your job

539
00:26:53,169 --> 00:27:00,880
and that will typically take maybe

540
00:26:56,034 --> 00:27:03,123
20,000 to 40,000 clock cycles which you

541
00:27:00,088 --> 00:27:05,139
know a clock cycle nowadays is less than

542
00:27:03,429 --> 00:27:10,330
a nanosecond so you say yeah it's a

543
00:27:06,039 --> 00:27:12,088
you're talking maybe 10 microseconds

544
00:27:10,033 --> 00:27:14,122
what's the big deal there but that'll

545
00:27:12,088 --> 00:27:18,163
add up if you start sending long files

546
00:27:15,022 --> 00:27:21,109
out over you know millions of bytes if

547
00:27:19,063 --> 00:27:25,065
you start sending them a one byte at a

548
00:27:22,009 --> 00:27:28,208
time you'll spend most of that time

549
00:27:25,083 --> 00:27:31,126
sitting in the operating system going

550
00:27:28,289 --> 00:27:34,301
going crazy so this is not a good idea

551
00:27:32,026 --> 00:27:36,945
but it does work and that's actually a

552
00:27:34,409 --> 00:27:39,498
easy mistake you can make the programmer

553
00:27:37,179 --> 00:27:42,970
is to not use it is to use this

554
00:27:40,299 --> 00:27:45,010
low-level writing and reading and the

555
00:27:42,097 --> 00:27:47,406
program will function fine it's just it

556
00:27:45,001 --> 00:27:55,003
will be really really slow but just to

557
00:27:48,279 --> 00:27:57,940
give you a demo of this idea of calls

558
00:27:55,021 --> 00:28:00,110
the operating system there's a pretty

559
00:27:57,094 --> 00:27:59,453
cool

560
00:28:03,029 --> 00:28:08,460
so this program and this is on the web

561
00:28:06,179 --> 00:28:10,277
linked off the webpage the code for this

562
00:28:08,046 --> 00:28:14,064
lecture so this one called

563
00:28:11,159 --> 00:28:18,197
CPE standard in meaning copy standard

564
00:28:14,064 --> 00:28:19,161
input is just the code I showed you and

565
00:28:18,539 --> 00:28:25,601
so if you type something it will just

566
00:28:20,061 --> 00:28:33,074
echo it back so it's reading in so it

567
00:28:26,159 --> 00:28:33,740
looks to you and to me like it's a

568
00:28:35,012 --> 00:28:43,051
reading on line of text and then echoing

569
00:28:39,009 --> 00:28:45,057
it back but what it's actually doing is

570
00:28:43,159 --> 00:28:47,171
again the interface to the terminal is

571
00:28:45,057 --> 00:28:48,120
one that it doesn't actually wake up

572
00:28:47,279 --> 00:28:50,366
this code until it gets a complete line

573
00:28:49,002 --> 00:28:53,055
but it's actually just printing these

574
00:28:51,149 --> 00:28:58,620
characters back one one character at a

575
00:28:53,073 --> 00:29:02,252
time and I can demo that by there's a

576
00:28:58,062 --> 00:29:06,159
pretty interesting facility called

577
00:29:02,909 --> 00:29:09,120
tracing s trace then what s chase will

578
00:29:07,059 --> 00:29:14,498
do if you give it the name of a program

579
00:29:09,012 --> 00:29:17,058
is it will detect every every system

580
00:29:15,029 --> 00:29:20,100
call that you make every basically

581
00:29:17,058 --> 00:29:22,877
called to the operating system functions

582
00:29:20,001 --> 00:29:25,053
that you make when you run a program and

583
00:29:23,399 --> 00:29:27,450
it will generally view out this huge

584
00:29:25,062 --> 00:29:29,124
amount of inscrutable stuff that you

585
00:29:27,045 --> 00:29:32,494
don't really want to see I'll just show

586
00:29:30,024 --> 00:29:32,683
you this Oh

587
00:29:32,099 --> 00:29:37,258
it's telling you logging every single

588
00:29:36,009 --> 00:29:42,818
call and it's usually way too much stuff

589
00:29:38,149 --> 00:29:45,000
so the more useful way to do this is to

590
00:29:42,899 --> 00:29:47,850
give it an argument that says I only

591
00:29:45,000 --> 00:29:51,059
want to watch some limited class of

592
00:29:47,085 --> 00:29:52,089
functions of when this is running and so

593
00:29:51,059 --> 00:29:58,082
what I just want our calls to the right

594
00:29:53,025 --> 00:30:00,060
the low level output right and you'll

595
00:29:58,289 --> 00:30:05,291
see that what happens then is this

596
00:30:00,006 --> 00:30:09,045
string i typed in I turned into a series

597
00:30:05,309 --> 00:30:12,340
of 1 byte right calls to the low level

598
00:30:09,099 --> 00:30:14,105
right function

599
00:30:12,034 --> 00:30:20,131
and of course some way I could show you

600
00:30:15,059 --> 00:30:20,131
the reeds and right try that

601
00:30:23,008 --> 00:30:28,076
and it's all confused because I'm I'm

602
00:30:27,035 --> 00:30:30,122
messing this comes out on standard error

603
00:30:29,048 --> 00:30:32,087
but on the terminal it sort of

604
00:30:31,022 --> 00:30:35,045
interleaving standard error and standard

605
00:30:32,087 --> 00:30:36,184
out so it's kind of messy to look at but

606
00:30:35,045 --> 00:30:40,049
again you can see that it's taking my

607
00:30:37,084 --> 00:30:48,176
characters and it's reading 1 and

608
00:30:40,085 --> 00:30:51,167
writing 1 in this loop so let's see

609
00:30:49,076 --> 00:30:54,088
control D to get out of it back to the

610
00:30:52,067 --> 00:30:54,088
code

611
00:31:01,069 --> 00:31:05,143
so what's this short count business why

612
00:31:04,027 --> 00:31:08,053
would that occur well there's a couple

613
00:31:06,043 --> 00:31:10,062
ones as I mentioned if you counter an

614
00:31:08,053 --> 00:31:12,109
end-of-file you're not going to read in

615
00:31:10,062 --> 00:31:16,126
however many bytes you're given for the

616
00:31:13,009 --> 00:31:21,021
buffer if you are reading text lines

617
00:31:17,026 --> 00:31:24,040
from a terminal the terminal

618
00:31:21,021 --> 00:31:26,095
handler will just send a wine two words

619
00:31:24,004 --> 00:31:28,087
at a time with the newline character

620
00:31:26,095 --> 00:31:32,110
terminating it if you're reading or

621
00:31:29,023 --> 00:31:36,034
writing a network packet the way network

622
00:31:33,001 --> 00:31:38,029
packets work is that or messages if you

623
00:31:36,034 --> 00:31:43,045
have a big long message it's broken into

624
00:31:38,038 --> 00:31:52,129
smaller chunks typically about a

625
00:31:43,045 --> 00:31:55,072
thousand bytes or so question if you are

626
00:31:53,029 --> 00:32:02,038
trying to read from an end-of-file where

627
00:31:55,072 --> 00:32:03,133
we turn 0 is that a short count it's a

628
00:32:02,038 --> 00:32:08,080
really short count yes but it's not a

629
00:32:04,033 --> 00:32:11,119
negative yes so as it says here if you

630
00:32:08,008 --> 00:32:13,012
encounter an in your file it'll actually

631
00:32:12,019 --> 00:32:16,042
there's two things actually it's a

632
00:32:13,084 --> 00:32:17,176
really good question if you're like near

633
00:32:16,042 --> 00:32:22,048
the end of a file you have 100 bytes

634
00:32:18,076 --> 00:32:24,157
left and you say read 200 your first

635
00:32:22,048 --> 00:32:27,052
call to read will come back and get 100

636
00:32:25,057 --> 00:32:29,119
character it would say 100 and it will

637
00:32:27,052 --> 00:32:32,083
get that number and then you call again

638
00:32:30,019 --> 00:32:34,084
the second time and it will return 0 and

639
00:32:32,083 --> 00:32:37,135
so that's how you actually detect the

640
00:32:34,084 --> 00:32:38,167
true end of file as opposed to you know

641
00:32:38,035 --> 00:32:41,080
some other reason you might have gotten

642
00:32:39,067 --> 00:32:43,102
a short count is if that you actually

643
00:32:41,008 --> 00:32:45,085
get a read of 0 the only case you'll get

644
00:32:44,002 --> 00:32:52,015
at 4 is an end of file so that's a good

645
00:32:46,057 --> 00:32:54,112
question thanks so again if over the

646
00:32:52,015 --> 00:32:57,022
Internet typically packets are round a

647
00:32:55,012 --> 00:33:00,016
thousand bytes it's actually depends on

648
00:32:57,022 --> 00:33:02,061
what where it's gone through what layers

649
00:33:00,052 --> 00:33:05,053
in the protocols it's gone through but

650
00:33:02,061 --> 00:33:08,092
1500 bytes is actually the standard what

651
00:33:05,062 --> 00:33:09,139
they call minimum transmission unit so

652
00:33:08,092 --> 00:33:12,109
if you have a big long file will come

653
00:33:10,039 --> 00:33:14,077
back and in blocks like that and if

654
00:33:13,009 --> 00:33:15,052
you're trying to read into a larger

655
00:33:14,077 --> 00:33:17,169
buffer

656
00:33:15,052 --> 00:33:27,087
it will typically come back in chunk

657
00:33:18,069 --> 00:33:29,104
question no in other words your and

658
00:33:27,087 --> 00:33:31,159
again if you're writing code you

659
00:33:30,004 --> 00:33:33,103
shouldn't expect any number particularly

660
00:33:32,059 --> 00:33:44,098
it will be dependent on the

661
00:33:34,003 --> 00:33:46,099
implementation no because I'm only I'm

662
00:33:44,098 --> 00:33:50,155
only reading or writing one character at

663
00:33:46,099 --> 00:33:54,118
a time right so I guess you're asking

664
00:33:51,055 --> 00:33:56,101
what if I like spent of a weak typing

665
00:33:55,018 --> 00:33:59,053
characters in a really long string and

666
00:33:57,001 --> 00:34:04,075
hit return I don't know if you try it

667
00:33:59,053 --> 00:34:05,152
let me know the answer but it will cause

668
00:34:04,075 --> 00:34:07,096
an error but that part believe me

669
00:34:06,052 --> 00:34:10,111
they've really gone through that code a

670
00:34:07,096 --> 00:34:11,161
lot of times and and gotten rid of all

671
00:34:11,011 --> 00:34:15,016
those lurking buffer overflow

672
00:34:12,061 --> 00:34:16,134
vulnerabilities in the code but will let

673
00:34:15,061 --> 00:34:19,087
you do it I don't actually know but

674
00:34:17,034 --> 00:34:21,085
within the you should write your code

675
00:34:19,087 --> 00:34:23,104
again expecting short counts as a

676
00:34:21,085 --> 00:34:24,181
possibility and by the way that's one of

677
00:34:24,004 --> 00:34:28,021
the the headaches of using this

678
00:34:25,081 --> 00:34:29,146
low-level i/o is is dealing with short

679
00:34:28,021 --> 00:34:33,037
counts is not it's often a sort of a

680
00:34:30,046 --> 00:34:36,052
nuisance of an application level so you

681
00:34:33,037 --> 00:34:39,836
don't usually package this up this kind

682
00:34:36,052 --> 00:34:42,711
of low-level file IO into other

683
00:34:40,169 --> 00:34:45,490
libraries that you're calling it's only

684
00:34:43,179 --> 00:34:53,140
really demonstrating this is the sort of

685
00:34:45,049 --> 00:34:55,060
lowest level in the step and writing

686
00:34:53,014 --> 00:34:57,016
also can give you a short count for

687
00:34:55,006 --> 00:34:59,008
example if you're sending packets over a

688
00:34:57,034 --> 00:35:02,098
network it will only send as many as is

689
00:34:59,062 --> 00:35:04,063
that packet can hold and then return

690
00:35:02,098 --> 00:35:06,117
back to you and you have to keep pumping

691
00:35:04,063 --> 00:35:09,115
them out to send the different packets

692
00:35:07,017 --> 00:35:12,040
and so usually when you write code that

693
00:35:10,015 --> 00:35:17,034
uses this goal of while you have to

694
00:35:12,004 --> 00:35:19,062
anticipate these short counts so

695
00:35:17,034 --> 00:35:25,081
professor O'Halloran wrote a package

696
00:35:19,098 --> 00:35:26,179
called Rio and you'll for now we'll just

697
00:35:25,081 --> 00:35:28,138
talk about what this package is this is

698
00:35:27,079 --> 00:35:29,083
a package that you're really going to

699
00:35:29,038 --> 00:35:32,061
want to you

700
00:35:29,083 --> 00:35:34,141
use for the the final web for the course

701
00:35:32,061 --> 00:35:36,130
and so for right now it's more of a

702
00:35:35,041 --> 00:35:38,092
high-level here's an example of code

703
00:35:37,003 --> 00:35:41,044
that uses low-level IO

704
00:35:38,092 --> 00:35:43,117
and packages up in a way that makes it a

705
00:35:41,071 --> 00:35:45,084
little bit more palatable so Rio

706
00:35:44,017 --> 00:35:52,084
provides actually a number of different

707
00:35:45,084 --> 00:35:57,121
two different well actually three two

708
00:35:52,084 --> 00:36:01,099
different levels of of interface to the

709
00:35:58,021 --> 00:36:04,048
file this file IO the lowest one is

710
00:36:01,099 --> 00:36:09,181
basically just a fairly small wrapper

711
00:36:04,048 --> 00:36:12,139
around the existing the the IO the reads

712
00:36:10,081 --> 00:36:15,109
and writes you saw that will handle the

713
00:36:13,039 --> 00:36:18,106
short count issue and so when you say

714
00:36:16,009 --> 00:36:21,010
with Rio if you make a call to the read

715
00:36:19,006 --> 00:36:25,042
end function and you say some number

716
00:36:21,001 --> 00:36:27,019
bite then that function will not return

717
00:36:25,042 --> 00:36:30,058
until it's read that number of bytes so

718
00:36:27,028 --> 00:36:32,071
better be careful that that that many

719
00:36:30,058 --> 00:36:36,097
bytes are there if it's a network socket

720
00:36:32,071 --> 00:36:38,080
or a file well because it will flag an

721
00:36:36,097 --> 00:36:42,097
error message if it will actually hang

722
00:36:39,061 --> 00:36:45,133
up if it's a network connection waiting

723
00:36:42,097 --> 00:36:47,128
to read the bytes or return an error if

724
00:36:46,033 --> 00:36:51,034
it hits a none into file what it's not

725
00:36:48,028 --> 00:36:52,111
expected and similarly with right n it's

726
00:36:51,043 --> 00:36:56,074
sort of a wrapper around the write

727
00:36:53,011 --> 00:36:59,016
function that will deal with just loop

728
00:36:56,074 --> 00:37:03,079
until the short counts are taken care of

729
00:36:59,061 --> 00:37:06,115
and then there is a another class of i/o

730
00:37:04,024 --> 00:37:08,071
that's called buffered i/o and this is

731
00:37:07,015 --> 00:37:11,083
what you really want to use in practice

732
00:37:08,071 --> 00:37:15,142
and what you mostly use with the

733
00:37:11,083 --> 00:37:18,106
standard UNIX iOS functions is that you

734
00:37:16,042 --> 00:37:22,093
want to within the user code build up a

735
00:37:19,006 --> 00:37:25,054
little buffer of bytes that have either

736
00:37:22,093 --> 00:37:27,172
been read in but not yet consumed by the

737
00:37:25,054 --> 00:37:30,055
application program or you accumulate

738
00:37:28,072 --> 00:37:32,113
some number of bytes in your program

739
00:37:30,064 --> 00:37:39,067
before it actually shoved out into the

740
00:37:33,013 --> 00:37:41,110
file or out onto the network and there's

741
00:37:39,094 --> 00:37:42,723
two versions of that one is a text

742
00:37:42,001 --> 00:37:46,170
oriented wine oriented eye

743
00:37:43,569 --> 00:37:52,592
and the other is just a byte oriented

744
00:37:46,269 --> 00:37:54,880
i/o so let's go through the what the

745
00:37:52,799 --> 00:37:56,820
functions aren't actually look at the

746
00:37:54,088 --> 00:37:58,144
code for them so as I mentioned the ones

747
00:37:57,009 --> 00:38:01,011
called readin and writin are just very

748
00:37:59,044 --> 00:38:04,143
thin they have the same general

749
00:38:01,209 --> 00:38:05,288
semantics as the read and write but they

750
00:38:04,539 --> 00:38:09,608
deal with the short count issue

751
00:38:05,999 --> 00:38:13,083
so let's actually take a look at read em

752
00:38:10,229 --> 00:38:21,317
so again readin is given a file

753
00:38:13,839 --> 00:38:24,915
descriptor a destination buffer and a

754
00:38:22,109 --> 00:38:27,880
indication of how many characters how

755
00:38:25,599 --> 00:38:37,611
many bytes it's supposed to read and

756
00:38:27,088 --> 00:38:39,257
it's supposed to it's supposed to we

757
00:38:37,719 --> 00:38:43,150
returned I guess it will return either

758
00:38:40,049 --> 00:38:50,380
negative number if there's an error zero

759
00:38:43,015 --> 00:38:53,694
if it's at an end of file or the number

760
00:38:50,038 --> 00:38:55,069
of bytes read so I guess I was a little

761
00:38:53,829 --> 00:38:57,670
bit I should have been more careful if

762
00:38:55,069 --> 00:39:00,118
it hits an end of file partway through

763
00:38:57,067 --> 00:39:02,406
it will return a short count but that's

764
00:39:01,018 --> 00:39:05,044
the only case it won't return a short

765
00:39:03,009 --> 00:39:09,130
countess if there really it could have

766
00:39:05,044 --> 00:39:11,583
read more bytes so the main loop here

767
00:39:09,013 --> 00:39:15,162
you see is it keeps calling read over

768
00:39:11,979 --> 00:39:17,001
and over again until it's happy ah one

769
00:39:15,279 --> 00:39:19,920
way it can be happy is if it's read as

770
00:39:17,199 --> 00:39:23,283
many bytes as it was supposed to write

771
00:39:19,092 --> 00:39:28,011
read in the first place the other is

772
00:39:24,039 --> 00:39:31,440
that if it hits an error code and you'll

773
00:39:28,839 --> 00:39:31,440
notice that

774
00:39:33,329 --> 00:39:43,332
oh and that there's some subtlety of

775
00:39:40,589 --> 00:39:44,688
tracking which type of error that is but

776
00:39:43,359 --> 00:39:47,380
in general the common cases it will

777
00:39:45,579 --> 00:39:54,390
return the negative number indicating an

778
00:39:47,038 --> 00:39:58,096
error if it if the number read is zero

779
00:39:54,039 --> 00:40:01,105
then that indicated into file and so

780
00:39:58,096 --> 00:40:05,145
what it will return is as many bytes as

781
00:40:02,005 --> 00:40:10,021
it's read so return the short count and

782
00:40:06,045 --> 00:40:12,414
here it's just saying okay I've read

783
00:40:10,021 --> 00:40:14,098
this number of bytes and increment and

784
00:40:12,819 --> 00:40:16,848
decrement the right values so the point

785
00:40:14,098 --> 00:40:18,103
is that we'll keep looping keep doing

786
00:40:17,109 --> 00:40:21,760
reads until it either gets the number of

787
00:40:19,003 --> 00:40:26,014
bytes it should it hits an error or it

788
00:40:21,076 --> 00:40:27,139
encounters an end-of-file and you'll see

789
00:40:26,014 --> 00:40:29,101
it has its checking for all these

790
00:40:28,039 --> 00:40:33,103
different error conditions for every

791
00:40:30,001 --> 00:40:36,022
call it make so this code by the way is

792
00:40:34,003 --> 00:40:38,020
sort of typical that it looks a little

793
00:40:36,022 --> 00:40:40,024
messy when you first look at it but if

794
00:40:38,002 --> 00:40:44,098
you sort of study it it all makes sense

795
00:40:40,042 --> 00:40:47,089
oh so now let's talk about buffered i/o

796
00:40:45,016 --> 00:40:49,051
and what buffered i/o is and this is a

797
00:40:47,089 --> 00:40:50,092
very important concept so it's part of

798
00:40:49,051 --> 00:41:00,090
the reason we want to show you the code

799
00:40:50,092 --> 00:41:04,147
for it so the idea of buffered i/o is

800
00:41:00,549 --> 00:41:08,950
that that there's a buffer meaning just

801
00:41:05,047 --> 00:41:11,098
an array of characters array of bytes

802
00:41:08,095 --> 00:41:16,147
they're allocated and associated with

803
00:41:11,098 --> 00:41:18,447
this particular file and the program if

804
00:41:17,047 --> 00:41:21,426
it's on a read what it will do is it

805
00:41:19,329 --> 00:41:25,240
will fill up this buffer it will give a

806
00:41:21,849 --> 00:41:28,540
read with a much larger number with a

807
00:41:25,024 --> 00:41:30,091
large number basically the size of the

808
00:41:28,054 --> 00:41:33,061
actual how much number you've allocated

809
00:41:30,091 --> 00:41:36,172
for this buffer and the system will fill

810
00:41:34,024 --> 00:41:39,903
that up with up to that number of

811
00:41:37,072 --> 00:41:42,154
characters and then when the user

812
00:41:40,119 --> 00:41:46,130
program wants to now look at this

813
00:41:43,054 --> 00:41:47,803
get some bytes it will

814
00:41:46,013 --> 00:41:50,392
check do I already have some in the

815
00:41:48,289 --> 00:41:53,338
buffer that haven't been read yet and if

816
00:41:50,509 --> 00:41:56,542
so I'll just return those and if not

817
00:41:53,779 --> 00:41:59,690
then I'll refill the buffer so the idea

818
00:41:56,839 --> 00:42:00,937
of it is instead of every time going to

819
00:41:59,069 --> 00:42:03,468
the operating system and asking for one

820
00:42:01,819 --> 00:42:06,823
character small number of characters

821
00:42:04,089 --> 00:42:09,133
that called the operating system says

822
00:42:06,859 --> 00:42:11,953
give me pretty much as many characters

823
00:42:09,529 --> 00:42:14,578
as you've got up to some limit and then

824
00:42:12,799 --> 00:42:17,900
I'll just go away and what the

825
00:42:15,019 --> 00:42:21,410
application program I sort of pulled

826
00:42:17,009 --> 00:42:22,037
these out a couple bytes at a time but I

827
00:42:21,041 --> 00:42:26,980
won't bug the operating system to do it

828
00:42:23,018 --> 00:42:29,026
I being the real function and the way it

829
00:42:27,349 --> 00:42:34,970
does it is by just keeping a pointer of

830
00:42:29,098 --> 00:42:39,124
the indicates what part of the the bytes

831
00:42:34,097 --> 00:42:42,976
that I've already brought in from the

832
00:42:40,024 --> 00:42:45,343
operating system call but the haven't

833
00:42:43,849 --> 00:42:47,851
been supplied yet to the application

834
00:42:45,559 --> 00:42:49,588
program and so in this sort of larger

835
00:42:47,869 --> 00:42:54,500
picture of things if you imagine you're

836
00:42:49,849 --> 00:42:56,450
you're walking you through a file at any

837
00:42:54,005 --> 00:42:59,027
given point in time this buffer will

838
00:42:56,045 --> 00:43:01,444
represent some range of in that file

839
00:42:59,072 --> 00:43:03,140
where the green is the stuff that's

840
00:43:01,849 --> 00:43:06,898
already been read by the application

841
00:43:04,004 --> 00:43:09,062
program the pink is the stuff that's

842
00:43:07,339 --> 00:43:12,406
been read but from the operating system

843
00:43:09,098 --> 00:43:16,103
out of a file but not yet read by the

844
00:43:13,009 --> 00:43:20,180
application program and the way this is

845
00:43:17,048 --> 00:43:23,116
implemented once you think about it it's

846
00:43:20,018 --> 00:43:28,627
not too hard to do is it associated with

847
00:43:24,016 --> 00:43:33,625
every file connection then is a file

848
00:43:28,789 --> 00:43:37,220
descriptor account that tells you how

849
00:43:33,769 --> 00:43:44,980
many bytes there are that have not been

850
00:43:37,022 --> 00:43:48,038
read yet a a pointer to where this this

851
00:43:44,098 --> 00:43:51,197
changeover is and then the actual

852
00:43:48,038 --> 00:43:54,697
storage of the the buffer itself the

853
00:43:52,097 --> 00:43:57,097
characters allocated the bytes allocated

854
00:43:55,039 --> 00:43:57,970
to the buffer itself

855
00:43:58,609 --> 00:44:07,703
and so here's an example then of of

856
00:44:03,092 --> 00:44:10,511
using Rio to do this echo that you first

857
00:44:08,549 --> 00:44:16,920
read a line and reading a line means it

858
00:44:11,339 --> 00:44:20,990
will look for and stop at a line feed

859
00:44:16,092 --> 00:44:24,271
character and writing it back out and

860
00:44:20,099 --> 00:44:24,208
again if you do the demo

861
00:44:30,589 --> 00:44:33,615
of this code

862
00:44:37,072 --> 00:44:39,078
Hey

863
00:44:48,038 --> 00:44:53,069
it's a little again you get let me just

864
00:44:51,041 --> 00:44:57,690
trace right because it's a little hard

865
00:44:53,069 --> 00:44:57,438
to see the read hard to figure out with

866
00:45:03,086 --> 00:45:10,185
so you'll see that it read the whole

867
00:45:09,057 --> 00:45:14,064
line and now it's done to add the

868
00:45:11,085 --> 00:45:18,159
operating system-level it's written just

869
00:45:14,064 --> 00:45:24,135
one chunks worth one call to the the

870
00:45:19,059 --> 00:45:28,115
operating systems write function instead

871
00:45:25,035 --> 00:45:28,043
of a byte by byte

872
00:45:38,349 --> 00:45:42,384
okay so again I'm not going to go

873
00:45:41,229 --> 00:45:46,150
through all the code but it's actually

874
00:45:42,699 --> 00:45:47,778
worth your while to do this and by the

875
00:45:46,015 --> 00:45:50,038
way I've actually done some applications

876
00:45:48,489 --> 00:45:52,563
where I took the Rio code I want to add

877
00:45:50,038 --> 00:45:54,043
some features to it but it's a very

878
00:45:53,229 --> 00:45:59,262
useful starting point to be able to

879
00:45:54,088 --> 00:46:00,927
build your own customized routines okay

880
00:45:59,559 --> 00:46:06,880
so let's talk about some other parts of

881
00:46:01,719 --> 00:46:10,420
files one is that associated with a file

882
00:46:06,088 --> 00:46:11,457
is what they call metadata so the data

883
00:46:10,042 --> 00:46:14,047
are the actual contents of the files

884
00:46:12,249 --> 00:46:16,272
actual bytes inside that file but

885
00:46:14,092 --> 00:46:18,141
there's a whole bunch of other stuff

886
00:46:16,479 --> 00:46:21,670
that's associated with the file

887
00:46:19,041 --> 00:46:25,190
information about what type of file it

888
00:46:21,067 --> 00:46:30,756
is what protection read/write/execute

889
00:46:25,559 --> 00:46:34,150
protections it has some information

890
00:46:31,359 --> 00:46:34,410
about the ownership of that file what

891
00:46:34,015 --> 00:46:39,144
type it is

892
00:46:34,869 --> 00:46:40,875
and also the times associated with it

893
00:46:39,279 --> 00:46:43,284
when was it created when was it last

894
00:46:41,469 --> 00:46:46,690
accessed and when was it last modified

895
00:46:43,779 --> 00:46:49,779
so that's known as a metadata and every

896
00:46:46,069 --> 00:46:52,218
a file has that kind of information

897
00:46:49,779 --> 00:46:54,880
associated with it and you can actually

898
00:46:52,839 --> 00:47:02,140
and it's in a data structure called a

899
00:46:54,088 --> 00:47:03,927
stat data structure and you can if you

900
00:47:02,014 --> 00:47:10,069
want to write code that then sort of

901
00:47:04,719 --> 00:47:13,725
probes the directory structure of a of a

902
00:47:10,069 --> 00:47:16,908
file system you can make a call to the

903
00:47:13,779 --> 00:47:18,873
stat function and it's given the the

904
00:47:17,529 --> 00:47:24,640
path name of the file you want to stat

905
00:47:19,719 --> 00:47:27,744
and then a pointer to it one of these

906
00:47:24,064 --> 00:47:29,223
stat data structures and then that our

907
00:47:27,969 --> 00:47:32,440
data structure will get filled in by the

908
00:47:29,799 --> 00:47:35,440
information for this particular file and

909
00:47:32,044 --> 00:47:39,723
then you can test various attributes

910
00:47:35,044 --> 00:47:43,051
about that file and see basically get

911
00:47:40,119 --> 00:47:46,203
the information that that's stored here

912
00:47:44,014 --> 00:47:49,323
and there's all these nasty compile time

913
00:47:46,959 --> 00:47:51,998
constants that you use or macros that

914
00:47:49,449 --> 00:47:51,458
use to

915
00:47:53,014 --> 00:47:58,092
look at and examine these visa metadata

916
00:48:03,008 --> 00:48:08,087
so here's a example I will do it but

917
00:48:07,019 --> 00:48:11,111
it's a function called stat check it's

918
00:48:09,059 --> 00:48:14,093
in the same directory and so if you

919
00:48:12,011 --> 00:48:17,090
check some file or typically say well

920
00:48:14,093 --> 00:48:21,095
it's a regular file and yes you're

921
00:48:17,009 --> 00:48:25,013
allowed to read it but now if I call

922
00:48:21,095 --> 00:48:28,127
chmod to eliminate set all the

923
00:48:26,003 --> 00:48:34,028
protections to zero you know say no you

924
00:48:29,027 --> 00:48:39,071
can't read it now and so again that's

925
00:48:34,055 --> 00:48:42,080
just making use of this Gator here so

926
00:48:39,071 --> 00:48:45,110
now this is the part that gets a lot

927
00:48:42,008 --> 00:48:47,012
more tricky it's how our files how are

928
00:48:46,001 --> 00:48:49,043
all this information about file is

929
00:48:47,084 --> 00:48:56,167
actually represented by the programs

930
00:48:49,052 --> 00:48:57,067
question yes stat gist

931
00:49:06,098 --> 00:49:14,156
I'll tell you one way you can find out

932
00:49:09,033 --> 00:49:19,035
what step does if you say man 2 stat

933
00:49:15,056 --> 00:49:21,114
you'll get more than you want to know so

934
00:49:19,035 --> 00:49:30,099
in general you know if you say man's

935
00:49:22,014 --> 00:49:34,026
debt it'll give a unix of command that

936
00:49:30,099 --> 00:49:39,108
you can use to step a file so I can say

937
00:49:34,026 --> 00:49:45,114
stat dot and it will print out some

938
00:49:40,089 --> 00:49:51,096
information about a file in this case of

939
00:49:46,014 --> 00:49:56,090
my local directory let's see I can stat

940
00:49:52,059 --> 00:50:01,128
any file here and it will print out some

941
00:49:56,009 --> 00:50:05,082
some cryptic information about it but if

942
00:50:02,028 --> 00:50:08,034
you say man 2 stat the UNIX man pages

943
00:50:06,063 --> 00:50:13,122
are divided into different categories

944
00:50:08,034 --> 00:50:16,088
and things that our system calls UNIX

945
00:50:14,022 --> 00:50:20,109
system library calls are typically in

946
00:50:16,088 --> 00:50:23,109
section 2 of the man pages and so that

947
00:50:21,009 --> 00:50:27,009
will return information about it but the

948
00:50:24,009 --> 00:50:29,022
main point of it is stat is then a

949
00:50:27,009 --> 00:50:31,038
function that you call where you give it

950
00:50:29,022 --> 00:50:34,026
a path name and a pointer to a buffer

951
00:50:31,038 --> 00:50:39,041
that you want it and it will then fill

952
00:50:34,062 --> 00:50:40,158
in the contents of the buffer with the

953
00:50:39,041 --> 00:50:44,112
information about that particular file

954
00:50:41,058 --> 00:50:48,063
and the form that it fills it in is one

955
00:50:45,012 --> 00:50:52,017
of these data structures called a struct

956
00:50:48,063 --> 00:50:54,114
step and that's pretty typical of a lot

957
00:50:52,017 --> 00:50:58,020
of these functions is that they have

958
00:50:55,014 --> 00:51:00,090
some predefined struct and if you want

959
00:50:58,047 --> 00:51:02,109
to get it if you want to get information

960
00:51:00,009 --> 00:51:04,074
you pass you allocate one of those

961
00:51:03,009 --> 00:51:06,018
struts you pass a pointer to it and then

962
00:51:05,055 --> 00:51:11,063
the library function will fill in the

963
00:51:06,099 --> 00:51:10,163
details does that make sense

964
00:51:22,054 --> 00:51:28,133
okay so now let's look at some of the

965
00:51:26,869 --> 00:51:32,090
internal data structures that the

966
00:51:29,033 --> 00:51:34,130
operating system maintains regarding the

967
00:51:32,009 --> 00:51:38,033
files associated with a program and this

968
00:51:35,003 --> 00:51:40,072
is a source of really nasty exam

969
00:51:38,033 --> 00:51:42,116
problems I'll just warn you so you're

970
00:51:40,369 --> 00:51:45,290
going to want to read this part of the

971
00:51:43,016 --> 00:51:47,725
book carefully study the practice

972
00:51:45,029 --> 00:51:49,108
problems look at the old exams because I

973
00:51:47,869 --> 00:51:51,290
can guarantee you you're going to get

974
00:51:49,369 --> 00:51:54,590
some of these on the final that's a

975
00:51:51,029 --> 00:51:58,031
promise and they can be infinitely

976
00:51:54,059 --> 00:52:00,104
obscure so we can we can torch you with

977
00:51:58,049 --> 00:52:05,090
these so the main point is that

978
00:52:01,004 --> 00:52:07,833
associated with any executing process

979
00:52:05,009 --> 00:52:15,011
which you can think of a process is a

980
00:52:07,869 --> 00:52:18,230
running program is a something called

981
00:52:15,092 --> 00:52:21,149
the descriptor table and what that

982
00:52:18,023 --> 00:52:26,099
contains is for every open file that you

983
00:52:22,049 --> 00:52:30,053
have it has a pointer to a data

984
00:52:26,099 --> 00:52:31,163
structure called an entry in a table

985
00:52:30,089 --> 00:52:37,094
that's maintained by the operating

986
00:52:32,063 --> 00:52:45,095
system globally which describes each of

987
00:52:38,039 --> 00:52:50,083
the open files actually each of every

988
00:52:45,095 --> 00:52:56,096
time a file is opened that allocates a

989
00:52:50,083 --> 00:52:59,108
record in this open file table and so as

990
00:52:56,096 --> 00:53:03,104
I mentioned file descriptor 0 1 & 2 have

991
00:53:00,008 --> 00:53:06,041
specific meanings and the other files or

992
00:53:04,004 --> 00:53:08,045
other ones that you've opened up during

993
00:53:06,041 --> 00:53:13,046
the course of your program execution and

994
00:53:08,045 --> 00:53:17,108
have not yet closed so that so each of

995
00:53:13,046 --> 00:53:20,425
these then is a reference to a

996
00:53:18,008 --> 00:53:24,077
particular open file and it gives

997
00:53:20,839 --> 00:53:26,839
information about that file and it also

998
00:53:24,077 --> 00:53:28,079
gives the position in the file that

999
00:53:26,839 --> 00:53:30,916
currently is that I told you every time

1000
00:53:28,097 --> 00:53:32,716
you open a file there's a for a regular

1001
00:53:31,609 --> 00:53:34,705
file at least there's an Associated

1002
00:53:33,589 --> 00:53:38,590
position of where in the file

1003
00:53:35,569 --> 00:53:39,660
it was your last reader right or where

1004
00:53:38,599 --> 00:53:44,660
would you be your next free to write and

1005
00:53:40,479 --> 00:53:46,516
so that's the file pause and there's

1006
00:53:44,066 --> 00:53:49,515
also a reference count which is used by

1007
00:53:46,849 --> 00:53:51,895
the operating system to keep track of

1008
00:53:50,109 --> 00:53:58,640
because we'll see it's possible to have

1009
00:53:52,309 --> 00:54:01,309
multiple multiple processes sharing an

1010
00:53:58,064 --> 00:54:02,069
entry in this Open File table and it

1011
00:54:01,309 --> 00:54:05,350
uses this reference count which is

1012
00:54:03,014 --> 00:54:09,613
standard way of keeping track of memory

1013
00:54:05,719 --> 00:54:11,725
allocation to know when it no longer

1014
00:54:09,739 --> 00:54:16,792
needs that entry if when there's been

1015
00:54:12,319 --> 00:54:19,400
enough when the file is no longer

1016
00:54:17,269 --> 00:54:23,338
accessible and therefore this entry is

1017
00:54:19,004 --> 00:54:25,058
not needed so for every one of your open

1018
00:54:23,959 --> 00:54:28,910
files that will have an entry in this

1019
00:54:25,094 --> 00:54:31,203
table and this table as I said is shared

1020
00:54:28,091 --> 00:54:35,770
across the whole operating system and

1021
00:54:32,049 --> 00:54:38,143
then associated with every file is

1022
00:54:36,589 --> 00:54:42,380
called the V node which stands for

1023
00:54:38,989 --> 00:54:45,046
virtual node and this is where that

1024
00:54:42,038 --> 00:54:47,647
contains the sort of information about

1025
00:54:45,559 --> 00:54:51,170
this file in particular where is it

1026
00:54:47,989 --> 00:54:54,994
stored on this information that you can

1027
00:54:51,017 --> 00:55:00,076
get from stat and things like that how

1028
00:54:55,489 --> 00:55:04,400
big it is and and things like that so

1029
00:55:00,229 --> 00:55:06,268
that's for every every file in the

1030
00:55:04,004 --> 00:55:09,613
system actually has a V node entry

1031
00:55:06,619 --> 00:55:13,630
whether it's open or closed now this can

1032
00:55:10,009 --> 00:55:16,054
get complicated so for example if within

1033
00:55:13,729 --> 00:55:18,808
a single program you call open twice on

1034
00:55:16,459 --> 00:55:22,420
the same function you'll actually get

1035
00:55:19,519 --> 00:55:24,615
two different file descriptors and

1036
00:55:22,042 --> 00:55:28,231
you'll be able to access that same file

1037
00:55:25,479 --> 00:55:32,536
and have two different positions in it

1038
00:55:28,609 --> 00:55:37,651
and it makes sense if you imagine you're

1039
00:55:33,049 --> 00:55:40,090
reading from a file and you might want

1040
00:55:38,029 --> 00:55:42,055
to read from two different positions in

1041
00:55:40,459 --> 00:55:43,464
that file within the same program and

1042
00:55:42,289 --> 00:55:47,380
you can do that that's perfectly legal

1043
00:55:43,959 --> 00:55:49,270
you just call open twice and that will

1044
00:55:48,199 --> 00:55:52,930
keep track of two

1045
00:55:49,027 --> 00:55:54,076
positions so the point is these file

1046
00:55:52,093 --> 00:55:56,095
descriptors might be referring to the

1047
00:55:54,076 --> 00:55:58,099
same file but they're actually at

1048
00:55:56,095 --> 00:56:01,108
different positions within the file and

1049
00:55:58,099 --> 00:56:03,163
that can happen also if you're if you've

1050
00:56:02,008 --> 00:56:06,091
opened a file for both reading and for

1051
00:56:04,063 --> 00:56:09,109
writing and you're writing ahead and

1052
00:56:06,091 --> 00:56:11,164
then reading characters bytes that have

1053
00:56:10,009 --> 00:56:15,067
already been written that makes sense

1054
00:56:12,064 --> 00:56:19,078
it's not such a good idea to have two

1055
00:56:15,067 --> 00:56:21,151
different write file opens that are

1056
00:56:19,078 --> 00:56:24,079
writing simultaneously you can mess up

1057
00:56:22,051 --> 00:56:25,060
the file pretty badly that way but

1058
00:56:24,088 --> 00:56:28,144
there's nothing in the operating system

1059
00:56:26,041 --> 00:56:32,104
that prevents you from doing that so it

1060
00:56:29,044 --> 00:56:36,067
won't it's not a good idea but it's a

1061
00:56:33,004 --> 00:56:39,049
legal operation so that's the point is

1062
00:56:36,067 --> 00:56:42,148
you have to distinguish at what level is

1063
00:56:39,049 --> 00:56:50,092
sharing taking place and you see that if

1064
00:56:43,048 --> 00:56:53,146
you have two different table entries

1065
00:56:50,092 --> 00:56:55,108
sharing one file then that what's

1066
00:56:54,046 --> 00:56:59,064
different there is that you can be

1067
00:56:56,008 --> 00:56:59,064
working at different file positions

1068
00:57:00,048 --> 00:57:06,142
similarly of course the more common

1069
00:57:03,052 --> 00:57:09,054
thing is you have two different open

1070
00:57:07,042 --> 00:57:12,064
files in there refer to different files

1071
00:57:09,072 --> 00:57:15,106
but now and this is where life gets

1072
00:57:12,064 --> 00:57:19,078
exciting if you call Fork you remember

1073
00:57:16,006 --> 00:57:22,042
about Fork that it spawns a child but

1074
00:57:19,078 --> 00:57:23,164
that child inherits a lot of information

1075
00:57:22,042 --> 00:57:27,046
from its parent and one of the things

1076
00:57:24,064 --> 00:57:29,092
that inherits is its descriptor table it

1077
00:57:27,082 --> 00:57:33,096
gets a replica of that descriptor table

1078
00:57:29,092 --> 00:57:36,126
and so now both the parent and the child

1079
00:57:33,096 --> 00:57:38,194
have identical entries in their

1080
00:57:37,026 --> 00:57:42,097
descriptor table and so they're sharing

1081
00:57:39,094 --> 00:57:45,133
files but not at the file level but at

1082
00:57:42,097 --> 00:57:49,111
the Open File table and what that means

1083
00:57:46,033 --> 00:57:52,090
is if the parent does a read it'll bump

1084
00:57:50,011 --> 00:57:56,055
along the file position and if the child

1085
00:57:52,009 --> 00:57:59,014
know does it read it will it will see

1086
00:57:56,055 --> 00:58:01,069
this from this new position so you can

1087
00:57:59,095 --> 00:58:01,102
see why the exam problems get really

1088
00:58:01,069 --> 00:58:05,140
interesting

1089
00:58:02,065 --> 00:58:07,141
because that will keep track of all

1090
00:58:06,004 --> 00:58:13,012
these different possibilities and

1091
00:58:08,041 --> 00:58:15,750
they'll do different things and so and

1092
00:58:14,002 --> 00:58:17,098
then of course the parent or the child

1093
00:58:16,119 --> 00:58:19,960
can start opening and closing their own

1094
00:58:18,016 --> 00:58:22,665
files as well and that will get very

1095
00:58:19,096 --> 00:58:25,995
messy and here's what you see the reason

1096
00:58:22,809 --> 00:58:30,700
for having reference counts here that if

1097
00:58:26,859 --> 00:58:34,180
you have a lot of forking going on then

1098
00:58:30,007 --> 00:58:39,103
you can create multiple pointers to this

1099
00:58:34,018 --> 00:58:42,097
a table entry and in order to really

1100
00:58:40,066 --> 00:58:46,093
really close the file each of these has

1101
00:58:42,097 --> 00:58:48,486
to call closed before the file is truly

1102
00:58:46,093 --> 00:58:56,532
truly closed from an operating system

1103
00:58:49,359 --> 00:58:59,910
perspective so there's other fun things

1104
00:58:57,369 --> 00:59:02,388
that make life interesting too and

1105
00:58:59,091 --> 00:59:04,020
contribute to the exam problem

1106
00:59:02,559 --> 00:59:10,607
possibilities what is it call called

1107
00:59:04,839 --> 00:59:10,841
dupe - and the purpose the dupe - is -

1108
00:59:12,042 --> 00:59:21,097
excuse me duplicate a entry in the

1109
00:59:18,819 --> 00:59:24,827
descriptor table and the most common use

1110
00:59:21,097 --> 00:59:27,168
of that is a IO redirection that either

1111
00:59:25,619 --> 00:59:31,420
greater or less than sign to either

1112
00:59:28,068 --> 00:59:33,142
redirect read the instead of from

1113
00:59:31,042 --> 00:59:36,115
standard input from a file or instead of

1114
00:59:34,042 --> 00:59:39,651
writing to standard output to write to a

1115
00:59:37,015 --> 00:59:41,113
file and the way the operating system

1116
00:59:40,029 --> 00:59:44,890
actually implements that is shortly

1117
00:59:42,013 --> 00:59:54,021
after starting the program it will call

1118
00:59:44,089 --> 00:59:56,508
called Duke - to make it so that the

1119
00:59:54,021 --> 01:00:01,048
file descriptor 1 is not the standard

1120
00:59:57,309 --> 01:00:04,390
output of the for this process but it's

1121
01:00:01,048 --> 01:00:07,069
actually the original standard output

1122
01:00:04,039 --> 01:00:09,198
but it's actually a descriptor for the

1123
01:00:07,069 --> 01:00:10,698
file that it's supposed to write to and

1124
01:00:09,549 --> 01:00:12,550
same with if it's doing input

1125
01:00:11,319 --> 01:00:16,010
redirection

1126
01:00:12,055 --> 01:00:18,071
and but you can call Duke to yourself

1127
01:00:16,001 --> 01:00:22,009
and do these kind of things and these

1128
01:00:18,071 --> 01:00:21,109
actually good reasons for doing so

1129
01:00:25,084 --> 01:00:31,178
so in particular imagine I open the file

1130
01:00:29,003 --> 01:00:39,020
and standard output points to the sort

1131
01:00:32,078 --> 01:00:42,104
of normal thing and I open a new file I

1132
01:00:39,002 --> 01:00:43,019
call it B and then I call Duke to excuse

1133
01:00:43,004 --> 01:00:46,007
me

1134
01:00:43,037 --> 01:00:48,089
and now what both file descriptor 1 and

1135
01:00:46,034 --> 01:00:50,129
file descriptor for are sharing this

1136
01:00:48,089 --> 01:00:53,174
entry in the file table and you see the

1137
01:00:51,029 --> 01:00:57,032
reference count of 2 and so in order to

1138
01:00:54,074 --> 01:00:59,092
really close it then what would

1139
01:00:57,032 --> 01:01:02,066
typically happen at this point is the

1140
01:00:59,092 --> 01:01:03,188
this is happens before it starts to your

1141
01:01:02,066 --> 01:01:11,081
program you'd want to close file

1142
01:01:04,088 --> 01:01:13,094
descriptor 4 and in fact there's a lot

1143
01:01:11,081 --> 01:01:16,127
of bugs you can make by not closing

1144
01:01:13,094 --> 01:01:18,125
files it's easy to make mistakes when

1145
01:01:17,027 --> 01:01:27,086
you have multiple entries in these

1146
01:01:19,025 --> 01:01:30,041
tables yep no C if I call close this one

1147
01:01:27,086 --> 01:01:33,175
it just decrement sits reference count

1148
01:01:30,041 --> 01:01:34,075
but this remains a valid entry here

1149
01:01:35,044 --> 01:01:51,103
while a yes but due to will decrement

1150
01:01:43,000 --> 01:01:53,092
the reference count of the original dupe

1151
01:01:52,003 --> 01:02:02,832
to goes backwards from where you think

1152
01:01:53,092 --> 01:02:04,120
it should so do two is the I want what

1153
01:02:02,859 --> 01:02:10,420
what I referred to for example file

1154
01:02:05,002 --> 01:02:13,030
descriptor I want file descriptor for to

1155
01:02:10,042 --> 01:02:15,951
become what I can use to and refer to

1156
01:02:13,048 --> 01:02:18,417
with file descriptor 1 here it will

1157
01:02:16,329 --> 01:02:24,000
actually decrement the reference count

1158
01:02:18,849 --> 01:02:30,760
of this before it done does the copy

1159
01:02:24,000 --> 01:02:34,026
otherwise it would create like a an

1160
01:02:30,076 --> 01:02:33,081
orphan in this table right

1161
01:02:36,053 --> 01:02:45,068
Oh so anyways dupe 2 also is a powerful

1162
01:02:41,009 --> 01:02:47,096
but dangerous mechanism so now finally

1163
01:02:45,068 --> 01:02:50,132
let me just mention the much more common

1164
01:02:48,077 --> 01:02:53,078
i/o that application programs use is

1165
01:02:51,032 --> 01:02:55,103
what's known as the standard i/o and

1166
01:02:53,078 --> 01:02:58,151
that's what's documented in knr and it's

1167
01:02:56,003 --> 01:03:03,041
actually part of the the C standard all

1168
01:02:59,051 --> 01:03:04,145
these different functions and so the

1169
01:03:03,041 --> 01:03:07,043
main feature it adds is sort of like

1170
01:03:05,045 --> 01:03:09,128
what you saw with the REO package it

1171
01:03:07,043 --> 01:03:12,065
adds buffering so it doesn't have to do

1172
01:03:10,028 --> 01:03:21,071
this low-level stuff and it avoids all

1173
01:03:12,065 --> 01:03:23,087
than some of the nastiness and the way

1174
01:03:21,071 --> 01:03:29,072
it works is what we've already seen it

1175
01:03:23,087 --> 01:03:31,093
uses buffering to do a vio so just as an

1176
01:03:29,081 --> 01:03:31,093
example

1177
01:03:44,068 --> 01:03:50,377
here's some code that calls printf one

1178
01:03:49,039 --> 01:03:58,930
character at a time to print the word

1179
01:03:50,989 --> 01:03:58,930
hello but if I run that and is trace it

1180
01:04:05,009 --> 01:04:10,044
you see that there's only one system

1181
01:04:07,749 --> 01:04:13,180
call to two right and it works the same

1182
01:04:10,359 --> 01:04:15,426
way you saw with the Rio code it builds

1183
01:04:13,018 --> 01:04:20,116
up a buffer and it's not until this call

1184
01:04:16,029 --> 01:04:24,084
to F flush that forces the output to

1185
01:04:21,016 --> 01:04:26,017
actually be a printed output usually

1186
01:04:24,579 --> 01:04:31,596
that happens automatically actually if

1187
01:04:26,017 --> 01:04:35,038
you print up a line feed it will flush

1188
01:04:31,749 --> 01:04:45,807
it so that I think that called F wash is

1189
01:04:35,038 --> 01:04:50,777
probably redundant here so and so that's

1190
01:04:46,329 --> 01:04:50,408
the benefit so buffered i/o is much more

1191
01:04:51,869 --> 01:05:04,908
efficient because it because of the

1192
01:04:54,091 --> 01:05:06,540
buffering so as a result we've now seen

1193
01:05:05,259 --> 01:05:10,450
three different types of i/o there's the

1194
01:05:07,359 --> 01:05:13,390
low-level i/o called you referred to as

1195
01:05:10,045 --> 01:05:14,050
UNIX i/o you saw this package that was

1196
01:05:13,039 --> 01:05:16,096
written specifically for the book and

1197
01:05:14,095 --> 01:05:19,224
for the course called Rio and then

1198
01:05:16,096 --> 01:05:23,235
there's a much larger and in fact richer

1199
01:05:20,079 --> 01:05:26,950
set of i/o functions provided by the

1200
01:05:24,099 --> 01:05:29,230
UNIX standard library so you might ask a

1201
01:05:26,095 --> 01:05:29,188
couple questions one is well why the

1202
01:05:29,023 --> 01:05:33,097
heck did you write this when you've

1203
01:05:30,088 --> 01:05:35,092
already got that if if UNIX provides

1204
01:05:33,097 --> 01:05:37,926
buffered i/o why did you do it yourself

1205
01:05:35,092 --> 01:05:42,097
and the reason is this stuff doesn't it

1206
01:05:38,799 --> 01:05:45,801
works really well for the i/o you do to

1207
01:05:42,097 --> 01:05:47,406
a terminal or defiled but it doesn't do

1208
01:05:45,819 --> 01:05:50,820
very well with network connections it

1209
01:05:48,279 --> 01:05:53,470
wasn't really designed for that and so

1210
01:05:50,829 --> 01:05:53,928
it gets really messed up and so the main

1211
01:05:53,047 --> 01:05:56,406
reason you're going to find yourself

1212
01:05:54,819 --> 01:05:59,470
using this is when you're starting to

1213
01:05:56,829 --> 01:06:02,829
use network connections oh the other

1214
01:05:59,047 --> 01:06:04,926
thing is these do not coexist very well

1215
01:06:02,829 --> 01:06:06,852
buffered i/o with a reow i/o

1216
01:06:05,349 --> 01:06:08,400
because they each maintain their own

1217
01:06:07,059 --> 01:06:11,130
buffers and they don't know about each

1218
01:06:08,859 --> 01:06:13,390
other and they get terribly confused so

1219
01:06:11,769 --> 01:06:13,930
you kind of have to pick one or the

1220
01:06:13,039 --> 01:06:14,135
other

1221
01:06:13,093 --> 01:06:16,166
with respect to any

1222
01:06:15,035 --> 01:06:25,037
ticular i/o connection and don't try to

1223
01:06:17,066 --> 01:06:27,092
mix and match them so like I said UNIX

1224
01:06:25,055 --> 01:06:29,108
i/o then the low-level stuff from an

1225
01:06:27,092 --> 01:06:31,097
application perspective it's like really

1226
01:06:30,008 --> 01:06:34,100
painful to use especially with short

1227
01:06:31,097 --> 01:06:39,140
counts and error codes and and all that

1228
01:06:35,000 --> 01:06:42,002
stuff and so in general you want to

1229
01:06:40,004 --> 01:06:44,051
either write your own package or use

1230
01:06:42,002 --> 01:06:46,076
some other package around it and so as I

1231
01:06:44,087 --> 01:06:48,143
said standard i/o it gives you printf

1232
01:06:46,094 --> 01:06:51,163
and scanf and all these nice features

1233
01:06:49,043 --> 01:07:00,137
it's uniform it exists on all systems

1234
01:06:52,063 --> 01:07:04,076
it's reasonably standardized so in

1235
01:07:01,037 --> 01:07:07,130
general then use the the standard i/o

1236
01:07:04,076 --> 01:07:12,131
for most year of day-to-day uses of

1237
01:07:08,003 --> 01:07:16,052
files I'll use the raw IO for low-level

1238
01:07:13,031 --> 01:07:20,045
stuff like when you have to and partly

1239
01:07:16,079 --> 01:07:21,104
it turns out signals are not you

1240
01:07:20,045 --> 01:07:24,074
shouldn't use standard i/o when you're

1241
01:07:22,004 --> 01:07:26,051
writing signal handlers and then the REO

1242
01:07:24,074 --> 01:07:29,156
you're going to find useful for in

1243
01:07:26,051 --> 01:07:34,108
particular for doing networking one

1244
01:07:30,056 --> 01:07:36,155
other thing that you should one bug that

1245
01:07:35,008 --> 01:07:41,021
students do over and over again in this

1246
01:07:37,055 --> 01:07:44,117
course is they try to do a line oriented

1247
01:07:41,021 --> 01:07:47,045
i/o on things that aren't lines so like

1248
01:07:45,017 --> 01:07:48,113
a JPEG image or something like that and

1249
01:07:47,045 --> 01:07:52,058
the reason that's important is that

1250
01:07:49,013 --> 01:07:55,040
these functions are treat the end of

1251
01:07:52,058 --> 01:07:56,120
line character zero a is a very special

1252
01:07:55,004 --> 01:07:58,013
character they'll stop reading or

1253
01:07:57,002 --> 01:08:02,015
something like that or if it's going

1254
01:07:59,003 --> 01:08:04,058
between Windows and UNIX it will

1255
01:08:02,033 --> 01:08:06,080
actually change one from carriage

1256
01:08:04,085 --> 01:08:08,090
returns from line feed to carriage

1257
01:08:06,008 --> 01:08:10,097
return line feed sin way functions like

1258
01:08:09,035 --> 01:08:13,112
steer land and steer copy will stop when

1259
01:08:11,069 --> 01:08:14,078
they hit a null byte and that's not what

1260
01:08:14,012 --> 01:08:19,040
you want to do when these are network

1261
01:08:15,059 --> 01:08:21,098
packets you're trying to send out so be

1262
01:08:19,004 --> 01:08:24,213
careful some of the functions you've

1263
01:08:21,098 --> 01:08:26,105
used a lot and you're very familiar with

1264
01:08:24,609 --> 01:08:30,340
may be completely inappropriate for

1265
01:08:27,068 --> 01:08:32,159
are things where you're doing binary of

1266
01:08:30,034 --> 01:08:35,075
data or you're communicating over

1267
01:08:33,059 --> 01:08:37,136
networks and things like that so be sure

1268
01:08:35,075 --> 01:08:39,134
you understand what you're doing when

1269
01:08:38,036 --> 01:08:44,120
you start to use these kind of functions

1270
01:08:40,034 --> 01:08:47,063
oh so those do you really want to know

1271
01:08:45,002 --> 01:08:48,098
this stuff there's there's a fellow

1272
01:08:47,063 --> 01:08:54,128
named Richard Stevens who unfortunately

1273
01:08:49,016 --> 01:08:57,092
died awhile quite a while ago but his

1274
01:08:55,028 --> 01:08:59,105
books live on and there's various people

1275
01:08:57,092 --> 01:09:04,121
have signed up to become co-authors with

1276
01:09:00,005 --> 01:09:08,056
him in his absence and creating new

1277
01:09:05,021 --> 01:09:11,030
editions of these books that used to

1278
01:09:08,056 --> 01:09:13,094
date back way far so and if you really

1279
01:09:12,011 --> 01:09:16,043
want to know how this stuff works you

1280
01:09:13,094 --> 01:09:17,156
want to be the 8th programmer these

1281
01:09:16,043 --> 01:09:21,071
books are the best you can get but I'll

1282
01:09:18,056 --> 01:09:25,060
also warn you your bookshelf will become

1283
01:09:21,071 --> 01:09:27,137
very heavy laden because there's there's

1284
01:09:25,006 --> 01:09:30,023
volumes one two and three and then

1285
01:09:28,037 --> 01:09:33,044
there's networking books and Stevens is

1286
01:09:30,077 --> 01:09:34,115
like a encyclopedic reference but

1287
01:09:33,044 --> 01:09:36,044
they're excellent books if you really

1288
01:09:35,015 --> 01:09:40,022
want to understand something

1289
01:09:36,044 --> 01:09:43,088
read Stevens oh and there's another book

1290
01:09:40,022 --> 01:09:45,119
that is just specific to Linux that's

1291
01:09:43,088 --> 01:09:48,101
fairly nice and somewhat it's very

1292
01:09:46,019 --> 01:09:50,081
detailed but since it's only trying to

1293
01:09:49,001 --> 01:09:54,008
deal with Linux it's a little bit less

1294
01:09:50,081 --> 01:09:56,114
of weird than trying to read Stevens

1295
01:09:54,071 --> 01:09:58,073
because Stevens will say in this version

1296
01:09:57,014 --> 01:10:00,050
of UNIX it works this way in this

1297
01:09:58,091 --> 01:10:01,154
version it works that way and blah blah

1298
01:10:00,005 --> 01:10:04,100
blah and it's all different and it will

1299
01:10:02,054 --> 01:10:10,078
drive you crazy but Stevens is still

1300
01:10:05,045 --> 01:10:12,053
it's an outstanding set of books ok so

1301
01:10:10,078 --> 01:10:13,172
this is an example and I'm not going to

1302
01:10:13,025 --> 01:10:16,097
go through it but these are the kind of

1303
01:10:14,072 --> 01:10:19,121
things that we use to torture students

1304
01:10:16,097 --> 01:10:22,160
that you open some file descriptors and

1305
01:10:20,021 --> 01:10:26,057
you do some dupes and you do some Forks

1306
01:10:23,006 --> 01:10:29,039
and so you end up with a real spaghetti

1307
01:10:26,057 --> 01:10:31,112
for all the pointers and what's shared

1308
01:10:29,093 --> 01:10:34,121
and what's not shared and then you ask

1309
01:10:32,012 --> 01:10:36,098
what will this print and of course you

1310
01:10:35,021 --> 01:10:40,093
have to trace through in great detail

1311
01:10:36,098 --> 01:10:41,185
what's really going on so those are

1312
01:10:40,093 --> 01:10:44,125
in the book and I recommend you work on

1313
01:10:42,085 --> 01:10:46,170
some of those okay that'll do it for

1314
01:10:45,025 --> 01:10:47,070
today then

