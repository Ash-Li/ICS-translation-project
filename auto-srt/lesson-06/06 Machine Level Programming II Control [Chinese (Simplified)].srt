1
00:00:01,001 --> 00:00:09,084
好吧，让我们 继续在我们的覆盖范围 

2
00:00:05,879 --> 00:00:13,320
的机器语言的II和我 

3
00:00:09,084 --> 00:00:14,213
认为六个 部分组成 的系列正如我所说 

4
00:00:13,032 --> 00:00:16,119
昨日机器语言是 

5
00:00:14,969 --> 00:00:19,740
排序本课程的核心，它 

6
00:00:17,019 --> 00:00:22,080
为您提供了一套工具 和 

7
00:00:19,074 --> 00:00:23,453
理解是 ， 把你远远超出 

8
00:00:22,008 --> 00:00:26,477
什么年平均 

9
00:00:24,119 --> 00:00:29,130
运行中的磨 程序员 或 

10
00:00:27,269 --> 00:00:31,800
软件开发者都知道

11
00:00:29,013 --> 00:00:33,110
关于它来讲是非常强大的 

12
00:00:31,008 --> 00:00:38,022
您更好地了解该系统的 

13
00:00:34,001 --> 00:00:41,067
哪里出了问题，为什么，为什么节目 

14
00:00:38,094 --> 00:00:42,096
死机什么的意思是和 

15
00:00:41,076 --> 00:00:45,141
所以它的一个非常核心的部分

16
00:00:43,014 --> 00:00:50,043
材料如你所知的数据网络是由于 

17
00:00:46,041 --> 00:00:51,830
今晚 约被称为下一个方式 

18
00:00:50,043 --> 00:00:55,107
炸弹实验室，我相信这是未来 

19
00:00:52,199 --> 00:00:58,710
今晚还有这样的炸弹实验室将 

20
00:00:56,007 --> 00:01:01,014
靠你 的理解 能力 

21
00:00:58,071 --> 00:01:02,166
机器级代码，以便这两个 

22
00:01:01,077 --> 00:01:04,158
讲座实际上是足以让 

23
00:01:03,066 --> 00:01:07,143
你开始对一些 早期部分 

24
00:01:05,058 --> 00:01:10,134
该实验室的你会学到更多 的 

25
00:01:08,043 --> 00:01:13,071
朗诵周一亲自或 

26
00:01:11,034 --> 00:01:16,086
如果你正在浏览的记录的版本

27
00:01:13,071 --> 00:01:18,620
那这将帮助你一起 继续 前进 

28
00:01:16,086 --> 00:01:20,154
炸弹网页就像这一切的实验室 

29
00:01:19,259 --> 00:01:23,700
当然，至少前两个我们给 

30
00:01:21,054 --> 00:01:24,953
您对他们有相当数量的时间，但 

31
00:01:23,007 --> 00:01:28,026
不要因此就认为这意味着 

32
00:01:25,439 --> 00:01:31,530
你可以懈怠 或其他工作 

33
00:01:28,089 --> 00:01:33,138
课程，那么最后几分钟 

34
00:01:31,053 --> 00:01:35,852
跳，并完成这个抢炸弹 

35
00:01:34,038 --> 00:01:38,109
实验一旦你得到你在做什么窍门 

36
00:01:36,329 --> 00:01:41,520
这样做是相当的，你可以只是种 

37
00:01:39,009 --> 00:01:44,103
沿曲轴，但有一定的 

38
00:01:41,052 --> 00:01:46,113
学习曲线 ，将带你到 

39
00:01:45,003 --> 00:01:49,882
甚至开始使用它有效地使 

40
00:01:47,013 --> 00:01:49,792
不要把它关闭 

41
00:01:52,048 --> 00:01:54,051
啊 

42
00:01:55,093 --> 00:02:00,102
嗯哦，是这样的 

43
00:02:11,038 --> 00:02:15,080
所以上次 我们介绍了很 

44
00:02:14,003 --> 00:02:18,005
机水平的基本原则

45
00:02:15,008 --> 00:02:20,012
编程有 存在 的想法 

46
00:02:18,005 --> 00:02:23,012
你有 机会获得特殊状态 

47
00:02:20,084 --> 00:02:25,139
之后人 来到寄存器

48
00:02:23,075 --> 00:02:29,314
类内斯特 寄存器的 存储 部 

49
00:02:26,039 --> 00:02:31,070
没有他们是 缓存的 一部分 没有通过 

50
00:02:29,989 --> 00:02:34,042
特别他们是不同的 ，他们 不 

51
00:02:31,007 --> 00:02:35,015
存在 当 你是 一个海拔 程序 

52
00:02:34,519 --> 00:02:37,597
编程，看你没有任何 

53
00:02:35,078 --> 00:02:39,086
洞察他们和一般 

54
00:02:38,299 --> 00:02:43,010
今天我们将做的就是 去 

55
00:02:40,058 --> 00:02:43,139
超越那种非常基础和启动 

56
00:02:43,001 --> 00:02:47,042
谈论如何控制你 

57
00:02:44,039 --> 00:02:49,043
控制的执行流 

58
00:02:47,042 --> 00:02:52,043
在机器级别的指令

59
00:02:49,079 --> 00:02:54,112
以及如何使用这些技术来 

60
00:02:52,043 --> 00:02:57,116
实现基本构造条件 

61
00:02:55,012 --> 00:02:59,941
声明循环和switch语句

62
00:02:58,016 --> 00:03:01,112
再下一次，我们将讨论 

63
00:03:00,049 --> 00:03:07,640
这不是一个整 场讲座程序

64
00:03:02,012 --> 00:03:10,070
自己的，这样x86和几个

65
00:03:07,064 --> 00:03:14,078
其代光机有这些 

66
00:03:10,007 --> 00:03:16,031
那 是 一个位标志好奇的小 

67
00:03:14,078 --> 00:03:19,090
所谓的条件代码和他们的

68
00:03:16,094 --> 00:03:24,113
如何条件操作的工作基础

69
00:03:19,009 --> 00:03:25,067
这样一台机器级的程序员，那我们 

70
00:03:25,013 --> 00:03:32,014
谈到你有 最后一次 

71
00:03:26,048 --> 00:03:35,093
该组寄存器和一个的可见性 

72
00:03:32,023 --> 00:03:37,432
和记忆，但你也有更多的

73
00:03:35,093 --> 00:03:38,099
事情，这只是部分清单 

74
00:03:37,639 --> 00:03:42,661
实际上，有 越来越多的东西 

75
00:03:39,053 --> 00:03:45,412
您可以添加到这个 画面，但我们 

76
00:03:42,859 --> 00:03:49,956
在64位x86 64畅谈

77
00:03:45,889 --> 00:03:55,970
现在有16个寄存器8，其中有 

78
00:03:50,829 --> 00:03:58,760
名基于旧的x86是历史 

79
00:03:55,097 --> 00:03:59,986
的东西， 其中68引入 

80
00:03:58,076 --> 00:04:03,167
所以就简单地命名为 名称那些 

81
00:04:00,859 --> 00:04:06,380
8，通过我们的15和这些寄存器 

82
00:04:04,067 --> 00:04:09,226
在 大多数情况下只有 一个那 

83
00:04:06,038 --> 00:04:11,647
很特别的是RSP它的堆栈 

84
00:04:09,829 --> 00:04:14,848
指针时，它会告诉你在哪里， 我们将 

85
00:04:11,989 --> 00:04:17,044
学到了很多有关 堆栈开始 

86
00:04:15,019 --> 00:04:18,103
接下来的时间，但它的排序， 其中 

87
00:04:17,539 --> 00:04:20,690
大多数

88
00:04:18,859 --> 00:04:24,862
状态是管理执行 

89
00:04:20,069 --> 00:04:26,096
的程序 ，所以你不能只 使用 

90
00:04:24,889 --> 00:04:30,910
即或以任意 方式而设置

91
00:04:26,096 --> 00:04:31,180
其他的你或多或少与进来 

92
00:04:31,099 --> 00:04:35,240
资格的发言 

93
00:04:32,008 --> 00:04:36,053
还有，他们称之为另一个寄存器 

94
00:04:35,024 --> 00:04:41,111
在我们的IP具有 无关 

95
00:04:37,025 --> 00:04:45,154
死亡这意味着IP方式

96
00:04:42,011 --> 00:04:47,108
在IA32指令指针被称为 

97
00:04:45,379 --> 00:04:50,445
IP，现在它被称为我们的IP就像 

98
00:04:48,008 --> 00:04:54,056
该登记处是EAX现在它是我们的IX 

99
00:04:51,039 --> 00:04:56,098
所以它包含所有的地址 

100
00:04:54,056 --> 00:05:00,137
当前执行的指令和 

101
00:04:56,629 --> 00:05:03,590
你可以将它不是 一个寄存器， 你 

102
00:05:01,037 --> 00:05:05,081
在一个正常的方式，但你实际上访问

103
00:05:03,059 --> 00:05:07,103
还有， 你可以找到窍门

104
00:05:05,081 --> 00:05:10,720
什么该值是如此，只是 

105
00:05:08,003 --> 00:05:12,056
告诉你在哪里在程序 哪一部分 

106
00:05:11,449 --> 00:05:14,780
该方案是 目前正在 

107
00:05:12,056 --> 00:05:15,149
执行，然后还有这些东西 

108
00:05:14,078 --> 00:05:17,081
这被称为条件码和 

109
00:05:16,049 --> 00:05:20,102
我们只显示了四个居然有 

110
00:05:18,008 --> 00:05:24,247
更像是他们八个但 不相关 

111
00:05:21,002 --> 00:05:27,065
我们一般的讨论中都 

112
00:05:24,319 --> 00:05:30,110
一个位标志，他们得到不设置 

113
00:05:27,065 --> 00:05:31,924
直接但 作为 其他 的 副作用 

114
00:05:30,011 --> 00:05:34,560
所 发生的 ，他们是操作

115
00:05:32,509 --> 00:05:38,515
的基础，其条件

116
00:05:34,659 --> 00:05:41,090
操作被决定让我们去 

117
00:05:38,569 --> 00:05:42,622
通过什么意思那些有 

118
00:05:41,009 --> 00:05:44,698
他们给出的名字，但这些名字 

119
00:05:43,099 --> 00:05:49,105
真正有用的记住他们 

120
00:05:44,779 --> 00:05:50,836
意味着这么CF意味着进位标志和 

121
00:05:49,159 --> 00:05:53,810
如果你想添加的两个数字 认为 

122
00:05:51,349 --> 00:05:56,365
他们的两个无符号数，你 

123
00:05:53,081 --> 00:05:58,690
做算术，有时 

124
00:05:56,509 --> 00:06:01,528
额外的一个弹出 左手 

125
00:05:59,419 --> 00:06:04,480
侧右那是进位，如果你 

126
00:06:01,699 --> 00:06:10,550
您添加的数字排序的太

127
00:06:05,029 --> 00:06:12,650
大到被包含在 所述32或64个 

128
00:06:10,055 --> 00:06:15,056
位，甚至导致16或八个 

129
00:06:12,065 --> 00:06:18,152
因此产生的额外位这就是 

130
00:06:15,056 --> 00:06:22,124
所谓进位零标志 

131
00:06:19,052 --> 00:06:25,411
这听起来像它的设置如果在 

132
00:06:23,024 --> 00:06:26,953
你刚才计算的值为零 ， 这些 

133
00:06:25,879 --> 00:06:29,220
由算术通常设置 

134
00:06:27,169 --> 00:06:31,530
顺便说一下说明书 

135
00:06:29,022 --> 00:06:34,107
如果该值的符号标志， 据说刚 

136
00:06:31,053 --> 00:06:36,057
计算为1和最显著 

137
00:06:35,007 --> 00:06:42,009
位意味着它是一个负值， 

138
00:06:36,093 --> 00:06:43,185
在OLE标志溢出标志 是 牙齿 

139
00:06:42,009 --> 00:06:47,016
溢出的恭维版本，以便在 

140
00:06:44,085 --> 00:06:49,134
特别是如果你的数据网络记得 

141
00:06:47,016 --> 00:06:53,034
你怎么知道我们是否添加了两个 

142
00:06:50,034 --> 00:06:55,050
值溢出是如果症状 

143
00:06:53,034 --> 00:06:56,097
操作数是相同的 ，但

144
00:06:55,005 --> 00:06:56,094
结果的符号是不同于 

145
00:06:56,097 --> 00:06:58,164
那 

146
00:06:57,039 --> 00:07:01,116
所以无论你增加了两个正 数 

147
00:06:59,064 --> 00:07:03,126
并得到了否定的结果，这是 一个 

148
00:07:02,016 --> 00:07:05,115
积极的溢出或者你加了两个 

149
00:07:04,026 --> 00:07:08,052
负数并 得到了负 

150
00:07:06,015 --> 00:07:11,016
结果是负溢出 

151
00:07:08,052 --> 00:07:14,145
你不能溢出了两个参数 

152
00:07:11,016 --> 00:07:18,018
符号相反权利，使那些 

153
00:07:15,045 --> 00:07:21,123
四个标志被置作为排序的正常 

154
00:07:18,018 --> 00:07:25,026
许多人的指示不活动

155
00:07:22,023 --> 00:07:26,112
我们的朋友的le.a指令， 

156
00:07:25,026 --> 00:07:29,064
我提到的是怎样的一个古怪的

157
00:07:27,012 --> 00:07:34,044
指令GCC真的喜欢了很多 

158
00:07:29,064 --> 00:07:35,073
你会看到它在很多地方 ，但 

159
00:07:34,044 --> 00:07:38,106
一般来说， 大部分时间这些 

160
00:07:36,054 --> 00:07:42,075
标志得到完全忽略，因为 谁 

161
00:07:39,006 --> 00:07:44,007
在乎权利 ，但他们出现在 

162
00:07:42,075 --> 00:07:48,081
当你做的不同点 

163
00:07:44,007 --> 00:07:51,084
有条件的操作，以便有一些

164
00:07:49,035 --> 00:07:53,040
特别说明 ，其 唯一的作用 

165
00:07:51,084 --> 00:07:54,183
是设置条件码和一个

166
00:07:53,085 --> 00:07:58,089
你会看到，尤其 是 

167
00:07:55,083 --> 00:08:00,114
所谓比较 CMP和方式的 

168
00:07:59,025 --> 00:08:02,097
在这些端部的队列 是所有 

169
00:08:01,014 --> 00:08:09,042
只是他们的工作的反思

170
00:08:02,097 --> 00:08:10,116
64位字四字正如 我所说所以 

171
00:08:09,042 --> 00:08:14,073
比较是有点像 减法 

172
00:08:11,016 --> 00:08:16,073
除了你没有， 你的指令

173
00:08:14,073 --> 00:08:18,168
不与结果做任何事 

174
00:08:16,073 --> 00:08:22,131
正常减法指令是如X 

175
00:08:19,068 --> 00:08:24,099
减去等于Ÿ它会读取两个数字 

176
00:08:23,031 --> 00:08:28,038
但随后将存储结果 

177
00:08:24,099 --> 00:08:29,133
无论X存储，但只是比较 

178
00:08:29,001 --> 00:08:32,079
取这 两个值做了 

179
00:08:30,033 --> 00:08:34,110
减法 ，不会做任何事 

180
00:08:32,079 --> 00:08:38,114
结果，但它会设置 它的这些 

181
00:08:35,001 --> 00:08:39,005
4个 状况标志和 

182
00:08:39,095 --> 00:08:44,117
只是几 件事情 要记住 ， 

183
00:08:42,023 --> 00:08:49,121
往往将是混乱 的来源

184
00:08:45,017 --> 00:08:52,028
是记得 在参数 

185
00:08:50,021 --> 00:08:55,058
我们写他们 的 机器 代码的方法是 

186
00:08:52,028 --> 00:08:57,053
你会的 方式 期望相反

187
00:08:55,058 --> 00:08:59,093
我有人问我最后 一次有 

188
00:08:57,053 --> 00:09:02,054
另一个有几分 两种 方言 的 

189
00:08:59,093 --> 00:09:04,106
在x86机器上使用的汇编代码

190
00:09:02,063 --> 00:09:07,124
有一个 的二手由英特尔和 

191
00:09:05,006 --> 00:09:11,020
微软与我们不使用 它，然后 

192
00:09:08,024 --> 00:09:13,031
有一个用那种使用 

193
00:09:11,002 --> 00:09:15,077
Linux系统，这就是我们使用的一个 

194
00:09:13,094 --> 00:09:16,169
和他们不同 ，的一个 

195
00:09:15,095 --> 00:09:19,106
他们的怪癖是他们自己写的 

196
00:09:17,069 --> 00:09:21,074
参数在不同的顺序，因此 

197
00:09:20,006 --> 00:09:24,062
会让你发疯 的阅读尝试 

198
00:09:22,019 --> 00:09:26,024
阅读如果你熟悉一个很

199
00:09:24,062 --> 00:09:29,105
如果你曾经 试图 开车 像 

200
00:09:26,069 --> 00:09:34,073
在 道路 上的 错误的一边 ，你 经常 

201
00:09:30,005 --> 00:09:37,076
会崩溃，你做坏事嗯所以 

202
00:09:35,009 --> 00:09:39,095
这只是顺便说一句什么我找到 

203
00:09:37,076 --> 00:09:42,125
当我在看代码，我的方式 

204
00:09:39,095 --> 00:09:48,143
看到一个比较指令其实我

205
00:09:43,025 --> 00:09:51,077
写成的两个比较评论 

206
00:09:49,043 --> 00:09:53,126
但我翻的 顺序，这样我敢肯定 

207
00:09:51,077 --> 00:09:56,144
我有点守 在我心中是什么 

208
00:09:54,026 --> 00:09:59,039
比较上升了，因此这些标志得到 

209
00:09:57,044 --> 00:10:02,060
根据规则设定

210
00:09:59,039 --> 00:10:04,067
减法，所以它原来， 

211
00:10:02,006 --> 00:10:06,014
进位标志和溢出标志你 

212
00:10:04,067 --> 00:10:08,072
必须做翻转你的感觉是什么 

213
00:10:06,068 --> 00:10:10,082
发生，因为它是一个减法

214
00:10:08,072 --> 00:10:16,081
而不是加法，但它是相同的 

215
00:10:10,082 --> 00:10:18,155
一般的想法， 这样 排序显示你 

216
00:10:16,081 --> 00:10:20,087
一个特定的一个 和另一 

217
00:10:19,055 --> 00:10:24,068
指令你会看到他们的唯一

218
00:10:21,041 --> 00:10:27,041
目的在世界上是设置

219
00:10:24,068 --> 00:10:29,069
条件标志条件代码 是 

220
00:10:27,041 --> 00:10:31,049
测试指令，这通常是

221
00:10:29,078 --> 00:10:32,156
用于比较，你认为这是当 

222
00:10:32,021 --> 00:10:35,069
你有两个值，你想 

223
00:10:33,056 --> 00:10:37,058
他们互相比较和测试 

224
00:10:35,069 --> 00:10:39,071
是，如果你真的只是有一个值 和 

225
00:10:37,076 --> 00:10:42,104
你想看看是什么感觉是 

226
00:10:39,089 --> 00:10:43,160
零 是负 的那些是主要的 

227
00:10:43,004 --> 00:10:46,079
你 其实 关心的事情是这样的 

228
00:10:44,006 --> 00:10:50,009
只有你自己才能决定，但只是一点 

229
00:10:46,079 --> 00:10:52,118
因为我想他们有他们的排序 

230
00:10:50,063 --> 00:10:52,154
的 具有两个参数的 可能性 

231
00:10:53,018 --> 00:10:55,043
到 

232
00:10:53,054 --> 00:10:57,056
所以他们决定好，让我们继续前进 

233
00:10:55,043 --> 00:10:59,138
并做到这一点你怎么有两个参数 

234
00:10:57,056 --> 00:11:02,132
到测试指令， 什么是和两个 

235
00:11:00,038 --> 00:11:06,116
结果，然后测试值等什么 

236
00:11:03,032 --> 00:11:10,115
您通常看到的是一个测试，这两个 

237
00:11:07,016 --> 00:11:16,019
参数是相同的，所以试验Q％RI X 

238
00:11:11,015 --> 00:11:18,098
逗号％RI x， 其中，这样你只是 

239
00:11:16,046 --> 00:11:21,083
任何寄存器本身 和一个属性 

240
00:11:18,098 --> 00:11:24,098
最终操作是这是他们叫什么 

241
00:11:21,083 --> 00:11:25,169
项目有力添加结束 两件事 

242
00:11:24,098 --> 00:11:28,099
同样的东西放在一起给你同样的 

243
00:11:26,069 --> 00:11:28,072
时间

244
00:11:30,007 --> 00:11:37,016
所以我们可以看到这些，现在让我告诉 

245
00:11:36,041 --> 00:11:39,077
你是这样的条件代码怎么弄 

246
00:11:37,079 --> 00:11:41,084
现在设置你如何 真正阅读 

247
00:11:39,077 --> 00:11:43,118
你如何使用它们以及有

248
00:11:41,084 --> 00:11:45,092
两个原则，你其实可以 

249
00:11:44,018 --> 00:11:49,085
提取并获得条件码

250
00:11:46,064 --> 00:11:51,110
值直接出这个特殊的 

251
00:11:49,085 --> 00:11:53,183
状态寄存器但这是非常不寻常 

252
00:11:52,001 --> 00:11:58,007
要做到这一点 更重要的是常见的就是 你 

253
00:11:54,083 --> 00:12:00,167
无论是尝试读取它，并设置1位 

254
00:11:58,016 --> 00:12:04,049
标志基础上，结果在一个reg一些

255
00:12:01,067 --> 00:12:06,149
其他寄存器或者你尝试做一个 

256
00:12:04,049 --> 00:12:10,058
条件分支所以与第一示例

257
00:12:07,049 --> 00:12:12,068
在您尝试的方式来阅读这 

258
00:12:10,058 --> 00:12:15,007
你可以利用它与 done 

259
00:12:12,068 --> 00:12:19,076
指令集 ，你会看到有 一个 

260
00:12:15,529 --> 00:12:22,540
全范围的设定指令，但 

261
00:12:19,076 --> 00:12:24,149
它们 唯一的区别其实只是 

262
00:12:22,054 --> 00:12:29,123
什么条件他们设定来

263
00:12:25,049 --> 00:12:33,050
在这样的什么一组指令的作用是

264
00:12:30,023 --> 00:12:37,082
它设置了一个单一的单字节 

265
00:12:33,005 --> 00:12:40,028
寄存器为1或0， 并且所述 

266
00:12:37,082 --> 00:12:43,169
对于是否将其设置为一个 或基础

267
00:12:40,073 --> 00:12:47,078
零是基于条件是什么 

268
00:12:44,069 --> 00:12:49,106
代码在 本质上有什么什么 

269
00:12:47,078 --> 00:12:51,092
碰巧最近的指令

270
00:12:50,006 --> 00:12:54,104
事先是它的算术 

271
00:12:51,092 --> 00:12:57,092
指令或一组指令或 

272
00:12:55,004 --> 00:13:00,026
测试指令或比较 

273
00:12:57,092 --> 00:13:02,120
指令，正如你可以看到有 

274
00:13:00,026 --> 00:13:04,124
他们都基于某种逻辑

275
00:13:03,002 --> 00:13:09,031
这些条件码的组合

276
00:13:05,024 --> 00:13:14,063
对应于名字所暗示的是什么

277
00:13:09,049 --> 00:13:17,060
因此，例如集合S指令是 

278
00:13:14,063 --> 00:13:19,064
真如果符号标志是真谛

279
00:13:17,006 --> 00:13:22,013
，最近结果为阴性 

280
00:13:19,064 --> 00:13:25,129
并有 少 其他的 小于 

281
00:13:22,067 --> 00:13:28,088
小于或 等于 我们 T的 补码 

282
00:13:26,029 --> 00:13:30,125
比较他们必须考虑到 

283
00:13:28,088 --> 00:13:33,110
考虑所做的 最新结果 

284
00:13:31,025 --> 00:13:37,060
导致溢出或不是因为 

285
00:13:34,001 --> 00:13:40,360
会影响比较结果 

286
00:13:37,006 --> 00:13:42,008
所以这是我们 折磨的原因 之一 

287
00:13:40,459 --> 00:13:44,450
你理解补 

288
00:13:42,062 --> 00:13:45,071
算术以及如何比较

289
00:13:44,045 --> 00:13:48,056
dalts，让你明白 

290
00:13:46,052 --> 00:13:50,140
位级行为，这样 就可以 

291
00:13:48,056 --> 00:13:53,135
了解这些指示 

292
00:13:51,004 --> 00:13:58,082
所以我们很残忍 ，但我们有一个理由 

293
00:13:54,035 --> 00:14:00,083
我们的残酷 所以你说一口怎么办 

294
00:13:59,018 --> 00:14:02,072
你对付一口好这里的 

295
00:14:00,083 --> 00:14:03,131
另一件事，我们没有告诉你还没有 和 

296
00:14:02,072 --> 00:14:05,159
我们要不断告诉 你更多 

297
00:14:04,031 --> 00:14:08,039
东西一遍又一遍 的 事实证明 

298
00:14:06,059 --> 00:14:11,117
对于这些 16个寄存器 中的每一个 

299
00:14:09,011 --> 00:14:16,025
您可以直接设置最低阶

300
00:14:12,017 --> 00:14:17,108
它咬为0或1， 它不会 

301
00:14:16,025 --> 00:14:20,030
影响事实证明它 不影响 

302
00:14:18,008 --> 00:14:23,075
任何的，其他7个 叮咬 

303
00:14:20,003 --> 00:14:31,091
登记，他们都有 科基 

304
00:14:23,075 --> 00:14:34,130
名称L的有以下手段，使 

305
00:14:32,018 --> 00:14:36,071
这里使用的将 所有的例子 

306
00:14:35,003 --> 00:14:41,066
这一起做一些事情， 

307
00:14:36,071 --> 00:14:43,133
隐约有用的假设，我想 

308
00:14:41,093 --> 00:14:46,172
功能GT，将采取两个数字 

309
00:14:44,033 --> 00:14:50,075
并加以比较，并设置结果

310
00:14:47,072 --> 00:14:53,137
返回的 1结果值 如果X是 更大 

311
00:14:50,075 --> 00:14:57,077
除Y， 否则 为0 

312
00:14:54,037 --> 00:15:01,039
所以这里的用汇编代码

313
00:14:57,077 --> 00:15:00,085
一些黏合问题

314
00:15:03,032 --> 00:15:08,068
成功让我的错误 或 

315
00:15:13,025 --> 00:15:16,081
我可能不会想 尝试这样做 

316
00:15:27,096 --> 00:15:41,118
哦，不，我会解决这个问题 以后反正 是 

317
00:15:34,086 --> 00:15:42,180
世界不是结束正常的 

318
00:15:42,018 --> 00:15:45,117
汇编代码一件事你已经注意到了

319
00:15:43,008 --> 00:15:49,050
是该指令是缩进 

320
00:15:46,017 --> 00:15:52,044
通过标签的空间，这是唯一的事情 

321
00:15:50,022 --> 00:15:56,076
一路过来的 左边空白处或标签，以便 

322
00:15:52,044 --> 00:15:58,055
这仅仅是几分这个什么的 

323
00:15:56,076 --> 00:15:59,085
汇编其实是相当宽容的 

324
00:15:58,055 --> 00:16:03,081
格式化的东西，但不是这种方式 

325
00:16:00,066 --> 00:16:06,305
它通常看起来如此反正点

326
00:16:03,081 --> 00:16:08,142
是有一个比较一个规则 

327
00:16:06,899 --> 00:16:11,820
您需要了解程序

328
00:16:09,042 --> 00:16:12,126
是不是这样的第一个参数传递 

329
00:16:11,082 --> 00:16:15,123
寄存器RDI 

330
00:16:13,026 --> 00:16:17,795
以及第二和寄存器RS I和 

331
00:16:16,023 --> 00:16:20,028
如果我要返回结果

332
00:16:18,029 --> 00:16:24,600
从功能我这样做，将它存储 

333
00:16:20,073 --> 00:16:27,108
并注册 我们的斧头才返回如此 

334
00:16:24,006 --> 00:16:30,021
第一指令比较这两个

335
00:16:28,008 --> 00:16:35,013
你注意到我如何翻转的顺序 

336
00:16:30,075 --> 00:16:38,076
它说，RSI这 就是 为什么我RD其 

337
00:16:35,013 --> 00:16:41,067
是X但是当 我将其标注为我说，X到Y 

338
00:16:38,085 --> 00:16:42,150
让 我精神上 我在思考 

339
00:16:41,067 --> 00:16:45,126
下令实际做出比较 

340
00:16:43,005 --> 00:16:47,070
而不是这样，他们会上市，所以我 

341
00:16:46,026 --> 00:16:52,083
总是这样，当我在看代码 

342
00:16:48,015 --> 00:16:54,066
帮我翻转这两个四周， 

343
00:16:52,083 --> 00:16:55,167
那么这里是我们的指令，使得 

344
00:16:54,066 --> 00:16:58,101
比较指令集这四个 

345
00:16:56,067 --> 00:17:01,125
条件码寄存器x”和现在的 

346
00:16:59,001 --> 00:17:05,085
集合G说，现在设置这个单字节

347
00:17:02,025 --> 00:17:09,030
注册我们的 斧头到Z 的最低字节 

348
00:17:05,085 --> 00:17:13,088
1，如果该原因的结果是 

349
00:17:09,075 --> 00:17:17,134
比较是更大的，从而根据 

350
00:17:13,088 --> 00:17:17,017
这此规则 

351
00:17:17,087 --> 00:17:25,152
并与该效果设置 

352
00:17:22,089 --> 00:17:28,128
只是因为这 一个 八 字节的一个咬

353
00:17:26,052 --> 00:17:31,131
注册 零个或一个 现在我的 

354
00:17:29,028 --> 00:17:33,111
问题是， 这些剩下的 七个 

355
00:17:32,031 --> 00:17:37,077
字节都无论发生在那里 

356
00:17:34,011 --> 00:17:42,017
之前，我希望它是全零如此 

357
00:17:37,077 --> 00:17:45,078
在它的方式是有点怪

358
00:17:42,071 --> 00:17:50,112
有一个名为移动的指令 

359
00:17:45,087 --> 00:17:53,091
零扩展字节现在太长你 

360
00:17:51,012 --> 00:17:58,098
要知道这些更好，如果有时间好吗 

361
00:17:54,027 --> 00:18:01,101
嗯，什么这是什么意思是，你可以 

362
00:17:58,098 --> 00:18:02,133
实际上从任何地方复制字节像

363
00:18:02,001 --> 00:18:06,093
一些其他的低位字节

364
00:18:03,033 --> 00:18:09,057
注册到一个新的寄存器，你会

365
00:18:06,093 --> 00:18:11,169
把置零到它的左边 那 

366
00:18:09,057 --> 00:18:14,064
他们的意思是 零扩展 

367
00:18:12,069 --> 00:18:17,084
似乎顺理成章，但有一件事，你会 

368
00:18:14,064 --> 00:18:20,076
通知是 这里 的 目的是EAX 

369
00:18:17,084 --> 00:18:23,100
你还记得虽然它不 

370
00:18:20,076 --> 00:18:27,144
在这里展示这的低32位

371
00:18:24,000 --> 00:18:32,007
寄存器是 一个 X，然后你会说好 

372
00:18:28,044 --> 00:18:34,128
只有让我 中途 有 怎样的权利 

373
00:18:32,007 --> 00:18:37,085
我要确保高32位被设置 

374
00:18:35,028 --> 00:18:45,084
零 井的奇怪怪癖之一 

375
00:18:38,048 --> 00:18:49,110
86 64 是用于任何计算，其中 

376
00:18:45,084 --> 00:18:52,101
结果是一个32位结果，将添加 

377
00:18:50,001 --> 00:18:56,049
零来的剩余的32位 

378
00:18:53,001 --> 00:18:58,008
注册和它的例如不同

379
00:18:56,058 --> 00:19:03,083
字节级操作只会影响 

380
00:18:58,071 --> 00:19:05,079
自行车两个字节或操作 

381
00:19:03,083 --> 00:19:08,088
就像你有什么，如果数据类型 

382
00:19:06,051 --> 00:19:11,100
中短只影响 这两个字节 

383
00:19:08,088 --> 00:19:13,187
但四个字节指令集 

384
00:19:12,000 --> 00:19:17,091
高位字节到零， 这是一些 

385
00:19:14,087 --> 00:19:19,173
有人在 AMD，我不 知道是谁 

386
00:19:17,091 --> 00:19:21,099
决定这是一个好 主意 ，它 

387
00:19:20,073 --> 00:19:25,074
可能是一个好主意 ，但它 确实 

388
00:19:22,071 --> 00:19:27,126
混乱，但这东西你会 

389
00:19:25,074 --> 00:19:29,103
有只是有点记得在 

390
00:19:28,026 --> 00:19:30,115
回你的 头脑，当你看到 喜欢 的东西 

391
00:19:30,003 --> 00:19:33,058
这个 

392
00:19:31,015 --> 00:19:35,053
所以该指令的效果是 

393
00:19:33,058 --> 00:19:38,110
借此一咬结果这是 

394
00:19:35,053 --> 00:19:41,074
注册我们的 斧头副本 的 下 门咬 

395
00:19:39,001 --> 00:19:44,038
它在同一个地方，因为它已经是 

396
00:19:41,074 --> 00:19:47,152
但随后设置其余7个字节 

397
00:19:44,047 --> 00:19:54,100
到零，这是我们想的 那么你会 

398
00:19:48,052 --> 00:19:55,083
看到这种模式常常质疑

399
00:19:55,000 --> 00:19:59,071
得到它了 

400
00:19:55,083 --> 00:20:01,129
好了，现在的排序有时 我 

401
00:19:59,071 --> 00:20:04,119
要做到这一点， 我 只是想获得一个 

402
00:20:02,029 --> 00:20:08,298
比特标志作为比较的结果

403
00:20:05,019 --> 00:20:10,051
但更普遍的我想要做的 

404
00:20:08,559 --> 00:20:14,260
一些与该 信息 ，而 不是 

405
00:20:10,051 --> 00:20:17,080
只需设置一个位，因此最简单的版本 

406
00:20:14,026 --> 00:20:22,042
是关于什么的 一个条件 ，如果和 

407
00:20:17,008 --> 00:20:24,387
可能的其他嗯，这是通过做 

408
00:20:22,042 --> 00:20:26,134
其实这两种方法可以做到这一点，所以我们会 

409
00:20:25,179 --> 00:20:30,192
经过排序 的通用 

410
00:20:27,034 --> 00:20:33,034
传统的方式，然后我们会 展示 

411
00:20:30,309 --> 00:20:35,530
更专业的方式更新，我们将 

412
00:20:33,034 --> 00:20:37,048
比较这些使传统的 方式是 

413
00:20:35,053 --> 00:20:38,137
用什么 作为一个跳 

414
00:20:37,048 --> 00:20:41,113
指令和跳转指令 

415
00:20:39,037 --> 00:20:44,038
通常的指令执行在

416
00:20:42,013 --> 00:20:46,692
特定的顺序只是当你喜欢 

417
00:20:44,047 --> 00:20:49,066
写一个程序，你写一个系列 

418
00:20:46,809 --> 00:20:52,450
声明他们执行一个后 

419
00:20:49,066 --> 00:20:53,122
下一跳转指令就是这样，你 

420
00:20:52,045 --> 00:20:56,104
可以去的地方，你是 

421
00:20:54,022 --> 00:20:59,047
别的地方，要么跳过一些 

422
00:20:57,004 --> 00:21:03,393
指令或跳回其他一些 

423
00:20:59,047 --> 00:21:06,054
先前的位置或其它地方和 

424
00:21:03,429 --> 00:21:08,140
有2种跳那些是 

425
00:21:06,054 --> 00:21:10,087
无条件那里 有几个 

426
00:21:08,014 --> 00:21:13,075
种但无条件 跳转手段 

427
00:21:10,087 --> 00:21:14,155
当我说跳你跳，但有 

428
00:21:13,075 --> 00:21:17,098
其他条件跳转即会

429
00:21:15,055 --> 00:21:18,148
实际上只有做到这一点跳跃如果 

430
00:21:17,098 --> 00:21:20,191
条件码被设定适当

431
00:21:19,048 --> 00:21:23,092
你会看到，这些名字 

432
00:21:21,091 --> 00:21:24,148
跳转指令是一样的 

433
00:21:23,092 --> 00:21:27,097
用同一套指令

434
00:21:25,048 --> 00:21:30,112
条件，有多种 

435
00:21:27,097 --> 00:21:33,192
不同的原因 ，该计划可能 

436
00:21:31,012 --> 00:21:34,020
给予要么跳或不跳 

437
00:21:37,064 --> 00:21:42,086
所以我打算用这个 例子来 

438
00:21:40,082 --> 00:21:46,085
告诉你几种不同 的版本 

439
00:21:42,086 --> 00:21:47,153
它和喜欢的一切，你会看到这里 

440
00:21:46,085 --> 00:21:51,089
这些特定的程序都不是 

441
00:21:48,053 --> 00:21:56,141
有用的，但它们说明了 这样 的想法 

442
00:21:52,025 --> 00:21:59,072
想象我想计算的 

443
00:21:57,041 --> 00:22:02,117
两个值的差，然后采取 

444
00:21:59,072 --> 00:22:03,080
其绝对值所以有各种 

445
00:22:03,017 --> 00:22:05,102
方法，你 能想象 在 这样做 

446
00:22:04,052 --> 00:22:08,108
办法，我要做到这一点是决定 

447
00:22:06,002 --> 00:22:11,033
无论是 从由Y X或X中减去y 

448
00:22:09,008 --> 00:22:14,009
根据的相对值 

449
00:22:11,033 --> 00:22:17,096
这两个，当然精明 

450
00:22:14,009 --> 00:22:20,074
观察者会发现，这有

451
00:22:17,096 --> 00:22:23,102
问题，如果你有在地方队

452
00:22:20,074 --> 00:22:24,149
如果结果因为没有 

453
00:22:24,002 --> 00:22:30,541
绝对值但 我们不打算 

454
00:22:25,049 --> 00:22:32,051
担心表 ，以便换句话说 

455
00:22:30,559 --> 00:22:35,480
我只想说，如果X 大于 

456
00:22:32,051 --> 00:22:36,850
y时， 我想 从X， 如果 跟踪ÿ 

457
00:22:35,048 --> 00:22:39,140
X 小于或 等于YI 希望 

458
00:22:37,309 --> 00:22:42,860
用1减去X 和下面的代码 

459
00:22:40,004 --> 00:22:44,041
它其中蓝色和红色或 

460
00:22:42,086 --> 00:22:48,137
颜色编码它的不同部分 

461
00:22:44,077 --> 00:22:53,078
所以在这里你看到的比较指令 

462
00:22:49,037 --> 00:22:56,039
又一次我写出来的 

463
00:22:53,078 --> 00:22:58,133
反向为了帮我记录下来 的 

464
00:22:56,039 --> 00:23:01,112
什么比较，它说我 

465
00:22:59,033 --> 00:23:04,049
要比较X和Y，如果X是 

466
00:23:02,012 --> 00:23:08,051
小于 或等于YI想跳 

467
00:23:04,049 --> 00:23:11,063
通过这个 标签L4 指定的位置 

468
00:23:08,051 --> 00:23:13,720
因此在一般在汇编代码，如果

469
00:23:11,063 --> 00:23:16,088
你给一个名字，然后一个 冒号 什么 

470
00:23:14,179 --> 00:23:20,179
到了左侧被称为标签 

471
00:23:16,088 --> 00:23:21,104
它只是一个标记，只有 

472
00:23:20,179 --> 00:23:24,830
在汇编代码中看到它不是 

473
00:23:22,004 --> 00:23:28,012
实际上在对象的代码，将

474
00:23:24,083 --> 00:23:31,088
我稍后会 被用来 计算一个地址 

475
00:23:28,012 --> 00:23:35,060
用于确定 将什么编码 

476
00:23:32,033 --> 00:23:36,041
其中，这一跳将实际降落时 

477
00:23:35,006 --> 00:23:38,965
你看汇编代码中的一个 

478
00:23:37,013 --> 00:23:42,074
它提供的功能是一点点 

479
00:23:39,559 --> 00:23:45,800
更简单的方法去理解它 ，而不是看 

480
00:23:42,074 --> 00:23:47,102
在地址，所以它只是告诉你 

481
00:23:45,008 --> 00:23:48,837
在看会发生跳跃 

482
00:23:48,002 --> 00:23:54,511
这个位置 

483
00:23:49,629 --> 00:23:56,629
什么，你会在这里看到的是在这些 

484
00:23:54,529 --> 00:23:57,604
两个分支 的蓝色代码兑 

485
00:23:56,629 --> 00:24:03,950
红色，你正在做的事情是在一种 情况下 

486
00:23:58,279 --> 00:24:07,354
从X减去这里y您移动X

487
00:24:03,095 --> 00:24:09,110
到我们的 斧头和你从它减去y 

488
00:24:08,029 --> 00:24:17,840
在这里，你做 你的对面 

489
00:24:10,001 --> 00:24:21,002
从Y，在这种情况下减去X等等 

490
00:24:17,084 --> 00:24:23,023
在第一种情况下，你会做跳跃 

491
00:24:21,011 --> 00:24:27,010
如果X 小于或 等于y你会 

492
00:24:23,779 --> 00:24:28,864
紧凑值Y X， 你会做一回 

493
00:24:27,109 --> 00:24:32,090
你记住， 我没有做 

494
00:24:29,629 --> 00:24:33,694
任何特殊的返回值回 

495
00:24:32,009 --> 00:24:37,228
从功能的所有我需要做的就是

496
00:24:34,279 --> 00:24:38,344
坚持下去并注册 IX和主叫 

497
00:24:37,309 --> 00:24:42,310
功能会知道这是在哪里可以找到 

498
00:24:38,929 --> 00:24:44,840
返回值，以便在这里做一个代表 

499
00:24:42,409 --> 00:24:46,970
在这里它做减法，它 

500
00:24:44,084 --> 00:24:51,523
干脆直接从做一回

501
00:24:46,097 --> 00:24:52,876
它的一部分，所以这是一个非常 

502
00:24:52,279 --> 00:24:56,330
简单的代码，但你 

503
00:24:53,749 --> 00:24:58,813
可以看到它使用此跳转到 

504
00:24:56,033 --> 00:25:01,097
创建的代码的两个不同部分

505
00:24:59,389 --> 00:25:05,440
在 两种不同的 得到 执行 

506
00:25:01,097 --> 00:25:04,144
条件问题 

507
00:25:06,077 --> 00:25:15,706
那是什么我很抱歉，我没听到你 

508
00:25:11,045 --> 00:25:18,076
哦 也有几件事情之一就是 

509
00:25:16,399 --> 00:25:22,070
你想要的结果在我们的X结束 

510
00:25:18,076 --> 00:25:24,115
右记住 减法 

511
00:25:22,007 --> 00:25:29,746
指令structions只是 两个 

512
00:25:24,799 --> 00:25:32,330
参数说明那里，你 

513
00:25:29,809 --> 00:25:34,640
取两个值，然后你的那些 

514
00:25:32,033 --> 00:25:36,095
第二个参数的目的地 

515
00:25:34,064 --> 00:25:39,103
争论则会覆盖那儿有什么

516
00:25:36,095 --> 00:25:41,171
有新的结果，所以这是一个非常 

517
00:25:39,679 --> 00:25:46,340
典型的模式，你会看到你移动

518
00:25:42,071 --> 00:25:48,520
一些值到寄存器，然后你 

519
00:25:46,034 --> 00:25:51,038
进入我们的斧头是很常见的 ，然后你 

520
00:25:49,159 --> 00:25:54,860
做一些运算

521
00:25:51,074 --> 00:25:57,643
注册为目的地 来样 

522
00:25:54,086 --> 00:25:59,102
更新它，如果它就像 如果你是 

523
00:25:58,309 --> 00:26:02,870
写，看看是否所有的时间你有

524
00:26:00,002 --> 00:26:06,391
写排序X加等于 什么 

525
00:26:02,087 --> 00:26:07,366
X减等于和 你的所有 

526
00:26:06,409 --> 00:26:10,450
算术不得不在那些中表达

527
00:26:08,149 --> 00:26:10,450
条款

528
00:26:12,075 --> 00:26:19,754
好了 ，所以它的乐趣 ，看装配 

529
00:26:17,049 --> 00:26:23,115
约五分钟， 然后你 的代码 

530
00:26:20,429 --> 00:26:26,370
生病的 这么一件事情 进行排序 

531
00:26:24,015 --> 00:26:29,022
目前这些相同的想法 ，但给它 

532
00:26:26,037 --> 00:26:32,846
多一点点抽象的形式是 

533
00:26:29,085 --> 00:26:34,164
写一下，看看但在C的形式， 

534
00:26:33,179 --> 00:26:38,250
看起来像汇编代码，并在很多

535
00:26:35,064 --> 00:26:41,102
的C的特征的特定一个 

536
00:26:38,025 --> 00:26:45,099
一般不做广告是有一个 

537
00:26:42,002 --> 00:26:54,401
声明呼吁去到你可以把 

538
00:26:45,099 --> 00:26:55,104
在 你的代码的标签， 你可以告诉 

539
00:26:54,419 --> 00:26:58,530
程序，如果有事则 

540
00:26:56,049 --> 00:27:00,084
你要跳转到 的 那 部分 

541
00:26:58,053 --> 00:27:04,053
程序，所以它看起来很像 是 

542
00:27:00,084 --> 00:27:08,115
你看到跳JL汇编代码的权利 

543
00:27:04,053 --> 00:27:11,102
电子商务不是什么该说这就像 

544
00:27:09,015 --> 00:27:14,040
我正在 做一个测试，然后如果测试 

545
00:27:12,002 --> 00:27:16,023
在这种情况下我称之为 端测试 

546
00:27:14,004 --> 00:27:19,047
因为它是测试的对面

547
00:27:16,023 --> 00:27:21,114
这是在原来的程序 ，如果 

548
00:27:19,083 --> 00:27:23,312
为此测试条件成立 ，我想 

549
00:27:22,014 --> 00:27:27,015
跳转到 节目 我是 另一部分 

550
00:27:24,059 --> 00:27:29,060
调用别的，你注意到我大写 

551
00:27:27,015 --> 00:27:34,050
因为它不是实际的其他 

552
00:27:29,159 --> 00:27:39,450
一个一个if-then-else和肯定，如果这 

553
00:27:34,005 --> 00:27:40,934
一个非常其实是最准确的 

554
00:27:39,045 --> 00:27:44,097
我应该 只是简单地 说 返回结果 

555
00:27:41,429 --> 00:27:48,000
从这个角度这个 代码 一点点 

556
00:27:44,097 --> 00:27:49,158
过时的，所以我应该说回报 

557
00:27:48,000 --> 00:27:52,065
结果，但另一种说法，是 

558
00:27:50,058 --> 00:27:54,060
已经做了跳转到此处并返回 

559
00:27:52,065 --> 00:27:55,119
从那里，你会看到结果

560
00:27:54,078 --> 00:27:58,164
不同的编译器 生成 

561
00:27:56,019 --> 00:28:01,047
不同形式的所以我要去

562
00:27:59,064 --> 00:28:04,089
通常使用呈现这样 

563
00:28:01,047 --> 00:28:06,138
代码只是让你可以看看和 

564
00:28:04,089 --> 00:28:08,172
了解这些控制结构

565
00:28:07,038 --> 00:28:12,063
看起来像，而无需进行排序 

566
00:28:09,072 --> 00:28:14,147
细察低级汇编代码

567
00:28:12,063 --> 00:28:14,147
说明

568
00:28:16,013 --> 00:28:28,074
所以我们考虑采取这个问题是 我 

569
00:28:27,012 --> 00:28:30,084
想有一个家庭作业或练习 

570
00:28:28,074 --> 00:28:32,121
究竟那种所以问题

571
00:28:30,084 --> 00:28:34,131
一般来说，你可以做到这一点既不方式 

572
00:28:33,021 --> 00:28:36,090
为什么编译器挑选一个相对于 

573
00:28:35,031 --> 00:28:39,075
另 一种是我认为这是一个完全 

574
00:28:36,009 --> 00:28:42,056
武断的决定，但我始终 

575
00:28:39,075 --> 00:28:42,137
发现GCC确实是这样

576
00:28:44,078 --> 00:28:51,084
谈排序的好了，什么样的 

577
00:28:50,016 --> 00:28:55,023
想象一下你正在写一个编译器如何 

578
00:28:52,038 --> 00:28:57,101
你会采取这种特殊的情况下，我 只是 

579
00:28:55,023 --> 00:29:02,025
表明它概括成一个规则

580
00:28:58,001 --> 00:29:05,007
编译IF-THEN-ELSE表达式 和 

581
00:29:02,025 --> 00:29:07,077
我会 在 看到 使用的 版本 

582
00:29:05,061 --> 00:29:08,160
问号 ：版本，你 

583
00:29:07,077 --> 00:29:10,163
一种封装了整个 

584
00:29:09,006 --> 00:29:14,007
条件是一个单一表达式

585
00:29:11,063 --> 00:29:16,080
而不是语句，但你 可以 

586
00:29:14,061 --> 00:29:18,150
了解这些规则将是 

587
00:29:16,008 --> 00:29:22,059
同样在这两种情况下如此想象 

588
00:29:19,005 --> 00:29:26,010
一般来说，你有一个C代码，其中有一个 

589
00:29:23,031 --> 00:29:29,090
测试控制是否返回

590
00:29:26,055 --> 00:29:33,060
一种表达的结果或其它，并 

591
00:29:29,009 --> 00:29:37,014
这是我的 ABS 差异代码看起来 

592
00:29:33,006 --> 00:29:41,010
就像如果我以 这种形式等写的 

593
00:29:37,095 --> 00:29:44,097
一般来说，我们可以说什么就是什么什么 

594
00:29:42,000 --> 00:29:48,051
我们要做的是，我们会来参加考试和 

595
00:29:44,097 --> 00:29:57,120
针锋相对并 倒转 ，并说，如果该测试 

596
00:29:48,051 --> 00:30:00,126
是不是真的那么我们会因此如果n 测试 

597
00:29:58,002 --> 00:30:02,091
那么真的，我们将跳转 到的某些部分 

598
00:30:01,026 --> 00:30:06,090
这里我们编译的代码的代码 

599
00:30:03,009 --> 00:30:10,014
对于其他 的表达，如果说 

600
00:30:06,009 --> 00:30:12,012
这里测试失败使原来 

601
00:30:10,014 --> 00:30:17,052
测试条件成立那么我们会坚持在 

602
00:30:13,002 --> 00:30:19,071
任何代码才能计算

603
00:30:17,052 --> 00:30:21,126
做了表达，然后我们将合并 

604
00:30:19,089 --> 00:30:23,145
回到一起的情况下 ，你看到哪里 

605
00:30:22,026 --> 00:30:26,043
它只是一个小功能，我们 

606
00:30:24,045 --> 00:30:28,137
可以就在这里所说的代表，让出 

607
00:30:26,043 --> 00:30:29,094
事情 ，但如果这是一条线 

608
00:30:29,037 --> 00:30:30,111
码

609
00:30:29,094 --> 00:30:32,148
再有就是线路的一大堆 

610
00:30:31,011 --> 00:30:35,049
之后 ， 通常要合并 

611
00:30:33,048 --> 00:30:37,217
再聚首，并从继续 

612
00:30:35,049 --> 00:30:40,868
那里，所以这就是这个显示所有 

613
00:30:37,649 --> 00:30:44,690
我将要一切以完成

614
00:30:41,309 --> 00:30:46,394
事后所以这是一种方法，我 喜欢 

615
00:30:45,059 --> 00:30:48,960
你知道，虽然 我们不是在写 

616
00:30:47,159 --> 00:30:51,720
在这个过程中的编译器，我认为它 

617
00:30:48,096 --> 00:30:53,100
帮助想在 一般 条款 

618
00:30:51,072 --> 00:30:57,111
的编译器将如何转化规则 

619
00:30:54,036 --> 00:30:59,195
C代码到汇编代码，使得当 

620
00:30:58,011 --> 00:31:01,083
你看到的汇编代码，你会 

621
00:30:59,519 --> 00:31:04,532
识别这些模式并了解 

622
00:31:01,083 --> 00:31:05,145
他们的意思是这样 的问题 后，你去 

623
00:31:04,649 --> 00:31:11,730
else 子句 不喜欢秋天 

624
00:31:06,045 --> 00:31:15,134
通过对 约翰是是这样，就像 

625
00:31:11,073 --> 00:31:17,157
我们一般是看到了它喜欢在这里 

626
00:31:15,539 --> 00:31:20,960
将始终陷入做了 很好的 

627
00:31:18,057 --> 00:31:20,096
题

628
00:31:22,061 --> 00:31:26,070
好了，所以这是一个版本 

629
00:31:25,011 --> 00:31:29,090
有条件的，这是最普遍的方式 

630
00:31:27,051 --> 00:31:32,142
它使用的方式总是做 

631
00:31:29,009 --> 00:31:34,062
但还有另一种方法，你会 

632
00:31:33,042 --> 00:31:38,060
看到代码相当普遍这有点 

633
00:31:35,043 --> 00:31:41,112
所谓有条件移动优化

634
00:31:38,006 --> 00:31:43,059
它是从一个有点不直观 

635
00:31:42,012 --> 00:31:46,038
为什么 软件 开发者的角度 

636
00:31:44,013 --> 00:31:48,042
你会永远想这样做的基本 

637
00:31:46,038 --> 00:31:50,079
想法是我要计算这两个 

638
00:31:48,042 --> 00:31:53,043
然后和麋鹿的价值观，他们会

639
00:31:50,079 --> 00:31:53,160
生产，之后才是我选择 

640
00:31:53,043 --> 00:31:56,097
哪一个我用

641
00:31:54,006 --> 00:32:00,057
如此看来浪费， 但实际上 

642
00:31:56,097 --> 00:32:02,166
原来 是 ，如果有更有效 

643
00:32:01,011 --> 00:32:05,088
是相当简单的计算和 

644
00:32:03,066 --> 00:32:07,071
那原因是，我们会看到一个小 

645
00:32:05,088 --> 00:32:09,174
当我们谈论性能更加 位 

646
00:32:07,071 --> 00:32:13,143
优化现代处理器是 

647
00:32:10,074 --> 00:32:17,100
有点像在油轮航行

648
00:32:14,043 --> 00:32:20,106
海 这 意味着它在沿着犁 

649
00:32:18,000 --> 00:32:25,053
某些方向，那 真的是难 

650
00:32:21,006 --> 00:32:28,050
让它停止或开启， 让 你 

651
00:32:25,053 --> 00:32:31,071
说什么你在说什么 ，但认为 

652
00:32:28,005 --> 00:32:33,069
指令序列的你知道

653
00:32:31,071 --> 00:32:36,084
代码的海洋，你巡航 

654
00:32:34,014 --> 00:32:38,085
通过和这些东西 只是飞 

655
00:32:36,084 --> 00:32:41,133
通过的代码的直序列 

656
00:32:38,085 --> 00:32:43,134
因为他们是他们做他们所谓的 

657
00:32:42,033 --> 00:32:45,108
流水线这意味着他们将开始

658
00:32:44,034 --> 00:32:47,130
在前一个指令的部分

659
00:32:46,008 --> 00:32:50,040
他们的下一个和实际完成 

660
00:32:48,003 --> 00:32:53,016
上升到 20个或 更多 的深度 

661
00:32:50,004 --> 00:32:55,095
深多远了他们的指令

662
00:32:53,043 --> 00:32:58,068
努力 向前背叛和未来 

663
00:32:56,031 --> 00:33:00,108
指令同时完成了的那些 

664
00:32:58,068 --> 00:33:04,092
这仍然让我的海洋

665
00:33:01,008 --> 00:33:06,084
我的油轮类比线，但所有的 

666
00:33:04,092 --> 00:33:08,100
突然你来，然后 会发生什么 

667
00:33:06,084 --> 00:33:11,178
当他们打了一个分支，他们会尽力 

668
00:33:09,072 --> 00:33:14,127
想叫分支预测和猜测 

669
00:33:12,078 --> 00:33:15,174
其中这种分支要去 

670
00:33:15,027 --> 00:33:17,091
在那里，你知道 

671
00:33:16,074 --> 00:33:19,074
良好条件分支应该是 

672
00:33:17,091 --> 00:33:20,166
采取抑或是要落空 和 

673
00:33:19,074 --> 00:33:23,136
他们很擅长，他们是很好的 

674
00:33:21,066 --> 00:33:28,089
在 的 这 90百分之八九十 

675
00:33:24,036 --> 00:33:31,065
时间，以便 他们可以 预见，即使 它适合 

676
00:33:28,089 --> 00:33:32,118
在路上我的比喻是曲线

677
00:33:31,065 --> 00:33:36,150
打破

678
00:33:33,018 --> 00:33:38,025
并开始在这个方向和打算

679
00:33:37,005 --> 00:33:41,007
只要他们得到它的权利是非常 

680
00:33:38,088 --> 00:33:44,124
有效的，但如果他们弄错了它的 

681
00:33:41,007 --> 00:33:47,079
因为如果你必须停止回事情它

682
00:33:45,024 --> 00:33:51,051
向上转弯的其他方式 重新开始和 

683
00:33:48,042 --> 00:33:55,098
可以采取 40说明40时钟 

684
00:33:51,051 --> 00:33:57,063
这样的循环在床上的情况这样做， 

685
00:33:55,098 --> 00:33:59,130
这就是 ，如果你认为的 很常见 

686
00:33:57,063 --> 00:34:01,161
像一个绝对值可以预测 

687
00:34:00,003 --> 00:34:06,048
值是否将是积极的 

688
00:34:02,061 --> 00:34:07,134
或负，如果不是这样，通常的一半左右 

689
00:34:06,075 --> 00:34:10,137
无论你想你的时候要去 

690
00:34:08,034 --> 00:34:13,083
猜测错了，所以这是有条件的 

691
00:34:11,037 --> 00:34:16,122
移动指令事实证明这是多

692
00:34:13,083 --> 00:34:18,105
容易只是通过计算两个犁 

693
00:34:17,022 --> 00:34:22,053
然后在最后一分钟 你有 

694
00:34:19,005 --> 00:34:24,060
做的是移动值到寄存器或 

695
00:34:22,053 --> 00:34:26,432
不和不需要停止 

696
00:34:24,006 --> 00:34:31,080
整个处理器，使本回合中，

697
00:34:26,909 --> 00:34:33,935
所以这是我的，如果长时间解释 

698
00:34:32,034 --> 00:34:35,603
你不想了解我 

699
00:34:34,169 --> 00:34:42,000
只是说好了只是相信我，这是个好 

700
00:34:35,909 --> 00:34:45,510
有时 想法 所以一般 

701
00:34:42,000 --> 00:34:47,085
然后，模式，如果我用同样的想法是我 

702
00:34:45,051 --> 00:34:50,097
要 计算两个结果，我会 

703
00:34:47,085 --> 00:34:53,624
调用的结果，这是一个eval这

704
00:34:50,097 --> 00:34:56,151
是EVAL 麋鹿价值，我会同时计算 

705
00:34:54,389 --> 00:35:00,060
其中我会尽我的 测试，然后这个 

706
00:34:57,051 --> 00:35:02,139
红色的东西想象，一切都以done 

707
00:35:00,006 --> 00:35:06,084
单指令，说我会复制 

708
00:35:03,039 --> 00:35:08,124
导致EVAL的价值，但只有当 

709
00:35:06,084 --> 00:35:12,126
一个条件成立所以这就是为什么它是 

710
00:35:09,024 --> 00:35:16,029
所谓有条件的举动然后我们会看到 

711
00:35:13,026 --> 00:35:18,027
这是你看到的样子我的代码

712
00:35:16,029 --> 00:35:22,077
最初的版本开始有 

713
00:35:18,027 --> 00:35:26,055
跳回我必须明确地告诉

714
00:35:22,077 --> 00:35:28,143
GCC 不要把使用条件移动 

715
00:35:26,055 --> 00:35:32,106
因为它确实要 非常糟糕 

716
00:35:29,043 --> 00:35:35,048
所以你必须把它强制不和我 

717
00:35:33,006 --> 00:35:35,093
这样做，在这里

718
00:35:36,099 --> 00:35:41,148
所以这里的实际代码 ，然后，再 

719
00:35:39,599 --> 00:35:46,260
你会看到的 颜色编码 ，它的 

720
00:35:42,048 --> 00:35:48,051
既做减法它实际上是

721
00:35:46,026 --> 00:35:51,365
做移动和减去移动和 

722
00:35:48,078 --> 00:35:52,907
减去所以它做两个分支 

723
00:35:51,599 --> 00:35:58,050
你 的书房和麋鹿 以前看到的 

724
00:35:53,609 --> 00:35:59,910
分支它做一个比较 ，然后 

725
00:35:58,005 --> 00:36:03,554
这里是条件移动指令 

726
00:35:59,091 --> 00:36:05,115
在这种情况下，这里的L C举动是不是 

727
00:36:03,599 --> 00:36:12,810
字长它比小于 或等于 

728
00:36:06,015 --> 00:36:15,102
的方向，以便在壳体中的，我 

729
00:36:12,081 --> 00:36:18,140
需要的红色值 基本上 你看到的 

730
00:36:16,002 --> 00:36:22,041
红色值被存储在寄存器RDX在 

731
00:36:19,004 --> 00:36:26,473
这种情况下，我将它复制 到结果 

732
00:36:22,041 --> 00:36:29,480
注册，以便再次是这样的想法 

733
00:36:26,869 --> 00:36:32,070
先走一步，做的一切， 然后 

734
00:36:29,849 --> 00:36:34,560
挑在去年年底和点

735
00:36:32,007 --> 00:36:39,021
这一个指令， 它 看起来 就像 

736
00:36:34,056 --> 00:36:40,595
只要该处理器执行 

737
00:36:39,021 --> 00:36:44,063
这有点像 一个 移动 指令 

738
00:36:41,099 --> 00:36:44,630
这是相当简单的做 

739
00:36:47,005 --> 00:36:50,021
好的 

740
00:36:48,023 --> 00:36:52,088
那么，为什么会这样所有的 时间以及 

741
00:36:50,021 --> 00:36:56,033
有一对夫妇一个原因是， 

742
00:36:52,088 --> 00:36:58,106
可能是一个非常 非常糟糕的 主意办 

743
00:36:56,033 --> 00:37:01,040
两者的计算，如果你有喜欢

744
00:36:59,006 --> 00:37:03,077
在一个破解密码， 你知道 

745
00:37:02,003 --> 00:37:05,009
找到企业数量和另一 

746
00:37:03,077 --> 00:37:11,078
你可能不希望 两者都 做 的 

747
00:37:05,063 --> 00:37:13,127
那些所以一般 在 这种情况下 ，因此 

748
00:37:11,087 --> 00:37:15,173
在你会发现GCC只会做

749
00:37:14,027 --> 00:37:18,083
如果这两个分支是相当 

750
00:37:16,073 --> 00:37:20,150
简单计算即 

751
00:37:18,083 --> 00:37:23,159
他们正在试图 做的，他们 有时 

752
00:37:21,005 --> 00:37:26,009
当你只是普通的不能做，所以对 

753
00:37:24,059 --> 00:37:29,072
例如，如果您使用的是有条件的 

754
00:37:26,054 --> 00:37:31,058
守卫指针是否可 

755
00:37:29,072 --> 00:37:33,089
提领或不是因为它是一个空 

756
00:37:31,058 --> 00:37:35,069
指针潜在一个空指针然后 

757
00:37:33,089 --> 00:37:41,132
你真的不想尝试空 

758
00:37:35,069 --> 00:37:45,071
指针引用只是为了用于为 

759
00:37:42,032 --> 00:37:48,071
一种方法来节省一些 时间和同样的，如果 

760
00:37:45,071 --> 00:37:50,144
如果你可以有如果一个副作用 

761
00:37:48,071 --> 00:37:52,148
执行任一分支的结果可能 

762
00:37:51,044 --> 00:37:55,076
是改变的其他部分 

763
00:37:53,048 --> 00:37:58,136
程序的状态 ，那么你真的不 希望 

764
00:37:55,076 --> 00:38:00,163
这样做，要么 等条件 

765
00:37:59,036 --> 00:38:03,104
仅移动被使用，那么在这 

766
00:38:01,063 --> 00:38:06,122
你有两个有点特例

767
00:38:04,004 --> 00:38:10,040
计算比较 容易做到 安全 

768
00:38:07,022 --> 00:38:12,029
做没有副作用，但出现这种情况 

769
00:38:10,004 --> 00:38:14,071
只是往往足以使这实际上是一个 

770
00:38:12,029 --> 00:38:14,107
值得的事情 

771
00:38:15,089 --> 00:38:21,102
好了，可以让我们 和 条件语句 

772
00:38:19,035 --> 00:38:27,068
现在让我们来看看循环之类的 

773
00:38:22,002 --> 00:38:30,024
下一步起来控制结构和 

774
00:38:27,068 --> 00:38:32,136
看到实际上有三种 不同 

775
00:38:30,024 --> 00:38:34,110
循环 有AA，而环路 

776
00:38:33,036 --> 00:38:36,099
你熟悉和一个for循环 

777
00:38:35,001 --> 00:38:39,024
你很熟悉，它有一个 

778
00:38:36,099 --> 00:38:40,101
第三个这在我的整个生命

779
00:38:39,033 --> 00:38:43,062
写作和我已经写了大量的C代码 

780
00:38:41,001 --> 00:38:46,080
在我的生活中，我用这个像约六 

781
00:38:43,062 --> 00:38:47,070
次，但事实证明 它是 

782
00:38:46,008 --> 00:38:50,031
最简单的 实现 ，所以我们会去 

783
00:38:48,042 --> 00:38:53,091
继续做它 ，以便 它被称为 

784
00:38:51,003 --> 00:38:57,015
在do-while循环等等 关键字 

785
00:38:53,091 --> 00:38:59,109
做什么，然后有一些东西，你做 

786
00:38:57,015 --> 00:39:02,073
这是该做的 身体 ，然后 

787
00:39:00,009 --> 00:39:05,028
有一个在告诉你结束测试

788
00:39:02,073 --> 00:39:06,156
是否继续重复这个循环 ，使 

789
00:39:05,028 --> 00:39:09,030
它像是翻转正常while循环 

790
00:39:07,056 --> 00:39:10,140
你必须 在 条件 测试 

791
00:39:09,048 --> 00:39:16,092
前，在这里你有它在最后 

792
00:39:11,004 --> 00:39:18,036
所以事实证明，如果我们认为 条款 

793
00:39:16,092 --> 00:39:22,173
的 去到这是一个非常简单的 

794
00:39:18,072 --> 00:39:26,079
事情到了 代码 替换这 一点， 

795
00:39:23,073 --> 00:39:29,151
会做一个测试 ，如果测试其持有 

796
00:39:27,042 --> 00:39:32,058
将跳转回来，说好一个做出反应 

797
00:39:30,051 --> 00:39:36,144
节目我是急性一部分 

798
00:39:32,058 --> 00:39:39,095
只是所以它建立了一个循环，你

799
00:39:37,044 --> 00:39:44,129
可以认为 它是一个字面上的环 

800
00:39:39,095 --> 00:39:44,129
控制流兜兜转转， 和 

801
00:39:45,092 --> 00:39:49,155
顺便说这其实是一种半 

802
00:39:48,027 --> 00:39:53,046
有用的功能，它被称为流行计数

803
00:39:50,055 --> 00:39:58,056
在有时有多少的人在那里 

804
00:39:53,046 --> 00:40:01,065
在这种 情况下， 在64位 数据的一个字 

805
00:39:58,056 --> 00:40:02,115
字还有的是一些代 

806
00:40:01,065 --> 00:40:04,137
你在哪里需要数据网络

807
00:40:03,015 --> 00:40:10,041
使用所有写这个功能您 

808
00:40:05,037 --> 00:40:13,092
最喜欢的业务，并与一个相当 

809
00:40:10,041 --> 00:40:20,073
在操作小限制 ，但我们不 

810
00:40:13,092 --> 00:40:21,120
这样做 ，所以今天在这里我要说的是你 

811
00:40:20,073 --> 00:40:24,156
看到 有一个相当的 

812
00:40:22,002 --> 00:40:28,024
采取 这种简单的方法

813
00:40:25,056 --> 00:40:30,091
特别是循环，把它逼到 

814
00:40:28,042 --> 00:40:32,065
的条件的组合，其中

815
00:40:30,091 --> 00:40:34,153
你要做的就是你跳回到你 

816
00:40:32,065 --> 00:40:35,122
术前，这里的实际 代码 

817
00:40:35,053 --> 00:40:39,091
为了它 

818
00:40:36,022 --> 00:40:42,040
我不会去通过 所有的，但你 可以 

819
00:40:39,091 --> 00:40:43,153
从这些注释认为， 

820
00:40:42,004 --> 00:40:46,090
这里非常密切关注的代码， 

821
00:40:44,053 --> 00:40:53,071
主要 看 的 是 这个跳跃如果 

822
00:40:47,026 --> 00:40:58,078
不等于标签L2而这需要你 

823
00:40:53,071 --> 00:41:02,140
回到这里 ，因此一般形式 

824
00:40:58,078 --> 00:41:04,105
然后，它是你需要做什么， 然后这个 

825
00:41:03,004 --> 00:41:07,030
这就是 所谓的循环体 的一部分 

826
00:41:05,005 --> 00:41:09,073
这是测试，因此现在你设置 

827
00:41:07,066 --> 00:41:12,067
一些代码，你可以执行 

828
00:41:09,073 --> 00:41:17,107
体进行测试，如果测试 

829
00:41:12,076 --> 00:41:19,132
拥有你回去循环，使一会儿

830
00:41:18,007 --> 00:41:23,038
环真的只是我能做什么循环 

831
00:41:20,032 --> 00:41:24,106
一个做，而只是循环，你移动 

832
00:41:23,038 --> 00:41:27,076
试验开始时，唯一的 

833
00:41:25,006 --> 00:41:30,070
因此，不同的是用do循环 

834
00:41:27,076 --> 00:41:31,144
你从来不这样做的测试中 

835
00:41:30,007 --> 00:41:35,031
第一次通过你保证 

836
00:41:32,044 --> 00:41:38,083
做第一次不管是什么 

837
00:41:35,094 --> 00:41:40,156
而while循环将 明确测试 

838
00:41:38,083 --> 00:41:42,151
即使在最开始和并跳过 

839
00:41:41,056 --> 00:41:46,120
在循环，如果条件不 

840
00:41:43,051 --> 00:41:48,097
持有如此有两种方式产生 

841
00:41:47,002 --> 00:41:50,095
代码是否有 两个以上 的 方法 

842
00:41:48,097 --> 00:41:52,132
生成的代码为 while循环，但 

843
00:41:51,013 --> 00:41:56,014
你会发现GCC 两个 使用两个 

844
00:41:53,032 --> 00:41:59,080
不同的方式之一就是我们会发现 

845
00:41:56,023 --> 00:42:01,060
当 我们使用这种优化设置我 

846
00:41:59,008 --> 00:42:05,014
谈到所谓 减去 最后一次 

847
00:42:01,006 --> 00:42:07,093
资本O代表优化AJI这 

848
00:42:05,086 --> 00:42:11,143
当然意味着调试正如你已经 

849
00:42:08,047 --> 00:42:16,048
知道有一些历史的东西

850
00:42:12,043 --> 00:42:17,116
减去 ģ标志 装置，以便当我 

851
00:42:16,057 --> 00:42:19,135
上次提到的这原来 是 

852
00:42:18,016 --> 00:42:22,045
优化的完美水平 

853
00:42:20,035 --> 00:42:24,049
这当然要能 

854
00:42:22,045 --> 00:42:26,137
看机器代码和理解 

855
00:42:24,049 --> 00:42:28,126
和它如何与C代码，因为 

856
00:42:27,037 --> 00:42:31,048
它某种简单 

857
00:42:29,026 --> 00:42:32,098
优化，但它并不试图 

858
00:42:31,048 --> 00:42:36,064
重写你的整个程序，使它 

859
00:42:32,098 --> 00:42:37,123
运行而即使减去·1更好 

860
00:42:36,064 --> 00:42:40,117
这是在 一个新的水平 

861
00:42:38,023 --> 00:42:41,115
优化 你 有时会 发现 它 

862
00:42:41,017 --> 00:42:47,052
会做一些很酷 

863
00:42:42,015 --> 00:42:49,038
的东西，但是当你真正作为一个程序 

864
00:42:47,052 --> 00:42:51,099
开发商作为一个软件开发出来 

865
00:42:49,038 --> 00:42:53,100
有或者 你跟公司和肯定 

866
00:42:51,099 --> 00:42:56,145
什么优化级别你使用 

867
00:42:54,000 --> 00:43:01,349
他们可能会 说- OH -这就是排序 

868
00:42:57,045 --> 00:43:03,194
公共点的所以通常有 

869
00:43:01,349 --> 00:43:05,490
更高水平的优化，我们 

870
00:43:03,599 --> 00:43:08,220
特意从釜底抽薪，使 

871
00:43:05,049 --> 00:43:11,618
这个代码更易于理解这样 

872
00:43:08,022 --> 00:43:14,027
反正与默认优化 

873
00:43:12,059 --> 00:43:16,157
我们使用这门课程它做了 

874
00:43:14,072 --> 00:43:18,147
改造我打电话跳到中间 

875
00:43:17,039 --> 00:43:21,240
翻译这些 都是顺便 说一下我自己 

876
00:43:19,047 --> 00:43:26,896
名字你不会发现他们在 任何其他 

877
00:43:21,024 --> 00:43:29,603
文档，但与 它 的想法 是 

878
00:43:27,319 --> 00:43:31,415
再想象我有一个while 循环 

879
00:43:29,819 --> 00:43:34,920
这种形式，其中有一个测试中 

880
00:43:32,279 --> 00:43:36,690
机身很好地执行什么了

881
00:43:34,092 --> 00:43:38,127
问题我已经比以前做的

882
00:43:36,069 --> 00:43:41,468
是一些我以前执行测试 

883
00:43:39,027 --> 00:43:43,125
我开始 循环的第一次迭代 

884
00:43:42,089 --> 00:43:48,210
所以我会 在这里做 的方式 是我就 

885
00:43:44,025 --> 00:43:50,118
跳的 是什么中间 

886
00:43:48,021 --> 00:43:53,600
旧线圈代码的测试部 

887
00:43:51,018 --> 00:43:56,177
该循环然后让 该测试 

888
00:43:53,789 --> 00:44:01,796
确定我是否真的进入 

889
00:43:56,339 --> 00:44:08,460
环本身，因此这是一个例子 

890
00:44:01,859 --> 00:44:10,680
一去我弹出数的代码版本

891
00:44:08,046 --> 00:44:14,645
功能，所以我写了一个流行数 

892
00:44:10,068 --> 00:44:16,427
使用while 循环这一次函数

893
00:44:15,059 --> 00:44:18,113
原来，不管你做什么或while循环 

894
00:44:17,039 --> 00:44:24,660
你会得到这样的结果相同 

895
00:44:18,599 --> 00:44:27,644
特定的功能和，你会看到

896
00:44:24,066 --> 00:44:30,120
它的外观是它跃升到 

897
00:44:28,049 --> 00:44:33,104
的代码，并与测试部分则如果 

898
00:44:31,002 --> 00:44:36,009
持有那么它 实际上 在 开始 

899
00:44:33,599 --> 00:44:37,920
的循环，然后 在第一次 执行 

900
00:44:36,027 --> 00:44:41,366
从那里，它看起来一样的 

901
00:44:37,092 --> 00:44:43,125
do-while循环，它只是做的是什么 

902
00:44:41,609 --> 00:44:46,640
在环做测试跳回 

903
00:44:44,025 --> 00:44:46,064
开始 

904
00:44:48,041 --> 00:44:52,080
虽然再有第二 

905
00:44:50,579 --> 00:44:55,440
方法是在某些方面 更 

906
00:44:52,008 --> 00:44:57,527
传统的，你会发现，如果你 

907
00:44:55,044 --> 00:45:01,053
利用优化其中之一是相当 

908
00:44:58,319 --> 00:45:03,930
有用的东西在实践中 这样 做 只是 

909
00:45:01,053 --> 00:45:05,055
要告诉你 ，而不是决定 

910
00:45:03,093 --> 00:45:09,093
其中之一，我要告诉你我 

911
00:45:05,055 --> 00:45:12,060
决定向您展示这两个和的想法 

912
00:45:09,093 --> 00:45:14,097
这是 做 它基本上是采取 

913
00:45:13,005 --> 00:45:17,097
而循环并把它变成做，而

914
00:45:14,097 --> 00:45:20,696
循环，但引入的有条件 

915
00:45:17,097 --> 00:45:23,172
事先将基本守卫 

916
00:45:21,569 --> 00:45:28,260
你的入口处循环，使你做一个 

917
00:45:24,072 --> 00:45:28,961
最初的测试，如果是假的，那么你 

918
00:45:28,026 --> 00:45:31,125
跳过环路一起 

919
00:45:29,609 --> 00:45:36,690
否则，就会像一个做同时进行 

920
00:45:32,025 --> 00:45:38,144
环等具有相当 

921
00:45:36,069 --> 00:45:40,071
直接转换成代码

922
00:45:38,369 --> 00:45:43,500
并再次显得有些 

923
00:45:40,071 --> 00:45:46,092
从 它具有以往不同

924
00:45:43,005 --> 00:45:49,114
最初的测试，但那么它 看起来像 一个 

925
00:45:46,092 --> 00:45:48,781
do-while循环

926
00:45:50,092 --> 00:45:54,190
所以我不会告诉你的 组件 

927
00:45:52,009 --> 00:45:58,448
这些版本，但如果你，如果你看 

928
00:45:55,009 --> 00:46:01,020
在实际的代码是在所有 

929
00:45:59,339 --> 00:46:05,650
链接到 您的目录

930
00:46:02,001 --> 00:46:07,015
类目录的类 网页，以便 

931
00:46:05,065 --> 00:46:09,070
实际上你可以看看代码和 

932
00:46:07,015 --> 00:46:13,051
你会看到，它遵循完全 

933
00:46:09,007 --> 00:46:18,025
这样我描述它，然后第三 

934
00:46:13,051 --> 00:46:21,058
类型的循环是for循环，其用C 

935
00:46:18,088 --> 00:46:23,095
其实是一个很强大很一般 

936
00:46:22,021 --> 00:46:27,066
型的东西，所以它是非常 普遍 

937
00:46:23,095 --> 00:46:29,664
使用 ，但 你 可以看到，在for循环 

938
00:46:27,066 --> 00:46:33,118
有四个组成部分 它有一个 

939
00:46:30,519 --> 00:46:37,180
初始化的测试有一个规则 

940
00:46:34,018 --> 00:46:39,117
在这样的情况下更新，以此来 

941
00:46:37,018 --> 00:46:41,044
继续循环，然后它有 

942
00:46:39,279 --> 00:46:45,400
循环体，因此这里的 

943
00:46:41,044 --> 00:46:47,116
我的弹出钙函数，其中的版本 

944
00:46:45,004 --> 00:46:52,078
我只是通过在所有位 

945
00:46:48,016 --> 00:46:55,098
该单词提取出来，并加入

946
00:46:53,014 --> 00:47:00,663
他们积累他们就可以出结果

947
00:46:55,098 --> 00:47:03,100
所以翻录除了这个你会看到 

948
00:47:00,789 --> 00:47:05,841
是的环路的这四个 块 

949
00:47:04,000 --> 00:47:09,007
对应的初始化 设置 

950
00:47:06,309 --> 00:47:13,900
等于零的测试是比较我 

951
00:47:09,007 --> 00:47:17,856
而我在这里设置为字长

952
00:47:13,009 --> 00:47:20,418
为八个 吨左右但多少字节 

953
00:47:18,549 --> 00:47:24,549
在 一个int乘上8来获得 

954
00:47:21,309 --> 00:47:26,950
字的大小，然后更新是我加 

955
00:47:24,549 --> 00:47:31,500
加上然后 身体就是 这个东西 

956
00:47:26,095 --> 00:47:34,144
这就是括号内这里，所以我可以 

957
00:47:31,005 --> 00:47:39,564
想到 这一点，一般一个一个一般 

958
00:47:35,044 --> 00:47:43,117
方式来思考一个for循环和看到的是 

959
00:47:40,059 --> 00:47:49,155
此规则将变成一个for循环 

960
00:47:44,017 --> 00:47:52,896
成while循环，因此它说什么是 

961
00:47:50,019 --> 00:47:56,118
我先做初始化，然后我 

962
00:47:53,049 --> 00:48:01,210
做一个循环，我我这个保护它 

963
00:47:57,009 --> 00:48:04,240
测试，然后我继续这样做是 

964
00:48:01,021 --> 00:48:04,088
执行主体 ，然后进行 

965
00:48:04,024 --> 00:48:06,113
随你 

966
00:48:04,088 --> 00:48:09,187
到目前为止还，然后 用 继续 

967
00:48:07,013 --> 00:48:13,372
测试使 某种语义 

968
00:48:09,979 --> 00:48:18,950
的行为的定义 

969
00:48:13,489 --> 00:48:22,940
for循环， 看这样我就可以把我的 

970
00:48:18,095 --> 00:48:25,234
for循环不同的部分我的 ，说 

971
00:48:22,094 --> 00:48:28,633
好吧好吧，我承担了规则，并用它 

972
00:48:26,089 --> 00:48:31,096
收拾他们，形成同时工作， 

973
00:48:29,479 --> 00:48:34,513
当然，你知道，你可以排序的 

974
00:48:31,789 --> 00:48:36,710
这两个之间去为一个有点 

975
00:48:34,819 --> 00:48:38,860
品味的问题是否在指定循环 

976
00:48:36,071 --> 00:48:47,117
应该使用一个循环或写

977
00:48:39,229 --> 00:48:51,282
而循环，这样一个原因，它是 

978
00:48:48,017 --> 00:48:53,093
真正有用的 做-一个哦 

979
00:48:51,759 --> 00:48:55,831
优化 我跟大家介绍的就是 

980
00:48:53,093 --> 00:48:59,032
它是最初的 测试相当普遍 

981
00:48:56,479 --> 00:49:02,536
是平凡的平凡真实所以对于 

982
00:48:59,869 --> 00:49:04,942
例如，在这里，如果我等于零 ，我 

983
00:49:03,049 --> 00:49:07,930
它比较字尺寸 

984
00:49:05,599 --> 00:49:10,940
通常将32

985
00:49:07,093 --> 00:49:12,502
清楚，测试结果是真，这是一个特定的 

986
00:49:10,094 --> 00:49:15,243
的事情，所以你会看到 的 是， 

987
00:49:13,339 --> 00:49:20,390
编译器可以明白这一点 ，只是 

988
00:49:16,089 --> 00:49:24,163
扔掉这个守卫码会 

989
00:49:20,039 --> 00:49:26,428
必须有 ，否则这样使 

990
00:49:24,829 --> 00:49:27,904
我认为这是最主要的原因 ， 

991
00:49:26,779 --> 00:49:31,880
这是得到改造

992
00:49:28,579 --> 00:49:33,676
用的哦一个优化级别 

993
00:49:31,088 --> 00:49:36,477
那很多时候并不 需要这个 

994
00:49:34,549 --> 00:49:36,621
初步测试

995
00:49:39,839 --> 00:49:45,888
好吧所以现在我 要 与 完成了 

996
00:49:42,579 --> 00:49:50,652
什么是在 它的直接环路的东西 

997
00:49:46,329 --> 00:49:55,428
是那种 如果你是 你所期望 

998
00:49:51,309 --> 00:49:58,480
有你 知道把一个C代码到 

999
00:49:56,319 --> 00:50:01,900
一些很低级的，所有你 

1000
00:49:58,048 --> 00:50:03,145
可以做的是跳跃和测试以及可能 

1001
00:50:01,009 --> 00:50:05,071
这是显而易见的，但也许不是开关 

1002
00:50:04,045 --> 00:50:08,454
在另一方面语句是完全 

1003
00:50:06,052 --> 00:50:10,147
不同的野兽 ，我想 告诉你 

1004
00:50:08,859 --> 00:50:14,170
因为有一个 在 没有 对应 

1005
00:50:11,047 --> 00:50:19,054
你会如何甚至认为普通的C代码

1006
00:50:14,017 --> 00:50:21,088
关于它和它的相当一点点 

1007
00:50:19,054 --> 00:50:25,383
更难做密码和你要 

1008
00:50:21,088 --> 00:50:27,103
要做到这一点的炸弹实验室所以这里的

1009
00:50:25,869 --> 00:50:31,893
即switch语句的一个例子 

1010
00:50:28,003 --> 00:50:33,100
的一无所知， 除了有用 

1011
00:50:32,109 --> 00:50:37,030
证明对如何一些原则

1012
00:50:34,000 --> 00:50:40,063
把一个switch语句成装配 

1013
00:50:37,003 --> 00:50:43,015
代码，所以它的观点是，你 知道 

1014
00:50:40,063 --> 00:50:46,117
和C，你打开 一个特定的值 

1015
00:50:43,015 --> 00:50:49,944
一些类型的整数值，然后将其 

1016
00:50:47,017 --> 00:50:51,103
将匹配不同的情况 下，每 

1017
00:50:50,079 --> 00:50:58,200
这些案件必须有一些不变 

1018
00:50:52,003 --> 00:51:01,072
数值常数的整数值和 

1019
00:50:58,002 --> 00:51:04,033
的C的怪异的特征之一是，如果

1020
00:51:01,072 --> 00:51:06,154
你不要在你的情况下结束 

1021
00:51:04,051 --> 00:51:10,090
没有 明确说破它会做 

1022
00:51:07,054 --> 00:51:13,153
什么作为通过这样的下跌 

1023
00:51:10,009 --> 00:51:17,038
这个例子在这里它将除以zÿ 

1024
00:51:14,053 --> 00:51:21,882
然后它只会滑翔 右转入 

1025
00:51:18,019 --> 00:51:24,091
这种说法，增加了Ë至W，这是 

1026
00:51:22,359 --> 00:51:26,500
通过像最差设计的一个方式 

1027
00:51:24,091 --> 00:51:27,115
在节目的历史决定

1028
00:51:26,005 --> 00:51:30,051
语言 

1029
00:51:28,015 --> 00:51:34,042
它已经越来越多的原因

1030
00:51:30,096 --> 00:51:35,128
你知道艺术突破和错误 ，没有人 

1031
00:51:34,042 --> 00:51:38,110
能理解比其他任何一个

1032
00:51:36,028 --> 00:51:40,084
语言和某些部分

1033
00:51:39,001 --> 00:51:42,094
奇怪的原因 ，他们已经把它活着 

1034
00:51:40,084 --> 00:51:45,121
即使进入Java和所有这些其他 

1035
00:51:43,003 --> 00:51:48,046
该解决很多 最坏的语言

1036
00:51:46,021 --> 00:51:50,053
部分你知道最危险的部分 

1037
00:51:48,046 --> 00:51:53,122
的 C，但不知何故，他们一直在 这个 缝合 

1038
00:51:50,053 --> 00:51:56,140
所以只是作为一个建议，作为一个程序员 

1039
00:51:54,022 --> 00:52:00,037
如果你永远永远使用这个，你

1040
00:51:57,004 --> 00:52:02,089
有意想让它去从一个案例 

1041
00:52:00,037 --> 00:52:05,128
另一个你应该把评论 

1042
00:52:03,025 --> 00:52:08,044
在那里说相信我， 我真的 做到了 

1043
00:52:06,028 --> 00:52:09,037
希望落空我知道你 

1044
00:52:08,044 --> 00:52:13,047
几乎从来没有想这样做， 但我 

1045
00:52:10,018 --> 00:52:16,030
这里所以这是一个相当 普遍 

1046
00:52:13,074 --> 00:52:18,166
会议上， 我不知道有多少次 

1047
00:52:16,003 --> 00:52:23,049
我已经说了，因为我忘了虫子

1048
00:52:19,066 --> 00:52:27,109
把 制动器反正够我 

1049
00:52:23,076 --> 00:52:31,102
编者按你看到的其他功能 

1050
00:52:28,009 --> 00:52:34,030
而看到的是，你可以插入一个聚成一团

1051
00:52:32,002 --> 00:52:36,046
多情况下，如果你认为它这是 

1052
00:52:34,003 --> 00:52:39,022
只是 秋天的 一个特例 通过 

1053
00:52:36,046 --> 00:52:41,143
右侧为 五个无关 

1054
00:52:39,049 --> 00:52:43,111
但通过下降到六，但所以这是 

1055
00:52:42,043 --> 00:52:46,099
大致相同的办法并没有什么 

1056
00:52:44,011 --> 00:52:50,029
这不是，这不是坏的，它不 

1057
00:52:46,099 --> 00:52:51,115
需要注释，另外一个是

1058
00:52:50,029 --> 00:52:55,048
，有一个默认的，所以如果没有的 

1059
00:52:52,015 --> 00:52:57,097
这些案件匹配要么是因为X为 0 

1060
00:52:55,048 --> 00:53:02,062
或更小或X是一个非常大的数字 

1061
00:52:57,097 --> 00:53:03,193
或在这种情况下，如果X是 4没有 

1062
00:53:02,062 --> 00:53:06,070
匹配的情况下，当然你也 

1063
00:53:04,093 --> 00:53:08,191
知道这些 情况不必是 

1064
00:53:06,007 --> 00:53:11,008
在任何特定的顺序是它所以这是 

1065
00:53:09,091 --> 00:53:16,098
所有的排序的情况下的特性 

1066
00:53:11,008 --> 00:53:20,050
switch语句的语句转起来 

1067
00:53:17,061 --> 00:53:22,120
所以一般来说，如果你在那种写 

1068
00:53:21,022 --> 00:53:25,024
如果你被告知 

1069
00:53:23,002 --> 00:53:27,085
你不可使用 switch语句 

1070
00:53:25,042 --> 00:53:29,134
再有什么你可能做的是写

1071
00:53:28,003 --> 00:53:35,011
如果其他的if else的这个大长链

1072
00:53:30,034 --> 00:53:37,102
是别人的权利， 你会期望， 要 

1073
00:53:35,083 --> 00:53:38,131
是 机器代码，但它不是 等 

1074
00:53:38,002 --> 00:53:41,055
让我告诉 你什么是机器代码 

1075
00:53:39,031 --> 00:53:41,055
不

1076
00:53:41,065 --> 00:53:48,065
它是一种长的故事 这么认为的 

1077
00:53:45,068 --> 00:53:53,093
它的一般形式为一些 

1078
00:53:48,065 --> 00:53:55,130
的代码块，其中的入口点

1079
00:53:53,093 --> 00:53:57,098
由这些情况下值标记和 

1080
00:53:56,003 --> 00:53:59,027
那么块 

1081
00:53:57,098 --> 00:53:59,194
你在不同的共同认识串

1082
00:53:59,054 --> 00:54:04,118
不同的方式和做各种事情 

1083
00:54:00,094 --> 00:54:07,106
我什么都做 的是编译代码 

1084
00:54:05,018 --> 00:54:11,053
所有这些块，并将其储存 

1085
00:54:08,006 --> 00:54:14,087
远在存储器某些部分加载 

1086
00:54:11,053 --> 00:54:16,142
存储器来包含这些代码块和 

1087
00:54:14,087 --> 00:54:20,162
那么我要建立一个表 ，每个 

1088
00:54:17,042 --> 00:54:23,111
此表 的条目描述了 

1089
00:54:21,062 --> 00:54:27,086
开始的这些码的一个的位置 

1090
00:54:24,011 --> 00:54:31,043
块，我把他们 的 订单 我 

1091
00:54:27,086 --> 00:54:34,175
标签的情况下，如果我有你知道 我要 

1092
00:54:31,043 --> 00:54:37,052
涵盖从那么它的假设零范围 

1093
00:54:35,075 --> 00:54:39,167
但通常认为并非如此 

1094
00:54:37,052 --> 00:54:43,103
零到N减一个 

1095
00:54:40,067 --> 00:54:48,164
我也会有这样的表将有很多 

1096
00:54:44,003 --> 00:54:53,072
地址条目告诉我在哪里 

1097
00:54:49,064 --> 00:54:54,130
这些代码块位于和然后 

1098
00:54:53,072 --> 00:55:00,095
我要 利用这个很酷 

1099
00:54:55,003 --> 00:55:04,034
指令这是一个有点像它的 

1100
00:55:00,095 --> 00:55:06,173
因为如果你把它像一个光线索引，所以如果 

1101
00:55:04,061 --> 00:55:09,110
你觉得射线索引就意味着你 

1102
00:55:07,073 --> 00:55:14,132
能抢到值超出中间 

1103
00:55:10,001 --> 00:55:17,063
一些你知道数组的一些设定值 

1104
00:55:15,032 --> 00:55:20,063
而不必通过它们的步骤 一个 

1105
00:55:17,072 --> 00:55:24,143
由之一，它 在这里 是同样的想法 ， 

1106
00:55:20,063 --> 00:55:28,082
我将我的价值，并用它来 

1107
00:55:25,043 --> 00:55:32,045
找出直接在这里我要跳 

1108
00:55:28,082 --> 00:55:34,093
到的代码 ， 而无需一个块 

1109
00:55:32,045 --> 00:55:37,124
通过一堆其他条件步骤

1110
00:55:34,093 --> 00:55:38,180
所以，你可以再次看到效率

1111
00:55:38,024 --> 00:55:41,123
从它的 之间 的 区别 

1112
00:55:39,008 --> 00:55:45,074
那种一步 到位知道 到底 

1113
00:55:42,023 --> 00:55:48,056
要成为与步进

1114
00:55:46,046 --> 00:55:52,135
通过你知道n平均超过两

1115
00:55:48,056 --> 00:55:52,135
条件去的地步，我想去 

1116
00:55:53,004 --> 00:56:00,723
让我们看看这个在装配 

1117
00:55:56,259 --> 00:56:03,261
代码级，它是一个一点点 

1118
00:56:01,119 --> 00:56:07,218
长长的东西，因为我们必须建立一些 

1119
00:56:03,279 --> 00:56:10,930
所以在这里解决这个机器是我的 

1120
00:56:08,109 --> 00:56:14,184
例如我有三个参数 

1121
00:56:10,093 --> 00:56:16,093
所以只记得我告诉你，我们的 VI和 

1122
00:56:14,859 --> 00:56:22,630
我们对前两个参数 的 SI 

1123
00:56:16,093 --> 00:56:26,262
第三个参数是RDX和这里的 

1124
00:56:22,063 --> 00:56:29,068
开始拨码开关的，它只是 

1125
00:56:27,099 --> 00:56:33,180
使得参数Z的副本，这里 

1126
00:56:30,013 --> 00:56:37,902
由于某种原因， 然后 在看 

1127
00:56:33,018 --> 00:56:41,937
比较X 2 6和Y 6 是 一个重要的 

1128
00:56:38,019 --> 00:56:45,720
数，因为 你 看到 6为最大 

1129
00:56:42,099 --> 00:56:45,720
的 我 的任何 情况下， 值 

1130
00:56:47,056 --> 00:56:54,070
现在它的使用跳转指令 

1131
00:56:51,046 --> 00:56:56,130
去LA我们会发现， 告诉 

1132
00:56:54,007 --> 00:57:00,100
你默认的 行为应该是什么

1133
00:56:57,003 --> 00:57:03,007
所以这有点冲掉了的 

1134
00:57:01,063 --> 00:57:06,142
默认情况下 是两种 情况 

1135
00:57:03,007 --> 00:57:08,020
X是太小或 X是太大，我 

1136
00:57:07,042 --> 00:57:12,049
应该提到有一个巧招 

1137
00:57:08,083 --> 00:57:16,099
那里，如果你看看J A指跳 

1138
00:57:12,049 --> 00:57:19,125
上面这是无符号的比较 

1139
00:57:16,099 --> 00:57:21,175
什么它利用的是我们的我们 

1140
00:57:20,025 --> 00:57:25,069
结果是，你要记住，如果一个

1141
00:57:22,075 --> 00:57:27,079
数字为 负数，如果你认为它是 

1142
00:57:25,069 --> 00:57:31,095
一个无符号的价值就变得非常大

1143
00:57:28,015 --> 00:57:36,076
正值 ，从而通过执行 J A 

1144
00:57:31,095 --> 00:57:39,172
而不是AJ GI的跳大于我 

1145
00:57:36,076 --> 00:57:48,162
做跳跃上面在说我要 

1146
00:57:40,072 --> 00:57:53,098
跳转到 默认如果x是 

1147
00:57:49,062 --> 00:57:58,078
大于6也将导致 其 

1148
00:57:53,098 --> 00:58:00,184
跳如果X 小于 0拿到这么 

1149
00:57:58,078 --> 00:58:02,155
它是一个无符号的巧招 对 

1150
00:58:01,084 --> 00:58:06,133
有符号数是趁着 

1151
00:58:03,055 --> 00:58:08,131
然后将最后一部分是这样的 

1152
00:58:07,033 --> 00:58:14,068
工作的真正心脏，这是 我很 

1153
00:58:09,031 --> 00:58:18,055
特别去到指令，让我 

1154
00:58:14,068 --> 00:58:20,140
索引到表，并提取出 的 

1155
00:58:18,055 --> 00:58:24,082
该地址，然后跳转到该 

1156
00:58:21,004 --> 00:58:30,010
地址，这就是让我去 

1157
00:58:24,082 --> 00:58:33,157
直接将一些代码块基于

1158
00:58:31,000 --> 00:58:38,023
我们是否我的价值观会看到将 在 

1159
00:58:34,057 --> 00:58:41,064
0和6之间的范围，从而就会有 

1160
00:58:38,023 --> 00:58:41,064
七个条目在 该表 

1161
00:58:44,289 --> 00:58:49,366
一个一件事，只是为了 保持跟踪 弥补 

1162
00:58:47,359 --> 00:58:54,370
以后你会看到 ，由于某些原因 

1163
00:58:50,059 --> 00:58:57,130
海湾合作委员会说，你知道，如果我看所有 

1164
00:58:54,469 --> 00:58:59,530
代码其实我不使用W作为 

1165
00:58:57,013 --> 00:59:01,882
初始化非常多，所以我不会打扰 

1166
00:59:00,079 --> 00:59:04,430
这样做，直到某个地方的代码中 

1167
00:59:01,999 --> 00:59:10,130
块，这样只是 我们必须 跟踪 

1168
00:59:04,043 --> 00:59:12,922
的是，这里 好了 ，所以这是一个神奇的 

1169
00:59:10,013 --> 00:59:17,722
指令 现在如果我们 看看这个 

1170
00:59:13,309 --> 00:59:20,420
在所有的汇编代码，你会看到这是 

1171
00:59:17,839 --> 00:59:22,858
实际跳转 表和它的 

1172
00:59:20,042 --> 00:59:24,047
它构建的在组件中指定

1173
00:59:23,029 --> 00:59:26,660
代码是汇编 到工作

1174
00:59:24,092 --> 00:59:32,401
实际上填补了这样的内容 

1175
00:59:26,066 --> 00:59:36,265
表原谅我，但是什么大会 

1176
00:59:33,229 --> 00:59:39,232
代码 是告诉汇编器是 我需要的 

1177
00:59:36,859 --> 00:59:42,871
四，它只是一个声明，说我 

1178
00:59:39,259 --> 00:59:46,261
在这里需要一个8字节的值和值 

1179
00:59:42,979 --> 00:59:49,130
应与你决定什么地址 

1180
00:59:46,459 --> 00:59:51,880
您后来决定是地址 

1181
00:59:49,013 --> 00:59:54,089
我要去哪里贴标签和8 

1182
00:59:51,088 --> 00:59:56,707
所有这些其他的， 这些都是在 

1183
00:59:54,089 --> 01:00:00,568
正如我从X所提及的顺序等于0 

1184
00:59:57,499 --> 01:00:04,567
到6，我们已经可以看到几个 

1185
01:00:01,369 --> 01:00:08,418
是有趣的情况在这里让我 

1186
01:00:05,179 --> 01:00:08,247
看看，如果我已经有了 这一张图片 

1187
01:00:11,056 --> 01:00:14,056
是啊

1188
01:00:16,003 --> 01:00:22,099
所以我们实际上可以看到已经有些 

1189
01:00:20,035 --> 01:00:24,097
这个switch语句 的 内置逻辑

1190
01:00:22,099 --> 01:00:27,124
进入条目在此排序

1191
01:00:24,097 --> 01:00:30,100
表，以便特别是没有的情况下 

1192
01:00:28,024 --> 01:00:34,087
零这里，所以零的情况下应该是 

1193
01:00:31,000 --> 01:00:37,027
默认情况下有是这里的任何情况下 

1194
01:00:34,087 --> 01:00:38,134
案例应该是默认的 ，它 

1195
01:00:37,027 --> 01:00:42,058
事实证明，我们之前已经看到

1196
01:00:39,034 --> 01:00:43,129
J A指令去 LA如此 大号8 

1197
01:00:42,058 --> 01:00:47,065
实际上是在码块是 

1198
01:00:44,029 --> 01:00:49,114
将成为默认的情况下，所以你 

1199
01:00:47,065 --> 01:00:52,081
看基本上 就可以 认为这 是 

1200
01:00:50,014 --> 01:00:54,070
有时保持具有孔的 

1201
01:00:52,081 --> 01:00:57,088
switch语句和我们要公正 

1202
01:00:54,007 --> 01:01:04,069
说那些填补这些漏洞

1203
01:00:58,051 --> 01:01:06,109
应到默认 情况下，在这里 

1204
01:01:05,032 --> 01:01:09,103
你会发现 ，他们 没有放 

1205
01:01:07,009 --> 01:01:17,085
任何特别逻辑顺序一个一个 

1206
01:01:10,003 --> 01:01:21,076
您将再次看到的是L7的 

1207
01:01:17,085 --> 01:01:24,085
这里重复两次，因为它涵盖了

1208
01:01:21,076 --> 01:01:26,077
两种情况下， 五 ，六，以便再次你会 

1209
01:01:24,085 --> 01:01:29,149
看到那种增加了一倍的处理 

1210
01:01:26,086 --> 01:01:31,171
自动跳转表 ，我们将 

1211
01:01:30,049 --> 01:01:34,128
给你同样的地址多 

1212
01:01:32,071 --> 01:01:34,128
不同的情况下， 

1213
01:01:37,073 --> 01:01:41,108
还好 ，现在 它的 其余部分 是看 

1214
01:01:40,004 --> 01:01:44,039
在各码块并且这由 

1215
01:01:42,008 --> 01:01:47,099
我展示你的方式，我花了一个文件 

1216
01:01:44,075 --> 01:01:48,149
而且我知道你有点提取位 

1217
01:01:47,099 --> 01:01:52,100
它但是 通常你在看 

1218
01:01:49,049 --> 01:01:55,094
在一个大的订单，这个整体上市等等

1219
01:01:53,000 --> 01:01:57,065
现在我们可以 看个人代码 

1220
01:01:55,094 --> 01:01:58,163
块，看看发生了什么事情，并

1221
01:01:57,065 --> 01:02:02,081
你会看到例如情况下，一个告诉我 

1222
01:01:59,063 --> 01:02:04,136
到两个数相乘，你会看到 

1223
01:02:02,081 --> 01:02:05,177
在 一般的突破，它只是 

1224
01:02:05,036 --> 01:02:11,042
要 变成 回报 

1225
01:02:06,077 --> 01:02:13,112
在这里说明，因为我的功能去 

1226
01:02:11,042 --> 01:02:16,085
遗憾的代码跳你看这 

1227
01:02:14,012 --> 01:02:21,026
功能做了一个switch语句，然后 

1228
01:02:16,085 --> 01:02:22,157
无论什么被中计算 

1229
01:02:21,026 --> 01:02:26,054
switch语句获取返回的 

1230
01:02:23,057 --> 01:02:29,066
这个结果让编译器不 

1231
01:02:26,054 --> 01:02:31,121
其实到了一个单点，并说 

1232
01:02:29,066 --> 01:02:34,124
还好大家都回来在这一点上 

1233
01:02:32,021 --> 01:02:38,029
只是坚持直接回报的地方 

1234
01:02:35,024 --> 01:02:38,029
这些断裂发生 

1235
01:02:41,059 --> 01:02:49,151
所以这里做了乘法和返回 

1236
01:02:46,024 --> 01:02:52,073
这里实际上是一个奇怪的方式 

1237
01:02:50,051 --> 01:02:55,130
总是让我感到什么有点吃惊 

1238
01:02:52,073 --> 01:03:02,077
编译器确实这是从来没有完全相同 

1239
01:02:56,003 --> 01:03:06,004
你期望什么，所以特别是它 

1240
01:03:03,013 --> 01:03:12,050
拼凑今秋通过案例 

1241
01:03:06,004 --> 01:03:16,028
通过两个代码块，它不得不做

1242
01:03:12,005 --> 01:03:20,006
这些分别，因为记得 Mw为 

1243
01:03:16,064 --> 01:03:22,148
没有设置之前，我进入了这些代码

1244
01:03:20,051 --> 01:03:25,058
块并推迟设置，并在这里 

1245
01:03:23,048 --> 01:03:29,132
我打 了一个突然 我 的 K3 和 实际上 都 

1246
01:03:25,058 --> 01:03:32,111
需要什么W¯¯ 是这是一个等 

1247
01:03:30,032 --> 01:03:34,124
我猜编译说好天哪我

1248
01:03:33,011 --> 01:03:37,019
想我最好把W到一个之前在这里

1249
01:03:35,024 --> 01:03:39,107
我们继续这样的 结果，它像是 

1250
01:03:37,091 --> 01:03:43,187
创建两个代码块，但它跳跃

1251
01:03:40,007 --> 01:03:51,026
从第二个 该块成 

1252
01:03:44,087 --> 01:03:53,165
在这里中途通过这个其他块的 

1253
01:03:51,026 --> 01:03:58,085
一些实际的耶所以这里的实际 

1254
01:03:54,065 --> 01:04:00,080
代码这 是确实的 块 

1255
01:03:58,085 --> 01:04:02,087
分工是非常快，你怎么有 

1256
01:04:00,008 --> 01:04:04,103
写师在书中发现 

1257
01:04:03,005 --> 01:04:08,096
我不会通过它放在这里，然后这个 

1258
01:04:05,075 --> 01:04:10,088
跳L6是什么，我说去 合并， 

1259
01:04:08,096 --> 01:04:12,155
合并是你们把这些 

1260
01:04:10,088 --> 01:04:17,171
2案件聚集在这里是它的 

1261
01:04:13,055 --> 01:04:20,126
设置L到一个重新它利用 

1262
01:04:18,071 --> 01:04:23,072
该特征的， 并且上部32 

1263
01:04:21,026 --> 01:04:29,029
位都设置为零 ， 这样II可以使用 

1264
01:04:23,072 --> 01:04:28,129
搬到这里提单资料是问题 

1265
01:04:33,008 --> 01:04:39,096
没有什么无码

1266
01:04:37,349 --> 01:04:42,950
跳转表之类的嵌入式让我 

1267
01:04:39,096 --> 01:04:41,195
只是告诉你真正的快 

1268
01:04:43,007 --> 01:04:51,030
没有可能坏主意跳，如果你 

1269
01:04:48,081 --> 01:04:51,177
看的点S文件汇编

1270
01:04:51,003 --> 01:04:54,075
代码文件哦 

1271
01:04:52,077 --> 01:04:57,099
所有这些东西我展示你我 

1272
01:04:55,002 --> 01:04:58,044
提炼出来 的那个，但是这一切都在 

1273
01:04:57,099 --> 01:05:00,117
那里

1274
01:04:58,044 --> 01:05:03,048
并且使得编译器生成的这些 

1275
01:05:01,017 --> 01:05:06,033
表至少那种框架 

1276
01:05:03,084 --> 01:05:08,603
这些表 的细节的 

1277
01:05:06,033 --> 01:05:12,050
得到由汇编填满，所以它是

1278
01:05:09,359 --> 01:05:12,500
由编译器生成

1279
01:05:16,089 --> 01:05:21,165
好吧，这只是 说明你这一个 

1280
01:05:19,449 --> 01:05:24,513
示例的处理 一特定的方式 

1281
01:05:21,849 --> 01:05:28,866
办理落空的情况下，然后 

1282
01:05:25,089 --> 01:05:31,140
其余的再你会看到这里 

1283
01:05:29,019 --> 01:05:34,630
我如果我得到这个情况下，我需要的 

1284
01:05:31,599 --> 01:05:37,686
事实上W被初始化为1，所以我们会 

1285
01:05:34,063 --> 01:05:40,422
这样做这里的默认情况下，它只是 

1286
01:05:38,469 --> 01:05:43,470
设计2W的，因此这就是它所做的一切 

1287
01:05:40,989 --> 01:05:45,027
所以反正我实际上显示你所有 

1288
01:05:43,569 --> 01:05:46,611
代码块，但 我向您展示一个 

1289
01:05:45,369 --> 01:05:49,380
通过一个，但他们 只是都挺 

1290
01:05:46,989 --> 01:05:52,023
强的文件，并 没有特定的 

1291
01:05:49,479 --> 01:06:03,501
为了它什么并不重要 ，他们的订单 

1292
01:05:52,329 --> 01:06:10,332
是是是的，这样 是为原因 

1293
01:06:03,699 --> 01:06:13,713
上面跳开头所以这 

1294
01:06:10,359 --> 01:06:18,384
跳上面拉的样子，如果X是 

1295
01:06:13,839 --> 01:06:20,841
或者小于 0或 大于6它 

1296
01:06:18,609 --> 01:06:28,698
会去默认情况下，它会 

1297
01:06:21,039 --> 01:06:33,042
如果如果X只能这样做索引伎俩 

1298
01:06:29,499 --> 01:06:35,640
为0和6 之间 ， 这就是通常 

1299
01:06:33,339 --> 01:06:38,364
这个工作的方式，你会看到， 

1300
01:06:35,064 --> 01:06:39,115
无论值的范围 ，你给它具有 

1301
01:06:38,589 --> 01:06:42,624
找出最小， 

1302
01:06:40,015 --> 01:06:45,084
最大的一个设置，以便它去 

1303
01:06:42,939 --> 01:06:47,013
默认情况下，如果它指出范围 

1304
01:06:45,219 --> 01:06:52,390
然后设置 一个表中的值 

1305
01:06:47,679 --> 01:06:55,900
像一些该范围内的问题 

1306
01:06:52,039 --> 01:06:58,728
负数-是它尝试做 

1307
01:06:55,009 --> 01:07:00,078
该索引将其与 X功率 ，从而 

1308
01:06:59,079 --> 01:07:03,174
我的问题，认识到我应该是

1309
01:07:00,969 --> 01:07:06,018
重复提问的问题是什么

1310
01:07:04,029 --> 01:07:08,037
如果这是你的情况下 ， 负数 

1311
01:07:06,459 --> 01:07:11,475
这是完全合法的它会 

1312
01:07:08,829 --> 01:07:13,877
通常有效 增加偏向 于它 

1313
01:07:11,619 --> 01:07:17,682
所以，无论 你的最低值 

1314
01:07:14,309 --> 01:07:20,900
成为0或者它会做这样的事情 

1315
01:07:18,249 --> 01:07:29,150
要避免做阴性对照索引 

1316
01:07:20,009 --> 01:07:32,338
另一个问题是，他肯定是啊，所以你 

1317
01:07:29,015 --> 01:07:34,088
可以从零 到一百万啊，他们 

1318
01:07:33,229 --> 01:07:36,292
可能是你可以在一百万零走 

1319
01:07:34,088 --> 01:07:37,166
并没有什么右之间，所以你会 

1320
01:07:36,859 --> 01:07:40,951
有两种情况下，你真的 不想要一个 

1321
01:07:38,066 --> 01:07:44,144
对于只是其中两个 例子百万条目表 

1322
01:07:41,779 --> 01:07:46,786
所以它会变成 一个 毡代码，但 

1323
01:07:45,044 --> 01:07:47,116
聪明的事情， 我们会如果 你 这样做 

1324
01:07:46,849 --> 01:07:50,851
知道二进制搜索

1325
01:07:48,016 --> 01:07:52,019
他们依赖于它知道 的事实

1326
01:07:50,869 --> 01:07:54,876
推进 所有的值，它 会 

1327
01:07:52,046 --> 01:07:58,345
实际上建立的是 菲尔普斯的这么 一棵树 

1328
01:07:55,569 --> 01:07:59,644
真的会做，如果你想

1329
01:07:58,759 --> 01:08:03,200
感谢算法是用做它 

1330
01:08:00,319 --> 01:08:09,324
测试对数数量，而不是 

1331
01:08:03,002 --> 01:08:09,621
的测试问题的线性数

1332
01:08:15,239 --> 01:08:22,130
哦耶 

1333
01:08:18,319 --> 01:08:24,367
是啊所以所以有2英寸一个

1334
01:08:22,013 --> 01:08:26,722
这是我居然回答都 

1335
01:08:24,799 --> 01:08:28,520
现在，如果一个是什么，如果有一些 

1336
01:08:26,839 --> 01:08:32,960
负值或者什么，如果最低 

1337
01:08:28,052 --> 01:08:35,120
数字是5700右以及怎样对 

1338
01:08:32,096 --> 01:08:37,181
通常做的就是把一些偏见， 你会 

1339
01:08:36,002 --> 01:08:42,121
加上或减去某个值，以 使 

1340
01:08:38,081 --> 01:08:43,085
第一种情况是在值 0，这就是 

1341
01:08:42,319 --> 01:08:46,040
它处理你知道 那些只是 

1342
01:08:43,085 --> 01:08:47,150
完全超出 范围 ，而另一个是 

1343
01:08:46,004 --> 01:08:51,047
如果它是一个非常大的传播

1344
01:08:48,005 --> 01:08:53,344
值和相对稀疏多少 

1345
01:08:51,047 --> 01:08:56,093
你使用它，有 它会恢复 

1346
01:08:53,839 --> 01:08:58,864
到FL代码和编译器具有自己 

1347
01:08:56,093 --> 01:09:00,095
它是如何做这些事规则， 你 

1348
01:08:59,089 --> 01:09:03,094
可以排序的运行试验和尝试， 

1349
01:09:01,013 --> 01:09:04,972
逆向工程，因为你知道这些 

1350
01:09:03,589 --> 01:09:08,080
是 由道路上的 一切有效 的问题 

1351
01:09:05,089 --> 01:09:08,080
欣赏的 

1352
01:09:11,069 --> 01:09:16,950
好了，所以我们要通过这个来获得 

1353
01:09:14,068 --> 01:09:16,095
哦 

1354
01:09:17,029 --> 01:09:26,558
所以反正就像我说的，我认为在我的 

1355
01:09:23,259 --> 01:09:30,850
自己的经验 ，你知道的理解 

1356
01:09:26,819 --> 01:09:33,430
在条件语句可以种人物 

1357
01:09:30,085 --> 01:09:35,089
说出来 它的直观 感觉 排序 的 

1358
01:09:33,043 --> 01:09:40,066
就像你所期望的程序做什么

1359
01:09:35,089 --> 01:09:42,288
而switch语句 也许是 

1360
01:09:40,066 --> 01:09:48,127
意想不到的是一种方式做一些事情 

1361
01:09:43,089 --> 01:09:50,160
这不是完全 明显，但随后 

1362
01:09:49,027 --> 01:09:53,038
当你想想看，欣赏 

1363
01:09:50,799 --> 01:09:55,270
它它实际上它给你一个很好的 

1364
01:09:53,038 --> 01:09:57,043
你再知道性能提升

1365
01:09:55,027 --> 01:10:02,044
该算法跳转表使它 

1366
01:09:57,043 --> 01:10:03,142
所以这是一个固定的时间常数 

1367
01:10:02,044 --> 01:10:06,112
步数来得到 你需要的地方 

1368
01:10:04,042 --> 01:10:10,341
在switch语句 如果你只是 

1369
01:10:07,012 --> 01:10:12,013
得到它的线性一个接一个，然后 

1370
01:10:10,719 --> 01:10:14,160
这将是 线性的 时间，你会 

1371
01:10:12,013 --> 01:10:16,102
希望你知道，如果一切都 

1372
01:10:14,016 --> 01:10:20,083
均匀， 平均约 你 怎么 会 

1373
01:10:17,002 --> 01:10:23,005
大约一半的平均，如果 

1374
01:10:20,083 --> 01:10:24,972
你如果是稀疏，你会看到它会

1375
01:10:23,005 --> 01:10:28,048
设立条件句的树，以便它可以 

1376
01:10:25,719 --> 01:10:30,850
做对数 时间，所以无论什么 

1377
01:10:28,048 --> 01:10:32,307
它会比你得到的只是什么更好 

1378
01:10:30,085 --> 01:10:34,146
在毛毯的明显形式只见 

1379
01:10:32,739 --> 01:10:35,460
在这里的一个问题

1380
01:10:36,849 --> 01:10:43,190
那么好消息 是，我不 成立 

1381
01:10:40,909 --> 01:10:45,961
跳树编译器设置到跳 

1382
01:10:43,019 --> 01:10:48,118
树的权利，但如果你问我是否 

1383
01:10:46,429 --> 01:10:50,530
是一个编译器我将如何建立

1384
01:10:48,289 --> 01:10:53,210
跳树权这是一个很好的 问题 

1385
01:10:50,053 --> 01:10:54,562
如果你知道二进制搜索正确的

1386
01:10:53,021 --> 01:10:56,105
你已经有了一个范围值，你 的 

1387
01:10:55,039 --> 01:11:00,055
接你比较它 的中间值 

1388
01:10:57,005 --> 01:11:03,694
它要么少，或者它大于或 

1389
01:11:00,199 --> 01:11:05,272
平等的，如果它比你少的排序 

1390
01:11:03,739 --> 01:11:06,748
递归处理一组，如果 

1391
01:11:05,929 --> 01:11:10,340
这是更大的其他帽子 那 

1392
01:11:07,639 --> 01:11:12,050
正是这些树看起来像这样 

1393
01:11:10,034 --> 01:11:13,123
他们是平衡二叉树和 

1394
01:11:12,005 --> 01:11:15,784
他们正在采取的事实的优点： 

1395
01:11:13,429 --> 01:11:18,490
在--see这是不正确的 所有 

1396
01:11:15,829 --> 01:11:21,170
语言，所有的情况下， 

1397
01:11:19,039 --> 01:11:24,130
你看我们的条件

1398
01:11:21,017 --> 01:11:26,596
他们确定的常数时， 

1399
01:11:24,949 --> 01:11:29,047
编译器做这些编译 

1400
01:11:26,749 --> 01:11:31,750
是恒定值，以确保可以进行排序

1401
01:11:29,929 --> 01:11:32,983
他们找出 有多少是什么 

1402
01:11:31,849 --> 01:11:35,863
值的范围，从而有决定 

1403
01:11:33,469 --> 01:11:41,503
哪个版本要 做到这一点，并生成 

1404
01:11:35,989 --> 01:11:44,210
代码的其他问题等等这些都是

1405
01:11:41,809 --> 01:11:47,380
所有的好， 这是一个非常好的问题 

1406
01:11:44,021 --> 01:11:49,076
所以，您 开始 思考 

1407
01:11:47,038 --> 01:11:50,737
你知道 它是 计算机 的方式 

1408
01:11:49,076 --> 01:11:52,245
科学家 应该思考的是如何做的你 

1409
01:11:51,079 --> 01:11:55,670
采取一些想法，我见过的一个案例 

1410
01:11:52,929 --> 01:11:57,952
以及如何处理条件X1和 

1411
01:11:55,067 --> 01:12:01,067
条件Y，你知道会发生什么

1412
01:11:58,159 --> 01:12:03,920
这一点，也 正是我们做什么，我们的排序 

1413
01:12:01,067 --> 01:12:05,132
我们是 用一个简单的 从来都是不快乐 

1414
01:12:03,092 --> 01:12:07,021
解释我们要了解我们 

1415
01:12:06,032 --> 01:12:10,731
实际上可以实现它作为一个程序 

1416
01:12:07,849 --> 01:12:10,866
如果我们不得不这么做 

1417
01:12:12,073 --> 01:12:19,157
某某只是一般 主 

1418
01:12:19,019 --> 01:12:24,095
你看到的是， 有一个相当 

1419
01:12:20,057 --> 01:12:26,063
有限 的锦囊 为其 

1420
01:12:24,095 --> 01:12:30,100
程序执行条件 

1421
01:12:27,017 --> 01:12:35,099
构建你见过三个基本 

1422
01:12:31,000 --> 01:12:38,006
一种是使用条件跳转到 

1423
01:12:35,099 --> 01:12:41,102
代码另一个 的 不同 部分 

1424
01:12:38,006 --> 01:12:44,063
使用条件的情绪 ;三是 

1425
01:12:42,002 --> 01:12:48,083
使用这个跳转表的想法和那些 

1426
01:12:45,017 --> 01:12:52,040
真的是把一点点 做 

1427
01:12:48,083 --> 01:12:54,137
程序考虑 所有有和 

1428
01:12:52,004 --> 01:12:58,055
你在程序中看到其他的东西 

1429
01:12:55,037 --> 01:13:01,096
那种改变流动 

1430
01:12:58,091 --> 01:13:05,099
什么得到执行的执行或全部

1431
01:13:01,096 --> 01:13:06,104
内置了这些基本图元和 

1432
01:13:05,099 --> 01:13:10,106
这是一般不错 ，我们所看到的 

1433
01:13:07,076 --> 01:13:13,076
就是当你从机器的C ^码去 

1434
01:13:11,069 --> 01:13:16,112
代码， 你 经常要一种部件 

1435
01:13:13,076 --> 01:13:20,113
一起各种低级别的指令

1436
01:13:17,012 --> 01:13:21,013
实现一些更高级别的结构

1437
01:13:21,071 --> 01:13:27,113
所以我们在不同的都看到了这些 

1438
01:13:24,005 --> 01:13:30,026
形成结石和下一次再说吧 

1439
01:13:28,013 --> 01:13:33,019
有关程序和，你可以

1440
01:13:30,071 --> 01:13:36,125
想象一下，因为 它 相当大话题 

1441
01:13:33,019 --> 01:13:39,070
值得一个整个程序非常 好 

1442
01:13:37,025 --> 01:13:39,070
好 谢谢 

