1
00:00:01,001 --> 00:00:09,084
okay let's continue on in our coverage

2
00:00:05,879 --> 00:00:13,320
of machine level programming ii and i

3
00:00:09,084 --> 00:00:14,213
think a six part series as i mentioned

4
00:00:13,032 --> 00:00:16,119
yesterday machine level programming is

5
00:00:14,969 --> 00:00:19,740
sort of the core of this course that it

6
00:00:17,019 --> 00:00:22,080
gives you a set of tools and

7
00:00:19,074 --> 00:00:23,453
understanding that take you well beyond

8
00:00:22,008 --> 00:00:26,477
what years to the average

9
00:00:24,119 --> 00:00:29,130
run-of-the-mill of programmer or

10
00:00:27,269 --> 00:00:31,800
software developer would would know

11
00:00:29,013 --> 00:00:33,110
about and it's very powerful in terms of

12
00:00:31,008 --> 00:00:38,022
your better understanding of the system

13
00:00:34,001 --> 00:00:41,067
what goes wrong of why why programs

14
00:00:38,094 --> 00:00:42,096
crash what the meaning of those are and

15
00:00:41,076 --> 00:00:45,141
so it's a fairly core part of the

16
00:00:43,014 --> 00:00:50,043
material as you know the data web is due

17
00:00:46,041 --> 00:00:51,830
tonight and the next way about is called

18
00:00:50,043 --> 00:00:55,107
the bomb lab and I believe that's coming

19
00:00:52,199 --> 00:00:58,710
out tonight as well so the bomb lab will

20
00:00:56,007 --> 00:01:01,014
rely on your ability to understand

21
00:00:58,071 --> 00:01:02,166
machine level code so the these two

22
00:01:01,077 --> 00:01:04,158
lectures will actually be enough to get

23
00:01:03,066 --> 00:01:07,143
you started on some of the earlier parts

24
00:01:05,058 --> 00:01:10,134
of that lab you'll learn a lot more at

25
00:01:08,043 --> 00:01:13,071
recitation on Monday either in person or

26
00:01:11,034 --> 00:01:16,086
if you're viewing the recorded version

27
00:01:13,071 --> 00:01:18,620
of that that will help you move along on

28
00:01:16,086 --> 00:01:20,154
bomb web like all the labs in this

29
00:01:19,259 --> 00:01:23,700
course at least the first two we give

30
00:01:21,054 --> 00:01:24,953
you a fair amount of time for them but

31
00:01:23,007 --> 00:01:28,026
don't be fooled into thinking that means

32
00:01:25,439 --> 00:01:31,530
you can just slack off or work on other

33
00:01:28,089 --> 00:01:33,138
courses and then the last few moments

34
00:01:31,053 --> 00:01:35,852
jump in and finish this grab the bomb

35
00:01:34,038 --> 00:01:38,109
lab once you get the hang of what you're

36
00:01:36,329 --> 00:01:41,520
doing it's pretty of you can just kind

37
00:01:39,009 --> 00:01:44,103
of crank along but there's a certain

38
00:01:41,052 --> 00:01:46,113
learning curve that will take you to

39
00:01:45,003 --> 00:01:49,882
even get started on it effectively so

40
00:01:47,013 --> 00:01:49,792
don't put it off

41
00:01:52,048 --> 00:01:54,051
ah

42
00:01:55,093 --> 00:02:00,102
um oh is this

43
00:02:11,038 --> 00:02:15,080
so last time we introduced the very

44
00:02:14,003 --> 00:02:18,005
basic principles of machine level

45
00:02:15,008 --> 00:02:20,012
programming the idea of there being

46
00:02:18,005 --> 00:02:23,012
special states that you have access to

47
00:02:20,084 --> 00:02:25,139
the registers which people came after

48
00:02:23,075 --> 00:02:29,314
class nestor register is part of memory

49
00:02:26,039 --> 00:02:31,070
no are they part of the cache no through

50
00:02:29,989 --> 00:02:34,042
special they're different they don't

51
00:02:31,007 --> 00:02:35,015
exist to a sea level program when you're

52
00:02:34,519 --> 00:02:37,597
programming and see you don't have any

53
00:02:35,078 --> 00:02:39,086
visibility into them and in general

54
00:02:38,299 --> 00:02:43,010
today what we're going to do then is go

55
00:02:40,058 --> 00:02:43,139
beyond the sort of very basics and start

56
00:02:43,001 --> 00:02:47,042
talking about the control how you

57
00:02:44,039 --> 00:02:49,043
control the flow of execution of

58
00:02:47,042 --> 00:02:52,043
instructions in a at the machine level

59
00:02:49,079 --> 00:02:54,112
and how you use those techniques to

60
00:02:52,043 --> 00:02:57,116
implement basic constructs conditional

61
00:02:55,012 --> 00:02:59,941
statements loops and switch statements

62
00:02:58,016 --> 00:03:01,112
and then next time we'll talk about

63
00:03:00,049 --> 00:03:07,640
procedures which weren't a whole lecture

64
00:03:02,012 --> 00:03:10,070
of its own so that x86 and several

65
00:03:07,064 --> 00:03:14,078
machines of its generation have these

66
00:03:10,007 --> 00:03:16,031
curious little of one bit flags that are

67
00:03:14,078 --> 00:03:19,090
called condition codes and they're the

68
00:03:16,094 --> 00:03:24,113
basis of how conditional operations work

69
00:03:19,009 --> 00:03:25,067
so to a machine level programmer then we

70
00:03:25,013 --> 00:03:32,014
talked last time that you have

71
00:03:26,048 --> 00:03:35,093
visibility of the set of registers and a

72
00:03:32,023 --> 00:03:37,432
and the memory but you also have more

73
00:03:35,093 --> 00:03:38,099
things and this is only a partial list

74
00:03:37,639 --> 00:03:42,661
actually there's more and more stuff

75
00:03:39,053 --> 00:03:45,412
that you can add to this picture but we

76
00:03:42,859 --> 00:03:49,956
talked about in the 64-bit x86 64

77
00:03:45,889 --> 00:03:55,970
there's now 16 registers 8 of which have

78
00:03:50,829 --> 00:03:58,760
names that are historic based on old x86

79
00:03:55,097 --> 00:03:59,986
stuff and 68 of which were introduced

80
00:03:58,076 --> 00:04:03,167
and so they simply named name those are

81
00:04:00,859 --> 00:04:06,380
8 through our 15 and of these registers

82
00:04:04,067 --> 00:04:09,226
for the most part the only one that's

83
00:04:06,038 --> 00:04:11,647
really special is RSP it's the stack

84
00:04:09,829 --> 00:04:14,848
pointer it tells you where and we'll

85
00:04:11,989 --> 00:04:17,044
learn a lot more about stacks starting

86
00:04:15,019 --> 00:04:18,103
next time but it's sort of where the

87
00:04:17,539 --> 00:04:20,690
most the

88
00:04:18,859 --> 00:04:24,862
the state is that manages the execution

89
00:04:20,069 --> 00:04:26,096
of procedures and so you can't just use

90
00:04:24,889 --> 00:04:30,910
that or set it in arbitrary ways but the

91
00:04:26,096 --> 00:04:31,180
other ones you more or less come in with

92
00:04:31,099 --> 00:04:35,240
qualifications for that statement

93
00:04:32,008 --> 00:04:36,053
there's another register that they call

94
00:04:35,024 --> 00:04:41,111
the our IP which has nothing to do with

95
00:04:37,025 --> 00:04:45,154
death it means that the IP means

96
00:04:42,011 --> 00:04:47,108
instruction pointer in ia32 is called a

97
00:04:45,379 --> 00:04:50,445
IP and now it's called our IP just like

98
00:04:48,008 --> 00:04:54,056
the registries to be EAX now it's our IX

99
00:04:51,039 --> 00:04:56,098
so it all it contains is the address of

100
00:04:54,056 --> 00:05:00,137
the currently executing instruction and

101
00:04:56,629 --> 00:05:03,590
you can it's not a register that you

102
00:05:01,037 --> 00:05:05,081
access in a normal way but you actually

103
00:05:03,059 --> 00:05:07,103
there are tricks that you can find out

104
00:05:05,081 --> 00:05:10,720
what the value of that is so that just

105
00:05:08,003 --> 00:05:12,056
tells you where in the program what part

106
00:05:11,449 --> 00:05:14,780
of the program is currently being

107
00:05:12,056 --> 00:05:15,149
executed and then there's these things

108
00:05:14,078 --> 00:05:17,081
that are called condition codes and

109
00:05:16,049 --> 00:05:20,102
we're only showing four there's actually

110
00:05:18,008 --> 00:05:24,247
more like eight of them but not relevant

111
00:05:21,002 --> 00:05:27,065
to our general discussion that are all

112
00:05:24,319 --> 00:05:30,110
one bit flags and they get set not

113
00:05:27,065 --> 00:05:31,924
directly but as a side effect of other

114
00:05:30,011 --> 00:05:34,560
operations that take place and they're

115
00:05:32,509 --> 00:05:38,515
the basis for which conditional

116
00:05:34,659 --> 00:05:41,090
operation gets decided so let's go

117
00:05:38,569 --> 00:05:42,622
through what those mean and there

118
00:05:41,009 --> 00:05:44,698
they're given names but these names are

119
00:05:43,099 --> 00:05:49,105
actually useful to memorize what they

120
00:05:44,779 --> 00:05:50,836
mean so CF means the carry flag and that

121
00:05:49,159 --> 00:05:53,810
if you think of adding two numbers think

122
00:05:51,349 --> 00:05:56,365
of them as two unsigned numbers and you

123
00:05:53,081 --> 00:05:58,690
do the binary arithmetic and sometimes

124
00:05:56,509 --> 00:06:01,528
an extra one pops out of the left hand

125
00:05:59,419 --> 00:06:04,480
side right that's the carry bit if you

126
00:06:01,699 --> 00:06:10,550
the numbers you added sort of were too

127
00:06:05,029 --> 00:06:12,650
big to be contained in the the 32 or 64

128
00:06:10,055 --> 00:06:15,056
bit or even sixteen or eight that result

129
00:06:12,065 --> 00:06:18,152
and so an extra bit was generated that's

130
00:06:15,056 --> 00:06:22,124
called the carry bit the zero flag is

131
00:06:19,052 --> 00:06:25,411
what it sounds like it's set if the the

132
00:06:23,024 --> 00:06:26,953
value you just computed is zero these

133
00:06:25,879 --> 00:06:29,220
are set typically by arithmetic

134
00:06:27,169 --> 00:06:31,530
instructions by the way

135
00:06:29,022 --> 00:06:34,107
the sign flag is said if the value just

136
00:06:31,053 --> 00:06:36,057
computed as a 1 and the most significant

137
00:06:35,007 --> 00:06:42,009
bit meaning it's a negative value and

138
00:06:36,093 --> 00:06:43,185
the ole flag overflow flag is a tooth

139
00:06:42,009 --> 00:06:47,016
compliment version of overflow so in

140
00:06:44,085 --> 00:06:49,134
particular if you remember from data web

141
00:06:47,016 --> 00:06:53,034
how do you know us if addition of two

142
00:06:50,034 --> 00:06:55,050
values is overflowed it's if the signs

143
00:06:53,034 --> 00:06:56,097
of the operands are the same but the

144
00:06:55,005 --> 00:06:56,094
sign of the result is different than

145
00:06:56,097 --> 00:06:58,164
that

146
00:06:57,039 --> 00:07:01,116
so either you added two positive numbers

147
00:06:59,064 --> 00:07:03,126
and got a negative result that was a

148
00:07:02,016 --> 00:07:05,115
positive overflow or you added two

149
00:07:04,026 --> 00:07:08,052
negative numbers and got a negative

150
00:07:06,015 --> 00:07:11,016
result that's negative overflow

151
00:07:08,052 --> 00:07:14,145
you can't overflow up the two arguments

152
00:07:11,016 --> 00:07:18,018
are of opposite signs right so those

153
00:07:15,045 --> 00:07:21,123
four flags get set as the sort of normal

154
00:07:18,018 --> 00:07:25,026
activity by many of the instructions not

155
00:07:22,023 --> 00:07:26,112
by our friend the le.a instruction which

156
00:07:25,026 --> 00:07:29,064
I mentioned is kind of a quirky

157
00:07:27,012 --> 00:07:34,044
instruction that GCC really likes a lot

158
00:07:29,064 --> 00:07:35,073
and you'll see it in a lot of places but

159
00:07:34,044 --> 00:07:38,106
in general and most of the time those

160
00:07:36,054 --> 00:07:42,075
flags get completely ignored because who

161
00:07:39,006 --> 00:07:44,007
cares right a but they do show up at

162
00:07:42,075 --> 00:07:48,081
various points when you're doing

163
00:07:44,007 --> 00:07:51,084
conditional operations so there's some

164
00:07:49,035 --> 00:07:53,040
special instructions whose only effect

165
00:07:51,084 --> 00:07:54,183
is to set condition codes and the one

166
00:07:53,085 --> 00:07:58,089
that you'll see is especially it's

167
00:07:55,083 --> 00:08:00,114
called compare CMP and by the way the

168
00:07:59,025 --> 00:08:02,097
the queue at the end of these is all

169
00:08:01,014 --> 00:08:09,042
just a reflection of their operating on

170
00:08:02,097 --> 00:08:10,116
64-bit words quadword as I said so the

171
00:08:09,042 --> 00:08:14,073
comparison is sort of like a subtraction

172
00:08:11,016 --> 00:08:16,073
instruction except that you don't you

173
00:08:14,073 --> 00:08:18,168
don't do anything with the result

174
00:08:16,073 --> 00:08:22,131
normal subtraction instruction is like X

175
00:08:19,068 --> 00:08:24,099
minus equals y it will read two numbers

176
00:08:23,031 --> 00:08:28,038
but then it will store the result

177
00:08:24,099 --> 00:08:29,133
wherever X is stored but compare just

178
00:08:29,001 --> 00:08:32,079
takes these two values does a

179
00:08:30,033 --> 00:08:34,110
subtraction and doesn't do anything with

180
00:08:32,079 --> 00:08:38,114
the result but it will set it's these

181
00:08:35,001 --> 00:08:39,005
four condition flags and

182
00:08:39,095 --> 00:08:44,117
just a few things to keep in mind that

183
00:08:42,023 --> 00:08:49,121
are often will be sources of confusion

184
00:08:45,017 --> 00:08:52,028
is remember that the arguments in the

185
00:08:50,021 --> 00:08:55,058
way we write them in machine code is the

186
00:08:52,028 --> 00:08:57,053
opposite of what you'd expect by the way

187
00:08:55,058 --> 00:08:59,093
I somebody asked me last time there's

188
00:08:57,053 --> 00:09:02,054
another there's sort of two dialects of

189
00:08:59,093 --> 00:09:04,106
assembly code used on x86 machines

190
00:09:02,063 --> 00:09:07,124
there's one that's used by Intel and

191
00:09:05,006 --> 00:09:11,020
Microsoft and we don't use it and then

192
00:09:08,024 --> 00:09:13,031
there's the one use that sort of used by

193
00:09:11,002 --> 00:09:15,077
Linux systems and that's the one we use

194
00:09:13,094 --> 00:09:16,169
and they're different and one of the

195
00:09:15,095 --> 00:09:19,106
quirks of them is they write their

196
00:09:17,069 --> 00:09:21,074
arguments in in different orders so it

197
00:09:20,006 --> 00:09:24,062
will drive you crazy reading trying to

198
00:09:22,019 --> 00:09:26,024
read if you're familiar with one it's

199
00:09:24,062 --> 00:09:29,105
like if you've ever tried to drive a car

200
00:09:26,069 --> 00:09:34,073
on the wrong side of the road you often

201
00:09:30,005 --> 00:09:37,076
will crash you do bad things um so

202
00:09:35,009 --> 00:09:39,095
that's just an aside that what I find by

203
00:09:37,076 --> 00:09:42,125
the way when I'm looking at code and I

204
00:09:39,095 --> 00:09:48,143
see a compare instruction I actually

205
00:09:43,025 --> 00:09:51,077
write as a comment of compare of the two

206
00:09:49,043 --> 00:09:53,126
but I flipped the order so that I'm sure

207
00:09:51,077 --> 00:09:56,144
that I sort of keep in my mind what the

208
00:09:54,026 --> 00:09:59,039
comparison was up and so these flags get

209
00:09:57,044 --> 00:10:02,060
set according to the rules of

210
00:09:59,039 --> 00:10:04,067
subtraction and so it turns out that the

211
00:10:02,006 --> 00:10:06,014
carry flag and the overflow flag you

212
00:10:04,067 --> 00:10:08,072
have to do to flip your sense of what

213
00:10:06,068 --> 00:10:10,082
happened because it's a subtraction

214
00:10:08,072 --> 00:10:16,081
rather than addition but it's the same

215
00:10:10,082 --> 00:10:18,155
general idea so that sort of shows you

216
00:10:16,081 --> 00:10:20,087
one particular one and another

217
00:10:19,055 --> 00:10:24,068
instruction that you'll see whose only

218
00:10:21,041 --> 00:10:27,041
purpose in the world is to to set

219
00:10:24,068 --> 00:10:29,069
condition flags condition codes is the

220
00:10:27,041 --> 00:10:31,049
test instruction and this is typically

221
00:10:29,078 --> 00:10:32,156
used to compare as you think it's when

222
00:10:32,021 --> 00:10:35,069
you have two values and you want to

223
00:10:33,056 --> 00:10:37,058
compare them to each other and the test

224
00:10:35,069 --> 00:10:39,071
is if you really just have one value and

225
00:10:37,076 --> 00:10:42,104
you want to see what it's like is it

226
00:10:39,089 --> 00:10:43,160
zero is it negative those are the main

227
00:10:43,004 --> 00:10:46,079
things you care about in fact that's the

228
00:10:44,006 --> 00:10:50,009
only thing you can determine but just

229
00:10:46,079 --> 00:10:52,118
because I guess they had they had sort

230
00:10:50,063 --> 00:10:52,154
of a possibility of having two arguments

231
00:10:53,018 --> 00:10:55,043
to the

232
00:10:53,054 --> 00:10:57,056
so they decided well let's to go ahead

233
00:10:55,043 --> 00:10:59,138
and do it how do you have two arguments

234
00:10:57,056 --> 00:11:02,132
to a test instruction what's and the two

235
00:11:00,038 --> 00:11:06,116
results and then test that value so what

236
00:11:03,032 --> 00:11:10,115
you typically see is a test where both

237
00:11:07,016 --> 00:11:16,019
arguments are the same so test q % RI X

238
00:11:11,015 --> 00:11:18,098
comma % RI x where so that you're just

239
00:11:16,046 --> 00:11:21,083
any register to itself and one property

240
00:11:18,098 --> 00:11:24,098
the end operation is it's what they call

241
00:11:21,083 --> 00:11:25,169
item potent adding ending two things the

242
00:11:24,098 --> 00:11:28,099
same things together gives you that same

243
00:11:26,069 --> 00:11:28,072
time

244
00:11:30,007 --> 00:11:37,016
so we can see these and now so I told

245
00:11:36,041 --> 00:11:39,077
you that's how the condition codes get

246
00:11:37,079 --> 00:11:41,084
set now how do you actually read them

247
00:11:39,077 --> 00:11:43,118
how do you make use of them well there's

248
00:11:41,084 --> 00:11:45,092
two in principle you can actually

249
00:11:44,018 --> 00:11:49,085
extract and get the condition code

250
00:11:46,064 --> 00:11:51,110
values directly out of this special

251
00:11:49,085 --> 00:11:53,183
status register but that's very unusual

252
00:11:52,001 --> 00:11:58,007
to do that what's more common is you

253
00:11:54,083 --> 00:12:00,167
either try to read it in and set a 1-bit

254
00:11:58,016 --> 00:12:04,049
flag based on the result in a reg some

255
00:12:01,067 --> 00:12:06,149
other register or you try and do a

256
00:12:04,049 --> 00:12:10,058
conditional branch so the first example

257
00:12:07,049 --> 00:12:12,068
where you try to read it in a way that

258
00:12:10,058 --> 00:12:15,007
you can make use of it is done with the

259
00:12:12,068 --> 00:12:19,076
set instruction and you'll see there's a

260
00:12:15,529 --> 00:12:22,540
whole range of set instructions of but

261
00:12:19,076 --> 00:12:24,149
their only difference is really just

262
00:12:22,054 --> 00:12:29,123
what the condition they're setting based

263
00:12:25,049 --> 00:12:33,050
on so the what a set instruction does is

264
00:12:30,023 --> 00:12:37,082
it sets a single byte of a single

265
00:12:33,005 --> 00:12:40,028
register to either 1 or 0 and the the

266
00:12:37,082 --> 00:12:43,169
basis for whether it sets it to one or

267
00:12:40,073 --> 00:12:47,078
to zero is a based on what the condition

268
00:12:44,069 --> 00:12:49,106
codes are in essence what's the what

269
00:12:47,078 --> 00:12:51,092
happened your most recent instruction

270
00:12:50,006 --> 00:12:54,104
beforehand was it an arithmetic

271
00:12:51,092 --> 00:12:57,092
instruction or a set instruction or a

272
00:12:55,004 --> 00:13:00,026
test instruction or a compare

273
00:12:57,092 --> 00:13:02,120
instruction and as you can see there's

274
00:13:00,026 --> 00:13:04,124
they're all based on some logical

275
00:13:03,002 --> 00:13:09,031
combination of these condition codes

276
00:13:05,024 --> 00:13:14,063
that correspond to what the names imply

277
00:13:09,049 --> 00:13:17,060
so for example the set s instruction is

278
00:13:14,063 --> 00:13:19,064
true if the sign flag is true meaning

279
00:13:17,006 --> 00:13:22,013
that the most recent result was negative

280
00:13:19,064 --> 00:13:25,129
and there's other ones in less than less

281
00:13:22,067 --> 00:13:28,088
than or equal to our T's complement

282
00:13:26,029 --> 00:13:30,125
comparisons and they have to take into

283
00:13:28,088 --> 00:13:33,110
consideration did the most recent result

284
00:13:31,025 --> 00:13:37,060
cause an overflow or not because that

285
00:13:34,001 --> 00:13:40,360
will affect the result of the comparison

286
00:13:37,006 --> 00:13:42,008
so that's part of the reason we tortured

287
00:13:40,459 --> 00:13:44,450
you with understanding two's complement

288
00:13:42,062 --> 00:13:45,071
arithmetic and how you compare

289
00:13:44,045 --> 00:13:48,056
dalts and making you understand the

290
00:13:46,052 --> 00:13:50,140
bit-level behavior so that you can

291
00:13:48,056 --> 00:13:53,135
understand what these instructions do

292
00:13:51,004 --> 00:13:58,082
so we're cruel but we have a reason for

293
00:13:54,035 --> 00:14:00,083
our cruelty so you say one bite how do

294
00:13:59,018 --> 00:14:02,072
you deal with one bite well here's

295
00:14:00,083 --> 00:14:03,131
another thing we didn't tell you yet and

296
00:14:02,072 --> 00:14:05,159
we're going to keep telling you more

297
00:14:04,031 --> 00:14:08,039
stuff over and over again it turns out

298
00:14:06,059 --> 00:14:11,117
for every one of these sixteen registers

299
00:14:09,011 --> 00:14:16,025
you can directly set the lowest order

300
00:14:12,017 --> 00:14:17,108
bite of it to either 0 or 1 and it won't

301
00:14:16,025 --> 00:14:20,030
affect it turns out it doesn't affect

302
00:14:18,008 --> 00:14:23,075
any of the other 7 bites of that

303
00:14:20,003 --> 00:14:31,091
register so and they all have Corky

304
00:14:23,075 --> 00:14:34,130
names the L means below in there so

305
00:14:32,018 --> 00:14:36,071
here's an example of using putting all

306
00:14:35,003 --> 00:14:41,066
this together to do something that

307
00:14:36,071 --> 00:14:43,133
vaguely useful suppose that I want a

308
00:14:41,093 --> 00:14:46,172
function GT that will take two numbers

309
00:14:44,033 --> 00:14:50,075
and compare them and set the result

310
00:14:47,072 --> 00:14:53,137
return result value of 1 if X is greater

311
00:14:50,075 --> 00:14:57,077
than Y and 0 otherwise

312
00:14:54,037 --> 00:15:01,039
and so here's the assembly code with

313
00:14:57,077 --> 00:15:00,085
some tabbing problems

314
00:15:03,032 --> 00:15:08,068
success getting bugs me or that

315
00:15:13,025 --> 00:15:16,081
I might not want to try and do this

316
00:15:27,096 --> 00:15:41,118
Oh No I will fix this later anyways it's

317
00:15:34,086 --> 00:15:42,180
not the end of the world normally an

318
00:15:42,018 --> 00:15:45,117
assembly code one thing you've noticed

319
00:15:43,008 --> 00:15:49,050
is that the instructions are indented

320
00:15:46,017 --> 00:15:52,044
via tab space and the only thing that's

321
00:15:50,022 --> 00:15:56,076
way over in the left margin or label so

322
00:15:52,044 --> 00:15:58,055
this is just sort of this what the the

323
00:15:56,076 --> 00:15:59,085
assembler is actually quite tolerant of

324
00:15:58,055 --> 00:16:03,081
formatting things but this isn't the way

325
00:16:00,066 --> 00:16:06,305
it normally looks so anyways the point

326
00:16:03,081 --> 00:16:08,142
is there's a comparing the one rule that

327
00:16:06,899 --> 00:16:11,820
you need to understand about procedure

328
00:16:09,042 --> 00:16:12,126
is isn't so the first argument is passed

329
00:16:11,082 --> 00:16:15,123
in register RDI

330
00:16:13,026 --> 00:16:17,795
and the second and register RS I and

331
00:16:16,023 --> 00:16:20,028
that if I'm going to return a result

332
00:16:18,029 --> 00:16:24,600
from a function I do that by storing it

333
00:16:20,073 --> 00:16:27,108
and register our ax before I return so

334
00:16:24,006 --> 00:16:30,021
the first instruction compares these two

335
00:16:28,008 --> 00:16:35,013
and you notice how I flip the order that

336
00:16:30,075 --> 00:16:38,076
it says RSI which is why an RD I which

337
00:16:35,013 --> 00:16:41,067
is X but when I annotate it I say X to Y

338
00:16:38,085 --> 00:16:42,150
so that I mentally am thinking in the

339
00:16:41,067 --> 00:16:45,126
order that the actual comparison is made

340
00:16:43,005 --> 00:16:47,070
rather than the way they're listed so I

341
00:16:46,026 --> 00:16:52,083
always do that when I'm looking at code

342
00:16:48,015 --> 00:16:54,066
to help me flip those two around and

343
00:16:52,083 --> 00:16:55,167
then here's our instruction so that

344
00:16:54,066 --> 00:16:58,101
compare instruction set these four

345
00:16:56,067 --> 00:17:01,125
condition code register x' and now the

346
00:16:59,001 --> 00:17:05,085
set G says now set this single byte

347
00:17:02,025 --> 00:17:09,030
register the lowest byte of our ax to Z

348
00:17:05,085 --> 00:17:13,088
1 if the reason the result was the

349
00:17:09,075 --> 00:17:17,134
comparison was greater so according to

350
00:17:13,088 --> 00:17:17,017
this this rule

351
00:17:17,087 --> 00:17:25,152
and and the effect of that was to set

352
00:17:22,089 --> 00:17:28,128
just as one bite of this eight byte

353
00:17:26,052 --> 00:17:31,131
register to either zero or one now my

354
00:17:29,028 --> 00:17:33,111
problem is that these remaining seven

355
00:17:32,031 --> 00:17:37,077
bytes have whatever happened to be there

356
00:17:34,011 --> 00:17:42,017
before and I want it to be all zeros so

357
00:17:37,077 --> 00:17:45,078
the the way it does it is a bit weird

358
00:17:42,071 --> 00:17:50,112
there's an instruction called move with

359
00:17:45,087 --> 00:17:53,091
zero extension byte too long now you get

360
00:17:51,012 --> 00:17:58,098
to know these better if with time okay

361
00:17:54,027 --> 00:18:01,101
um and what what that means is you can

362
00:17:58,098 --> 00:18:02,133
actually copy a byte from any place like

363
00:18:02,001 --> 00:18:06,093
the low order byte of some other

364
00:18:03,033 --> 00:18:09,057
register into a new register and you'll

365
00:18:06,093 --> 00:18:11,169
put put zeros to the left of it that's

366
00:18:09,057 --> 00:18:14,064
what they mean by zero extension that

367
00:18:12,069 --> 00:18:17,084
seems logical but one thing you'll

368
00:18:14,064 --> 00:18:20,076
notice is the destination here is EAX

369
00:18:17,084 --> 00:18:23,100
which you'll recall although it doesn't

370
00:18:20,076 --> 00:18:27,144
show here that's the lower 32 bits of

371
00:18:24,000 --> 00:18:32,007
register are a X and then you'd say well

372
00:18:28,044 --> 00:18:34,128
that only got me halfway there right how

373
00:18:32,007 --> 00:18:37,085
do I make sure the upper 32 bits are set

374
00:18:35,028 --> 00:18:45,084
to zero well one of the weird quirks of

375
00:18:38,048 --> 00:18:49,110
x86 64 is for any computation where the

376
00:18:45,084 --> 00:18:52,101
result is a 32-bit result it will add

377
00:18:50,001 --> 00:18:56,049
zeros to the remaining 32 bits of the

378
00:18:53,001 --> 00:18:58,008
register and it's different for example

379
00:18:56,058 --> 00:19:03,083
the byte level operations only affect

380
00:18:58,071 --> 00:19:05,079
the bikes the two byte or operations

381
00:19:03,083 --> 00:19:08,088
like what you'd have if the data type

382
00:19:06,051 --> 00:19:11,100
were short only affect those two bytes

383
00:19:08,088 --> 00:19:13,187
but the four byte instructions set the

384
00:19:12,000 --> 00:19:17,091
upper bytes to zero and that was some

385
00:19:14,087 --> 00:19:19,173
somebody at AMD and I don't know who it

386
00:19:17,091 --> 00:19:21,099
is decided this was a good idea and it

387
00:19:20,073 --> 00:19:25,074
might be a good idea but it's really

388
00:19:22,071 --> 00:19:27,126
confusing but that's something you'll

389
00:19:25,074 --> 00:19:29,103
have to just sort of remember in the

390
00:19:28,026 --> 00:19:30,115
back your mind when you see things like

391
00:19:30,003 --> 00:19:33,058
this

392
00:19:31,015 --> 00:19:35,053
so the effect of this instruction is to

393
00:19:33,058 --> 00:19:38,110
take this one bite result which is the

394
00:19:35,053 --> 00:19:41,074
lower door bite of register our ax copy

395
00:19:39,001 --> 00:19:44,038
it to the same place as it already is

396
00:19:41,074 --> 00:19:47,152
but then set the remaining seven bytes

397
00:19:44,047 --> 00:19:54,100
to zero which is what we want so you'll

398
00:19:48,052 --> 00:19:55,083
see this pattern quite often question

399
00:19:55,000 --> 00:19:59,071
got it

400
00:19:55,083 --> 00:20:01,129
okay so now that's sort of sometimes I

401
00:19:59,071 --> 00:20:04,119
want to do this I just want to get a one

402
00:20:02,029 --> 00:20:08,298
bit flag as a result of the comparison

403
00:20:05,019 --> 00:20:10,051
but more generally I want to do

404
00:20:08,559 --> 00:20:14,260
something with that information and not

405
00:20:10,051 --> 00:20:17,080
just set one bit so the simplest version

406
00:20:14,026 --> 00:20:22,042
is what about a conditional and if and

407
00:20:17,008 --> 00:20:24,387
possibly an else well that's done by

408
00:20:22,042 --> 00:20:26,134
this actually two ways to do it so we'll

409
00:20:25,179 --> 00:20:30,192
go through the sort of general purpose

410
00:20:27,034 --> 00:20:33,034
traditional way and then we'll show the

411
00:20:30,309 --> 00:20:35,530
more specialized newer way and we'll

412
00:20:33,034 --> 00:20:37,048
compare those so the traditional way is

413
00:20:35,053 --> 00:20:38,137
to use what's known as a jump

414
00:20:37,048 --> 00:20:41,113
instruction and a jump instruction

415
00:20:39,037 --> 00:20:44,038
normally instructions execute in a

416
00:20:42,013 --> 00:20:46,692
particular order just like when you're

417
00:20:44,047 --> 00:20:49,066
writing a program and you write a series

418
00:20:46,809 --> 00:20:52,450
of statements they execute one after the

419
00:20:49,066 --> 00:20:53,122
next a jump instruction is the way you

420
00:20:52,045 --> 00:20:56,104
can go from wherever you are to

421
00:20:54,022 --> 00:20:59,047
someplace else and either skip over some

422
00:20:57,004 --> 00:21:03,393
instructions or jump back to some other

423
00:20:59,047 --> 00:21:06,054
a previous position or wherever and

424
00:21:03,429 --> 00:21:08,140
there's two kinds of jumps ones that are

425
00:21:06,054 --> 00:21:10,087
unconditional where there's several

426
00:21:08,014 --> 00:21:13,075
kinds but an unconditional jump means

427
00:21:10,087 --> 00:21:14,155
when I say jump you jump but there's

428
00:21:13,075 --> 00:21:17,098
others conditional jumps that will

429
00:21:15,055 --> 00:21:18,148
actually only do that jumping if the

430
00:21:17,098 --> 00:21:20,191
condition codes are set appropriately

431
00:21:19,048 --> 00:21:23,092
and you'll see that the names of these

432
00:21:21,091 --> 00:21:24,148
jump instructions are the same as the

433
00:21:23,092 --> 00:21:27,097
set instructions with the same

434
00:21:25,048 --> 00:21:30,112
conditions so there's a variety of

435
00:21:27,097 --> 00:21:33,192
different reasons that the program may

436
00:21:31,012 --> 00:21:34,020
be given to either jump or not jump

437
00:21:37,064 --> 00:21:42,086
so I'm going to use this one example to

438
00:21:40,082 --> 00:21:46,085
show you several different versions of

439
00:21:42,086 --> 00:21:47,153
it and like everything you'll see here

440
00:21:46,085 --> 00:21:51,089
these particular programs aren't that

441
00:21:48,053 --> 00:21:56,141
useful but they illustrate ideas so

442
00:21:52,025 --> 00:21:59,072
imagine I wanted to compute the the

443
00:21:57,041 --> 00:22:02,117
difference of two values and then take

444
00:21:59,072 --> 00:22:03,080
their absolute value so there's various

445
00:22:03,017 --> 00:22:05,102
ways you could imagine doing it by the

446
00:22:04,052 --> 00:22:08,108
way I'm going to do it is decide to

447
00:22:06,002 --> 00:22:11,033
either subtract Y from X or X from Y

448
00:22:09,008 --> 00:22:14,009
depending on the relative values of

449
00:22:11,033 --> 00:22:17,096
those two and of course the astute

450
00:22:14,009 --> 00:22:20,074
observer will notice that this has

451
00:22:17,096 --> 00:22:23,102
problems if you have a team in somewhere

452
00:22:20,074 --> 00:22:24,149
if the result because there's no

453
00:22:24,002 --> 00:22:30,541
absolute value but we're not going to

454
00:22:25,049 --> 00:22:32,051
worry about that table so in other words

455
00:22:30,559 --> 00:22:35,480
I just want to say if X is greater than

456
00:22:32,051 --> 00:22:36,850
Y then I wanted to track Y from X and if

457
00:22:35,048 --> 00:22:39,140
X is less than or equal to Y I want to

458
00:22:37,309 --> 00:22:42,860
subtract X from 1 and here's the code

459
00:22:40,004 --> 00:22:44,041
for it where the blue and the red or

460
00:22:42,086 --> 00:22:48,137
color coding the different parts of it

461
00:22:44,077 --> 00:22:53,078
so here you see the compare instruction

462
00:22:49,037 --> 00:22:56,039
and again I've written them out in the

463
00:22:53,078 --> 00:22:58,133
reverse order to help me keep track of

464
00:22:56,039 --> 00:23:01,112
what the comparison is and it says I'm

465
00:22:59,033 --> 00:23:04,049
going to compare x and y and if X is

466
00:23:02,012 --> 00:23:08,051
less than or equal to Y I want to jump

467
00:23:04,049 --> 00:23:11,063
to a location specified by this label l4

468
00:23:08,051 --> 00:23:13,720
and so in general in assembly code if

469
00:23:11,063 --> 00:23:16,088
you give a name and then a colon what's

470
00:23:14,179 --> 00:23:20,179
to the left of that is called a label

471
00:23:16,088 --> 00:23:21,104
and it's just a tag that that only

472
00:23:20,179 --> 00:23:24,830
visible in the assembly code it's not

473
00:23:22,004 --> 00:23:28,012
actually in the object code that will

474
00:23:24,083 --> 00:23:31,088
later I'll be used to compute an address

475
00:23:28,012 --> 00:23:35,060
for determining that will encode what

476
00:23:32,033 --> 00:23:36,041
where this jump will actually land when

477
00:23:35,006 --> 00:23:38,965
you're looking at assembly code one of

478
00:23:37,013 --> 00:23:42,074
the features it provides is a little bit

479
00:23:39,559 --> 00:23:45,800
easier way to understand it than to look

480
00:23:42,074 --> 00:23:47,102
at addresses and so it just tells you to

481
00:23:45,008 --> 00:23:48,837
be looking at that the jump would occur

482
00:23:48,002 --> 00:23:54,511
to this position

483
00:23:49,629 --> 00:23:56,629
and what you'll see here is the in these

484
00:23:54,529 --> 00:23:57,604
two branches the blue code versus the

485
00:23:56,629 --> 00:24:03,950
red what you're doing is in one case

486
00:23:58,279 --> 00:24:07,354
subtracting Y from X here you move X

487
00:24:03,095 --> 00:24:09,110
into our ax and you subtract Y from it

488
00:24:08,029 --> 00:24:17,840
and here you do the opposite you're

489
00:24:10,001 --> 00:24:21,002
subtracting X from Y and in this case so

490
00:24:17,084 --> 00:24:23,023
in the first case you'll make the jump

491
00:24:21,011 --> 00:24:27,010
if X is less than or equal to Y you'll

492
00:24:23,779 --> 00:24:28,864
compact Y from X and you'll do a return

493
00:24:27,109 --> 00:24:32,090
and you remember that I don't have to do

494
00:24:29,629 --> 00:24:33,694
anything special to return a value back

495
00:24:32,009 --> 00:24:37,228
from a function all I have to do is

496
00:24:34,279 --> 00:24:38,344
stick it and register IX and the calling

497
00:24:37,309 --> 00:24:42,310
function will know that's where to find

498
00:24:38,929 --> 00:24:44,840
the return value so here it does a rep

499
00:24:42,409 --> 00:24:46,970
and here it does the subtraction and it

500
00:24:44,084 --> 00:24:51,523
simply does a return directly from that

501
00:24:46,097 --> 00:24:52,876
part of it so it's a pretty

502
00:24:52,279 --> 00:24:56,330
straightforward piece of code but you

503
00:24:53,749 --> 00:24:58,813
can see it's using this jumping to

504
00:24:56,033 --> 00:25:01,097
create two different parts of code that

505
00:24:59,389 --> 00:25:05,440
get executed under two different

506
00:25:01,097 --> 00:25:04,144
conditions question

507
00:25:06,077 --> 00:25:15,706
what's that I'm sorry I didn't hear you

508
00:25:11,045 --> 00:25:18,076
oh well there's a couple things one is

509
00:25:16,399 --> 00:25:22,070
you want the result to end up in our X

510
00:25:18,076 --> 00:25:24,115
right and remember the subtract

511
00:25:22,007 --> 00:25:29,746
instruction structions are just two

512
00:25:24,799 --> 00:25:32,330
argument instructions there that you

513
00:25:29,809 --> 00:25:34,640
take two values and then you the ones

514
00:25:32,033 --> 00:25:36,095
the second argument the destination

515
00:25:34,064 --> 00:25:39,103
argument you overwrite what was there

516
00:25:36,095 --> 00:25:41,171
with the new result so this is a pretty

517
00:25:39,679 --> 00:25:46,340
typical pattern you'll see of you move

518
00:25:42,071 --> 00:25:48,520
some value into a register and then you

519
00:25:46,034 --> 00:25:51,038
into our ax is very common and then you

520
00:25:49,159 --> 00:25:54,860
do some arithmetic operation with that

521
00:25:51,074 --> 00:25:57,643
register as a destination to kind of

522
00:25:54,086 --> 00:25:59,102
update it if it's like if you were

523
00:25:58,309 --> 00:26:02,870
writing and see if all the time you had

524
00:26:00,002 --> 00:26:06,391
to write sort of X plus equals something

525
00:26:02,087 --> 00:26:07,366
X minus equals and that all your

526
00:26:06,409 --> 00:26:10,450
arithmetic had to be expressed in those

527
00:26:08,149 --> 00:26:10,450
terms

528
00:26:12,075 --> 00:26:19,754
okay so it's fun to look at assembly

529
00:26:17,049 --> 00:26:23,115
code for about five minutes and then you

530
00:26:20,429 --> 00:26:26,370
get sick of it so one thing to sort of

531
00:26:24,015 --> 00:26:29,022
present these same ideas but give it in

532
00:26:26,037 --> 00:26:32,846
a little bit more abstract form is to

533
00:26:29,085 --> 00:26:34,164
write it and see but in a form of C that

534
00:26:33,179 --> 00:26:38,250
looks a lot like assembly code and in

535
00:26:35,064 --> 00:26:41,102
particular one of the features of C that

536
00:26:38,025 --> 00:26:45,099
is not generally advertised is there's a

537
00:26:42,002 --> 00:26:54,401
statement called go-to and you can put

538
00:26:45,099 --> 00:26:55,104
labels in your code and you can tell the

539
00:26:54,419 --> 00:26:58,530
program that if something happens then

540
00:26:56,049 --> 00:27:00,084
you want to jump to that part of the

541
00:26:58,053 --> 00:27:04,053
program so it looks a lot like that

542
00:27:00,084 --> 00:27:08,115
assembly code right that you saw jump jl

543
00:27:04,053 --> 00:27:11,102
e instead of what this says it's like

544
00:27:09,015 --> 00:27:14,040
i'm doing a test and then if the test is

545
00:27:12,002 --> 00:27:16,023
which in this case i call it end test

546
00:27:14,004 --> 00:27:19,047
because it's the opposite of the test

547
00:27:16,023 --> 00:27:21,114
that's in the original program and if

548
00:27:19,083 --> 00:27:23,312
that end test condition holds i want to

549
00:27:22,014 --> 00:27:27,015
jump to another part of the program i'm

550
00:27:24,059 --> 00:27:29,060
calling else and you notice i uppercase

551
00:27:27,015 --> 00:27:34,050
that because it's not the actual else of

552
00:27:29,159 --> 00:27:39,450
a an if-then-else and certainly if this

553
00:27:34,005 --> 00:27:40,934
one is well actually to be most accurate

554
00:27:39,045 --> 00:27:44,097
i should have simply said return result

555
00:27:41,429 --> 00:27:48,000
from this point this codes a little bit

556
00:27:44,097 --> 00:27:49,158
out of date so I should have said return

557
00:27:48,000 --> 00:27:52,065
result but another version would be to

558
00:27:50,058 --> 00:27:54,060
have done a goto down to here and return

559
00:27:52,065 --> 00:27:55,119
the result from there and you'll see

560
00:27:54,078 --> 00:27:58,164
different compilers generate in

561
00:27:56,019 --> 00:28:01,047
different forms so I'm going to

562
00:27:59,064 --> 00:28:04,089
typically use this way of presenting

563
00:28:01,047 --> 00:28:06,138
code just so that you can look at and

564
00:28:04,089 --> 00:28:08,172
understand what these control structures

565
00:28:07,038 --> 00:28:12,063
look like without having to sort of

566
00:28:09,072 --> 00:28:14,147
scrutinize the low-level assembly code

567
00:28:12,063 --> 00:28:14,147
instructions

568
00:28:16,013 --> 00:28:28,074
so we consider take this question yes I

569
00:28:27,012 --> 00:28:30,084
think there's a homework or practice

570
00:28:28,074 --> 00:28:32,121
problems of exactly that sort so in

571
00:28:30,084 --> 00:28:34,131
general you could do it neither way and

572
00:28:33,021 --> 00:28:36,090
why the compiler picks one versus the

573
00:28:35,031 --> 00:28:39,075
other is I think it's a completely

574
00:28:36,009 --> 00:28:42,056
arbitrary decision but consistently I

575
00:28:39,075 --> 00:28:42,137
found GCC does it this way

576
00:28:44,078 --> 00:28:51,084
okay so what sort of talking sort of

577
00:28:50,016 --> 00:28:55,023
imagine you're writing a compiler how

578
00:28:52,038 --> 00:28:57,101
would you take this special case I just

579
00:28:55,023 --> 00:29:02,025
showed and generalize it into a rule for

580
00:28:58,001 --> 00:29:05,007
compiling if-then-else expressions and

581
00:29:02,025 --> 00:29:07,077
I'm going to use the version of in see

582
00:29:05,061 --> 00:29:08,160
the question mark : version where you

583
00:29:07,077 --> 00:29:10,163
kind of encapsulate that whole

584
00:29:09,006 --> 00:29:14,007
conditional is a single expression

585
00:29:11,063 --> 00:29:16,080
rather than the statement but you can

586
00:29:14,061 --> 00:29:18,150
understand that these rules would be the

587
00:29:16,008 --> 00:29:22,059
same in either case so imagine in

588
00:29:19,005 --> 00:29:26,010
general you had a C code where there's a

589
00:29:23,031 --> 00:29:29,090
test controlling whether to return the

590
00:29:26,055 --> 00:29:33,060
result of one expression or another and

591
00:29:29,009 --> 00:29:37,014
this is what my ABS diff code would look

592
00:29:33,006 --> 00:29:41,010
like if I wrote it in that form and so

593
00:29:37,095 --> 00:29:44,097
in general what we can say is what what

594
00:29:42,000 --> 00:29:48,051
we'll do is we'll come take the test and

595
00:29:44,097 --> 00:29:57,120
tit and invert it and say if that test

596
00:29:48,051 --> 00:30:00,126
is not true then we will so if n test is

597
00:29:58,002 --> 00:30:02,091
true then we will jump to some part of

598
00:30:01,026 --> 00:30:06,090
the code where we've compiled the code

599
00:30:03,009 --> 00:30:10,014
for the else expression and if the that

600
00:30:06,009 --> 00:30:12,012
test fails here so that the original

601
00:30:10,014 --> 00:30:17,052
test condition holds then we'll stick in

602
00:30:13,002 --> 00:30:19,071
whatever code it takes to to compute the

603
00:30:17,052 --> 00:30:21,126
done expression and then we'll merge

604
00:30:19,089 --> 00:30:23,145
back together in the case you saw where

605
00:30:22,026 --> 00:30:26,043
it's just a single little function we

606
00:30:24,045 --> 00:30:28,137
can just call a rep here and get out of

607
00:30:26,043 --> 00:30:29,094
the thing but if this is one line of

608
00:30:29,037 --> 00:30:30,111
code

609
00:30:29,094 --> 00:30:32,148
then there's a whole bunch of lines

610
00:30:31,011 --> 00:30:35,049
after that typically you want to merge

611
00:30:33,048 --> 00:30:37,217
back together again and continue from

612
00:30:35,049 --> 00:30:40,868
there and so that's what this shows all

613
00:30:37,649 --> 00:30:44,690
I'll finish by going to whatever comes

614
00:30:41,309 --> 00:30:46,394
afterwards so this is a way I like to

615
00:30:45,059 --> 00:30:48,960
you know although we're not writing

616
00:30:47,159 --> 00:30:51,720
compilers in this course I think it

617
00:30:48,096 --> 00:30:53,100
helps to to think in terms of general

618
00:30:51,072 --> 00:30:57,111
rules of how a compiler would translate

619
00:30:54,036 --> 00:30:59,195
C code into assembly code so that when

620
00:30:58,011 --> 00:31:01,083
you see that assembly code you'll

621
00:30:59,519 --> 00:31:04,532
recognize these patterns and know what

622
00:31:01,083 --> 00:31:05,145
they mean question so after you go to

623
00:31:04,649 --> 00:31:11,730
the else clause doesn't like fall

624
00:31:06,045 --> 00:31:15,134
through to the John yes yes so just as

625
00:31:11,073 --> 00:31:17,157
we saw yes in general it like here it

626
00:31:15,539 --> 00:31:20,960
would fall through to the done good

627
00:31:18,057 --> 00:31:20,096
question

628
00:31:22,061 --> 00:31:26,070
okay so that's one version of

629
00:31:25,011 --> 00:31:29,090
conditional that's the most general way

630
00:31:27,051 --> 00:31:32,142
and the way it used to always be done

631
00:31:29,009 --> 00:31:34,062
but there's another approach that you'll

632
00:31:33,042 --> 00:31:38,060
see fairly common in code it's sort of

633
00:31:35,043 --> 00:31:41,112
an optimization called conditional move

634
00:31:38,006 --> 00:31:43,059
and it's bit non-intuitive from a

635
00:31:42,012 --> 00:31:46,038
software developers perspective of why

636
00:31:44,013 --> 00:31:48,042
you'd ever want to do this the basic

637
00:31:46,038 --> 00:31:50,079
idea is I'm going to compute both the

638
00:31:48,042 --> 00:31:53,043
then and the elks the values they'd

639
00:31:50,079 --> 00:31:53,160
produce and only after that I choose

640
00:31:53,043 --> 00:31:56,097
which one I use

641
00:31:54,006 --> 00:32:00,057
so it seems wasteful but it actually

642
00:31:56,097 --> 00:32:02,166
turns out to be more efficient if there

643
00:32:01,011 --> 00:32:05,088
are fairly simple computations and the

644
00:32:03,066 --> 00:32:07,071
reason of that is and we'll see a little

645
00:32:05,088 --> 00:32:09,174
bit more when we talk about performance

646
00:32:07,071 --> 00:32:13,143
optimization a modern processor is a

647
00:32:10,074 --> 00:32:17,100
little like a an oil tanker sailing in

648
00:32:14,043 --> 00:32:20,106
the sea meaning that it plows along in a

649
00:32:18,000 --> 00:32:25,053
certain direction and it really is hard

650
00:32:21,006 --> 00:32:28,050
to get it to stop or to turn so that you

651
00:32:25,053 --> 00:32:31,071
say what are you talking about but think

652
00:32:28,005 --> 00:32:33,069
of an instruction sequences you know the

653
00:32:31,071 --> 00:32:36,084
ocean of code that you're cruising

654
00:32:34,014 --> 00:32:38,085
through and these things can just fly

655
00:32:36,084 --> 00:32:41,133
through a straight sequence of code

656
00:32:38,085 --> 00:32:43,134
because they are they do what they call

657
00:32:42,033 --> 00:32:45,108
pipelining meaning they start bringing

658
00:32:44,034 --> 00:32:47,130
in parts of one instruction before

659
00:32:46,008 --> 00:32:50,040
they're done with the next and actually

660
00:32:48,003 --> 00:32:53,016
go up to depths of 20 or more

661
00:32:50,004 --> 00:32:55,095
instructions deep of how far had they're

662
00:32:53,043 --> 00:32:58,068
working to defecting forward and future

663
00:32:56,031 --> 00:33:00,108
instructions while finishing up the ones

664
00:32:58,068 --> 00:33:04,092
that still remain so that's my ocean

665
00:33:01,008 --> 00:33:06,084
line of my tanker analogy but all of a

666
00:33:04,092 --> 00:33:08,100
sudden you come and then what happens

667
00:33:06,084 --> 00:33:11,178
when they hit a branch they'll try to

668
00:33:09,072 --> 00:33:14,127
guess called branch prediction and guess

669
00:33:12,078 --> 00:33:15,174
where is this kind of branch going to go

670
00:33:15,027 --> 00:33:17,091
where you know

671
00:33:16,074 --> 00:33:19,074
well the conditional branch should be

672
00:33:17,091 --> 00:33:20,166
taken or is it going to fall through and

673
00:33:19,074 --> 00:33:23,136
they're pretty good at that they're good

674
00:33:21,066 --> 00:33:28,089
at it ninety ninety eight percent of the

675
00:33:24,036 --> 00:33:31,065
time so they can even anticipate suit it

676
00:33:28,089 --> 00:33:32,118
curves in the road my analogy is

677
00:33:31,065 --> 00:33:36,150
breaking down

678
00:33:33,018 --> 00:33:38,025
and start going in that direction and as

679
00:33:37,005 --> 00:33:41,007
long as they get it right it's very

680
00:33:38,088 --> 00:33:44,124
efficient but if they get it wrong it's

681
00:33:41,007 --> 00:33:47,079
as if you have to stop the thing back it

682
00:33:45,024 --> 00:33:51,051
up turn the other way start again and

683
00:33:48,042 --> 00:33:55,098
that can take 40 instructions 40 clock

684
00:33:51,051 --> 00:33:57,063
cycles so to do in bed situation so and

685
00:33:55,098 --> 00:33:59,130
this is pretty common if you think of

686
00:33:57,063 --> 00:34:01,161
like an absolute value can you predict

687
00:34:00,003 --> 00:34:06,048
whether a value is going to be positive

688
00:34:02,061 --> 00:34:07,134
or negative if not usually so about half

689
00:34:06,075 --> 00:34:10,137
the time whatever you guess you're going

690
00:34:08,034 --> 00:34:13,083
to guess wrong so these are conditional

691
00:34:11,037 --> 00:34:16,122
move instructions it turns out it's much

692
00:34:13,083 --> 00:34:18,105
easier to just plow through compute both

693
00:34:17,022 --> 00:34:22,053
and then at the last minute all you have

694
00:34:19,005 --> 00:34:24,060
to do is move a value into a register or

695
00:34:22,053 --> 00:34:26,432
not and that doesn't require stopping

696
00:34:24,006 --> 00:34:31,080
the whole processor and making this turn

697
00:34:26,909 --> 00:34:33,935
so that's my long explanation for and if

698
00:34:32,034 --> 00:34:35,603
you don't want to understand that I'll

699
00:34:34,169 --> 00:34:42,000
just say well just trust me it's a good

700
00:34:35,909 --> 00:34:45,510
idea sometimes so the the general

701
00:34:42,000 --> 00:34:47,085
pattern then if I use the same idea is I

702
00:34:45,051 --> 00:34:50,097
want to compute both results and I'll

703
00:34:47,085 --> 00:34:53,624
call the result and this is an eval this

704
00:34:50,097 --> 00:34:56,151
is eval the elks value I'll compute both

705
00:34:54,389 --> 00:35:00,060
of them I'll do my test and then this

706
00:34:57,051 --> 00:35:02,139
red thing imagine that's all done with a

707
00:35:00,006 --> 00:35:06,084
single instruction that says I'll copy

708
00:35:03,039 --> 00:35:08,124
the value of eval to result but only if

709
00:35:06,084 --> 00:35:12,126
a condition holds so that's why it's

710
00:35:09,024 --> 00:35:16,029
called a conditional move then we'll see

711
00:35:13,026 --> 00:35:18,027
this is the code by the way you saw my

712
00:35:16,029 --> 00:35:22,077
original version starting to have to

713
00:35:18,027 --> 00:35:26,055
jump back I had to explicitly tell the

714
00:35:22,077 --> 00:35:28,143
GCC don't put use conditional moves

715
00:35:26,055 --> 00:35:32,106
because it really wants to very badly

716
00:35:29,043 --> 00:35:35,048
and so you have to force it not to and I

717
00:35:33,006 --> 00:35:35,093
did that here

718
00:35:36,099 --> 00:35:41,148
so here's the actual code then and again

719
00:35:39,599 --> 00:35:46,260
you'll see the color coding that it's

720
00:35:42,048 --> 00:35:48,051
doing both subtractions it's actually

721
00:35:46,026 --> 00:35:51,365
doing the move and subtract move and

722
00:35:48,078 --> 00:35:52,907
subtract so it's doing both the branches

723
00:35:51,599 --> 00:35:58,050
you saw before the den and the Elks

724
00:35:53,609 --> 00:35:59,910
branch it's doing a comparison and then

725
00:35:58,005 --> 00:36:03,554
here is the conditional move instruction

726
00:35:59,091 --> 00:36:05,115
C move in this case the L here is not a

727
00:36:03,599 --> 00:36:12,810
word size it's the less than or equal to

728
00:36:06,015 --> 00:36:15,102
a direction so in the case the that I

729
00:36:12,081 --> 00:36:18,140
need the red value basically you saw the

730
00:36:16,002 --> 00:36:22,041
red value is stored in register RDX in

731
00:36:19,004 --> 00:36:26,473
that case I will copy it into the result

732
00:36:22,041 --> 00:36:29,480
register so again it's like this idea of

733
00:36:26,869 --> 00:36:32,070
just go ahead and do everything and then

734
00:36:29,849 --> 00:36:34,560
pick at the last end and the point is

735
00:36:32,007 --> 00:36:39,021
that this one instruction it looks just

736
00:36:34,056 --> 00:36:40,595
as far as for this processor execution

737
00:36:39,021 --> 00:36:44,063
that's sort of like a a move instruction

738
00:36:41,099 --> 00:36:44,630
that it's fairly straightforward to do

739
00:36:47,005 --> 00:36:50,021
okay

740
00:36:48,023 --> 00:36:52,088
so why does it do that all the time well

741
00:36:50,021 --> 00:36:56,033
there's a couple reasons one is that

742
00:36:52,088 --> 00:36:58,106
might be a really really bad idea to do

743
00:36:56,033 --> 00:37:01,040
both computations if you have to like

744
00:36:59,006 --> 00:37:03,077
crack a password in one and you know

745
00:37:02,003 --> 00:37:05,009
find the enterprise number and another

746
00:37:03,077 --> 00:37:11,078
you probably don't want to do both of

747
00:37:05,063 --> 00:37:13,127
those so in general in that case and so

748
00:37:11,087 --> 00:37:15,173
the and you'll notice GCC will only do

749
00:37:14,027 --> 00:37:18,083
this if both branches are fairly

750
00:37:16,073 --> 00:37:20,150
straightforward computations that

751
00:37:18,083 --> 00:37:23,159
they're trying to do and they sometimes

752
00:37:21,005 --> 00:37:26,009
when you just plain can't do it so for

753
00:37:24,059 --> 00:37:29,072
example if you're using a conditional to

754
00:37:26,054 --> 00:37:31,058
guard whether a pointer can be

755
00:37:29,072 --> 00:37:33,089
dereferenced or not because it's a null

756
00:37:31,058 --> 00:37:35,069
pointer potentially a null pointer then

757
00:37:33,089 --> 00:37:41,132
you really don't want to try that null

758
00:37:35,069 --> 00:37:45,071
pointer dereference just for the for as

759
00:37:42,032 --> 00:37:48,071
a way to save some time and similarly if

760
00:37:45,071 --> 00:37:50,144
if you could have a side-effect if the

761
00:37:48,071 --> 00:37:52,148
result of executing either branch could

762
00:37:51,044 --> 00:37:55,076
be to change some other part of the

763
00:37:53,048 --> 00:37:58,136
program state then you don't really want

764
00:37:55,076 --> 00:38:00,163
to do that either and so the conditional

765
00:37:59,036 --> 00:38:03,104
move only gets used then in this

766
00:38:01,063 --> 00:38:06,122
somewhat special case that you have two

767
00:38:04,004 --> 00:38:10,040
computations relatively easy to do safe

768
00:38:07,022 --> 00:38:12,029
to do no side-effects but that happens

769
00:38:10,004 --> 00:38:14,071
just often enough so this is actually a

770
00:38:12,029 --> 00:38:14,107
worthwhile thing

771
00:38:15,089 --> 00:38:21,102
okay so that gets us conditionals and

772
00:38:19,035 --> 00:38:27,068
now let's look at loops that sort of

773
00:38:22,002 --> 00:38:30,024
next step up in control structures and

774
00:38:27,068 --> 00:38:32,136
see actually has three different kinds

775
00:38:30,024 --> 00:38:34,110
of loops it has a a while loop which

776
00:38:33,036 --> 00:38:36,099
you're familiar with and a for loop

777
00:38:35,001 --> 00:38:39,024
which you're familiar with and it has a

778
00:38:36,099 --> 00:38:40,101
third one which in my whole life of

779
00:38:39,033 --> 00:38:43,062
writing and I've written a lot of C code

780
00:38:41,001 --> 00:38:46,080
in my life I've used this like about six

781
00:38:43,062 --> 00:38:47,070
times so but it turns out it's the

782
00:38:46,008 --> 00:38:50,031
simplest one to implement so we'll go

783
00:38:48,042 --> 00:38:53,091
ahead and do it so that the it's called

784
00:38:51,003 --> 00:38:57,015
the do-while loop and so the keyword is

785
00:38:53,091 --> 00:38:59,109
do and then there's some stuff you do

786
00:38:57,015 --> 00:39:02,073
that's the body of the do and then

787
00:39:00,009 --> 00:39:05,028
there's a test at the end that tells you

788
00:39:02,073 --> 00:39:06,156
whether to keep repeating this loop so

789
00:39:05,028 --> 00:39:09,030
it sort of flips the normal while loop

790
00:39:07,056 --> 00:39:10,140
you you have the conditional test at the

791
00:39:09,048 --> 00:39:16,092
front and here you have it at the end

792
00:39:11,004 --> 00:39:18,036
and so it turns out if we think in terms

793
00:39:16,092 --> 00:39:22,173
of go-to that's a pretty straightforward

794
00:39:18,072 --> 00:39:26,079
thing to replace this with a code that

795
00:39:23,073 --> 00:39:29,151
will do a test and if the test holds it

796
00:39:27,042 --> 00:39:32,058
will jump back and say okay a reacts

797
00:39:30,051 --> 00:39:36,144
acute that part of the program I was

798
00:39:32,058 --> 00:39:39,095
just in so it sets up a loop where you

799
00:39:37,044 --> 00:39:44,129
can think of it's literally a loop of

800
00:39:39,095 --> 00:39:44,129
control flow going round and round and

801
00:39:45,092 --> 00:39:49,155
by the way this is actually a semi

802
00:39:48,027 --> 00:39:53,046
useful function it's called pop count

803
00:39:50,055 --> 00:39:58,056
sometimes how many ones are there in a

804
00:39:53,046 --> 00:40:01,065
in a word of data in this case at 64-bit

805
00:39:58,056 --> 00:40:02,115
word there's been some generations of

806
00:40:01,065 --> 00:40:04,137
data web where you were required to

807
00:40:03,015 --> 00:40:10,041
write this function using all your

808
00:40:05,037 --> 00:40:13,092
favorite operations and with a fairly

809
00:40:10,041 --> 00:40:20,073
small limit on operations but we're not

810
00:40:13,092 --> 00:40:21,120
doing that today so here my point is you

811
00:40:20,073 --> 00:40:24,156
see that there's a fairly

812
00:40:22,002 --> 00:40:28,024
straightforward way of taking this

813
00:40:25,056 --> 00:40:30,091
particular loop and turning it into just

814
00:40:28,042 --> 00:40:32,065
combination of conditional that where

815
00:40:30,091 --> 00:40:34,153
you do is you jump back to where you

816
00:40:32,065 --> 00:40:35,122
were before and here's the actual code

817
00:40:35,053 --> 00:40:39,091
for it

818
00:40:36,022 --> 00:40:42,040
I won't go through all of it but you can

819
00:40:39,091 --> 00:40:43,153
believe from these annotations that it

820
00:40:42,004 --> 00:40:46,090
very closely follows the code here and

821
00:40:44,053 --> 00:40:53,071
the main thing to see is this jump if

822
00:40:47,026 --> 00:40:58,078
not equal to label l2 and that takes you

823
00:40:53,071 --> 00:41:02,140
back to here and so the general form of

824
00:40:58,078 --> 00:41:04,105
it then is you take a do and then this

825
00:41:03,004 --> 00:41:07,030
part that's called the body of the loop

826
00:41:05,005 --> 00:41:09,073
and this is the test and so now you set

827
00:41:07,066 --> 00:41:12,067
up some code where you can execute the

828
00:41:09,073 --> 00:41:17,107
body perform the test and if the test

829
00:41:12,076 --> 00:41:19,132
holds you go back to the loop so a while

830
00:41:18,007 --> 00:41:23,038
loop is really just what I could do loop

831
00:41:20,032 --> 00:41:24,106
a do while loop except that you move the

832
00:41:23,038 --> 00:41:27,076
test to the beginning and the only

833
00:41:25,006 --> 00:41:30,070
difference therefore is with a do loop

834
00:41:27,076 --> 00:41:31,144
you never you don't do the test it the

835
00:41:30,007 --> 00:41:35,031
first time through you're guaranteed to

836
00:41:32,044 --> 00:41:38,083
do it the first time no matter what

837
00:41:35,094 --> 00:41:40,156
while a while loop will explicitly test

838
00:41:38,083 --> 00:41:42,151
even at the very beginning and and skip

839
00:41:41,056 --> 00:41:46,120
over the loop if the condition doesn't

840
00:41:43,051 --> 00:41:48,097
hold so there's two ways to generate a

841
00:41:47,002 --> 00:41:50,095
code whether there's more than two ways

842
00:41:48,097 --> 00:41:52,132
to generate code for a while loop but

843
00:41:51,013 --> 00:41:56,014
you'll find GCC of two uses two

844
00:41:53,032 --> 00:41:59,080
different ways one is what we'll find

845
00:41:56,023 --> 00:42:01,060
when we use this optimization setting I

846
00:41:59,008 --> 00:42:05,014
talked about last time called minus

847
00:42:01,006 --> 00:42:07,093
capital o stands for optimized aji which

848
00:42:05,086 --> 00:42:11,143
means debug of course as you've already

849
00:42:08,047 --> 00:42:16,048
know there's some history to what the

850
00:42:12,043 --> 00:42:17,116
minus G flags means so and as I

851
00:42:16,057 --> 00:42:19,135
mentioned last time this turns out to be

852
00:42:18,016 --> 00:42:22,045
the perfect level of optimization for

853
00:42:20,035 --> 00:42:24,049
this course where you want to be able to

854
00:42:22,045 --> 00:42:26,137
look at machine code and understand it

855
00:42:24,049 --> 00:42:28,126
and how it relates to the C code because

856
00:42:27,037 --> 00:42:31,048
it does some sort of simple

857
00:42:29,026 --> 00:42:32,098
optimizations but it doesn't try to

858
00:42:31,048 --> 00:42:36,064
rewrite your whole program to make it

859
00:42:32,098 --> 00:42:37,123
run better whereas even with minus o 1

860
00:42:36,064 --> 00:42:40,117
which is the next level in the

861
00:42:38,023 --> 00:42:41,115
optimization you'll find sometimes it

862
00:42:41,017 --> 00:42:47,052
will do some pretty cool

863
00:42:42,015 --> 00:42:49,038
stuff but when you actually as a program

864
00:42:47,052 --> 00:42:51,099
developer as a software developer out

865
00:42:49,038 --> 00:42:53,100
there or you talk to companies and yes

866
00:42:51,099 --> 00:42:56,145
what optimization level do you use

867
00:42:54,000 --> 00:43:01,349
they'll probably say - OH - that's sort

868
00:42:57,045 --> 00:43:03,194
of the common point so usually there's

869
00:43:01,349 --> 00:43:05,490
higher levels optimization and we're

870
00:43:03,599 --> 00:43:08,220
purposely backing off from that to make

871
00:43:05,049 --> 00:43:11,618
this code easier to understand so

872
00:43:08,022 --> 00:43:14,027
anyways with the default optimization

873
00:43:12,059 --> 00:43:16,157
we're using for this course it does a

874
00:43:14,072 --> 00:43:18,147
transformation I call the jump to middle

875
00:43:17,039 --> 00:43:21,240
translation these are by the way my own

876
00:43:19,047 --> 00:43:26,896
names you won't find them in any other

877
00:43:21,024 --> 00:43:29,603
document but with the idea of it is

878
00:43:27,319 --> 00:43:31,415
imagine again I have a while loop of

879
00:43:29,819 --> 00:43:34,920
this form where there's a test in the

880
00:43:32,279 --> 00:43:36,690
body to execute well what out the

881
00:43:34,092 --> 00:43:38,127
problem I have to do compared to before

882
00:43:36,069 --> 00:43:41,468
is some I've to execute the test before

883
00:43:39,027 --> 00:43:43,125
I start the first iteration of the loop

884
00:43:42,089 --> 00:43:48,210
so the way I'll do it here is I'll just

885
00:43:44,025 --> 00:43:50,118
jump to the middle of the what was the

886
00:43:48,021 --> 00:43:53,600
old loop code to the test portion of

887
00:43:51,018 --> 00:43:56,177
that loop and then let that test

888
00:43:53,789 --> 00:44:01,796
determine whether I actually enter the

889
00:43:56,339 --> 00:44:08,460
loop itself and so this is an example of

890
00:44:01,859 --> 00:44:10,680
a go to a code version of my pop count

891
00:44:08,046 --> 00:44:14,645
function so I've written a pop count

892
00:44:10,068 --> 00:44:16,427
function using a while loop this time it

893
00:44:15,059 --> 00:44:18,113
turns out whether you do or a while loop

894
00:44:17,039 --> 00:44:24,660
you'll get the same result in this

895
00:44:18,599 --> 00:44:27,644
particular function and and you'll see

896
00:44:24,066 --> 00:44:30,120
the way it looks is it it jumped to the

897
00:44:28,049 --> 00:44:33,104
test portion of the code and and then if

898
00:44:31,002 --> 00:44:36,009
that holds it then actually starts in

899
00:44:33,599 --> 00:44:37,920
the first execution of the loop and then

900
00:44:36,027 --> 00:44:41,366
from there on it looks the same as the

901
00:44:37,092 --> 00:44:43,125
do-while loop it just does the what was

902
00:44:41,609 --> 00:44:46,640
in the loop does the test jumps back to

903
00:44:44,025 --> 00:44:46,064
the beginning

904
00:44:48,041 --> 00:44:52,080
although and then there's a second

905
00:44:50,579 --> 00:44:55,440
method which is in some ways more

906
00:44:52,008 --> 00:44:57,527
traditional and you'll find that if you

907
00:44:55,044 --> 00:45:01,053
use optimization one which is a fairly

908
00:44:58,319 --> 00:45:03,930
useful thing to do in practice so just

909
00:45:01,053 --> 00:45:05,055
to show you that instead of deciding

910
00:45:03,093 --> 00:45:09,093
which one I was going to show you I

911
00:45:05,055 --> 00:45:12,060
decided to show you both and the idea of

912
00:45:09,093 --> 00:45:14,097
that is to do it essentially to take a

913
00:45:13,005 --> 00:45:17,097
while loop and turn it into do-while

914
00:45:14,097 --> 00:45:20,696
loop but introducing a conditional

915
00:45:17,097 --> 00:45:23,172
beforehand that would essentially guard

916
00:45:21,569 --> 00:45:28,260
your entrance to the loop so you do an

917
00:45:24,072 --> 00:45:28,961
initial test and if that false then you

918
00:45:28,026 --> 00:45:31,125
skip over the loop all together

919
00:45:29,609 --> 00:45:36,690
otherwise it's performed like a do-while

920
00:45:32,025 --> 00:45:38,144
loop and so that has a fairly

921
00:45:36,069 --> 00:45:40,071
straightforward translation into code

922
00:45:38,369 --> 00:45:43,500
and that again it looks a little

923
00:45:40,071 --> 00:45:46,092
different from before that it has an

924
00:45:43,005 --> 00:45:49,114
initial test but then it looks like a

925
00:45:46,092 --> 00:45:48,781
do-while loop

926
00:45:50,092 --> 00:45:54,190
and so I won't show you the assembly

927
00:45:52,009 --> 00:45:58,448
versions of those but if you if you look

928
00:45:55,009 --> 00:46:01,020
at it actually the code is all in

929
00:45:59,339 --> 00:46:05,650
directories that are linked to your

930
00:46:02,001 --> 00:46:07,015
class directory to the class webpage so

931
00:46:05,065 --> 00:46:09,070
you can actually look at the code and

932
00:46:07,015 --> 00:46:13,051
you'll see that it follows exactly the

933
00:46:09,007 --> 00:46:18,025
way I'm describing it and then a third

934
00:46:13,051 --> 00:46:21,058
kind of loop is the for loop which in C

935
00:46:18,088 --> 00:46:23,095
is actually a very powerful very general

936
00:46:22,021 --> 00:46:27,066
type of thing and so it's very commonly

937
00:46:23,095 --> 00:46:29,664
used but you can see that the for loop

938
00:46:27,066 --> 00:46:33,118
has four components to it has an

939
00:46:30,519 --> 00:46:37,180
initialization as a test has a rule for

940
00:46:34,018 --> 00:46:39,117
doing an update in case as a way to

941
00:46:37,018 --> 00:46:41,044
continue the loop and then it has the

942
00:46:39,279 --> 00:46:45,400
body of the loop and so here's the

943
00:46:41,044 --> 00:46:47,116
version of my pop calc function where

944
00:46:45,004 --> 00:46:52,078
I'm just going through all the bits in

945
00:46:48,016 --> 00:46:55,098
the word extracting them out and adding

946
00:46:53,014 --> 00:47:00,663
them accumulating them to be the result

947
00:46:55,098 --> 00:47:03,100
so ripping apart this for you'll see

948
00:47:00,789 --> 00:47:05,841
that these four blocks of of the loop

949
00:47:04,000 --> 00:47:09,007
corresponds the initialization is to set

950
00:47:06,309 --> 00:47:13,900
equal to zero the test is to compare I

951
00:47:09,007 --> 00:47:17,856
to the word size which I've set here to

952
00:47:13,009 --> 00:47:20,418
be eight ton so however many bytes are

953
00:47:18,549 --> 00:47:24,549
in an int multiply that by 8 to get the

954
00:47:21,309 --> 00:47:26,950
word size and then the update is I plus

955
00:47:24,549 --> 00:47:31,500
plus and then the body is this stuff

956
00:47:26,095 --> 00:47:34,144
that's within the brackets here so I can

957
00:47:31,005 --> 00:47:39,564
think of that in general one one general

958
00:47:35,044 --> 00:47:43,117
way to think about a for loop and see is

959
00:47:40,059 --> 00:47:49,155
by this rule that will turn a for loop

960
00:47:44,017 --> 00:47:52,896
into a while loop and so what it says is

961
00:47:50,019 --> 00:47:56,118
I first do the initialization and then I

962
00:47:53,049 --> 00:48:01,210
do a loop where I I guard it with this

963
00:47:57,009 --> 00:48:04,240
test and then what I keep doing is

964
00:48:01,021 --> 00:48:04,088
executing the body and then performing

965
00:48:04,024 --> 00:48:06,113
whatever

966
00:48:04,088 --> 00:48:09,187
date there is and then continuing with

967
00:48:07,013 --> 00:48:13,372
the test so that sort of the semantics

968
00:48:09,979 --> 00:48:18,950
the the definition of the behavior of a

969
00:48:13,489 --> 00:48:22,940
for loop and see so I can take my

970
00:48:18,095 --> 00:48:25,234
different pieces of my for loop and say

971
00:48:22,094 --> 00:48:28,633
well okay I'll take that rule and use it

972
00:48:26,089 --> 00:48:31,096
to pack them in to form a while work and

973
00:48:29,479 --> 00:48:34,513
of course you know that you can sort of

974
00:48:31,789 --> 00:48:36,710
go between those two as somewhat a

975
00:48:34,819 --> 00:48:38,860
matter of taste whether a given loop

976
00:48:36,071 --> 00:48:47,117
should be written using a for loop or a

977
00:48:39,229 --> 00:48:51,282
while loop so one reason why it's

978
00:48:48,017 --> 00:48:53,093
actually useful to do the - oh one

979
00:48:51,759 --> 00:48:55,831
optimization I talked to you about is

980
00:48:53,093 --> 00:48:59,032
it's fairly common for the initial test

981
00:48:56,479 --> 00:49:02,536
to be trivially trivially true so for

982
00:48:59,869 --> 00:49:04,942
example in here if I equals zero and I'm

983
00:49:03,049 --> 00:49:07,930
comparing it to the word size which

984
00:49:05,599 --> 00:49:10,940
would typically be 32

985
00:49:07,093 --> 00:49:12,502
well that test is true that's a certain

986
00:49:10,094 --> 00:49:15,243
thing and so what you'll see is that the

987
00:49:13,339 --> 00:49:20,390
compiler can figure that out and just

988
00:49:16,089 --> 00:49:24,163
throw away this guarding code that would

989
00:49:20,039 --> 00:49:26,428
have to be there otherwise so so that

990
00:49:24,829 --> 00:49:27,904
that I believe is the main reason why

991
00:49:26,779 --> 00:49:31,880
this is the transformation that gets

992
00:49:28,579 --> 00:49:33,676
used to the oh one optimization level is

993
00:49:31,088 --> 00:49:36,477
that often times it doesn't need this

994
00:49:34,549 --> 00:49:36,621
initial test

995
00:49:39,839 --> 00:49:45,888
okay so now I'm going to finish up with

996
00:49:42,579 --> 00:49:50,652
what's in its immediately the loop stuff

997
00:49:46,329 --> 00:49:55,428
is sort of what you'd expect if you were

998
00:49:51,309 --> 00:49:58,480
to have to you know turn a C code into

999
00:49:56,319 --> 00:50:01,900
something very low-level where all you

1000
00:49:58,048 --> 00:50:03,145
could do is jumps and test well maybe

1001
00:50:01,009 --> 00:50:05,071
that's obvious but maybe not the switch

1002
00:50:04,045 --> 00:50:08,454
statement on the other hand is a totally

1003
00:50:06,052 --> 00:50:10,147
different beast and I want to show you

1004
00:50:08,859 --> 00:50:14,170
that because there's no counterpart in

1005
00:50:11,047 --> 00:50:19,054
normal C code of how you'd even think

1006
00:50:14,017 --> 00:50:21,088
about it and it's fairly a little bit

1007
00:50:19,054 --> 00:50:25,383
harder to do cipher and you're going to

1008
00:50:21,088 --> 00:50:27,103
have to do it in the bomb lab so here's

1009
00:50:25,869 --> 00:50:31,893
an example of a switch statement that is

1010
00:50:28,003 --> 00:50:33,100
of nothing about this is useful except

1011
00:50:32,109 --> 00:50:37,030
to demonstrate some principles of how to

1012
00:50:34,000 --> 00:50:40,063
turn a switch statement into a assembly

1013
00:50:37,003 --> 00:50:43,015
code so the point of it is as you know

1014
00:50:40,063 --> 00:50:46,117
and C you switch on a particular value

1015
00:50:43,015 --> 00:50:49,944
some type of integer value and then it

1016
00:50:47,017 --> 00:50:51,103
will match different cases where each of

1017
00:50:50,079 --> 00:50:58,200
these cases has to be some constant

1018
00:50:52,003 --> 00:51:01,072
numeric value constant integer value and

1019
00:50:58,002 --> 00:51:04,033
one of the weirdest features of C is if

1020
00:51:01,072 --> 00:51:06,154
you don't at the end of the case if you

1021
00:51:04,051 --> 00:51:10,090
don't explicitly say break it will do

1022
00:51:07,054 --> 00:51:13,153
what's known as falling through so in

1023
00:51:10,009 --> 00:51:17,038
this example here it will divide Y by Z

1024
00:51:14,053 --> 00:51:21,882
and then it will just glide right into

1025
00:51:18,019 --> 00:51:24,091
this statement that adds e to W this is

1026
00:51:22,359 --> 00:51:26,500
by the way like one of the worst design

1027
00:51:24,091 --> 00:51:27,115
decisions in the history of programming

1028
00:51:26,005 --> 00:51:30,051
languages

1029
00:51:28,015 --> 00:51:34,042
and it's been the cause of more and more

1030
00:51:30,096 --> 00:51:35,128
you know art break and bugs that nobody

1031
00:51:34,042 --> 00:51:38,110
could understand than any other single

1032
00:51:36,028 --> 00:51:40,084
part of the language and for some

1033
00:51:39,001 --> 00:51:42,094
bizarre reason they've kept it alive

1034
00:51:40,084 --> 00:51:45,121
even into Java and all these other

1035
00:51:43,003 --> 00:51:48,046
languages that fix a lot of the worst

1036
00:51:46,021 --> 00:51:50,053
parts you know the most dangerous parts

1037
00:51:48,046 --> 00:51:53,122
of C but somehow they kept this suture

1038
00:51:50,053 --> 00:51:56,140
and so just as a advice as a programmer

1039
00:51:54,022 --> 00:52:00,037
if you ever ever use this where you

1040
00:51:57,004 --> 00:52:02,089
purposely want it to go from one case to

1041
00:52:00,037 --> 00:52:05,128
another you should have to put a comment

1042
00:52:03,025 --> 00:52:08,044
in there to say trust me I really did

1043
00:52:06,028 --> 00:52:09,037
want it to fall through I know you

1044
00:52:08,044 --> 00:52:13,047
almost never want to do this but I do

1045
00:52:10,018 --> 00:52:16,030
here so that's a fairly common

1046
00:52:13,074 --> 00:52:18,166
convention I don't know how many times

1047
00:52:16,003 --> 00:52:23,049
I've had bugs that were because I forgot

1048
00:52:19,066 --> 00:52:27,109
to put brakes in anyways enough of my

1049
00:52:23,076 --> 00:52:31,102
editorializing the other feature you see

1050
00:52:28,009 --> 00:52:34,030
and see is you can insert a bunch up

1051
00:52:32,002 --> 00:52:36,046
multiple cases if you think of it that's

1052
00:52:34,003 --> 00:52:39,022
just a special case of the fall through

1053
00:52:36,046 --> 00:52:41,143
right the case five has nothing to do

1054
00:52:39,049 --> 00:52:43,111
but to fall through to six but so that's

1055
00:52:42,043 --> 00:52:46,099
the same general way and there's nothing

1056
00:52:44,011 --> 00:52:50,029
that's not that's not bad and it doesn't

1057
00:52:46,099 --> 00:52:51,115
require a comment and the other one is

1058
00:52:50,029 --> 00:52:55,048
that there's a default so if none of

1059
00:52:52,015 --> 00:52:57,097
these cases match either because X was 0

1060
00:52:55,048 --> 00:53:02,062
or smaller or X was a really big number

1061
00:52:57,097 --> 00:53:03,193
or in this case if X were 4 there's no

1062
00:53:02,062 --> 00:53:06,070
matching case and of course you also

1063
00:53:04,093 --> 00:53:08,191
know that these cases don't have to be

1064
00:53:06,007 --> 00:53:11,008
in any particular order is it so that's

1065
00:53:09,091 --> 00:53:16,098
all the sort of features of a case

1066
00:53:11,008 --> 00:53:20,050
statement of a switch statement turn up

1067
00:53:17,061 --> 00:53:22,120
so normally if you write this in sort of

1068
00:53:21,022 --> 00:53:25,024
if you were told

1069
00:53:23,002 --> 00:53:27,085
thou shalt not use switch statements

1070
00:53:25,042 --> 00:53:29,134
anymore what you'd probably do is write

1071
00:53:28,003 --> 00:53:35,011
this big long chain of if else if else

1072
00:53:30,034 --> 00:53:37,102
is else right and you'd expect that to

1073
00:53:35,083 --> 00:53:38,131
be the machine code but it's not and so

1074
00:53:38,002 --> 00:53:41,055
let me show you what the machine code

1075
00:53:39,031 --> 00:53:41,055
does

1076
00:53:41,065 --> 00:53:48,065
it's kind of a long story so think of

1077
00:53:45,068 --> 00:53:53,093
the general form of it as being some

1078
00:53:48,065 --> 00:53:55,130
blocks of code the entry points of which

1079
00:53:53,093 --> 00:53:57,098
are labeled by these case values and

1080
00:53:56,003 --> 00:53:59,027
then the blocks

1081
00:53:57,098 --> 00:53:59,194
you know string together in various

1082
00:53:59,054 --> 00:54:04,118
different ways and do various things

1083
00:54:00,094 --> 00:54:07,106
what I'm going to do is compile a code

1084
00:54:05,018 --> 00:54:11,053
for all of those blocks and store them

1085
00:54:08,006 --> 00:54:14,087
away in some part of memory load up

1086
00:54:11,053 --> 00:54:16,142
memory to contain these code blocks and

1087
00:54:14,087 --> 00:54:20,162
then I'm going to build a table and each

1088
00:54:17,042 --> 00:54:23,111
entry of this table describes the

1089
00:54:21,062 --> 00:54:27,086
starting location of one of these code

1090
00:54:24,011 --> 00:54:31,043
blocks and I'll put them in order of my

1091
00:54:27,086 --> 00:54:34,175
case labels if I have you know I want to

1092
00:54:31,043 --> 00:54:37,052
span a scope from well it's assumed zero

1093
00:54:35,075 --> 00:54:39,167
but typically that's not the case

1094
00:54:37,052 --> 00:54:43,103
zero up to n minus one

1095
00:54:40,067 --> 00:54:48,164
I'll have this table will have that many

1096
00:54:44,003 --> 00:54:53,072
entries of addresses to tell me where

1097
00:54:49,064 --> 00:54:54,130
these code blocks are located and then

1098
00:54:53,072 --> 00:55:00,095
I'm going to use this really cool

1099
00:54:55,003 --> 00:55:04,034
instruction which is a sort of like it's

1100
00:55:00,095 --> 00:55:06,173
as if you it's like a ray indexing so if

1101
00:55:04,061 --> 00:55:09,110
you think of a ray indexing it means you

1102
00:55:07,073 --> 00:55:14,132
can grab a value out of the middle of

1103
00:55:10,001 --> 00:55:17,063
some you know array some set of values

1104
00:55:15,032 --> 00:55:20,063
without having to step through them one

1105
00:55:17,072 --> 00:55:24,143
by one and it's the same idea here that

1106
00:55:20,063 --> 00:55:28,082
I will take my value and use that to

1107
00:55:25,043 --> 00:55:32,045
figure out directly where I should jump

1108
00:55:28,082 --> 00:55:34,093
to a block of code without having to

1109
00:55:32,045 --> 00:55:37,124
step through a bunch of other conditions

1110
00:55:34,093 --> 00:55:38,180
so and you can see the efficiency again

1111
00:55:38,024 --> 00:55:41,123
from that it's the difference between

1112
00:55:39,008 --> 00:55:45,074
sort of in one step knowing exactly

1113
00:55:42,023 --> 00:55:48,056
where you want to be versus stepping

1114
00:55:46,046 --> 00:55:52,135
through you know on average n over two

1115
00:55:48,056 --> 00:55:52,135
conditions to get to where I want to go

1116
00:55:53,004 --> 00:56:00,723
so let's look at this at the assembly

1117
00:55:56,259 --> 00:56:03,261
code level and it's a little bit of a

1118
00:56:01,119 --> 00:56:07,218
long thing because we have to build some

1119
00:56:03,279 --> 00:56:10,930
machinery around this so here's my

1120
00:56:08,109 --> 00:56:14,184
example I've got three arguments

1121
00:56:10,093 --> 00:56:16,093
so just remember I told you our VI and

1122
00:56:14,859 --> 00:56:22,630
our si for the first two arguments the

1123
00:56:16,093 --> 00:56:26,262
third argument is in RDX and here's the

1124
00:56:22,063 --> 00:56:29,068
beginning of the switch code it's just

1125
00:56:27,099 --> 00:56:33,180
making a copy of argument Z here for

1126
00:56:30,013 --> 00:56:37,902
some reason and then it's looking at

1127
00:56:33,018 --> 00:56:41,937
comparing X 2 6 and Y is 6 an important

1128
00:56:38,019 --> 00:56:45,720
number because you see 6 was the largest

1129
00:56:42,099 --> 00:56:45,720
value of any of my cases

1130
00:56:47,056 --> 00:56:54,070
and now it's using a jump instruction to

1131
00:56:51,046 --> 00:56:56,130
go to LA what we'll find is that tells

1132
00:56:54,007 --> 00:57:00,100
you what the default behavior should be

1133
00:56:57,003 --> 00:57:03,007
so it's sort of flushing away the the

1134
00:57:01,063 --> 00:57:06,142
default cases the cases that are either

1135
00:57:03,007 --> 00:57:08,020
X is too small or X is too large and I

1136
00:57:07,042 --> 00:57:12,049
should mention there's a clever trick

1137
00:57:08,083 --> 00:57:16,099
there if you look at J a means jump

1138
00:57:12,049 --> 00:57:19,125
above that's the unsigned comparison and

1139
00:57:16,099 --> 00:57:21,175
what it's making use of is our our

1140
00:57:20,025 --> 00:57:25,069
result that you remember that if a

1141
00:57:22,075 --> 00:57:27,079
number is negative if you think of it as

1142
00:57:25,069 --> 00:57:31,095
an unsigned value it becomes very large

1143
00:57:28,015 --> 00:57:36,076
positive value so by doing the J a

1144
00:57:31,095 --> 00:57:39,172
instead of AJ G I jump greater than I'm

1145
00:57:36,076 --> 00:57:48,162
doing jump above it's saying I want to

1146
00:57:40,072 --> 00:57:53,098
jump to the default if either X is

1147
00:57:49,062 --> 00:57:58,078
greater than 6 but also it will cause it

1148
00:57:53,098 --> 00:58:00,184
to jump if X is less than 0 got it so

1149
00:57:58,078 --> 00:58:02,155
it's a clever trick of unsigned versus

1150
00:58:01,084 --> 00:58:06,133
signed numbers is taking advantage of

1151
00:58:03,055 --> 00:58:08,131
and then the final part is this is the

1152
00:58:07,033 --> 00:58:14,068
real heart of the work this is my very

1153
00:58:09,031 --> 00:58:18,055
special go-to instruction that lets me

1154
00:58:14,068 --> 00:58:20,140
index into a table and extract out of

1155
00:58:18,055 --> 00:58:24,082
that an address and then jump to that

1156
00:58:21,004 --> 00:58:30,010
address so that's what lets me go

1157
00:58:24,082 --> 00:58:33,157
directly to some block of code based on

1158
00:58:31,000 --> 00:58:38,023
whether my values we'll see will be in

1159
00:58:34,057 --> 00:58:41,064
the range between 0 and 6 so there'll be

1160
00:58:38,023 --> 00:58:41,064
seven entries in that table

1161
00:58:44,289 --> 00:58:49,366
one one thing just to keep track up for

1162
00:58:47,359 --> 00:58:54,370
later you'll see that for some reason

1163
00:58:50,059 --> 00:58:57,130
the GCC said you know if I look at all

1164
00:58:54,469 --> 00:58:59,530
the code I actually don't use W as

1165
00:58:57,013 --> 00:59:01,882
initialized very much so I won't bother

1166
00:59:00,079 --> 00:59:04,430
doing it until somewhere within the code

1167
00:59:01,999 --> 00:59:10,130
blocks so just we'll have to keep track

1168
00:59:04,043 --> 00:59:12,922
of that here okay so this is the magic

1169
00:59:10,013 --> 00:59:17,722
instruction and now if we look and this

1170
00:59:13,309 --> 00:59:20,420
is all assembly code you'll see this is

1171
00:59:17,839 --> 00:59:22,858
the actual jump table and it's

1172
00:59:20,042 --> 00:59:24,047
constructed it specified in assembly

1173
00:59:23,029 --> 00:59:26,660
code it's the job of the assembler to

1174
00:59:24,092 --> 00:59:32,401
actually fill in the contents of this

1175
00:59:26,066 --> 00:59:36,265
table excuse me but what the assembly

1176
00:59:33,229 --> 00:59:39,232
code is telling the assembler is I need

1177
00:59:36,859 --> 00:59:42,871
a quad it's just a declaration to say I

1178
00:59:39,259 --> 00:59:46,261
need an 8 byte value here and that value

1179
00:59:42,979 --> 00:59:49,130
should match whatever address you decide

1180
00:59:46,459 --> 00:59:51,880
you later determine is the address of

1181
00:59:49,013 --> 00:59:54,089
where I'm going to stick a label 8 and

1182
00:59:51,088 --> 00:59:56,707
all these other ones and these are in

1183
00:59:54,089 --> 01:00:00,568
the order as I mentioned from x equals 0

1184
00:59:57,499 --> 01:00:04,567
through 6 and we can already see a few

1185
01:00:01,369 --> 01:00:08,418
cases that are interesting here let me

1186
01:00:05,179 --> 01:00:08,247
see if I've got a picture on this

1187
01:00:11,056 --> 01:00:14,056
yeah

1188
01:00:16,003 --> 01:00:22,099
so we can actually already see some of

1189
01:00:20,035 --> 01:00:24,097
the logic of this switch statement built

1190
01:00:22,099 --> 01:00:27,124
into the ordering of entries in this

1191
01:00:24,097 --> 01:00:30,100
table so in particular there is no case

1192
01:00:28,024 --> 01:00:34,087
zero here so case zero should be the

1193
01:00:31,000 --> 01:00:37,027
default there is no case for here the

1194
01:00:34,087 --> 01:00:38,134
case for should be the default and it

1195
01:00:37,027 --> 01:00:42,058
turns out and we already saw before the

1196
01:00:39,034 --> 01:00:43,129
J a instruction going to LA so L eight

1197
01:00:42,058 --> 01:00:47,065
is actually where the code block is

1198
01:00:44,029 --> 01:00:49,114
going to be for the default case so you

1199
01:00:47,065 --> 01:00:52,081
see basically you can think of this as

1200
01:00:50,014 --> 01:00:54,070
sometimes kept having holes in your

1201
01:00:52,081 --> 01:00:57,088
switch statement and we're going to just

1202
01:00:54,007 --> 01:01:04,069
fill in those holes by saying those

1203
01:00:58,051 --> 01:01:06,109
should go to the default case and here

1204
01:01:05,032 --> 01:01:09,103
you'll notice that they're not put in

1205
01:01:07,009 --> 01:01:17,085
any particularly logical order a one

1206
01:01:10,003 --> 01:01:21,076
thing you'll see again is L 7 is

1207
01:01:17,085 --> 01:01:24,085
repeated twice here because it covers

1208
01:01:21,076 --> 01:01:26,077
both cases five and six so again you'll

1209
01:01:24,085 --> 01:01:29,149
see that sort of doubling up is handled

1210
01:01:26,086 --> 01:01:31,171
automatically by the jump table we'll

1211
01:01:30,049 --> 01:01:34,128
give you the same address for multiple

1212
01:01:32,071 --> 01:01:34,128
different cases

1213
01:01:37,073 --> 01:01:41,108
okay and now the rest of it is to look

1214
01:01:40,004 --> 01:01:44,039
at the various code blocks and this by

1215
01:01:42,008 --> 01:01:47,099
the way I'm showing you I took a file

1216
01:01:44,075 --> 01:01:48,149
and I'm you know extracted little bits

1217
01:01:47,099 --> 01:01:52,100
of it but normally you're looking at

1218
01:01:49,049 --> 01:01:55,094
this whole listing in one big order so

1219
01:01:53,000 --> 01:01:57,065
now we can look at the individual code

1220
01:01:55,094 --> 01:01:58,163
blocks and see what's going on and

1221
01:01:57,065 --> 01:02:02,081
you'll see for example case one told me

1222
01:01:59,063 --> 01:02:04,136
to multiply two numbers and you'll see

1223
01:02:02,081 --> 01:02:05,177
that the break in the general it's just

1224
01:02:05,036 --> 01:02:11,042
going to be turned into return

1225
01:02:06,077 --> 01:02:13,112
instructions here because my function go

1226
01:02:11,042 --> 01:02:16,085
sorry to jump in code you see this

1227
01:02:14,012 --> 01:02:21,026
function did a switch statement and then

1228
01:02:16,085 --> 01:02:22,157
whatever whatever gets computed within

1229
01:02:21,026 --> 01:02:26,054
the switch statement gets returned as a

1230
01:02:23,057 --> 01:02:29,066
result of this so the compiler doesn't

1231
01:02:26,054 --> 01:02:31,121
actually come to a single point and say

1232
01:02:29,066 --> 01:02:34,124
okay everyone returned at this point it

1233
01:02:32,021 --> 01:02:38,029
just sticks returns directly in wherever

1234
01:02:35,024 --> 01:02:38,029
these breaks occur

1235
01:02:41,059 --> 01:02:49,151
so here it does a multiply and a return

1236
01:02:46,024 --> 01:02:52,073
here is actually a curious by the way

1237
01:02:50,051 --> 01:02:55,130
I'm always somewhat surprised by what

1238
01:02:52,073 --> 01:03:02,077
the compiler does it is never exactly

1239
01:02:56,003 --> 01:03:06,004
what you'd expect so in particular it it

1240
01:03:03,013 --> 01:03:12,050
patched together this fall through case

1241
01:03:06,004 --> 01:03:16,028
by two blocks of code and it had to do

1242
01:03:12,005 --> 01:03:20,006
these separately because remember W was

1243
01:03:16,064 --> 01:03:22,148
not set before I entered the these code

1244
01:03:20,051 --> 01:03:25,058
blocks it deferred setting that and here

1245
01:03:23,048 --> 01:03:29,132
I hit k3 and all of a sudden I actually

1246
01:03:25,058 --> 01:03:32,111
need whatever W was which was one and so

1247
01:03:30,032 --> 01:03:34,124
I guess the complier said well gosh I

1248
01:03:33,011 --> 01:03:37,019
guess I better set W to one here before

1249
01:03:35,024 --> 01:03:39,107
we continue so as a result it sort of

1250
01:03:37,091 --> 01:03:43,187
creates two code blocks but it jumps

1251
01:03:40,007 --> 01:03:51,026
from the second one this block into

1252
01:03:44,087 --> 01:03:53,165
partway through this other block here's

1253
01:03:51,026 --> 01:03:58,085
some actual yeah so here's the actual

1254
01:03:54,065 --> 01:04:00,080
code this is the block that does the

1255
01:03:58,085 --> 01:04:02,087
division it's very quickly how you have

1256
01:04:00,008 --> 01:04:04,103
to write division discovered in the book

1257
01:04:03,005 --> 01:04:08,096
I won't go through it here and then this

1258
01:04:05,075 --> 01:04:10,088
jump l6 is what I say go to merge and

1259
01:04:08,096 --> 01:04:12,155
the merge is where you're bringing these

1260
01:04:10,088 --> 01:04:17,171
two cases together here is where it's

1261
01:04:13,055 --> 01:04:20,126
setting L to one again it's making use

1262
01:04:18,071 --> 01:04:23,072
of this feature and that the upper 32

1263
01:04:21,026 --> 01:04:29,029
bits get set to zeros so I I can use a

1264
01:04:23,072 --> 01:04:28,129
move L instruction here yes question

1265
01:04:33,008 --> 01:04:39,096
did not have the code for what no the

1266
01:04:37,349 --> 01:04:42,950
jump table is sort of embedded let me

1267
01:04:39,096 --> 01:04:41,195
just show you real quick

1268
01:04:43,007 --> 01:04:51,030
no probably bad idea the jump if you

1269
01:04:48,081 --> 01:04:51,177
look at the the dot s file the assembly

1270
01:04:51,003 --> 01:04:54,075
code file Oh

1271
01:04:52,077 --> 01:04:57,099
all this stuff I'm showing you I've

1272
01:04:55,002 --> 01:04:58,044
extracted out of that but it's all in

1273
01:04:57,099 --> 01:05:00,117
there

1274
01:04:58,044 --> 01:05:03,048
and so that the compiler generated these

1275
01:05:01,017 --> 01:05:06,033
tables at least the sort of framework

1276
01:05:03,084 --> 01:05:08,603
for these tables the details of which

1277
01:05:06,033 --> 01:05:12,050
gets filled in by the assembler so it is

1278
01:05:09,359 --> 01:05:12,500
generated by the compiler

1279
01:05:16,089 --> 01:05:21,165
okay so that just shows you this one

1280
01:05:19,449 --> 01:05:24,513
example of handling a particular way to

1281
01:05:21,849 --> 01:05:28,866
handle the fall through case and then

1282
01:05:25,089 --> 01:05:31,140
the remaining ones again you'll see here

1283
01:05:29,019 --> 01:05:34,630
I got if I get to this case I need the

1284
01:05:31,599 --> 01:05:37,686
fact that W is initialized to 1 so we'll

1285
01:05:34,063 --> 01:05:40,422
do so here in the default case it just

1286
01:05:38,469 --> 01:05:43,470
designs to 2w and so that's all it does

1287
01:05:40,989 --> 01:05:45,027
so anyways I've actually shown you all

1288
01:05:43,569 --> 01:05:46,611
the code blocks but I've shown you one

1289
01:05:45,369 --> 01:05:49,380
by one but they're just all kind of

1290
01:05:46,989 --> 01:05:52,023
strong in the file and in no particular

1291
01:05:49,479 --> 01:06:03,501
order it doesn't matter what orders they

1292
01:05:52,329 --> 01:06:10,332
are yes yep so that was the reason for

1293
01:06:03,699 --> 01:06:13,713
that jump above at the beginning so this

1294
01:06:10,359 --> 01:06:18,384
jump above la was the way that if X was

1295
01:06:13,839 --> 01:06:20,841
either less than 0 or greater than 6 it

1296
01:06:18,609 --> 01:06:28,698
would go to the default case and it will

1297
01:06:21,039 --> 01:06:33,042
only do this indexing trick if the if X

1298
01:06:29,499 --> 01:06:35,640
is between 0 and 6 and that's typically

1299
01:06:33,339 --> 01:06:38,364
the way this works that you'll see that

1300
01:06:35,064 --> 01:06:39,115
whatever range of values you give it has

1301
01:06:38,589 --> 01:06:42,624
to figure out the smallest and the

1302
01:06:40,015 --> 01:06:45,084
largest one set up so it goes to the

1303
01:06:42,939 --> 01:06:47,013
default case if it's out of that range

1304
01:06:45,219 --> 01:06:52,390
and then set up a table for the values

1305
01:06:47,679 --> 01:06:55,900
within that range question like some

1306
01:06:52,039 --> 01:06:58,728
negative number - yeah does it try to do

1307
01:06:55,009 --> 01:07:00,078
the index into it with that X power so

1308
01:06:59,079 --> 01:07:03,174
the question I'm realize I should be

1309
01:07:00,969 --> 01:07:06,018
repeating questions the question is what

1310
01:07:04,029 --> 01:07:08,037
if it's a negative number for your case

1311
01:07:06,459 --> 01:07:11,475
which is perfectly legal it will

1312
01:07:08,829 --> 01:07:13,877
typically add a bias to it effectively

1313
01:07:11,619 --> 01:07:17,682
so that whatever your lowest value was

1314
01:07:14,309 --> 01:07:20,900
become 0 or it'll do something like that

1315
01:07:18,249 --> 01:07:29,150
to avoid having to do negative indexing

1316
01:07:20,009 --> 01:07:32,338
another question is he yes yeah so you

1317
01:07:29,015 --> 01:07:34,088
can go from zero to a million yeah they

1318
01:07:33,229 --> 01:07:36,292
could be you could go zero in a million

1319
01:07:34,088 --> 01:07:37,166
and nothing in between right so you'd

1320
01:07:36,859 --> 01:07:40,951
have two cases you really don't want a

1321
01:07:38,066 --> 01:07:44,144
million entry table for just two cases

1322
01:07:41,779 --> 01:07:46,786
so it will turn it into a felt code but

1323
01:07:45,044 --> 01:07:47,116
the clever thing that we'll do if you

1324
01:07:46,849 --> 01:07:50,851
know binary search

1325
01:07:48,016 --> 01:07:52,019
they relies on the fact that it knows in

1326
01:07:50,869 --> 01:07:54,876
advance all the values and it will

1327
01:07:52,046 --> 01:07:58,345
actually set up a tree of it Phelps's so

1328
01:07:55,569 --> 01:07:59,644
really it will do it if you want to

1329
01:07:58,759 --> 01:08:03,200
thank algorithmically it does it with a

1330
01:08:00,319 --> 01:08:09,324
logarithmic number of tests rather than

1331
01:08:03,002 --> 01:08:09,621
a linear number of test question

1332
01:08:15,239 --> 01:08:22,130
oh yeah

1333
01:08:18,319 --> 01:08:24,367
yeah so so there's two inches that one

1334
01:08:22,013 --> 01:08:26,722
is this which I actually answered both

1335
01:08:24,799 --> 01:08:28,520
now if one is what if there's some

1336
01:08:26,839 --> 01:08:32,960
negative values or what if the lowest

1337
01:08:28,052 --> 01:08:35,120
number is 5700 right well what it will

1338
01:08:32,096 --> 01:08:37,181
typically do is put some bias and you'll

1339
01:08:36,002 --> 01:08:42,121
add or subtract some value so that the

1340
01:08:38,081 --> 01:08:43,085
first case is at value 0 so that's where

1341
01:08:42,319 --> 01:08:46,040
it handles you know ones that are just

1342
01:08:43,085 --> 01:08:47,150
completely out of range and the other is

1343
01:08:46,004 --> 01:08:51,047
what if it's a really big spread of

1344
01:08:48,005 --> 01:08:53,344
values and relatively sparse how much

1345
01:08:51,047 --> 01:08:56,093
you're using it and there it will revert

1346
01:08:53,839 --> 01:08:58,864
to FL code and the compiler has its own

1347
01:08:56,093 --> 01:09:00,095
rules about how it does these things you

1348
01:08:59,089 --> 01:09:03,094
can sort of run experiments and try and

1349
01:09:01,013 --> 01:09:04,972
reverse engineer because you know these

1350
01:09:03,589 --> 01:09:08,080
are all valid questions by the way

1351
01:09:05,089 --> 01:09:08,080
appreciative

1352
01:09:11,069 --> 01:09:16,950
okay so we're going to get through this

1353
01:09:14,068 --> 01:09:16,095
Oh

1354
01:09:17,029 --> 01:09:26,558
so anyways and like I said I think in my

1355
01:09:23,259 --> 01:09:30,850
own experience you know understanding

1356
01:09:26,819 --> 01:09:33,430
the conditionals you can kind of figure

1357
01:09:30,085 --> 01:09:35,089
that out it's intuitive sort of feels

1358
01:09:33,043 --> 01:09:40,066
like what you'd expect a program to do

1359
01:09:35,089 --> 01:09:42,288
whereas a switch statement is maybe

1360
01:09:40,066 --> 01:09:48,127
unexpected it's a way to do something

1361
01:09:43,089 --> 01:09:50,160
that is not totally obvious but then

1362
01:09:49,027 --> 01:09:53,038
when you think about it and appreciate

1363
01:09:50,799 --> 01:09:55,270
it it's actually it gives you a good

1364
01:09:53,038 --> 01:09:57,043
performance boost you know again

1365
01:09:55,027 --> 01:10:02,044
algorithmically this jump table makes it

1366
01:09:57,043 --> 01:10:03,142
so it's a constant time a constant

1367
01:10:02,044 --> 01:10:06,112
number of steps to get to where you need

1368
01:10:04,042 --> 01:10:10,341
to in the switch statement if you just

1369
01:10:07,012 --> 01:10:12,013
get it linearly one after the other then

1370
01:10:10,719 --> 01:10:14,160
that would be linear time and you'd

1371
01:10:12,013 --> 01:10:16,102
expect on you know if everything's

1372
01:10:14,016 --> 01:10:20,083
uniform and average about how you'd be

1373
01:10:17,002 --> 01:10:23,005
about halfway through on average if

1374
01:10:20,083 --> 01:10:24,972
you're if it's sparse you'll see it will

1375
01:10:23,005 --> 01:10:28,048
set up a tree of conditionals so it can

1376
01:10:25,719 --> 01:10:30,850
do in logarithmic time so no matter what

1377
01:10:28,048 --> 01:10:32,307
it will be better than just what you get

1378
01:10:30,085 --> 01:10:34,146
in the obvious form of your felts I saw

1379
01:10:32,739 --> 01:10:35,460
a question over here

1380
01:10:36,849 --> 01:10:43,190
well the good news is I don't set up the

1381
01:10:40,909 --> 01:10:45,961
jump tree the compiler sets up to jump

1382
01:10:43,019 --> 01:10:48,118
tree right but if you're asking if I

1383
01:10:46,429 --> 01:10:50,530
were a compiler how would I set up the

1384
01:10:48,289 --> 01:10:53,210
jump tree right which is a good question

1385
01:10:50,053 --> 01:10:54,562
if you know binary search right that

1386
01:10:53,021 --> 01:10:56,105
you've got a range of values and you

1387
01:10:55,039 --> 01:11:00,055
pick you compare it to the middle value

1388
01:10:57,005 --> 01:11:03,694
and it's either less or it's greater or

1389
01:11:00,199 --> 01:11:05,272
equal and if it's less than you sort of

1390
01:11:03,739 --> 01:11:06,748
recursively handle the one set and if

1391
01:11:05,929 --> 01:11:10,340
it's greater the other hat that's

1392
01:11:07,639 --> 01:11:12,050
exactly what these trees look like so

1393
01:11:10,034 --> 01:11:13,123
they're balanced binary trees and

1394
01:11:12,005 --> 01:11:15,784
they're taking advantage of the fact

1395
01:11:13,429 --> 01:11:18,490
that in --see which is not true in all

1396
01:11:15,829 --> 01:11:21,170
languages that all the the case

1397
01:11:19,039 --> 01:11:24,130
conditions you're looking at our

1398
01:11:21,017 --> 01:11:26,596
constants they're determined when the

1399
01:11:24,949 --> 01:11:29,047
compiler is doing the compilation those

1400
01:11:26,749 --> 01:11:31,750
are constant values so it can can sort

1401
01:11:29,929 --> 01:11:32,983
them figure out how many there are what

1402
01:11:31,849 --> 01:11:35,863
range of values so there are decide

1403
01:11:33,469 --> 01:11:41,503
which version to do this and generate

1404
01:11:35,989 --> 01:11:44,210
the code other questions so these are

1405
01:11:41,809 --> 01:11:47,380
all good and it's a very good question

1406
01:11:44,021 --> 01:11:49,076
so and you're starting to think about

1407
01:11:47,038 --> 01:11:50,737
you know which is the way that computer

1408
01:11:49,076 --> 01:11:52,245
scientist should think is how do you

1409
01:11:51,079 --> 01:11:55,670
take some idea I've seen one case of

1410
01:11:52,929 --> 01:11:57,952
well how do I handle condition X and

1411
01:11:55,067 --> 01:12:01,067
condition Y and you know what happens if

1412
01:11:58,159 --> 01:12:03,920
this that's exactly what we do we sort

1413
01:12:01,067 --> 01:12:05,132
of we're never happy with a simple

1414
01:12:03,092 --> 01:12:07,021
explanation we want to understand how we

1415
01:12:06,032 --> 01:12:10,731
could actually implement it as a program

1416
01:12:07,849 --> 01:12:10,866
if we ever had to do so

1417
01:12:12,073 --> 01:12:19,157
so and so just in general that the main

1418
01:12:19,019 --> 01:12:24,095
thing you see is that there's a fairly

1419
01:12:20,057 --> 01:12:26,063
limited in bag of tricks for which the

1420
01:12:24,095 --> 01:12:30,100
program implements conditional

1421
01:12:27,017 --> 01:12:35,099
constructs you've seen basically three

1422
01:12:31,000 --> 01:12:38,006
one is to use conditional jumps go to

1423
01:12:35,099 --> 01:12:41,102
different parts of the code another to

1424
01:12:38,006 --> 01:12:44,063
use conditional moods and the third is

1425
01:12:42,002 --> 01:12:48,083
to use this jump table idea and those

1426
01:12:45,017 --> 01:12:52,040
are really that puts a little bit to do

1427
01:12:48,083 --> 01:12:54,137
of procedures consider all there is and

1428
01:12:52,004 --> 01:12:58,055
all the other stuff you see in a program

1429
01:12:55,037 --> 01:13:01,096
that sort of changes the flow of

1430
01:12:58,091 --> 01:13:05,099
execution or what gets executed are all

1431
01:13:01,096 --> 01:13:06,104
built out of those basic primitives and

1432
01:13:05,099 --> 01:13:10,106
that's generally true that what we see

1433
01:13:07,076 --> 01:13:13,076
is when you go from C codes of machine

1434
01:13:11,069 --> 01:13:16,112
code you often have to kind of piece

1435
01:13:13,076 --> 01:13:20,113
together various low-level instructions

1436
01:13:17,012 --> 01:13:21,013
to implement some higher-level construct

1437
01:13:21,071 --> 01:13:27,113
and so we've seen these all in different

1438
01:13:24,005 --> 01:13:30,026
form stone and next time then we'll talk

1439
01:13:28,013 --> 01:13:33,019
about procedures and that as you can

1440
01:13:30,071 --> 01:13:36,125
imagine a fairly major topic because it

1441
01:13:33,019 --> 01:13:39,070
is worth one entire procedure okay very

1442
01:13:37,025 --> 01:13:39,070
good thank you

