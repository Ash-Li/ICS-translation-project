1
00:00:01,011 --> 00:00:06,840
没事，大家下午好 

2
00:00:02,098 --> 00:00:11,098
欢迎很高兴见到你所有也欢迎 

3
00:00:06,939 --> 00:00:13,660
我们对视频所以上周我们的观众 

4
00:00:11,098 --> 00:00:18,115
看着这本虚拟内存 

5
00:00:13,066 --> 00:00:20,265
机制以及它如何提供这么 多 

6
00:00:19,015 --> 00:00:25,134
不同有用的功能的 

7
00:00:20,859 --> 00:00:26,867
有了这样 的系统一起 

8
00:00:25,269 --> 00:00:33,160
具有这种大型的抽象

9
00:00:26,939 --> 00:00:36,700
字节的连续数组现在一旦我们 

10
00:00:33,016 --> 00:00:42,028
鉴于该大阵列的 字节 现在 

11
00:00:36,007 --> 00:00:43,102
我们必须要管理它，我们有我们 

12
00:00:42,028 --> 00:00:46,111
必须有某种 机制来管理 

13
00:00:44,065 --> 00:00:50,071
并使用该资源好了， 

14
00:00:47,011 --> 00:00:55,027
这是我们对我们的讲座 话题 

15
00:00:51,025 --> 00:00:57,034
本周是存储分配 和如何 

16
00:00:55,027 --> 00:00:59,110
存储分配器的工作以及您如何使用

17
00:00:58,015 --> 00:01:07,063
他们来管理 他们那里的虚拟 

18
00:01:00,001 --> 00:01:11,019
您的系统内存，因此基本思路 

19
00:01:07,063 --> 00:01:14,089
动态存储器的分配器 是 

20
00:01:11,028 --> 00:01:18,055
应用程序使用它来操纵

21
00:01:14,089 --> 00:01:20,098
虚拟存储器来创建到分配 

22
00:01:18,055 --> 00:01:24,234
内存 和 虚拟内存的 空闲 块是 

23
00:01:21,079 --> 00:01:26,128
你在你的程序需要和它的这个 

24
00:01:24,729 --> 00:01:30,840
存储器被保持在它在的区域 

25
00:01:27,028 --> 00:01:33,094
虚拟存储器称为堆 确定和 

26
00:01:30,084 --> 00:01:35,113
几乎所有的语言有一定的问 一些 

27
00:01:33,094 --> 00:01:40,953
机构，用于获取和 

28
00:01:36,013 --> 00:01:47,044
操纵这个这个这个动态

29
00:01:41,799 --> 00:01:50,799
内存所以在NC它是一个手机它的 

30
00:01:47,044 --> 00:01:54,117
像Java的malloc包的语言 有 

31
00:01:50,799 --> 00:01:55,170
新的你知道新方法 

32
00:01:55,078 --> 00:01:59,083
现在分配器分配器 

33
00:01:58,012 --> 00:02:03,091
保持堆作为连续 

34
00:01:59,083 --> 00:02:04,482
块的集合，其中它块 可以 

35
00:02:03,091 --> 00:02:06,133
被分配或免费 

36
00:02:05,229 --> 00:02:10,140
好分配这意味着 他们 

37
00:02:07,033 --> 00:02:13,090
他们正在使用的一些程序 

38
00:02:10,014 --> 00:02:17,026
申请免费的含义，他们是 

39
00:02:13,009 --> 00:02:19,027
可以是使用由 

40
00:02:17,026 --> 00:02:21,073
应用和有有两家 

41
00:02:20,008 --> 00:02:24,052
类型的分配器有种 

42
00:02:21,073 --> 00:02:26,074
你在C发现，如分配器

43
00:02:24,052 --> 00:02:29,116
malloc的包装是达 

44
00:02:26,083 --> 00:02:31,962
应用程序 都明确地分配 

45
00:02:30,016 --> 00:02:34,063
在内存和明确地释放它 

46
00:02:32,709 --> 00:02:36,130
当，当， 当应用程序是 

47
00:02:34,063 --> 00:02:38,098
完成了它好了，所以系统 

48
00:02:36,013 --> 00:02:42,091
不会不会释放任何内存，你 

49
00:02:38,098 --> 00:02:44,151
分配除非你做它明确 

50
00:02:42,091 --> 00:02:48,190
通过调用free函数调用

51
00:02:45,051 --> 00:02:52,051
但有其他语言说 

52
00:02:49,009 --> 00:02:54,010
支持这些隐式分配器和

53
00:02:52,051 --> 00:02:58,068
这些隐含的分配器

54
00:02:55,000 --> 00:03:01,051
程序员明确地分配内存

55
00:02:58,068 --> 00:03:03,073
但随后该系统需要照顾 

56
00:03:01,051 --> 00:03:06,100
释放内存 好了，那就是在 

57
00:03:04,018 --> 00:03:09,100
释放内存的负担转移 

58
00:03:07,000 --> 00:03:13,015
从应用程序到到 

59
00:03:10,000 --> 00:03:15,001
该系统和它它释放该内存

60
00:03:13,015 --> 00:03:16,036
隐式类型的幕后 

61
00:03:15,001 --> 00:03:19,026
使用这个过程 被称为 垃圾 

62
00:03:16,036 --> 00:03:22,044
收集好了，所以像Java语言

63
00:03:19,026 --> 00:03:25,063
毫升的Lisp他们都他们都做隐 

64
00:03:23,016 --> 00:03:27,103
隐性他们都支持，密切在 

65
00:03:25,063 --> 00:03:29,116
分配器现在今天我们要公正

66
00:03:28,003 --> 00:03:32,061
我们要讨论外显记忆 

67
00:03:30,016 --> 00:03:36,925
周四 鳄鱼 ，我们将进入 

68
00:03:32,061 --> 00:03:39,610
隐含的鳄鱼和它们如何工作 

69
00:03:37,069 --> 00:03:44,030
现在分配器和看到的是它提供 

70
00:03:40,159 --> 00:03:48,181
通过在一组 标准C库 

71
00:03:44,003 --> 00:03:50,075
函数调用malloc的包中 

72
00:03:48,379 --> 00:03:53,900
malloc函数是用来分配

73
00:03:50,075 --> 00:03:56,159
存储器，并将其作为输入的尺寸 

74
00:03:53,009 --> 00:04:00,053
参数，它是在字节好，然后 

75
00:03:57,059 --> 00:04:03,101
它返回一个指向到存储器 

76
00:04:01,034 --> 00:04:07,040
块包含至少size个字节 

77
00:04:04,001 --> 00:04:11,006
并且该块被对准 T于86 

78
00:04:07,004 --> 00:04:16,863
系统，以8个字节在 x86 64个系统 

79
00:04:11,006 --> 00:04:20,905
16个字节，如果大小为零它 回归 到 无 

80
00:04:17,259 --> 00:04:26,287
然后返回-1喜欢最喜欢的 

81
00:04:20,959 --> 00:04:29,002
典型的系统调用程序员 

82
00:04:26,539 --> 00:04:32,180
通过调用自由释放内存

83
00:04:29,389 --> 00:04:34,940
功能需要作为自变量的 

84
00:04:32,018 --> 00:04:37,022
这 是从一些返回的指针

85
00:04:34,094 --> 00:04:42,143
malloc和它的先前指示

86
00:04:37,022 --> 00:04:45,023
没有返回值，也能够让我已经 

87
00:04:43,043 --> 00:04:47,048
鉴于此指针被退回 

88
00:04:45,032 --> 00:04:51,065
的malloc的先前指示它释放

89
00:04:47,093 --> 00:04:52,582
块在该地址，然后 

90
00:04:51,065 --> 00:04:55,103
该块返回到 池 

91
00:04:53,419 --> 00:05:00,440
可用内存现在有一些 

92
00:04:56,003 --> 00:05:02,006
还有一些其他的功能唾液酸是 

93
00:05:00,044 --> 00:05:04,049
malloc的版本，给你一个

94
00:05:02,033 --> 00:05:08,092
内存初始化块是 

95
00:05:04,049 --> 00:05:09,146
初始化为0和realloc您可以在 

96
00:05:08,389 --> 00:05:12,650
可以MALLOC一个块，然后调用的realloc 

97
00:05:10,046 --> 00:05:14,132
以前改变了大小

98
00:05:12,065 --> 00:05:16,130
分配的块，然后有一个

99
00:05:15,032 --> 00:05:19,501
其中使用函数称为S破 

100
00:05:17,003 --> 00:05:21,029
内部由分配器来成长， 

101
00:05:19,789 --> 00:05:25,370
缩小堆，因此，在分配器 

102
00:05:21,056 --> 00:05:26,665
需要更多的内存调用 分手吧2〜 

103
00:05:25,037 --> 00:05:29,072
获得额外的虚拟 内存和 

104
00:05:27,169 --> 00:05:32,240
那么了加 的热量 

105
00:05:29,072 --> 00:05:33,137
比例，生长堆，然后 

106
00:05:32,024 --> 00:05:38,193
它其添加到内存 中的 

107
00:05:34,037 --> 00:05:38,076
分配器被操纵 

108
00:05:39,007 --> 00:05:44,062
所以这里我们将如何 用一个例子

109
00:05:41,095 --> 00:05:49,156
malloc 和它在一个简单的程序 ，我们 

110
00:05:45,025 --> 00:05:53,071
有一个指针为int P和我们所说的 

111
00:05:50,056 --> 00:05:56,083
malloc 和我们 ， 我们要 分配一个 

112
00:05:53,071 --> 00:05:58,129
的n个阵列IMPS 所以这是这是 

113
00:05:56,083 --> 00:06:01,129
排序的标准方式调用它，我们 

114
00:05:59,029 --> 00:06:04,093
想要一个int，所以我们有n叫它 

115
00:06:02,029 --> 00:06:08,062
倍大事件，因为记得 

116
00:06:04,093 --> 00:06:11,122
参数为以字节为单位的malloc返回 

117
00:06:08,062 --> 00:06:15,070
一个指针，它返回一个通用指针 

118
00:06:12,022 --> 00:06:18,106
空星指针，所以我们将其转换为一个 

119
00:06:15,007 --> 00:06:24,007
指向int 使 编译器 

120
00:06:19,006 --> 00:06:29,055
快乐，然后将其分配给2P我们检查 

121
00:06:24,007 --> 00:06:33,052
对于 空返回值 的我们检查 

122
00:06:29,055 --> 00:06:36,058
所以我应该我应该指出的是 

123
00:06:34,015 --> 00:06:39,046
返回空气为零，以便我们 检查 

124
00:06:36,058 --> 00:06:43,072
复检复查该知道的气味 

125
00:06:39,046 --> 00:06:46,081
指针是0，并且 如果 打印错误 

126
00:06:43,072 --> 00:06:48,123
它没有现在一旦我们得到了指针的

127
00:06:46,081 --> 00:06:51,148
现在我们P可以把它就像一个数组 

128
00:06:49,023 --> 00:06:56,056
所以我们可以这样循环中，如果我们想 

129
00:06:52,048 --> 00:06:57,084
初始化它，我们在整个环 

130
00:06:56,056 --> 00:07:00,115
该阵列的元件

131
00:06:57,084 --> 00:07:02,086
现在初始化每一个到某一值

132
00:07:01,015 --> 00:07:04,027
当我们的时候，我们就完蛋就完蛋了

133
00:07:02,086 --> 00:07:05,101
与此块的内存 ， 我们已经 

134
00:07:04,027 --> 00:07:11,034
分配后，我们通过调用释放它

135
00:07:06,001 --> 00:07:11,034
自由与指针P 

136
00:07:11,999 --> 00:07:17,610
现在没事了，所以我们要看看 

137
00:07:14,789 --> 00:07:19,805
今天怎么样的malloc函数和 

138
00:07:17,061 --> 00:07:23,330
免费实现，所以我们打算 

139
00:07:19,949 --> 00:07:28,022
做一些简单的假设，从而 

140
00:07:23,879 --> 00:07:29,924
我要去内存字节地址我们 

141
00:07:28,679 --> 00:07:31,860
知道，但本作的目的

142
00:07:30,329 --> 00:07:33,335
讲座我们将 假定它是 

143
00:07:31,086 --> 00:07:38,375
它的字 地址好了，所以我们只是 

144
00:07:33,389 --> 00:07:43,417
去看看字大小的单位和我 

145
00:07:39,149 --> 00:07:50,246
将假设词语是4个字节 

146
00:07:43,669 --> 00:07:52,860
一个int所以基本上大小，使这 

147
00:07:51,119 --> 00:07:57,134
实际上不是这样，这是不是真正的我 

148
00:07:52,086 --> 00:07:57,575
要解决 这个 问题 所以基本上我们 

149
00:07:57,269 --> 00:08:01,277
要我们要思考的话 

150
00:07:58,349 --> 00:08:05,420
这 对字节 数量排序整数 

151
00:08:01,349 --> 00:08:07,406
大小的数量，然后我们的块或 

152
00:08:06,059 --> 00:08:10,130
这些词语连续块那 

153
00:08:07,919 --> 00:08:12,964
既可以分配或免费的，所以在这里 

154
00:08:10,769 --> 00:08:16,050
我们有堆的一部分，其 

155
00:08:13,369 --> 00:08:18,463
由 前分配块 的 

156
00:08:16,005 --> 00:08:21,824
后跟一个 双字的空闲块 

157
00:08:19,309 --> 00:08:24,317
紧接着又向前分配

158
00:08:21,869 --> 00:08:25,877
块， 然后免费三个词 

159
00:08:24,389 --> 00:08:28,478
阻挡， 我们将指出这些免费 

160
00:08:26,669 --> 00:08:31,705
块由白色和将指示 

161
00:08:29,279 --> 00:08:37,334
与一些树荫一些分配的块

162
00:08:32,029 --> 00:08:41,430
颜色，所以现在让我们看看如何序列 

163
00:08:37,829 --> 00:08:44,550
分配和冻结将工作和 

164
00:08:41,043 --> 00:08:47,452
现在请注意，我调用malloc与 

165
00:08:44,055 --> 00:08:49,149
在话不是字节只是为了保持规模

166
00:08:47,839 --> 00:08:52,970
只是为了让事情保持这些图片 

167
00:08:50,049 --> 00:08:52,097
简单

168
00:08:54,052 --> 00:09:03,100
所以在此我们首先调用 malloc 和 

169
00:08:58,048 --> 00:09:05,107
正向块的分配，然后我们

170
00:09:04,000 --> 00:09:08,005
卡内特这给了我们一个指针P1 

171
00:09:06,007 --> 00:09:10,776
然后我们再次调用malloc获得 

172
00:09:08,005 --> 00:09:15,061
五字块，它只是需要 它一个 

173
00:09:10,839 --> 00:09:17,410
自由的话，并分配它，我们 

174
00:09:15,061 --> 00:09:20,065
再次调用malloc 获得 六个字 

175
00:09:17,041 --> 00:09:24,129
块，然后我们释放这就是块

176
00:09:21,001 --> 00:09:28,039
在用P 指向此紫块 

177
00:09:25,029 --> 00:09:31,638
好了，所以现在我们是释放了 块 

178
00:09:28,039 --> 00:09:34,113
然后我们做了另一种分配 

179
00:09:31,899 --> 00:09:37,660
两条字块等的分配器 

180
00:09:35,013 --> 00:09:40,066
看起来，看它是否能找到一个空闲块 

181
00:09:37,066 --> 00:09:41,149
具有足够足够的空间，它会找出 

182
00:09:40,066 --> 00:09:45,111
它在这里 ， 认为这空闲块 

183
00:09:42,049 --> 00:09:50,068
有5分免费的话，然后将其

184
00:09:46,011 --> 00:09:58,024
分配的内部所请求的块 

185
00:09:50,068 --> 00:09:59,122
这是免费的块现在分配器工作

186
00:09:58,024 --> 00:10:01,863
下了很多很多不同的

187
00:10:00,022 --> 00:10:03,031
约束，所以很难写一个 

188
00:10:02,079 --> 00:10:07,870
因为所有这些分配器 

189
00:10:03,031 --> 00:10:10,066
限制的应用可以选择任何 

190
00:10:07,087 --> 00:10:11,173
分配和空闲块的组合

191
00:10:10,066 --> 00:10:15,485
所以你不能预测什么什么的 

192
00:10:12,073 --> 00:10:18,552
应用程序将请求与和 

193
00:10:16,079 --> 00:10:21,430
应用程序释放所需 

194
00:10:19,209 --> 00:10:24,070
通过时它释放 块的块传递一个 

195
00:10:21,043 --> 00:10:26,086
这是从返回的指针

196
00:10:24,007 --> 00:10:28,060
的malloc调用以前好了， 

197
00:10:26,086 --> 00:10:31,102
该应用程序有几个 

198
00:10:28,006 --> 00:10:33,735
约束，但是但实际上 只有一个 

199
00:10:32,002 --> 00:10:36,561
它具有 的是事实， 

200
00:10:34,329 --> 00:10:38,680
当它释放的东西它是 一个 

201
00:10:36,579 --> 00:10:41,667
从以前调用指针

202
00:10:38,068 --> 00:10:43,129
现在的malloc malloc的操作或 

203
00:10:42,459 --> 00:10:46,690
喜欢的malloc分配器下运行

204
00:10:44,029 --> 00:10:48,318
很多不同的 限制，他们不能 

205
00:10:46,069 --> 00:10:50,095
控制大小或数 

206
00:10:48,579 --> 00:10:52,930
分配的块，因为他们没有 

207
00:10:50,095 --> 00:10:55,674
在该应用程序是什么 控制 

208
00:10:52,093 --> 00:10:58,138
做的，如果应用程序调用马利克 

209
00:10:56,529 --> 00:11:01,990
马利克必须马上它可能响应

210
00:10:59,038 --> 00:11:03,117
你也许可以做一个更好的更 

211
00:11:01,099 --> 00:11:04,168
有效的版本， 按配料了 

212
00:11:03,459 --> 00:11:06,551
请求 ，然后响应所有 

213
00:11:05,068 --> 00:11:08,687
同时这些请求

214
00:11:07,379 --> 00:11:10,472
但分配器不能当它这样做 

215
00:11:09,299 --> 00:11:14,345
被调用时 ， 必须 处理 

216
00:11:11,309 --> 00:11:15,395
请求， 然后立即返回 它 

217
00:11:14,759 --> 00:11:17,777
有，当然有 分配 

218
00:11:16,169 --> 00:11:20,198
从空闲内存块，因此它不能 

219
00:11:17,939 --> 00:11:22,007
总的来说，我不能碰 任何分配 

220
00:11:20,459 --> 00:11:24,518
阻断右一旦它分配一个块 

221
00:11:22,619 --> 00:11:28,634
该块所属的应用程序 

222
00:11:25,049 --> 00:11:31,136
和malloc的包 无法触摸它 

223
00:11:28,769 --> 00:11:36,797
现在这个有一些影响， 这样 

224
00:11:31,919 --> 00:11:38,945
这意味着分配器不就可以了 

225
00:11:37,049 --> 00:11:40,142
不能走动块喜欢的话可以不 

226
00:11:39,179 --> 00:11:43,196
压缩块鳄鱼般的力量

227
00:11:40,979 --> 00:11:45,720
要采取分配的块和smoosh 

228
00:11:43,349 --> 00:11:48,362
他们都共同创造 更大的自由 

229
00:11:45,072 --> 00:11:50,891
块不错，但它不能这样做， 所以没关系 

230
00:11:48,479 --> 00:11:54,535
一旦你在 像C 语言知道 一旦 

231
00:11:51,539 --> 00:11:57,565
一旦鳄鱼给出了一个块到

232
00:11:55,039 --> 00:12:01,043
应用程序不能触摸它

233
00:11:57,799 --> 00:12:02,846
现在没事了块像块，因为 

234
00:12:01,439 --> 00:12:06,527
块保持的数据结构如

235
00:12:03,269 --> 00:12:10,271
结构或你认识的标标 

236
00:12:07,319 --> 00:12:11,417
反对它必须对齐大小 

237
00:12:10,289 --> 00:12:14,381
最大的对象 ， 它可以 

238
00:12:12,299 --> 00:12:18,314
所以对于64位系统这是发生没关系

239
00:12:15,209 --> 00:12:21,470
用于32位系统16字节对齐 

240
00:12:18,449 --> 00:12:21,470
这是 8字节对齐 

241
00:12:23,072 --> 00:12:28,158
现在短吻鳄是真的很有趣

242
00:12:26,779 --> 00:12:33,330
对象，因为他们他们结合了

243
00:12:29,058 --> 00:12:35,124
这两个种类 的运行 时间 的权衡

244
00:12:33,033 --> 00:12:38,061
那种速度和空间，因此它是一种 

245
00:12:36,024 --> 00:12:40,029
一个空间和性能的权衡你

246
00:12:38,061 --> 00:12:42,350
试图以优化 你 想让它 

247
00:12:40,029 --> 00:12:44,034
运行尽可能 快的 ，但 你要 

248
00:12:42,899 --> 00:12:47,010
用你 想要使用虚拟 

249
00:12:44,079 --> 00:12:50,082
存储器堆中 尽可能有效地 

250
00:12:47,001 --> 00:12:56,018
可能还好所以现在我们定义让我们 

251
00:12:50,082 --> 00:12:58,164
这些这些排序的速度和和 

252
00:12:56,018 --> 00:13:01,035
效率内存效率指标我们 

253
00:12:59,064 --> 00:13:03,087
有，我们有我们使用一个两个指标

254
00:13:01,035 --> 00:13:07,068
如此提供所谓的吞吐量一些

255
00:13:03,087 --> 00:13:11,100
（）和malloc的序列自由请求是 

256
00:13:07,068 --> 00:13:15,144
0至 R n 减1，从而只是一些地方 

257
00:13:12,000 --> 00:13:20,001
R 是一个malloc或 免费的 我们的目标是 

258
00:13:16,044 --> 00:13:23,123
以最大化吞吐量和峰值 

259
00:13:20,001 --> 00:13:25,670
内存利用率，是什么让的malloc 

260
00:13:23,519 --> 00:13:28,440
这样的迷人和有趣的研究

261
00:13:25,769 --> 00:13:31,260
是，这些 往往喜欢它的冲突 

262
00:13:28,044 --> 00:13:33,063
很容易做出 一个非常快的malloc 

263
00:13:31,026 --> 00:13:37,101
以使得具有可怕的记忆

264
00:13:33,063 --> 00:13:40,068
利用这样的吞吐量仅仅是

265
00:13:38,001 --> 00:13:43,450
每单位重新计算请求的数目

266
00:13:40,068 --> 00:13:46,125
时间，让我们有 5000 malloc的调用和 

267
00:13:43,459 --> 00:13:49,110
在10秒内5000个免费电话，然后我们 

268
00:13:47,025 --> 00:13:52,068
吞吐量是每一千操作 

269
00:13:49,011 --> 00:13:55,047
第二所以它只是衡量排序 

270
00:13:52,068 --> 00:13:56,097
如何有效是我们的malloc可以可以

271
00:13:55,047 --> 00:13:59,054
处理来自这些请求

272
00:13:56,097 --> 00:13:58,154
应用 

273
00:14:00,001 --> 00:14:11,020
现在高峰内存利用率是衡量

274
00:14:06,067 --> 00:14:13,114
如何排序多少有用的空间排序 

275
00:14:11,029 --> 00:14:16,075
多少它的措施如何有效 

276
00:14:14,014 --> 00:14:19,027
分配器可使用热之类的怎么样 

277
00:14:16,075 --> 00:14:20,116
多浪费在这类开销在 

278
00:14:19,027 --> 00:14:24,120
数据结构，所述分配器 

279
00:14:21,016 --> 00:14:29,062
在其方案中使用我们 

280
00:14:25,002 --> 00:14:32,086
因此，我们将定义一个有效载荷时，当 

281
00:14:29,062 --> 00:14:34,066
的malloc返回一个块时，我什么

282
00:14:33,004 --> 00:14:37,045
抱歉，当应用程序进行调用 

283
00:14:34,066 --> 00:14:39,142
对malloc这是一个 探路 一定规模 

284
00:14:37,045 --> 00:14:42,091
块 与 该块被称为 

285
00:14:40,042 --> 00:14:45,088
有效载荷，所以如果我们调用malloc与

286
00:14:42,091 --> 00:14:48,097
10个字节 我们请求一个 说法 

287
00:14:45,088 --> 00:14:51,097
块有它的有效载荷是在 

288
00:14:48,097 --> 00:14:52,153
至少10大小确定和 10个字节，其 

289
00:14:51,097 --> 00:14:54,178
我们要求 被称为有效载荷 

290
00:14:53,053 --> 00:14:58,086
一切都在那个块是其他

291
00:14:55,078 --> 00:14:58,086
开销确定 

292
00:15:00,024 --> 00:15:08,063
打完之后，我们已经运行的序列 

293
00:15:04,019 --> 00:15:10,085
要求总有效载荷是

294
00:15:08,279 --> 00:15:13,860
在目前所有的有效载荷的总和

295
00:15:10,679 --> 00:15:16,757
分配块好了，所以在一个完美的 

296
00:15:13,086 --> 00:15:20,105
分配器的总有效载荷 

297
00:15:17,459 --> 00:15:22,514
将将将等于的量 

298
00:15:20,879 --> 00:15:23,930
内存的所有总规模 

299
00:15:23,009 --> 00:15:26,102
分配的块或因为有会是 

300
00:15:24,389 --> 00:15:30,433
没有开销也只是 也只是 

301
00:15:26,939 --> 00:15:30,028
纯的每个块将是纯的有效载荷 

302
00:15:32,072 --> 00:15:37,691
现在我们要假定堆 

303
00:15:35,459 --> 00:15:40,541
是单调非递减，因此

304
00:15:38,339 --> 00:15:43,358
总是得到更大的好了 ，所以 我们这是一个 

305
00:15:41,279 --> 00:15:46,050
简化假设它 没有它不是 

306
00:15:43,529 --> 00:15:47,533
在一个真正的malloc包真实的，但我们会 

307
00:15:46,005 --> 00:15:50,234
只是假设，分配器从来没有 

308
00:15:47,929 --> 00:15:56,930
减小堆的 大小 ，只 

309
00:15:50,279 --> 00:15:59,610
增加堆的大小好了， 

310
00:15:57,029 --> 00:16:03,110
鉴于偷看那些给出这些概念 

311
00:15:59,061 --> 00:16:06,129
骨料有效载荷和堆大小的

312
00:16:03,839 --> 00:16:11,900
k加1后的峰值存储器利用率 

313
00:16:07,029 --> 00:16:15,578
要求是所有的总和是 

314
00:16:12,449 --> 00:16:20,730
由分割的所有有效载荷的总和

315
00:16:15,839 --> 00:16:24,844
堆的总大小，因此在 

316
00:16:20,073 --> 00:16:27,111
最好的情况下的每个中的每个堆块 

317
00:16:25,339 --> 00:16:30,388
由纯有效载荷因此的

318
00:16:28,011 --> 00:16:33,530
利用将1 这是最好的 

319
00:16:30,829 --> 00:16:36,230
我们可以做的，但 在每次练习 

320
00:16:33,629 --> 00:16:38,681
块分配器是要去的地方

321
00:16:36,023 --> 00:16:43,472
具有内部数据结构和填充

322
00:16:39,149 --> 00:16:46,160
每个阻止这是保持它

323
00:16:43,679 --> 00:16:47,738
从现在得到一个完美的利用 

324
00:16:46,259 --> 00:16:51,341
一个一个明显的一点是，由于 

325
00:16:48,269 --> 00:16:53,282
块必须对齐到一些你 

326
00:16:52,079 --> 00:16:55,127
知道是否有十六岁 的 两条 线 

327
00:16:53,399 --> 00:16:56,498
然后块都由开始于16

328
00:16:55,559 --> 00:16:59,970
边界， 他们必须至少 

329
00:16:57,389 --> 00:17:02,462
16个字节，因此如果你要申请 

330
00:16:59,097 --> 00:17:04,406
2个字节的有效载荷你有很多的 

331
00:17:03,119 --> 00:17:08,150
浪费字节正确的，会有点 

332
00:17:05,279 --> 00:17:10,367
降低利用率，所以这是一些 

333
00:17:08,429 --> 00:17:13,440
一些这方面的一些这种开销是 

334
00:17:11,159 --> 00:17:16,176
不可避免的，但作为你的工作 

335
00:17:13,539 --> 00:17:19,583
有人谁写的 一个工具 是马利克 

336
00:17:16,329 --> 00:17:19,394
要尽量保留尽可能小 

337
00:17:21,449 --> 00:17:26,511
所以内存利用率较低正是这种 

338
00:17:25,449 --> 00:17:29,820
例如，我们刚才讲 的是一个 

339
00:17:27,069 --> 00:17:31,152
例如我们所说的碎片 

340
00:17:29,082 --> 00:17:34,281
而且也有两种类型的 

341
00:17:31,899 --> 00:17:36,951
碎片内部碎片 

342
00:17:35,019 --> 00:17:38,091
发生如果有效载荷 小于 

343
00:17:37,419 --> 00:17:40,500
块大小 的 正是我们 

344
00:17:38,739 --> 00:17:44,790
我们谈论这样就可以 

345
00:17:41,229 --> 00:17:46,720
在块而导致的任何 填充或 

346
00:17:45,249 --> 00:17:51,312
某种数据结构的块中的 

347
00:17:46,072 --> 00:17:53,601
该分配器有时需要 

348
00:17:51,879 --> 00:17:56,895
你可能会做出政策决定 ，如果 

349
00:17:54,249 --> 00:17:59,320
它如果应用程序请求一小块

350
00:17:57,039 --> 00:18:01,098
你可能会返回一个更大的块刚 

351
00:17:59,032 --> 00:18:03,021
保持这样的块没有得到几分 

352
00:18:01,629 --> 00:18:05,694
分裂成小块，你 

353
00:18:03,309 --> 00:18:08,940
可能想保留块在一些

354
00:18:06,279 --> 00:18:08,940
最小尺寸

355
00:18:12,059 --> 00:18:20,066
现在内部碎片 ，你知道 

356
00:18:16,139 --> 00:18:21,224
给出了一系列的要求，我们可以，我们可以 

357
00:18:20,129 --> 00:18:24,191
只是停止和 冻结的热量和它的 

358
00:18:21,989 --> 00:18:26,580
很容易，因此计算量 

359
00:18:24,749 --> 00:18:28,784
内部碎片，我们可以在任何 

360
00:18:26,058 --> 00:18:31,083
在时间点上，我们可以只看 所有 

361
00:18:29,099 --> 00:18:34,124
我们我们所做的以前的请求 

362
00:18:31,083 --> 00:18:37,742
和并期待在有效载荷的大小 

363
00:18:34,349 --> 00:18:43,200
这些请求中的每一个，因此我们 

364
00:18:38,489 --> 00:18:44,489
可以这样我们就可以判断你的水平 

365
00:18:43,002 --> 00:18:45,821
及时了解情况获得在一个点上，我们可以 

366
00:18:44,489 --> 00:18:48,450
确定的内部水平

367
00:18:46,019 --> 00:18:52,073
碎片 只是通过看 

368
00:18:48,045 --> 00:18:54,584
以前的请求 ，因此有另 

369
00:18:52,559 --> 00:18:55,655
碎片的形式称为外部

370
00:18:54,989 --> 00:19:00,002
碎片是多一点 

371
00:18:56,519 --> 00:19:01,615
很难对付这样的外部 

372
00:19:00,119 --> 00:19:05,174
当有足够的发生碎裂 

373
00:19:02,479 --> 00:19:07,556
内存堆中，但有有 

374
00:19:05,669 --> 00:19:10,676
没有单一的自由块可满足 

375
00:19:08,249 --> 00:19:12,347
特定请求 确定，所以外部 

376
00:19:10,739 --> 00:19:15,742
碎片时发生 

377
00:19:13,229 --> 00:19:18,268
应用使一个块的请求 

378
00:19:15,769 --> 00:19:21,818
但无处在堆中有一个免费的

379
00:19:18,619 --> 00:19:24,637
块的大到足以满足 

380
00:19:22,259 --> 00:19:24,313
该请求 

381
00:19:25,073 --> 00:19:29,144
所以这样的一个例子 假设 

382
00:19:28,022 --> 00:19:32,851
这里是我们看着前面的例子 

383
00:19:30,044 --> 00:19:36,107
现在，我们有经过一系列的

384
00:19:33,049 --> 00:19:39,950
malloc和免费电话，我们有两个免费 

385
00:19:37,007 --> 00:19:41,075
在含有5堆一个块

386
00:19:39,095 --> 00:19:43,294
单词和另 一种含有两个词 

387
00:19:41,075 --> 00:19:45,173
所以总的自由总数 

388
00:19:44,149 --> 00:19:51,174
在我们堆的话是七七话 

389
00:19:46,073 --> 00:19:54,022
现在我们得到 六个字 的 要求 

390
00:19:51,399 --> 00:19:57,860
还好我们有我们有足够的空闲块 

391
00:19:54,679 --> 00:20:00,685
在人堆里， 但是 我们足够的话

392
00:19:57,086 --> 00:20:02,905
不能满足这一要求，它的 

393
00:20:01,279 --> 00:20:05,600
因为 它是因为 这个 

394
00:20:03,679 --> 00:20:09,727
现象称为外部碎片 

395
00:20:05,006 --> 00:20:12,070
例如，如果我们不得不如果我们不得不 

396
00:20:10,159 --> 00:20:13,240
不知何故分配

397
00:20:17,063 --> 00:20:20,145
是啊，我不知道在这种情况下， 我不 

398
00:20:19,071 --> 00:20:23,109
我想 我们本来 可以避免外部 

399
00:20:21,045 --> 00:20:25,137
碎片，但仍然有 

400
00:20:24,009 --> 00:20:29,034
足够的内存在这里我们只是它的方式 

401
00:20:26,037 --> 00:20:31,095
我们的模块 在配置 

402
00:20:29,034 --> 00:20:34,047
堆，我们不能满足该 请求，以便在 

403
00:20:31,095 --> 00:20:35,139
这本在这种情况下，该 

404
00:20:34,047 --> 00:20:39,236
分配器具有去获得更多的更 

405
00:20:36,039 --> 00:20:40,568
虚拟内存会去 和 它 

406
00:20:39,659 --> 00:20:43,736
必须获得更多的虚拟内存 

407
00:20:40,919 --> 00:20:47,580
和扩展堆了这种方式，并 

408
00:20:44,429 --> 00:20:49,517
得到一个 足够 大 的空闲块，所以你 

409
00:20:47,058 --> 00:20:52,097
知道评估和体悟 

410
00:20:50,309 --> 00:20:54,395
外部碎片很难 

411
00:20:52,097 --> 00:20:57,676
因为不像内部碎片 

412
00:20:55,169 --> 00:21:01,181
其依赖于先前的请求 

413
00:20:58,549 --> 00:21:04,020
外部碎片取决于未来

414
00:21:01,289 --> 00:21:06,630
请求因此，如果我们在 此 回顾 

415
00:21:04,002 --> 00:21:09,075
一点上，我们说的 是 我们的就是我们的堆 

416
00:21:06,063 --> 00:21:12,242
外部碎片以及我们这取决于

417
00:21:09,075 --> 00:21:14,121
正确的，我们不能说原来它是 

418
00:21:12,809 --> 00:21:17,490
因为下一个请求是为 

419
00:21:15,021 --> 00:21:19,460
大小的6块，但如果所有的 

420
00:21:17,049 --> 00:21:21,458
未来块 是未来的要求是 

421
00:21:19,649 --> 00:21:24,000
四个 ，你 下面我们 四个街区知道 

422
00:21:21,899 --> 00:21:26,730
说小块，然后 我们才能 

423
00:21:24,000 --> 00:21:28,049
满足这些，我们不会，我们 

424
00:21:26,073 --> 00:21:29,120
不会从 外部 遭受 

425
00:21:28,049 --> 00:21:30,200
碎片

426
00:21:32,096 --> 00:21:41,174
现在没事了，当我们建立一个 所有 鳄鱼 

427
00:21:37,085 --> 00:21:43,157
各种各样的问题来 了， 说我有 

428
00:21:42,074 --> 00:21:48,140
轻轻带过我简单的例子 

429
00:21:44,057 --> 00:21:51,116
正确的 你知道我们怎么 知道，如果我们所说的 

430
00:21:49,004 --> 00:21:53,090
免费如何免费知道多少内存 

431
00:21:52,016 --> 00:21:56,039
腾出正确的，我们不叫自由搭配 

432
00:21:54,026 --> 00:21:59,045
块大小，我们用指针调用它 

433
00:21:56,039 --> 00:22:02,108
所以如何做 三知道如何之大， 

434
00:21:59,045 --> 00:22:08,120
块是我们如何保持跟踪所有 

435
00:22:03,008 --> 00:22:11,101
空闲块时，我们有你知道什么时候

436
00:22:09,002 --> 00:22:13,073
我们要满足分配请求

437
00:22:12,001 --> 00:22:16,066
我们要争取我们要去看看 

438
00:22:13,091 --> 00:22:19,106
为空闲块比所述较大 

439
00:22:16,066 --> 00:22:21,092
对这种情况下做什么所需大小

440
00:22:20,006 --> 00:22:25,010
我们做与块的额外空间 

441
00:22:21,092 --> 00:22:25,166
我们做我们只是 把它放在你的块 

442
00:22:25,001 --> 00:22:29,027
了解和受苦一些内部 

443
00:22:26,066 --> 00:22:33,122
碎片做我们拆分块 

444
00:22:29,036 --> 00:22:36,133
成更小的块 有很多 的 

445
00:22:34,022 --> 00:22:39,083
在空闲块堆中我们怎么样 

446
00:22:37,033 --> 00:22:42,035
当我们做一个出来的时候， 分配器 

447
00:22:39,083 --> 00:22:43,145
获得一个分配请求是怎么做的 

448
00:22:42,053 --> 00:22:44,141
从所有挑中所有的

449
00:22:44,045 --> 00:22:50,099
不同的空闲块

450
00:22:45,041 --> 00:22:52,136
有很多选择 ，然后一旦当 

451
00:22:50,099 --> 00:22:55,112
免费尝试插入空闲块我们 

452
00:22:53,036 --> 00:22:58,064
在人堆里你知道它在哪里 

453
00:22:56,012 --> 00:23:01,040
插入它好时，它的时候 它是免费的 

454
00:22:58,064 --> 00:23:03,089
以及我们如何重新插入空闲块什么

455
00:23:01,004 --> 00:23:07,052
这是否意味着今天， 所以 我们要去 

456
00:23:03,089 --> 00:23:10,106
看看所有这些问题 开始 

457
00:23:07,088 --> 00:23:13,166
有知道多少免费的，所以有多大 

458
00:23:11,006 --> 00:23:19,049
我们的块大小，因此典型 

459
00:23:14,066 --> 00:23:20,132
标准方法是保持排序的

460
00:23:19,049 --> 00:23:23,090
在年初字大小的量 

461
00:23:21,032 --> 00:23:27,113
每个 给出的所述大小的 块 

462
00:23:23,009 --> 00:23:30,067
阻断在一些 单位，我向他们展示 

463
00:23:28,013 --> 00:23:35,051
在这里字长单位好了，所以，如果 

464
00:23:31,048 --> 00:23:37,097
如果应用程序马利克是 一个有效载荷 

465
00:23:35,051 --> 00:23:42,140
大小要要 像现在的有效载荷 

466
00:23:37,097 --> 00:23:44,110
四个大小则分配器需要 

467
00:23:43,004 --> 00:23:49,413
找块

468
00:23:45,001 --> 00:23:51,570
大小五个因此由四个 

469
00:23:49,809 --> 00:23:54,843
有效载荷字至少四个有效载荷 

470
00:23:51,669 --> 00:23:57,731
字，然后报头块必须是 

471
00:23:55,149 --> 00:24:00,700
一开始是一个字头

472
00:23:58,289 --> 00:24:03,294
表示的尺寸的总尺寸 

473
00:24:00,007 --> 00:24:05,616
该块 ，然后将它返回一个指针 

474
00:24:03,789 --> 00:24:09,360
P0 在这种情况下的开始 

475
00:24:06,309 --> 00:24:09,360
有效载荷好吗 

476
00:24:11,008 --> 00:24:15,059
好了，现在我们知道 每块 有多大 

477
00:24:14,021 --> 00:24:17,087
是，是很简单的 ，以及我们如何保持 

478
00:24:16,031 --> 00:24:20,117
跟踪空闲块的， 这是 

479
00:24:17,087 --> 00:24:22,133
它 有趣的 是最简单 

480
00:24:21,017 --> 00:24:26,108
方法是使用我们称之为 

481
00:24:23,033 --> 00:24:30,110
隐列表免费的隐式列表 

482
00:24:27,008 --> 00:24:33,080
块和这里的想法 是只放 

483
00:24:31,001 --> 00:24:38,045
在每一个块的 前部的头

484
00:24:33,008 --> 00:24:39,077
无论是分配的还是免费的 ，堆 

485
00:24:38,054 --> 00:24:41,111
那么我们就可以使用 起始于 

486
00:24:40,049 --> 00:24:47,060
堆的开始，我们可以使用 

487
00:24:42,011 --> 00:24:49,103
大小走路堆好了，这里有一个 

488
00:24:47,006 --> 00:24:52,028
大小的 5块，所以我们可以，我们可以 跳 

489
00:24:50,003 --> 00:24:57,047
我们知道下一块开始在 

490
00:24:52,082 --> 00:24:59,084
五与 第二块，我们偏移

491
00:24:57,047 --> 00:25:01,106
知道再下一块开始于 

492
00:24:59,084 --> 00:25:04,138
四个偏移等 

493
00:25:02,006 --> 00:25:07,070
好了，所以我们把它称为一个隐含的空闲列表 

494
00:25:05,038 --> 00:25:09,110
因为有有没有真正的名单 

495
00:25:07,007 --> 00:25:12,008
免费块，但我们不能我们 不能 

496
00:25:10,001 --> 00:25:17,072
反向所有的空闲块的 

497
00:25:12,008 --> 00:25:18,083
堆通过遍历所有的块 

498
00:25:17,081 --> 00:25:22,135
在热，然后就忽略 

499
00:25:19,055 --> 00:25:22,063
分配的块好了， 

500
00:25:25,037 --> 00:25:29,096
现在我们可以做的另一件事是 ，我们 

501
00:25:27,017 --> 00:25:31,115
实际上可以使用 一些些的 

502
00:25:29,096 --> 00:25:34,178
在块中的字来创建 

503
00:25:32,015 --> 00:25:39,097
某种 链表 单独 

504
00:25:35,078 --> 00:25:42,122
或双向链表 ，在这种情况下， 

505
00:25:39,097 --> 00:25:47,156
我们是自由的显式列表 

506
00:25:43,022 --> 00:25:50,036
块，我们就可以在 这个列表 里 如此 

507
00:25:48,056 --> 00:25:52,154
我们在这里，我们参观的第一个空闲块

508
00:25:50,036 --> 00:25:56,045
然后有一个指向下一个 

509
00:25:53,054 --> 00:25:57,056
空闲块等等所以这个你看 

510
00:25:56,045 --> 00:25:59,138
这可能是一个小更高效 

511
00:25:57,074 --> 00:26:03,170
因为如果我们想要自由穿越 

512
00:26:00,038 --> 00:26:07,043
列出在这种情况下，如果它的 将是 

513
00:26:04,007 --> 00:26:08,039
有序列表 中 的块数

514
00:26:07,043 --> 00:26:10,091
还好它会 在被线性 

515
00:26:09,002 --> 00:26:13,016
在堆 块的总数 ，其 

516
00:26:10,091 --> 00:26:16,094
可能是 相当大的 可能有很多 

517
00:26:13,016 --> 00:26:20,113
的分配块在这种情况下用

518
00:26:16,094 --> 00:26:22,150
显式列表中的任意穿越才刚刚是 

519
00:26:21,013 --> 00:26:26,050
在空闲列表的大小呈线性关系

520
00:26:23,005 --> 00:26:26,005
题 

521
00:26:29,026 --> 00:26:34,065
是啊，这问题是 我们不 

522
00:26:31,051 --> 00:26:36,147
需要一个免费的一下，我们这样做， 我会我们 

523
00:26:34,299 --> 00:26:37,470
有那下一个问题 

524
00:26:44,076 --> 00:26:48,157
现在另一种方法更复杂 

525
00:26:47,002 --> 00:26:52,057
方法，而不是具有一个自由列表 

526
00:26:49,057 --> 00:26:55,066
我们可以有多个空闲列表哪里 

527
00:26:52,057 --> 00:27:00,072
每个自由列表中包含的块

528
00:26:55,066 --> 00:27:00,072
一定的大小或一定范围内的 尺寸 的 

529
00:27:02,043 --> 00:27:09,082
或者我们可以得到真正看中的 ，并使用一些 

530
00:27:05,023 --> 00:27:12,102
那种某种平衡树 来 的 

531
00:27:09,082 --> 00:27:16,096
块排序使用树 排序 

532
00:27:12,309 --> 00:27:19,390
他们按大小顺序现在今天我们 

533
00:27:16,096 --> 00:27:21,145
看隐含名单 

534
00:27:19,039 --> 00:27:24,070
最简单的空闲列表，这将 

535
00:27:22,045 --> 00:27:27,024
找出了很多基本概念 

536
00:27:24,007 --> 00:27:34,009
在更复杂的免费 使用 

537
00:27:27,429 --> 00:27:36,490
名单的问题 还好，问题是什么 

538
00:27:34,072 --> 00:27:38,080
你什么意思，我们通过不同的自由 

539
00:27:36,049 --> 00:27:43,114
针对不同规模类列表等什么 

540
00:27:39,052 --> 00:27:47,091
我的意思 是，你确定 一系列的 

541
00:27:44,014 --> 00:27:49,108
尺寸和您 范围内 关联 

542
00:27:47,559 --> 00:27:52,630
与这些个人自由列表 

543
00:27:50,008 --> 00:27:56,020
好了，所以一个空闲列表可能会保留块 

544
00:27:52,063 --> 00:27:58,101
大小0-8和其他空闲列表 

545
00:27:56,002 --> 00:28:02,047
可能拥有大小9块到16 

546
00:27:59,001 --> 00:28:06,055
其他另一个自由列表可能17 

547
00:28:02,065 --> 00:28:09,154
32 你知道一些，因此你 

548
00:28:06,055 --> 00:28:12,564
保证你现在知道，当你 

549
00:28:10,054 --> 00:28:14,107
穿越你知道某个列表 

550
00:28:13,059 --> 00:28:20,110
在于：所述块的大小的范围

551
00:28:15,007 --> 00:28:23,080
列出你可能想要 做的原因

552
00:28:20,011 --> 00:28:28,012
通过的方式是，想像 你有 

553
00:28:23,008 --> 00:28:31,012
这些列表一个无限 多 

554
00:28:28,012 --> 00:28:34,060
对于每 一次 每一个可能的大小，然后 

555
00:28:32,002 --> 00:28:37,045
您分配的块，你会得到一个块 

556
00:28:34,006 --> 00:28:38,032
正是大小的你需要这样 

557
00:28:37,063 --> 00:28:40,090
有会是最小量 

558
00:28:38,086 --> 00:28:42,171
碎片如果你有无限 

559
00:28:40,009 --> 00:28:45,058
这些这些尺寸课程数量 

560
00:28:43,071 --> 00:28:47,167
现在，如果我们当然我们不能 有 

561
00:28:46,039 --> 00:28:50,074
无限数量，但这些更

562
00:28:48,067 --> 00:28:52,140
大小班，我们越是接近 

563
00:28:50,074 --> 00:28:52,140
这个理想 

564
00:28:54,049 --> 00:29:00,134
没事所以让我们看看 会怎样 

565
00:28:56,087 --> 00:29:03,128
建立隐含免费 列表 ，从而你 

566
00:29:01,034 --> 00:29:06,095
正确地指出来为每个每个

567
00:29:04,028 --> 00:29:17,075
块中，我们需要，我们需要双方 和 

568
00:29:06,095 --> 00:29:20,119
分配状态的问题，为什么 我们不能 

569
00:29:17,075 --> 00:29:20,119
映射各种规模类 

570
00:29:31,086 --> 00:29:36,655
是的，这就是为什么我们不能有一个 

571
00:29:34,008 --> 00:29:37,357
大小类别的无限数量的 

572
00:29:41,024 --> 00:29:47,033
我想你 知道会是一个 

573
00:29:44,066 --> 00:29:49,145
要想想有趣的策略 

574
00:29:48,014 --> 00:29:52,112
所以你不能有无限多 

575
00:29:50,045 --> 00:29:55,070
大小类，但你可以创建一个新的 

576
00:29:53,012 --> 00:29:59,063
大小类为每一个新的大小，你 

577
00:29:55,007 --> 00:30:01,028
得到和那可能只是工作，但它 

578
00:29:59,063 --> 00:30:04,070
取决于这些尺寸的范围内 

579
00:30:01,091 --> 00:30:07,094
类的频率和一个 

580
00:30:04,007 --> 00:30:11,060
你 可能有 问题 的是你，你 

581
00:30:08,021 --> 00:30:13,106
会得到也许如果你只得到它 

582
00:30:12,023 --> 00:30:15,110
取决于分配你的 

583
00:30:14,006 --> 00:30:17,105
你得到，如果你得到 一个 尺寸 

584
00:30:16,001 --> 00:30:20,090
同等数量的，如果你的分布 

585
00:30:18,005 --> 00:30:22,082
尺寸是 相当 一致的那 会 

586
00:30:20,099 --> 00:30:26,123
可能 工作得很好，如果你 

587
00:30:22,082 --> 00:30:27,164
得到，如果你有要求，如果你 

588
00:30:27,023 --> 00:30:31,061
有很多不同的 要求 

589
00:30:28,064 --> 00:30:35,081
大小级你有很多种类的 

590
00:30:31,061 --> 00:30:37,109
浪费空闲 列表，我认为正确的所以它的 

591
00:30:35,081 --> 00:30:40,135
一个很好的问题这取决于它依赖 

592
00:30:38,009 --> 00:30:45,026
您的工作负荷和那里，这是 

593
00:30:41,035 --> 00:30:48,041
为 ，这是一个非常有用的 

594
00:30:45,026 --> 00:30:50,125
战略，所以你如果有真 

595
00:30:48,041 --> 00:30:53,087
流行的尺寸班在您的要求 

596
00:30:51,025 --> 00:30:57,026
那么你可以只让你知道 

597
00:30:53,087 --> 00:30:59,114
特殊情况下的特殊情况下，免费名单 

598
00:30:57,035 --> 00:31:02,042
处理这些请求，然后再 

599
00:31:00,014 --> 00:31:05,015
让对方自由列表排序手柄的 

600
00:31:02,042 --> 00:31:06,065
更广泛的想象，如果你有一个 

601
00:31:05,015 --> 00:31:08,081
空闲列表，所有的块是在

602
00:31:06,065 --> 00:31:10,118
同样也可能是很多更有效 

603
00:31:08,081 --> 00:31:13,169
正确的，因为你不仅会 内特你 

604
00:31:11,018 --> 00:31:16,043
需要像一个位向量1 1比特用于每个 

605
00:31:14,069 --> 00:31:18,113
潜在的块来告诉你 它 是否 

606
00:31:16,043 --> 00:31:20,111
分配或免费的，所以它可能是很 

607
00:31:19,013 --> 00:31:24,019
高效的你不会你就不需要 

608
00:31:21,011 --> 00:31:24,073
走任何任何 列表或任何 

609
00:31:26,003 --> 00:31:29,009
这是一个很好的问题 ，这就是 

610
00:31:28,001 --> 00:31:31,064
那种你会想的事情

611
00:31:29,036 --> 00:31:35,113
当你做你的Mallik实验室是 一个 

612
00:31:31,073 --> 00:31:38,141
在有一个巨大的设计空间

613
00:31:36,013 --> 00:31:41,030
实现malloc函数，我们只是 

614
00:31:39,041 --> 00:31:43,060
我们只是探讨它的一个小部分 

615
00:31:41,003 --> 00:31:46,094
现在 

616
00:31:43,006 --> 00:31:50,030
所以用这种隐含列表中，我们要去

617
00:31:47,021 --> 00:31:52,240
需要块的大小和 

618
00:31:50,084 --> 00:31:53,180
那么它的分配状态无论 是 

619
00:31:52,429 --> 00:31:56,480
分配或免费，现在我们可以做到这一点

620
00:31:54,008 --> 00:31:56,039
在两个单词权利， 但 会 

621
00:31:56,048 --> 00:31:59,072
浪费

622
00:31:57,011 --> 00:32:01,094
所以标准的关键是要采取 

623
00:31:59,072 --> 00:32:04,531
优势的 事实，有块 

624
00:32:01,094 --> 00:32:05,123
对齐好了，所以这实际上是 

625
00:32:05,179 --> 00:32:08,242
这是一种痛苦的在脖子上 

626
00:32:06,023 --> 00:32:10,102
总是要调整这些块，但我们 

627
00:32:08,809 --> 00:32:13,460
可以利用它在这种情况下， 

628
00:32:10,309 --> 00:32:16,610
其原因 是，如果一个块是 

629
00:32:13,046 --> 00:32:18,092
由8个或16个字节对齐，有的说8 

630
00:32:16,061 --> 00:32:20,123
边界则低阶位是 

631
00:32:18,092 --> 00:32:22,169
总是为0， 所以如果它对齐 

632
00:32:21,023 --> 00:32:25,055
为8字节边界的低位 

633
00:32:23,069 --> 00:32:32,132
三个 低位3位将 

634
00:32:25,055 --> 00:32:38,120
始终为0右8是1 0 0 0 16 1与 

635
00:32:33,032 --> 00:32:46,055
4个零24 1 1 0 0 0 右 所以有 任何 

636
00:32:39,002 --> 00:32:48,026
任何8字节 任何8字节对齐 块具有 

637
00:32:46,055 --> 00:32:50,120
是大小为8，它必须开始 

638
00:32:48,044 --> 00:32:55,061
地址是8 没事 多 

639
00:32:51,002 --> 00:33:00,044
所以那些大小 所以 总是大小 

640
00:32:55,061 --> 00:33:03,122
该块将总是具有 0 2 3 3或 4 

641
00:33:00,062 --> 00:33:05,063
设置0的低位 ，所以我们可以采取 

642
00:33:04,022 --> 00:33:09,083
它可以利用 这一 优势 ， 

643
00:33:05,072 --> 00:33:11,125
我们只是做我们只能 一只 眼睛 

644
00:33:09,083 --> 00:33:14,087
我们只是 有一个报头字和 

645
00:33:12,025 --> 00:33:19,034
我们将使用低阶 位存储 

646
00:33:15,023 --> 00:33:21,086
分配状态很好，而且我们 可以做 

647
00:33:19,034 --> 00:33:25,040
因为我们 知道 它总是 零，因此 

648
00:33:21,086 --> 00:33:26,120
当我们使我们使用低次位 

649
00:33:25,004 --> 00:33:29,075
存储分配情况，然后

650
00:33:27,002 --> 00:33:32,039
剩余的位对应于所述大小 

651
00:33:30,011 --> 00:33:35,033
然后，每当我们要提取的 

652
00:33:32,057 --> 00:33:37,076
大小我们只是掩盖了这种分配

653
00:33:35,033 --> 00:33:40,036
状态，并始终将其设置为零，因为 

654
00:33:37,076 --> 00:33:39,163
我们知道，这是零 

655
00:33:47,789 --> 00:33:54,850
所以让我们看看具体是什么给这个

656
00:33:51,019 --> 00:33:58,608
给出这种形式的隐性列表 我们如何 

657
00:33:54,085 --> 00:34:01,111
也许在这种情况下，一些事情， 从而 

658
00:33:58,779 --> 00:34:06,010
我们要承担咬词 

659
00:34:02,011 --> 00:34:10,048
好大小 的单词和我们要 

660
00:34:06,001 --> 00:34:12,028
八个字节边界对齐好了， 

661
00:34:10,048 --> 00:34:13,147
记得我们的块的有效载荷 

662
00:34:12,028 --> 00:34:17,029
总是要开始的八八 

663
00:34:14,047 --> 00:34:19,176
字节边界，所以我们做到这一点的方法是 

664
00:34:17,029 --> 00:34:21,073
我们在创建这个未使用的字 

665
00:34:19,599 --> 00:34:25,300
开始是对排列堆 

666
00:34:21,073 --> 00:34:29,074
这一个八字节边界，然后说 

667
00:34:25,003 --> 00:34:31,099
在堆中的第一个块开始于一个 

668
00:34:29,083 --> 00:34:33,154
从从四个偏移

669
00:34:32,026 --> 00:34:39,195
开始堆的，所以我们有 

670
00:34:34,054 --> 00:34:41,643
报头是不对准，然后 

671
00:34:39,429 --> 00:34:44,260
我们有以下的有效载荷

672
00:34:42,129 --> 00:34:48,204
这种情况下，在一个一个字的有效载荷 

673
00:34:44,026 --> 00:34:50,098
而开始于这一点，开始上 

674
00:34:48,879 --> 00:34:54,700
这本单词边界 ， 然后 

675
00:34:50,098 --> 00:34:58,131
下一个块，在这里我们要说明 

676
00:34:54,007 --> 00:35:02,406
空闲块包括八个字节 

677
00:34:59,031 --> 00:35:05,104
然后是，再接一个分配 

678
00:35:03,099 --> 00:35:09,960
阻止这里的 十六个字节的一个

679
00:35:06,004 --> 00:35:09,096
或4名 前锋 

680
00:35:10,095 --> 00:35:16,173
现在的有效载荷只有两个字如此

681
00:35:15,000 --> 00:35:19,044
我们要垫右侧 我们 所有 的块 

682
00:35:17,073 --> 00:35:21,075
因为我们假定他们是 

683
00:35:19,044 --> 00:35:23,052
内衬八个字节边界，我们所有的 

684
00:35:21,093 --> 00:35:25,101
块必须是尺寸的倍数 

685
00:35:24,024 --> 00:35:28,050
所以这里 8 还好的多是中 

686
00:35:26,073 --> 00:35:30,120
内部分裂的情况下，我们 

687
00:35:28,005 --> 00:35:31,083
有这样的额外这个额外的块

688
00:35:31,002 --> 00:35:34,631
为了保持对准 

689
00:35:32,028 --> 00:35:39,099
要求，使得确保了

690
00:35:34,829 --> 00:35:43,950
下一个块的有效载荷开始于一个8 

691
00:35:39,099 --> 00:35:44,142
字节 对齐边界 等等 ，所以我们 

692
00:35:43,095 --> 00:35:46,179
可以只是简单地跟着走这堆 

693
00:35:45,042 --> 00:35:51,104
这些头屏蔽掉分配 

694
00:35:47,079 --> 00:35:59,588
位，然后我们有这个特殊的 

695
00:35:52,004 --> 00:36:04,038
事件负载 

696
00:36:00,299 --> 00:36:06,990
它的大小 为0 的分配块 

697
00:36:04,038 --> 00:36:09,099
这是这是 一招 ，这 是一个 

698
00:36:06,099 --> 00:36:10,176
欺骗你应该 使用 过 所以这和 

699
00:36:09,099 --> 00:36:13,658
我们会看到，当我们 看看为什么合并 

700
00:36:11,076 --> 00:36:15,170
这就是为什么这会有所帮助，但这个本 

701
00:36:14,549 --> 00:36:18,960
在最后分配的块

702
00:36:16,007 --> 00:36:20,061
消除某种 特殊情况 

703
00:36:18,096 --> 00:36:22,149
当 我们当我们 开始合并免费 

704
00:36:21,024 --> 00:36:27,613
块，我们将 在刚刚 谈论 

705
00:36:23,049 --> 00:36:31,140
一只是 一瞬间，但你可以完成你的 

706
00:36:27,829 --> 00:36:34,920
存在此分配的大小0的块是 

707
00:36:32,004 --> 00:36:36,203
也有利于在当你终止 

708
00:36:34,092 --> 00:36:38,127
走在这条列表，你可以，你可以查 

709
00:36:36,599 --> 00:36:42,200
对于大小为 0 的大小分配块 

710
00:36:39,027 --> 00:36:41,120
终止搜索 

711
00:36:43,013 --> 00:36:48,027
好了，所以给这种 结构 

712
00:36:45,042 --> 00:36:50,097
那么我们如何找到一个空闲块好吗 

713
00:36:48,027 --> 00:36:52,062
有许多不同的方式 

714
00:36:50,097 --> 00:36:54,162
首先这就是所谓的第一种方式 

715
00:36:52,062 --> 00:36:58,103
首先 第一嵌入是搜索 

716
00:36:55,062 --> 00:37:00,150
从一开始，只是空闲列表

717
00:36:59,003 --> 00:37:07,035
寻找 我们 可以发现 第一块 

718
00:37:01,005 --> 00:37:09,036
满足要求，所以我们是 

719
00:37:07,035 --> 00:37:11,097
分配，我们现在需要 的块 

720
00:37:09,081 --> 00:37:14,088
10号，我们在开始 的 开始 

721
00:37:11,097 --> 00:37:18,123
堆和我们走，我们 走 了 一个列表 

722
00:37:14,088 --> 00:37:22,149
堆找一个空闲块那是在 

723
00:37:19,023 --> 00:37:25,044
至少大小为10，它需要 

724
00:37:23,049 --> 00:37:32,091
实际上，它需要为10 加 

725
00:37:25,044 --> 00:37:35,046
我们的头2所以一旦所以这是一个的大小

726
00:37:32,091 --> 00:37:36,183
简单的想法 ， 现在有些人 有 

727
00:37:35,046 --> 00:37:39,099
提出所谓的下一个合适的替代

728
00:37:37,083 --> 00:37:40,158
所以这里的想法是 ，与其 

729
00:37:39,099 --> 00:37:43,101
开始从每个时间超 

730
00:37:41,058 --> 00:37:46,065
堆开始找块 

731
00:37:44,001 --> 00:37:49,083
它位于 我们只是拿起 我们离开 

732
00:37:46,065 --> 00:37:52,152
最后一 关 时间 好了， 我们来看看我们 

733
00:37:49,083 --> 00:37:54,087
扫描堆，我们发现一个块 的大 

734
00:37:53,052 --> 00:37:56,121
足以满足该请求，然后 

735
00:37:55,023 --> 00:38:00,036
我们记住的是我们离开的地方 

736
00:37:57,021 --> 00:38:02,034
并在下 一次请求到来 

737
00:38:00,036 --> 00:38:04,083
我们拿起搜索开始，我们 

738
00:38:02,034 --> 00:38:06,132
离开现在这好像是一个 

739
00:38:04,083 --> 00:38:08,145
好主意，但但研究皮拉哲 

740
00:38:07,032 --> 00:38:11,073
人们所做的研究表明 

741
00:38:09,045 --> 00:38:15,051
这实际上会导致更糟糕 

742
00:38:11,073 --> 00:38:18,087
碎片化，所以你知道你可以 

743
00:38:15,051 --> 00:38:20,058
可以考虑它，但它通常是 

744
00:38:18,087 --> 00:38:27,096
通常可能不是最好的东西 

745
00:38:20,058 --> 00:38:29,121
现在要做的另一种 选择是找到 

746
00:38:27,096 --> 00:38:32,142
的是， 在热的自由块的块 

747
00:38:30,021 --> 00:38:36,108
在这最适合这么看堆

748
00:38:33,042 --> 00:38:39,090
在 在所有块 一般 看 

749
00:38:37,008 --> 00:38:43,055
堆和找到 适合 的块 

750
00:38:39,009 --> 00:38:45,060
最好的好了，所以，如果 我们问了 10个字节 

751
00:38:43,055 --> 00:38:48,126
尝试扫描热量为块 

752
00:38:46,041 --> 00:38:51,132
有最接近它的10个字节 好吗 

753
00:38:49,026 --> 00:38:55,325
所以这就是所谓的最适合的，这就是 

754
00:38:52,032 --> 00:38:56,261
你可以看到它可能是更多的 是 

755
00:38:55,559 --> 00:38:57,608
听起来这将 是一个很多 

756
00:38:56,549 --> 00:38:59,549
昂贵 正确的 ，因为你必须 

757
00:38:58,049 --> 00:39:01,103
看的 只是 寻找，直到你 ，而不是 

758
00:38:59,549 --> 00:39:03,571
找到 一个适合 你必须扫描所有的 

759
00:39:01,589 --> 00:39:05,666
空闲块，然后挑选出 最好 的 一个 

760
00:39:03,769 --> 00:39:08,843
不错，但它有一个很好的 特性， 它 

761
00:39:06,359 --> 00:39:11,375
提高内存的利用率好了，所以如果 

762
00:39:09,509 --> 00:39:14,555
这不，这是一个典型的 例子中 

763
00:39:11,519 --> 00:39:16,577
时空权衡所以它的速度较慢，但 

764
00:39:14,969 --> 00:39:20,017
它改善提高了我们的使用

765
00:39:17,099 --> 00:39:20,134
我们使用内存的方式效率

766
00:39:23,042 --> 00:39:29,641
并有一个我们提到我们 

767
00:39:27,074 --> 00:39:31,091
提到的一种替代的方式来组织 

768
00:39:30,019 --> 00:39:35,000
使用 多个空闲列表 空闲列表 

769
00:39:31,091 --> 00:39:35,168
针对不同规模类 现在去 

770
00:39:35,000 --> 00:39:38,075
回到这个例子再次，如果我们有一个 

771
00:39:36,068 --> 00:39:41,257
大小类别之一 的无限数量的

772
00:39:38,075 --> 00:39:43,118
每个将实现最合适的尺寸

773
00:39:41,869 --> 00:39:46,640
以恒定的时间搜索 ，我们不 

774
00:39:44,018 --> 00:39:50,063
确切地知道哪些空闲列表以获得 

775
00:39:46,064 --> 00:39:52,145
从课程的问题 块 是如何 

776
00:39:50,063 --> 00:39:57,074
多少内存这样的组织将 

777
00:39:53,045 --> 00:39:59,914
使用，但对有趣的事情 

778
00:39:57,074 --> 00:40:02,353
使用 多个自由列表是， 

779
00:40:00,319 --> 00:40:05,368
以上的这些自由列表的越多，你

780
00:40:03,019 --> 00:40:06,054
有你越接近一个真正的最好的 

781
00:40:05,809 --> 00:40:08,830
适合 

782
00:40:06,369 --> 00:40:10,910
好了，你可以接近最佳配合和 

783
00:40:09,019 --> 00:40:14,050
那么在某些时候你开始得到 

784
00:40:10,091 --> 00:40:15,113
收益递减 ，从而使这是另一个 

785
00:40:14,329 --> 00:40:17,720
这类设计决策是多少 

786
00:40:16,013 --> 00:40:20,018
这些多空闲列表你需要

787
00:40:17,072 --> 00:40:23,121
和什么样的应该是什么什么 

788
00:40:20,018 --> 00:40:23,607
尺寸范围是与它们 相关联 

789
00:40:24,094 --> 00:40:28,165
现在没事了，现在的问题，一旦我们发现 

790
00:40:27,007 --> 00:40:34,024
所以应用一个块 作出了 

791
00:40:29,065 --> 00:40:35,101
调用的malloc malloc的包 

792
00:40:34,024 --> 00:40:39,049
看着空闲列表，不知怎的 

793
00:40:36,001 --> 00:40:42,013
使用一些相关政策它确定了 

794
00:40:39,049 --> 00:40:43,072
阻止在其中所请求的 一个嗒嗒 

795
00:40:42,013 --> 00:40:47,080
在其中所请求的块的空闲块

796
00:40:43,072 --> 00:40:49,126
将适合好吗所以现在这是什么 做 

797
00:40:47,008 --> 00:40:54,024
具有malloc的封装具有至 

798
00:40:50,026 --> 00:40:57,117
分配它具有某种采取 

799
00:40:54,096 --> 00:41:01,150
这所以有一个 问题是怎么做的 

800
00:40:58,017 --> 00:41:04,084
它可以分配的整个块 

801
00:41:02,005 --> 00:41:06,058
返回回程序员 或者 

802
00:41:04,084 --> 00:41:08,122
可能它可以选择打出一个 

803
00:41:07,003 --> 00:41:10,087
部分仅仅只有块的所述部分 

804
00:41:09,022 --> 00:41:16,098
多数民众赞成需要，然后创建一个较小

805
00:41:10,087 --> 00:41:21,118
空闲块好了，例如 ，如果，如果我们 

806
00:41:16,098 --> 00:41:25,147
如果我们的，如果我们的应用程序已经 

807
00:41:22,018 --> 00:41:29,077
要求大小为4的块或对不起 

808
00:41:26,047 --> 00:41:31,072
它如果malloc的包中检测

809
00:41:29,077 --> 00:41:32,164
即，它在为了满足 

810
00:41:31,072 --> 00:41:39,079
应用请求它需要的块 

811
00:41:33,064 --> 00:41:41,068
大小为4 行包括然后头部它 

812
00:41:39,079 --> 00:41:44,125
看起来，它会尝试寻找 

813
00:41:41,068 --> 00:41:48,076
至少大小的空闲块，从而向前 

814
00:41:45,025 --> 00:41:52,041
比方说，它选择这个块 的一些 

815
00:41:49,048 --> 00:41:55,135
原因可能是因为它是下一个合适 

816
00:41:52,041 --> 00:42:04,042
拿起这里，所以这个可用块

817
00:41:56,035 --> 00:42:05,116
其实 6包含 六个字所以 

818
00:42:04,042 --> 00:42:07,120
分配器必须决定是否只是为了

819
00:42:06,016 --> 00:42:10,102
保持规模的此块六只 

820
00:42:08,002 --> 00:42:13,078
返回回至 

821
00:42:11,002 --> 00:42:16,060
应用程序或是否分割该

822
00:42:13,096 --> 00:42:18,142
块分割成两个块成 分配 

823
00:42:16,006 --> 00:42:21,082
大小的块中 的四个它然后返回 

824
00:42:19,042 --> 00:42:25,134
到应用程序， 然后免费 

825
00:42:22,036 --> 00:42:25,134
尺寸的两个块

826
00:42:30,045 --> 00:42:35,070
现在没事了另一个 问题是如何释放 

827
00:42:33,809 --> 00:42:37,170
所以被请求应用程序的块

828
00:42:35,007 --> 00:42:38,096
该分配被称为免费的，它是 

829
00:42:37,017 --> 00:42:42,042
问分配器，以腾出 

830
00:42:38,789 --> 00:42:48,990
特别块，所以这是很 

831
00:42:42,042 --> 00:42:51,451
简单，所以如果我们要 腾出这 

832
00:42:48,099 --> 00:42:53,228
禁止您刚刚清除 分配标志 

833
00:42:51,829 --> 00:42:56,855
所以，如果我们要 腾出 块我们 

834
00:42:54,119 --> 00:42:59,186
刚创建你只是 你只是设定 明确 

835
00:42:57,089 --> 00:43:02,250
被分配位到零 ，你 

836
00:42:59,789 --> 00:43:04,740
做它真的很简单 ，但问题 

837
00:43:02,025 --> 00:43:09,794
现在这个这就造成 外部 

838
00:43:04,074 --> 00:43:12,141
碎片化，所以如果现在如果，如果我们 只是 

839
00:43:10,019 --> 00:43:16,890
空间大小的该块什么用 

840
00:43:13,041 --> 00:43:18,920
是尺寸的块6现在由 

841
00:43:16,089 --> 00:43:23,151
两个连续的较小的块 中的 一个 

842
00:43:19,289 --> 00:43:26,318
大小为4和 现在如果 尺寸 2 的一个 等 

843
00:43:24,051 --> 00:43:30,093
即，再接一个五年的请求 

844
00:43:26,579 --> 00:43:31,676
块现在我们的权利，就是为了让这一点，但 

845
00:43:30,093 --> 00:43:34,712
我们有足够的内存，它甚至 

846
00:43:32,549 --> 00:43:39,572
在这种情况下，更糟糕的是内存是所有 

847
00:43:35,549 --> 00:43:41,600
连续的，只是因为只是 因为 

848
00:43:39,779 --> 00:43:44,810
我们只是哦，我们 只是清除了 免费 

849
00:43:42,059 --> 00:43:47,087
块中，我们没有，我们没有 真正注意到 

850
00:43:45,089 --> 00:43:48,930
这是连续的，所以我们结束 

851
00:43:47,339 --> 00:43:52,339
起来，这是一个情况下，我们 有 

852
00:43:48,093 --> 00:43:51,502
这两个连续的自由块

853
00:43:53,074 --> 00:43:59,129
所以这这表明 ，当我们做 

854
00:43:57,047 --> 00:44:02,123
当我们腾出块，我们不知何故 

855
00:44:00,029 --> 00:44:05,093
需要合并任何相邻块 

856
00:44:03,023 --> 00:44:08,087
保持块尽可能大的权利 

857
00:44:05,093 --> 00:44:11,186
所以我们不能 的不变性之一 

858
00:44:08,087 --> 00:44:14,120
任何像样的分配是，他们 

859
00:44:12,086 --> 00:44:16,142
从未从未有连续的空闲块 

860
00:44:15,002 --> 00:44:22,010
这样它总是一个空闲块 

861
00:44:17,042 --> 00:44:24,140
其次 是 分配的块 好了， 

862
00:44:23,000 --> 00:44:28,081
这个想法是 ，如果我们 释放一个特定的 

863
00:44:25,004 --> 00:44:31,046
所以在这里我们有这个分配的块和 

864
00:44:28,081 --> 00:44:34,088
如果我们释放该块， 我们不知何故 

865
00:44:31,082 --> 00:44:37,153
要检查 ，看看 是否有任何 

866
00:44:34,088 --> 00:44:41,090
相邻的空闲块以下任一 

867
00:44:38,053 --> 00:44:44,102
任一颈部或者在存储器或下 

868
00:44:41,009 --> 00:44:47,012
以前在内存中，如果有我们 

869
00:44:45,002 --> 00:44:49,064
需要的释放过程的一部分作为 

870
00:44:47,093 --> 00:44:51,161
我们需要合并这两个区块 

871
00:44:49,064 --> 00:44:56,066
成到一个更大的块最大 

872
00:44:52,061 --> 00:44:58,124
可能块可能现在这是很

873
00:44:56,066 --> 00:45:02,105
容易 ，如果我们如果我们要求免费 

874
00:44:59,024 --> 00:45:04,082
此块这个绿色块 这是很 

875
00:45:03,005 --> 00:45:07,022
易检查 下一个块 

876
00:45:04,082 --> 00:45:08,141
因为你，我们有我们的大小

877
00:45:07,022 --> 00:45:11,101
包括这个头 ，所以我们知道， 

878
00:45:09,041 --> 00:45:16,088
下一个块开始于 四个 偏移 

879
00:45:12,001 --> 00:45:18,002
所以我们只是我们只是我们 只是检查 ，我们知道 

880
00:45:16,088 --> 00:45:19,142
而我们知道，头部为 

881
00:45:18,002 --> 00:45:22,004
块是在四个偏移，所以我们只是 

882
00:45:20,042 --> 00:45:24,107
检查中所分配的状态

883
00:45:22,004 --> 00:45:27,086
使用使用 尺寸下一个块

884
00:45:25,007 --> 00:45:30,104
使用我们的头规模场，但 

885
00:45:27,086 --> 00:45:32,182
关于前一个块什么什么 

886
00:45:31,004 --> 00:45:36,098
这块我们怎么检查 

887
00:45:33,082 --> 00:45:37,169
以及给定的给所有我们谈 

888
00:45:36,098 --> 00:45:39,113
对，现在 我们 唯一的 必由之路 

889
00:45:38,069 --> 00:45:42,083
能做到这将 是在开始 

890
00:45:40,013 --> 00:45:45,026
堆的开始，现在走 

891
00:45:42,083 --> 00:45:48,122
免费列表，直到我们得到这个电流 

892
00:45:45,026 --> 00:45:51,113
阻止想起了以前的块 ， 

893
00:45:49,022 --> 00:45:54,098
每次我们每次我们遍历 我们 的时间 

894
00:45:52,013 --> 00:45:56,087
记得以前块好让 

895
00:45:54,098 --> 00:45:58,130
但是这将是非常低效的权利 

896
00:45:56,087 --> 00:46:00,176
那 会是什么 ，这将使 

897
00:45:59,003 --> 00:46:03,068
在热的尺寸自由线性

898
00:46:01,076 --> 00:46:04,148
因为我们不得不以 检查 

899
00:46:03,095 --> 00:46:05,124
前面的块中，我们不得不走 

900
00:46:05,048 --> 00:46:07,080
开始

901
00:46:06,024 --> 00:46:12,039
最开始， 走到整个 

902
00:46:07,008 --> 00:46:13,014
堆所以该解决方案是WAS 

903
00:46:12,039 --> 00:46:18,066
提出了一个著名的计算机 科学家 

904
00:46:14,004 --> 00:46:20,016
多恩·克努斯于1973年 ，它是非常聪明 

905
00:46:18,066 --> 00:46:22,074
它很简单像所有真正的好 

906
00:46:20,052 --> 00:46:24,129
想法似乎很明显 ，当你看到 

907
00:46:23,046 --> 00:46:29,082
它，但它原来 是很聪明 

908
00:46:25,029 --> 00:46:32,124
和一个非常非常有用的技术和 

909
00:46:29,082 --> 00:46:36,135
想法只是复制每个块 

910
00:46:33,024 --> 00:46:39,099
复制头块在所述端部 

911
00:46:37,035 --> 00:46:42,108
块确定，所以每 块现在包含 

912
00:46:39,099 --> 00:46:45,195
页眉和页脚相同报头 

913
00:46:43,008 --> 00:46:52,011
和页脚，然后这 将创建排序 

914
00:46:46,095 --> 00:46:56,184
隐式向后 倒退 链接 

915
00:46:52,038 --> 00:47:01,077
我们可以使用 所以现在给定的给予一定的 

916
00:46:57,084 --> 00:47:04,125
我们要给予一定的块地 

917
00:47:01,077 --> 00:47:07,080
我们要释放我们知道， 

918
00:47:05,025 --> 00:47:12,644
该块的大小也只是 一个 

919
00:47:08,007 --> 00:47:14,094
一个字的前面 和记忆等等，所以我们 

920
00:47:12,869 --> 00:47:19,874
正好可以 和 它始终有固定的固定 

921
00:47:14,094 --> 00:47:21,105
一个字的偏移，从而给你知道 

922
00:47:20,369 --> 00:47:23,444
给定的一个指针的这个头 

923
00:47:22,005 --> 00:47:26,324
块，我们可以看一个背单词， 看 

924
00:47:24,119 --> 00:47:29,070
大小和分配的分配 

925
00:47:26,369 --> 00:47:31,020
先前块的状态确定，所以我们 

926
00:47:29,007 --> 00:47:33,102
加入这样可以让我们做 ，在 

927
00:47:31,002 --> 00:47:36,851
常量时间，所以这 是页脚 

928
00:47:34,002 --> 00:47:39,033
有时被称为 边界和标签 

929
00:47:36,869 --> 00:47:43,350
克努特 称这是边界的标签，但我们会 

930
00:47:39,033 --> 00:47:45,572
公正， 或者我们可以称之为一个页脚 

931
00:47:43,035 --> 00:47:48,036
可以用概念形式的平行

932
00:47:45,869 --> 00:47:50,130
头的， 但 关键的是， 

933
00:47:48,045 --> 00:47:53,069
它只是 相同的具有相同 

934
00:47:50,013 --> 00:47:53,069
大小和分配状态

935
00:47:54,096 --> 00:48:06,174
还好现在这么给出肯定的问题，所以

936
00:48:06,069 --> 00:48:08,145
问题是，如果我们希望 有一个 

937
00:48:07,074 --> 00:48:10,613
当我们分配一块做边界标签

938
00:48:09,045 --> 00:48:16,454
我们需要预留 空间，并 

939
00:48:11,279 --> 00:48:17,288
回答是 大部分的 时间 我会告诉 

940
00:48:16,859 --> 00:48:21,934
你一个 

941
00:48:17,369 --> 00:48:22,393
我会告诉你在一个位一个优化

942
00:48:23,069 --> 00:48:34,958
好了，所以给定给这个想法 的 上 

943
00:48:28,559 --> 00:48:36,638
边界标签，并和并考虑到 

944
00:48:35,579 --> 00:48:41,160
我们有一些分配的块，我们 

945
00:48:37,349 --> 00:48:43,351
要释放此黄色块有 

946
00:48:41,016 --> 00:48:43,405
题

947
00:48:51,589 --> 00:48:59,680
是的，我们八九不离十退出 呀所以才来 

948
00:48:56,059 --> 00:49:01,138
总之，你需要的时候的问题

949
00:49:00,499 --> 00:49:03,525
当您正在寻找分配

950
00:49:01,849 --> 00:49:07,908
适合你的块必须包括 

951
00:49:03,759 --> 00:49:07,827
报头的大小和边界标记 

952
00:49:10,239 --> 00:49:15,243
它会你，那么你就必须再

953
00:49:12,799 --> 00:49:17,806
你必须插入填充以获得 

954
00:49:15,279 --> 00:49:20,320
大小共块大小，这是一个

955
00:49:17,869 --> 00:49:22,932
这组 多的多的是 

956
00:49:20,689 --> 00:49:30,703
满足您的对齐要求

957
00:49:23,499 --> 00:49:33,170
对不起啊，我的意思是它可以是的，如果你

958
00:49:30,829 --> 00:49:34,900
有它 的问题 是 我 岂不 使用 

959
00:49:33,017 --> 00:49:37,606
大量的内存，它可以如果再就 

960
00:49:35,539 --> 00:49:39,562
依赖于请求的请求 

961
00:49:37,759 --> 00:49:41,764
图案是如果应用程序是 

962
00:49:39,769 --> 00:49:42,838
请求许多小的净荷然后 

963
00:49:42,259 --> 00:49:45,304
它会它会浪费很多 

964
00:49:43,459 --> 00:49:48,910
内存如果它要求大 

965
00:49:45,709 --> 00:49:48,910
有效载荷没有那么糟糕 

966
00:49:51,052 --> 00:49:56,131
所以给出没关系，我们有一些块 

967
00:49:54,026 --> 00:49:58,100
我们希望 释放有 4案件 

968
00:49:56,599 --> 00:50:02,180
我们需要考虑的时候，当 

969
00:49:59,000 --> 00:50:04,004
合并的情况下，未来

970
00:50:02,018 --> 00:50:08,099
块分配和前 

971
00:50:04,004 --> 00:50:10,058
块是免费被分配的情况下

972
00:50:08,099 --> 00:50:12,173
下一个块是免费的，以前的 

973
00:50:10,058 --> 00:50:14,144
块被分配的情况下，其中 所述 

974
00:50:13,073 --> 00:50:16,094
前一块是免费的，下一 

975
00:50:15,044 --> 00:50:18,083
块 的情况下 分配的 

976
00:50:16,094 --> 00:50:23,132
前一个 和下一个 块是 

977
00:50:18,083 --> 00:50:26,144
自由好了，万一有，我们有

978
00:50:24,032 --> 00:50:30,331
我们希望使我们的分配块

979
00:50:27,044 --> 00:50:31,097
由两个分配块包围我们 

980
00:50:30,619 --> 00:50:37,280
不要做任何正确的，因为只有 

981
00:50:31,097 --> 00:50:39,113
我们自由存储器中，以便所以在这种情况下，

982
00:50:37,028 --> 00:50:41,072
我们刚刚设置保持头的大小 

983
00:50:40,013 --> 00:50:47,232
和页脚保持不变，我们只是 

984
00:50:41,072 --> 00:50:46,701
设置分配状态转向免费 

985
00:50:49,022 --> 00:50:56,371
现在如果要是下一块是免费的 

986
00:50:53,024 --> 00:50:59,102
和先前块被分配什么

987
00:50:56,569 --> 00:51:02,150
我们做的是我们，我们检查的边界标签

988
00:51:00,002 --> 00:51:03,071
在前面的块，我们看到， 

989
00:51:02,015 --> 00:51:07,067
它的分配所以没有什么做 

990
00:51:03,071 --> 00:51:10,073
还有我们使用尺寸 检查 

991
00:51:07,067 --> 00:51:12,122
下一个块，我们的分配状态

992
00:51:10,073 --> 00:51:15,097
使用n 跳转到 下一个 的头 

993
00:51:13,022 --> 00:51:20,161
块中，我们看到它的分配 

994
00:51:15,097 --> 00:51:22,696
状态是免费的，所以这两个块 需要 

995
00:51:20,359 --> 00:51:28,010
以被合并，所以我们做 的只是 

996
00:51:23,569 --> 00:51:29,623
添加添加两种尺寸一起 

997
00:51:28,001 --> 00:51:34,030
创建这个更大的聚结块和

998
00:51:30,109 --> 00:51:36,650
设置它的分配状态到零 

999
00:51:34,003 --> 00:51:41,069
在现在的情况下一个块 

1000
00:51:36,065 --> 00:51:43,073
是免费的，我们再次我们检查 

1001
00:51:41,096 --> 00:51:47,141
边界高科技页脚当我们看到 

1002
00:51:43,073 --> 00:51:51,172
这是我们看到它是免费的，所以在这种情况下， 

1003
00:51:48,041 --> 00:51:54,128
我们创建了必须更新的 大小 

1004
00:51:52,072 --> 00:51:57,076
在旧旧的头 

1005
00:51:55,028 --> 00:52:00,056
先前块创建这个新的现在 

1006
00:51:57,076 --> 00:52:01,154
较大的聚结块，我们和我们 

1007
00:52:00,056 --> 00:52:04,153
更新 标题和边界检查 

1008
00:52:02,054 --> 00:52:04,153
因此页脚

1009
00:52:06,061 --> 00:52:10,156
然后在情况下其中两个 

1010
00:52:08,008 --> 00:52:20,041
前一个和下一个拦截器是 

1011
00:52:11,056 --> 00:52:22,063
免费，我们创建一个单一的块单 

1012
00:52:21,013 --> 00:52:25,068
块这三者的总和

1013
00:52:23,026 --> 00:52:25,068
这些大小

1014
00:52:27,299 --> 00:52:36,386
好了， 是该 清楚 

1015
00:52:28,919 --> 00:52:38,927
大家现在如果你 指出来 

1016
00:52:37,169 --> 00:52:41,177
正确地指出，边界标签 

1017
00:52:39,719 --> 00:52:43,721
可以创建 额外的内部 

1018
00:52:41,249 --> 00:52:45,268
碎片化，因为他们是他们 

1019
00:52:43,739 --> 00:52:50,750
不有效载荷的一部分，以便通过 定义 

1020
00:52:45,439 --> 00:52:53,880
他们，如果 他们的开销，所以你 

1021
00:52:50,849 --> 00:52:56,897
也许你会问自己 有没有 

1022
00:52:53,088 --> 00:52:59,257
在这里你不需要任何情况下， 

1023
00:52:57,329 --> 00:52:59,401
边界标签

1024
00:53:06,021 --> 00:53:13,109
所以这其中块需要哪些块

1025
00:53:11,007 --> 00:53:14,009
需要一个边界标签

1026
00:53:16,043 --> 00:53:18,049
您 

1027
00:53:28,046 --> 00:53:32,138
你可以逃脱作为一个分配 

1028
00:53:30,063 --> 00:53:32,138
块 需要一个 

1029
00:53:47,002 --> 00:53:52,074
是的你，如果你不 打算如果 

1030
00:53:50,349 --> 00:53:55,395
你不是，如果你 不需要合并 

1031
00:53:52,092 --> 00:53:58,140
你不需要到页脚和 

1032
00:53:55,809 --> 00:54:01,883
你不凝聚什么样块

1033
00:53:59,004 --> 00:54:02,153
分配博客 

1034
00:54:04,449 --> 00:54:12,538
所以什么，所以我们也许可以，也许，也许我们

1035
00:54:11,179 --> 00:54:15,208
不需要那些那些边界 高科技 

1036
00:54:13,339 --> 00:54:18,406
在分配的块页脚权只是 

1037
00:54:15,469 --> 00:54:21,505
在空闲块，但后来我们如何去 

1038
00:54:19,009 --> 00:54:25,078
以确定前一个块是 

1039
00:54:21,829 --> 00:54:31,872
分配或免费如果所分配的块 

1040
00:54:25,699 --> 00:54:31,755
没有边界的标签页脚是 

1041
00:54:32,032 --> 00:54:39,103
对不起，好耶，你想给它一个 

1042
00:54:37,087 --> 00:54:40,093
当你释放它，但不知何故，当我们

1043
00:54:40,003 --> 00:54:44,005
做凝聚我们需要检查

1044
00:54:41,047 --> 00:54:49,120
在某种程度上说，以前的块是否 

1045
00:54:44,005 --> 00:54:52,012
它的分配或自由 不错，但怎么做 

1046
00:54:50,002 --> 00:54:58,048
它知道 它是否 是一个边界标签 

1047
00:54:52,012 --> 00:55:08,020
或者没有不知道没有那也没关系，就是这样 

1048
00:54:58,066 --> 00:55:09,151
还好是的宾果你知道了，那么记住 

1049
00:55:08,092 --> 00:55:13,153
这个数字还记得，因为 我们 

1050
00:55:10,051 --> 00:55:16,075
对准我们已经有了我们已经 得到了多个 

1051
00:55:14,053 --> 00:55:19,105
至少三个比特这三个或四个 

1052
00:55:16,075 --> 00:55:22,078
位始终为零 ，我们只是 

1053
00:55:20,005 --> 00:55:25,102
使用其中的一个，为什么不使用其他 

1054
00:55:23,005 --> 00:55:30,097
一个包含的分配状态 

1055
00:55:26,002 --> 00:55:33,039
先前块好了，所以 非常 好 

1056
00:55:30,097 --> 00:55:32,139
这是

1057
00:55:38,092 --> 00:55:49,451
而这样的想法所以这里的块

1058
00:55:45,076 --> 00:55:52,095
我们要自由，这里是它的头 

1059
00:55:50,279 --> 00:55:55,930
我们 通过 在P它和我们想 

1060
00:55:52,779 --> 00:55:59,680
我们要释放它 ，我们已经有了我们已经 

1061
00:55:55,093 --> 00:56:01,114
得到了一个位，我们知道，如果我们有一个8 

1062
00:55:59,068 --> 00:56:05,095
字节对齐，我们知道这些都是 

1063
00:56:02,014 --> 00:56:08,017
所有隐含0，所以我们使用这 

1064
00:56:05,095 --> 00:56:14,097
我们希望释放一个分配的块

1065
00:56:08,017 --> 00:56:17,646
所以它具有1的分配状态和 

1066
00:56:14,097 --> 00:56:20,149
让我们用这个让我们用其中的一个 

1067
00:56:17,799 --> 00:56:25,898
空闲比特来表示分配

1068
00:56:21,049 --> 00:56:32,118
先前块的状态OK 至今 

1069
00:56:26,789 --> 00:56:38,200
如果前面的块分配 

1070
00:56:33,018 --> 00:56:39,040
那么这将是一个1，当我们 

1071
00:56:38,002 --> 00:56:42,111
检查， 看看我们是否需要 

1072
00:56:39,004 --> 00:56:44,883
凝聚我们只是检查，我们只是 

1073
00:56:42,309 --> 00:56:46,365
所检查的是第二所分配 

1074
00:56:45,279 --> 00:56:49,630
位以前的分配位

1075
00:56:46,869 --> 00:56:52,930
块，如果是1，我们并不 需要 

1076
00:56:49,063 --> 00:56:53,119
知道它的大小 确定，我们并不 需要 

1077
00:56:52,093 --> 00:56:56,712
知道该 块是因为我们 

1078
00:56:54,019 --> 00:56:59,838
不会在 这样 行不行合并会这样 

1079
00:56:57,549 --> 00:57:03,621
我们不需要所以在这里我们并不需要一个 

1080
00:57:00,009 --> 00:57:09,093
所分配的块边界标签，但 

1081
00:57:04,269 --> 00:57:14,230
现在如果，如果该块是免费的，它会 

1082
00:57:09,849 --> 00:57:19,250
有边界的标签，所以我们去检查一下 

1083
00:57:14,023 --> 00:57:23,057
该块是免费，则 

1084
00:57:19,025 --> 00:57:25,894
分配情况是什么样子 

1085
00:57:23,057 --> 00:57:28,115
表明自由，那么我们就知道我们需要 

1086
00:57:26,119 --> 00:57:32,167
到我们需要 凝聚 ，我们要 

1087
00:57:29,015 --> 00:57:33,964
需要我们将需要一个边界 

1088
00:57:32,599 --> 00:57:36,604
标签，因为我们需要知道的是 

1089
00:57:34,099 --> 00:57:40,174
块开始，我们需要 知道它的大小，以便 

1090
00:57:37,099 --> 00:57:43,490
我们可以回去 和更新本 

1091
00:57:40,849 --> 00:57:47,560
大小包括你知道总 

1092
00:57:43,049 --> 00:57:47,056
煤了尺寸等这两个区块 

1093
00:57:47,859 --> 00:57:57,890
所以这是说清楚是的 

1094
00:57:51,089 --> 00:57:59,126
哦，我只是把它仅仅是分配位 ，所以 

1095
00:57:57,089 --> 00:58:01,183
零表示不分配一个手段 

1096
00:58:00,026 --> 00:58:02,083
分配

1097
00:58:09,018 --> 00:58:13,049
哦，为什么 是那些为什么位 

1098
00:58:11,055 --> 00:58:18,074
总是位0 为什么 

1099
00:58:13,049 --> 00:58:19,067
好了，所以块必须对齐 ，以 

1100
00:58:18,569 --> 00:58:22,170
一个 八个 字节边界 

1101
00:58:19,067 --> 00:58:25,071
还好口服有效载荷必须对齐，以 

1102
00:58:22,017 --> 00:58:28,916
一个八个字节边界 还好这意味着 

1103
00:58:25,071 --> 00:58:31,690
该块已经是大小 

1104
00:58:29,069 --> 00:58:34,470
块必须是8的倍数

1105
00:58:32,329 --> 00:58:36,900
因为它是同样的 事情 是，当我们 

1106
00:58:34,047 --> 00:58:40,116
在做填充对准指示 

1107
00:58:36,009 --> 00:58:42,024
下一每个块必须是一个具有大小 

1108
00:58:41,016 --> 00:58:45,665
是 八的倍数， 这样 的 

1109
00:58:43,005 --> 00:58:48,039
随后，在存储器是块 

1110
00:58:45,809 --> 00:58:49,814
排列正确好吗 

1111
00:58:48,039 --> 00:58:51,488
所以你保证， 因为 

1112
00:58:50,309 --> 00:58:54,240
对齐要求你保证

1113
00:58:51,839 --> 00:58:55,800
这八个或十六 你 

1114
00:58:54,024 --> 00:58:58,603
保证块的大小 

1115
00:58:55,008 --> 00:59:01,008
总是的8 或16的倍数

1116
00:58:58,819 --> 00:59:04,050
可以的， 使和 使 

1117
00:59:01,008 --> 00:59:05,046
因为大小始终是一个 多 

1118
00:59:04,005 --> 00:59:10,774
八个或十六你 保证 

1119
00:59:06,018 --> 00:59:14,024
该三个或 四个四位是 

1120
00:59:10,819 --> 00:59:14,240
全部为零 

1121
00:59:18,004 --> 00:59:21,011
[音乐]

1122
00:59:22,015 --> 00:59:25,066
还有其他问题吗

1123
00:59:28,019 --> 00:59:31,028
[音乐]

1124
00:59:31,063 --> 00:59:38,002
好吧，让我 再 总结 一些关键 

1125
00:59:34,279 --> 00:59:40,400
当 一个执行的政策

1126
00:59:38,569 --> 00:59:42,610
分配器和我提到 有 

1127
00:59:40,004 --> 00:59:44,023
设计空间，这些东西是 

1128
00:59:42,979 --> 00:59:46,987
真正的大和 非常有趣 

1129
00:59:44,419 --> 00:59:48,462
有很多的事情，你有很多 

1130
00:59:47,059 --> 00:59:52,075
那你 必须做出 决定 有关 

1131
00:59:48,849 --> 00:59:54,943
各种政策，首先是

1132
00:59:52,219 --> 00:59:56,305
放置策略，即当我们的时候 

1133
00:59:55,789 --> 00:59:59,878
我们正在努力 ，当我们试图找到 

1134
00:59:57,079 --> 01:00:02,158
放置一个空闲块 我的意思是进出 

1135
01:00:00,679 --> 01:00:04,687
当我们试图将分配的 

1136
01:00:02,869 --> 01:00:04,963
阻挡在空闲块的地方

1137
01:00:04,759 --> 01:00:07,834
某处名单

1138
01:00:05,809 --> 01:00:10,900
什么什么我们用什么政策第一 

1139
01:00:08,509 --> 01:00:14,586
适合未来适合或最适合一般 

1140
01:00:11,719 --> 01:00:19,130
这些东西权衡吞吐量 

1141
01:00:15,279 --> 01:00:24,345
碎片没事这样的 

1142
01:00:19,013 --> 01:00:24,822
快了快了类似的版本 

1143
01:00:26,057 --> 01:00:30,075
如果你愿意，如果你愿意 

1144
01:00:28,095 --> 01:00:32,178
处理与类似的低级吞吐量

1145
01:00:30,075 --> 01:00:37,173
在最适合的情况下，你可以得到 

1146
01:00:33,078 --> 01:00:40,173
更好的内存利用率现在有

1147
01:00:38,073 --> 01:00:43,073
有趣的还有 有趣的方式 

1148
01:00:41,073 --> 01:00:45,120
改善最合适的性能 

1149
01:00:43,073 --> 01:00:48,129
你可能你可能会考虑 什么 

1150
01:00:46,002 --> 01:00:51,066
像般配是那种混合的 

1151
01:00:49,029 --> 01:00:55,047
首先适合和最适合的，所以也许也许 

1152
01:00:51,084 --> 01:00:56,127
你只能搜索你第一次知道 

1153
01:00:55,047 --> 01:00:58,098
堆的部分，然后确定 

1154
01:00:57,027 --> 01:01:01,029
你知道 的 ，也许不是 最合适 

1155
01:00:58,098 --> 01:01:02,124
搜索 你 整个堆 刚 

1156
01:01:01,029 --> 01:01:05,064
查询的堆的一些一些部分和 

1157
01:01:03,024 --> 01:01:07,092
再切断搜索，然后内 

1158
01:01:05,064 --> 01:01:10,160
你搜索你选择的区域

1159
01:01:07,092 --> 01:01:14,166
所以，最好的块的东西，

1160
01:01:11,006 --> 01:01:18,090
所谓良好的配合 ，这样的那种 

1161
01:01:15,066 --> 01:01:20,130
接近最适合， 也可以使用 

1162
01:01:19,044 --> 01:01:24,087
这些多空闲列表近似 

1163
01:01:21,003 --> 01:01:27,009
最适合的，这就是再有 

1164
01:01:24,087 --> 01:01:30,162
您 使用多个 真正的优势 

1165
01:01:27,009 --> 01:01:32,034
免费 列出的是， 它不仅 提高了 

1166
01:01:31,062 --> 01:01:35,067
内存利用率，但它提高 

1167
01:01:33,015 --> 01:01:37,089
性能也因为个人 

1168
01:01:35,067 --> 01:01:39,105
你正在找你知道 名单 

1169
01:01:37,089 --> 01:01:42,146
它们含有接近块

1170
01:01:40,005 --> 01:01:45,099
你要问什么 ，自 

1171
01:01:43,046 --> 01:01:47,142
你将所有的空闲块了 

1172
01:01:45,099 --> 01:01:49,101
其中在多个在多个 

1173
01:01:48,042 --> 01:01:52,080
免费列出那些空闲列表会 

1174
01:01:50,019 --> 01:01:55,023
短好了，你的搜索将采取 

1175
01:01:52,008 --> 01:01:57,011
更少的时间和你对你 的 概率 

1176
01:01:55,059 --> 01:01:59,132
找到适合的块上升 

1177
01:01:58,001 --> 01:02:03,098
因为你这些分离 

1178
01:02:00,032 --> 01:02:03,107
不同大小班 

1179
01:02:04,074 --> 01:02:10,077
现在有一个很好的，我们也有 

1180
01:02:07,047 --> 01:02:12,093
决定一些分裂的政策，所以当 

1181
01:02:10,077 --> 01:02:14,153
我们发现，我们找到一个免费的块的 大 

1182
01:02:12,093 --> 01:02:17,115
足够我们做什么用剩的 

1183
01:02:15,053 --> 01:02:20,097
你知道该块的剩余部分 

1184
01:02:18,015 --> 01:02:23,474
一旦我们把我们分配到块

1185
01:02:20,097 --> 01:02:24,120
那成空闲块 我们做什么 

1186
01:02:23,609 --> 01:02:27,720
与剩菜我们刚刚离开

1187
01:02:25,002 --> 01:02:29,031
在块本身剩余部分和

1188
01:02:27,072 --> 01:02:32,073
返回给应用程序 

1189
01:02:29,049 --> 01:02:35,058
你知道这样避免诸如此类的 

1190
01:02:32,073 --> 01:02:36,165
保持保持较大的块还是我们的 

1191
01:02:35,058 --> 01:02:41,124
继续前进，就像我一样拆显示它 

1192
01:02:37,065 --> 01:02:43,149
之前 和分裂我们继续 前进 ， 

1193
01:02:42,024 --> 01:02:46,067
分裂阻断和创建 

1194
01:02:44,049 --> 01:02:48,063
创建原始空闲块 

1195
01:02:46,067 --> 01:02:51,075
分配它的一部分， 然后 

1196
01:02:48,063 --> 01:02:53,124
创建一个较小的空闲块，这样的

1197
01:02:51,075 --> 01:02:57,078
你知道这是一个政策 ，我们可能会你可能 

1198
01:02:54,024 --> 01:03:00,096
想你可能要为小 

1199
01:02:57,078 --> 01:03:02,094
对于小型有效载荷要求您最多可以 

1200
01:03:00,096 --> 01:03:04,505
到一定的规模，你可能不希望 

1201
01:03:02,094 --> 01:03:07,158
拆分所以你可能不是你 可以决定不 

1202
01:03:05,369 --> 01:03:11,970
分裂块较小的你可能不是你 

1203
01:03:08,058 --> 01:03:14,076
可能决定不创建空闲块 

1204
01:03:11,097 --> 01:03:16,104
小于某些阈值和 

1205
01:03:14,076 --> 01:03:20,139
仅针对 四项要求分割

1206
01:03:17,067 --> 01:03:26,073
较大的块，然后有有一个

1207
01:03:21,039 --> 01:03:28,107
合并政策，现在我们已经看到了释放 

1208
01:03:27,027 --> 01:03:32,073
是相当快，现在它的恒定时间 

1209
01:03:29,007 --> 01:03:35,091
因为边界标签 页脚 ， 但 

1210
01:03:32,073 --> 01:03:37,119
你可能你可能想你可能想 

1211
01:03:35,091 --> 01:03:42,790
尝试只是速度达到甚至 更多 

1212
01:03:38,019 --> 01:03:48,027
通过推迟凝聚，所以你可以 

1213
01:03:43,609 --> 01:03:50,220
你能做到每次它凝聚 

1214
01:03:48,027 --> 01:03:53,103
免费被称为像像我们刚刚看到

1215
01:03:50,022 --> 01:03:56,040
在或者你可以推迟合并一些

1216
01:03:54,003 --> 01:03:58,008
以后你也许知道，当你 

1217
01:03:56,004 --> 01:04:00,012
扫描当你在空闲列表

1218
01:03:58,053 --> 01:04:02,079
扫描空闲列表中寻找设定的尝试 

1219
01:04:01,002 --> 01:04:04,065
试图找到努力的地方 

1220
01:04:02,079 --> 01:04:06,156
响应分配块一个malloc 

1221
01:04:04,083 --> 01:04:08,124
打电话也许你扫描自由列表 

1222
01:04:07,056 --> 01:04:12,092
你可以继续 做的凝聚 

1223
01:04:09,024 --> 01:04:12,092
在那个时候这样的权利 

1224
01:04:13,018 --> 01:04:17,020
我不是说哪一个更好它的 

1225
01:04:15,519 --> 01:04:19,390
很难这真的 很难说 了 

1226
01:04:17,038 --> 01:04:23,457
第三成膜助剂 得到 

1227
01:04:19,039 --> 01:04:26,508
边界的固定时间性能

1228
01:04:23,799 --> 01:04:31,827
基于标记的凝聚，但它，但它是一个 

1229
01:04:26,859 --> 01:04:34,926
选择 好了，所以这里的 总结，然后 

1230
01:04:32,079 --> 01:04:39,430
隐含的名单，这是最简单的 

1231
01:04:35,529 --> 01:04:45,400
那么 这是一个非常简单的 一种 

1232
01:04:39,043 --> 01:04:47,071
分配器我这是 它的成本 

1233
01:04:45,004 --> 01:04:53,011
分配是线性的中的大小

1234
01:04:47,071 --> 01:04:54,660
堆这是成本的 最坏情况 

1235
01:04:53,047 --> 01:04:57,118
免费是恒定的时间甚至

1236
01:04:55,299 --> 01:04:59,355
合并的内存使用情况将是会

1237
01:04:58,018 --> 01:05:03,147
取决于放置策略 

1238
01:04:59,859 --> 01:05:07,480
第一嵌入未来满足我们最合适的UM 

1239
01:05:03,309 --> 01:05:09,970
它不是， 因为 实践 中使用

1240
01:05:07,048 --> 01:05:14,127
线性时间的线性时间成本 

1241
01:05:09,097 --> 01:05:15,190
配置不错，但它也可以用在 

1242
01:05:14,559 --> 01:05:18,627
某种特殊用途的分配器，其中 

1243
01:05:16,009 --> 01:05:20,628
你有一个小的数目 大小班 

1244
01:05:19,239 --> 01:05:23,650
也许，或者你永远挺你知道你 

1245
01:05:21,519 --> 01:05:26,595
有一个非常小的或非常小的自由 

1246
01:05:23,065 --> 01:05:28,914
名单，但分裂的思想和 

1247
01:05:27,279 --> 01:05:31,960
凝聚我们看着是一般 

1248
01:05:29,499 --> 01:05:33,507
所有分配器好了，所以 的想法 

1249
01:05:31,096 --> 01:05:37,101
边界标签叫做边界基于标签 

1250
01:05:33,579 --> 01:05:42,130
聚结是不管使用 的 使用 

1251
01:05:38,046 --> 01:05:44,655
您免费列表，从而隐含的结构

1252
01:05:42,013 --> 01:05:47,442
列表是学习，是因为他们有用

1253
01:05:45,069 --> 01:05:50,430
介绍一些重要的概念，但 

1254
01:05:47,559 --> 01:05:52,710
通常他们不是他们不 

1255
01:05:50,043 --> 01:05:57,222
他们没有多大用处 

1256
01:05:52,071 --> 01:05:59,098
所以接下来的下一节课，我们看一些

1257
01:05:57,609 --> 01:06:03,657
自由更复杂的组织 

1258
01:05:59,098 --> 01:06:06,121
列出了明确的名单和多 

1259
01:06:04,089 --> 01:06:08,710
特别是免费列出了所有的权利，使 

1260
01:06:07,021 --> 01:06:12,810
我们会看到你那么好 运气在 你的 

1261
01:06:08,071 --> 01:06:14,930
贝因实验室今晚，我们将看到你 

1262
01:06:12,999 --> 01:06:15,056
星期四

